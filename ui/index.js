/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(172);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _componentsApp = __webpack_require__(2);
	
	var _componentsApp2 = _interopRequireDefault(_componentsApp);
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _flux = __webpack_require__(166);
	
	var _flux2 = _interopRequireDefault(_flux);
	
	_flux2["default"].onUpdate(function (state) {
	  return _react2["default"].render(_react2["default"].createElement(_componentsApp2["default"], { state: state, actions: _flux2["default"].actions }), document.getElementById('dg-container'));
	}, true);

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _counter = __webpack_require__(159);
	
	var _counter2 = _interopRequireDefault(_counter);
	
	__webpack_require__(164);
	
	var App = (function (_React$Component) {
	  _inherits(App, _React$Component);
	
	  function App() {
	    _classCallCheck(this, App);
	
	    _get(Object.getPrototypeOf(App.prototype), "constructor", this).apply(this, arguments);
	  }
	
	  _createClass(App, [{
	    key: "render",
	    value: function render() {
	      var _props = this.props;
	      var state = _props.state;
	      var actions = _props.actions;
	
	      return _react2["default"].createElement(
	        "div",
	        { className: "container" },
	        _react2["default"].createElement(
	          "div",
	          { className: "col-md-12" },
	          _react2["default"].createElement(
	            "div",
	            { className: "jumbotron" },
	            _react2["default"].createElement(
	              "h1",
	              null,
	              "I'm just an example"
	            ),
	            _react2["default"].createElement(
	              "p",
	              null,
	              "Edit or delete me in ./components/app"
	            ),
	            _react2["default"].createElement(
	              "p",
	              null,
	              "Documentation is in readme.md"
	            ),
	            _react2["default"].createElement(_counter2["default"], { value: state.getIn(['globalState', 'counter']), actions: actions })
	          )
	        )
	      );
	    }
	  }]);
	
	  return App;
	})(_react2["default"].Component);
	
	exports["default"] = App;
	module.exports = exports["default"];

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(4);


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var EventPluginUtils = __webpack_require__(6);
	var ReactChildren = __webpack_require__(10);
	var ReactComponent = __webpack_require__(24);
	var ReactClass = __webpack_require__(39);
	var ReactContext = __webpack_require__(14);
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactElement = __webpack_require__(13);
	var ReactElementValidator = __webpack_require__(34);
	var ReactDOM = __webpack_require__(42);
	var ReactDOMTextComponent = __webpack_require__(44);
	var ReactDefaultInjection = __webpack_require__(93);
	var ReactInstanceHandles = __webpack_require__(21);
	var ReactMount = __webpack_require__(69);
	var ReactPerf = __webpack_require__(30);
	var ReactPropTypes = __webpack_require__(124);
	var ReactReconciler = __webpack_require__(31);
	var ReactServerRendering = __webpack_require__(156);
	
	var assign = __webpack_require__(15);
	var findDOMNode = __webpack_require__(113);
	var onlyChild = __webpack_require__(158);
	
	ReactDefaultInjection.inject();
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if ("production" !== process.env.NODE_ENV) {
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var render = ReactPerf.measure('React', 'render', ReactMount.render);
	
	var React = {
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    only: onlyChild
	  },
	  Component: ReactComponent,
	  DOM: ReactDOM,
	  PropTypes: ReactPropTypes,
	  initializeTouchEvents: function(shouldUseTouch) {
	    EventPluginUtils.useTouchEvents = shouldUseTouch;
	  },
	  createClass: ReactClass.createClass,
	  createElement: createElement,
	  cloneElement: cloneElement,
	  createFactory: createFactory,
	  createMixin: function(mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	  constructAndRenderComponent: ReactMount.constructAndRenderComponent,
	  constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,
	  findDOMNode: findDOMNode,
	  render: render,
	  renderToString: ReactServerRendering.renderToString,
	  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  isValidElement: ReactElement.isValidElement,
	  withContext: ReactContext.withContext,
	
	  // Hook for JSX spread, don't use this for anything else.
	  __spread: assign
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	if (
	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    CurrentOwner: ReactCurrentOwner,
	    InstanceHandles: ReactInstanceHandles,
	    Mount: ReactMount,
	    Reconciler: ReactReconciler,
	    TextComponent: ReactDOMTextComponent
	  });
	}
	
	if ("production" !== process.env.NODE_ENV) {
	  var ExecutionEnvironment = __webpack_require__(53);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // If we're in Chrome, look for the devtools marker and provide a download
	    // link if not installed.
	    if (navigator.userAgent.indexOf('Chrome') > -1) {
	      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	        console.debug(
	          'Download the React DevTools for a better development experience: ' +
	          'https://fb.me/react-devtools'
	        );
	      }
	    }
	
	    var expectedFeatures = [
	      // shims
	      Array.isArray,
	      Array.prototype.every,
	      Array.prototype.forEach,
	      Array.prototype.indexOf,
	      Array.prototype.map,
	      Date.now,
	      Function.prototype.bind,
	      Object.keys,
	      String.prototype.split,
	      String.prototype.trim,
	
	      // shams
	      Object.create,
	      Object.freeze
	    ];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        console.error(
	          'One or more ES5 shim/shams expected by React are not available: ' +
	          'https://fb.me/react-warning-polyfills'
	        );
	        break;
	      }
	    }
	  }
	}
	
	React.version = '0.13.3';
	
	module.exports = React;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 5 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            currentQueue[queueIndex].run();
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(7);
	
	var invariant = __webpack_require__(9);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `Mount`: [required] Module that can convert between React dom IDs and
	 *   actual node references.
	 */
	var injection = {
	  Mount: null,
	  injectMount: function(InjectedMount) {
	    injection.Mount = InjectedMount;
	    if ("production" !== process.env.NODE_ENV) {
	      ("production" !== process.env.NODE_ENV ? invariant(
	        InjectedMount && InjectedMount.getNode,
	        'EventPluginUtils.injection.injectMount(...): Injected Mount module ' +
	        'is missing getNode.'
	      ) : invariant(InjectedMount && InjectedMount.getNode));
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp ||
	         topLevelType === topLevelTypes.topTouchEnd ||
	         topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove ||
	         topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown ||
	         topLevelType === topLevelTypes.topTouchStart;
	}
	
	
	var validateEventDispatches;
	if ("production" !== process.env.NODE_ENV) {
	  validateEventDispatches = function(event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchIDs = event._dispatchIDs;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var idsIsArr = Array.isArray(dispatchIDs);
	    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
	    var listenersLen = listenersIsArr ?
	      dispatchListeners.length :
	      dispatchListeners ? 1 : 0;
	
	    ("production" !== process.env.NODE_ENV ? invariant(
	      idsIsArr === listenersIsArr && IDsLen === listenersLen,
	      'EventPluginUtils: Invalid `event`.'
	    ) : invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen));
	  };
	}
	
	/**
	 * Invokes `cb(event, listener, id)`. Avoids using call if no scope is
	 * provided. The `(listener,id)` pair effectively forms the "dispatch" but are
	 * kept separate to conserve memory.
	 */
	function forEachEventDispatch(event, cb) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if ("production" !== process.env.NODE_ENV) {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      cb(event, dispatchListeners[i], dispatchIDs[i]);
	    }
	  } else if (dispatchListeners) {
	    cb(event, dispatchListeners, dispatchIDs);
	  }
	}
	
	/**
	 * Default implementation of PluginModule.executeDispatch().
	 * @param {SyntheticEvent} SyntheticEvent to handle
	 * @param {function} Application-level callback
	 * @param {string} domID DOM id to pass to the callback.
	 */
	function executeDispatch(event, listener, domID) {
	  event.currentTarget = injection.Mount.getNode(domID);
	  var returnValue = listener(event, domID);
	  event.currentTarget = null;
	  return returnValue;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, cb) {
	  forEachEventDispatch(event, cb);
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return id of the first dispatch execution who's listener returns true, or
	 * null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if ("production" !== process.env.NODE_ENV) {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchIDs[i])) {
	        return dispatchIDs[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchIDs)) {
	      return dispatchIDs;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchIDs = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if ("production" !== process.env.NODE_ENV) {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchID = event._dispatchIDs;
	  ("production" !== process.env.NODE_ENV ? invariant(
	    !Array.isArray(dispatchListener),
	    'executeDirectDispatch(...): Invalid `event`.'
	  ) : invariant(!Array.isArray(dispatchListener)));
	  var res = dispatchListener ?
	    dispatchListener(event, dispatchID) :
	    null;
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {bool} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatch: executeDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	  injection: injection,
	  useTouchEvents: false
	};
	
	module.exports = EventPluginUtils;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(8);
	
	var PropagationPhases = keyMirror({bubbled: null, captured: null});
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topBlur: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topReset: null,
	  topScroll: null,
	  topSelectionChange: null,
	  topSubmit: null,
	  topTextInput: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyMirror
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(9);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function(obj) {
	  var ret = {};
	  var key;
	  ("production" !== process.env.NODE_ENV ? invariant(
	    obj instanceof Object && !Array.isArray(obj),
	    'keyMirror(...): Argument must be an object.'
	  ) : invariant(obj instanceof Object && !Array.isArray(obj)));
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */
	
	"use strict";
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if ("production" !== process.env.NODE_ENV) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        'Invariant Violation: ' +
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(11);
	var ReactFragment = __webpack_require__(12);
	
	var traverseAllChildren = __webpack_require__(20);
	var warning = __webpack_require__(17);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var threeArgumentPooler = PooledClass.threeArgumentPooler;
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.forEachFunction = forEachFunction;
	  this.forEachContext = forEachContext;
	}
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(traverseContext, child, name, i) {
	  var forEachBookKeeping = traverseContext;
	  forEachBookKeeping.forEachFunction.call(
	    forEachBookKeeping.forEachContext, child, i);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc.
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	
	  var traverseContext =
	    ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, mapFunction, mapContext) {
	  this.mapResult = mapResult;
	  this.mapFunction = mapFunction;
	  this.mapContext = mapContext;
	}
	PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);
	
	function mapSingleChildIntoContext(traverseContext, child, name, i) {
	  var mapBookKeeping = traverseContext;
	  var mapResult = mapBookKeeping.mapResult;
	
	  var keyUnique = !mapResult.hasOwnProperty(name);
	  if ("production" !== process.env.NODE_ENV) {
	    ("production" !== process.env.NODE_ENV ? warning(
	      keyUnique,
	      'ReactChildren.map(...): Encountered two children with the same key, ' +
	      '`%s`. Child keys must be unique; when two children share a key, only ' +
	      'the first child will be used.',
	      name
	    ) : null);
	  }
	
	  if (keyUnique) {
	    var mappedChild =
	      mapBookKeeping.mapFunction.call(mapBookKeeping.mapContext, child, i);
	    mapResult[name] = mappedChild;
	  }
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * TODO: This may likely break any calls to `ReactChildren.map` that were
	 * previously relying on the fact that we guarded against null children.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} mapFunction.
	 * @param {*} mapContext Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	
	  var mapResult = {};
	  var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	  return ReactFragment.create(mapResult);
	}
	
	function forEachSingleChildDummy(traverseContext, child, name, i) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  count: countChildren
	};
	
	module.exports = ReactChildren;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(9);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function(copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function(a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function(a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function(instance) {
	  var Klass = this;
	  ("production" !== process.env.NODE_ENV ? invariant(
	    instance instanceof Klass,
	    'Trying to release an instance into a pool of a different type.'
	  ) : invariant(instance instanceof Klass));
	  if (instance.destructor) {
	    instance.destructor();
	  }
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances (optional).
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function(CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule ReactFragment
	*/
	
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	
	var warning = __webpack_require__(17);
	
	/**
	 * We used to allow keyed objects to serve as a collection of ReactElements,
	 * or nested sets. This allowed us a way to explicitly key a set a fragment of
	 * components. This is now being replaced with an opaque data structure.
	 * The upgrade path is to call React.addons.createFragment({ key: value }) to
	 * create a keyed fragment. The resulting data structure is opaque, for now.
	 */
	
	if ("production" !== process.env.NODE_ENV) {
	  var fragmentKey = '_reactFragment';
	  var didWarnKey = '_reactDidWarn';
	  var canWarnForReactFragment = false;
	
	  try {
	    // Feature test. Don't even try to issue this warning if we can't use
	    // enumerable: false.
	
	    var dummy = function() {
	      return 1;
	    };
	
	    Object.defineProperty(
	      {},
	      fragmentKey,
	      {enumerable: false, value: true}
	    );
	
	    Object.defineProperty(
	      {},
	      'key',
	      {enumerable: true, get: dummy}
	    );
	
	    canWarnForReactFragment = true;
	  } catch (x) { }
	
	  var proxyPropertyAccessWithWarning = function(obj, key) {
	    Object.defineProperty(obj, key, {
	      enumerable: true,
	      get: function() {
	        ("production" !== process.env.NODE_ENV ? warning(
	          this[didWarnKey],
	          'A ReactFragment is an opaque type. Accessing any of its ' +
	          'properties is deprecated. Pass it to one of the React.Children ' +
	          'helpers.'
	        ) : null);
	        this[didWarnKey] = true;
	        return this[fragmentKey][key];
	      },
	      set: function(value) {
	        ("production" !== process.env.NODE_ENV ? warning(
	          this[didWarnKey],
	          'A ReactFragment is an immutable opaque type. Mutating its ' +
	          'properties is deprecated.'
	        ) : null);
	        this[didWarnKey] = true;
	        this[fragmentKey][key] = value;
	      }
	    });
	  };
	
	  var issuedWarnings = {};
	
	  var didWarnForFragment = function(fragment) {
	    // We use the keys and the type of the value as a heuristic to dedupe the
	    // warning to avoid spamming too much.
	    var fragmentCacheKey = '';
	    for (var key in fragment) {
	      fragmentCacheKey += key + ':' + (typeof fragment[key]) + ',';
	    }
	    var alreadyWarnedOnce = !!issuedWarnings[fragmentCacheKey];
	    issuedWarnings[fragmentCacheKey] = true;
	    return alreadyWarnedOnce;
	  };
	}
	
	var ReactFragment = {
	  // Wrap a keyed object in an opaque proxy that warns you if you access any
	  // of its properties.
	  create: function(object) {
	    if ("production" !== process.env.NODE_ENV) {
	      if (typeof object !== 'object' || !object || Array.isArray(object)) {
	        ("production" !== process.env.NODE_ENV ? warning(
	          false,
	          'React.addons.createFragment only accepts a single object.',
	          object
	        ) : null);
	        return object;
	      }
	      if (ReactElement.isValidElement(object)) {
	        ("production" !== process.env.NODE_ENV ? warning(
	          false,
	          'React.addons.createFragment does not accept a ReactElement ' +
	          'without a wrapper object.'
	        ) : null);
	        return object;
	      }
	      if (canWarnForReactFragment) {
	        var proxy = {};
	        Object.defineProperty(proxy, fragmentKey, {
	          enumerable: false,
	          value: object
	        });
	        Object.defineProperty(proxy, didWarnKey, {
	          writable: true,
	          enumerable: false,
	          value: false
	        });
	        for (var key in object) {
	          proxyPropertyAccessWithWarning(proxy, key);
	        }
	        Object.preventExtensions(proxy);
	        return proxy;
	      }
	    }
	    return object;
	  },
	  // Extract the original keyed object from the fragment opaque type. Warn if
	  // a plain object is passed here.
	  extract: function(fragment) {
	    if ("production" !== process.env.NODE_ENV) {
	      if (canWarnForReactFragment) {
	        if (!fragment[fragmentKey]) {
	          ("production" !== process.env.NODE_ENV ? warning(
	            didWarnForFragment(fragment),
	            'Any use of a keyed object should be wrapped in ' +
	            'React.addons.createFragment(object) before being passed as a ' +
	            'child.'
	          ) : null);
	          return fragment;
	        }
	        return fragment[fragmentKey];
	      }
	    }
	    return fragment;
	  },
	  // Check if this is a fragment and if so, extract the keyed object. If it
	  // is a fragment-like object, warn that it should be wrapped. Ignore if we
	  // can't determine what kind of object this is.
	  extractIfFragment: function(fragment) {
	    if ("production" !== process.env.NODE_ENV) {
	      if (canWarnForReactFragment) {
	        // If it is the opaque type, return the keyed object.
	        if (fragment[fragmentKey]) {
	          return fragment[fragmentKey];
	        }
	        // Otherwise, check each property if it has an element, if it does
	        // it is probably meant as a fragment, so we can warn early. Defer,
	        // the warning to extract.
	        for (var key in fragment) {
	          if (fragment.hasOwnProperty(key) &&
	              ReactElement.isValidElement(fragment[key])) {
	            // This looks like a fragment object, we should provide an
	            // early warning.
	            return ReactFragment.extract(fragment);
	          }
	        }
	      }
	    }
	    return fragment;
	  }
	};
	
	module.exports = ReactFragment;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var ReactContext = __webpack_require__(14);
	var ReactCurrentOwner = __webpack_require__(19);
	
	var assign = __webpack_require__(15);
	var warning = __webpack_require__(17);
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true
	};
	
	/**
	 * Warn for mutations.
	 *
	 * @internal
	 * @param {object} object
	 * @param {string} key
	 */
	function defineWarningProperty(object, key) {
	  Object.defineProperty(object, key, {
	
	    configurable: false,
	    enumerable: true,
	
	    get: function() {
	      if (!this._store) {
	        return null;
	      }
	      return this._store[key];
	    },
	
	    set: function(value) {
	      ("production" !== process.env.NODE_ENV ? warning(
	        false,
	        'Don\'t set the %s property of the React element. Instead, ' +
	        'specify the correct value when initially creating the element.',
	        key
	      ) : null);
	      this._store[key] = value;
	    }
	
	  });
	}
	
	/**
	 * This is updated to true if the membrane is successfully created.
	 */
	var useMutationMembrane = false;
	
	/**
	 * Warn for mutations.
	 *
	 * @internal
	 * @param {object} element
	 */
	function defineMutationMembrane(prototype) {
	  try {
	    var pseudoFrozenProperties = {
	      props: true
	    };
	    for (var key in pseudoFrozenProperties) {
	      defineWarningProperty(prototype, key);
	    }
	    useMutationMembrane = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	/**
	 * Base constructor for all React elements. This is only used to make this
	 * work with a dynamic instanceof check. Nothing should live on this prototype.
	 *
	 * @param {*} type
	 * @param {string|object} ref
	 * @param {*} key
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function(type, key, ref, owner, context, props) {
	  // Built-in properties that belong on the element
	  this.type = type;
	  this.key = key;
	  this.ref = ref;
	
	  // Record the component responsible for creating this element.
	  this._owner = owner;
	
	  // TODO: Deprecate withContext, and then the context becomes accessible
	  // through the owner.
	  this._context = context;
	
	  if ("production" !== process.env.NODE_ENV) {
	    // The validation flag and props are currently mutative. We put them on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    this._store = {props: props, originalProps: assign({}, props)};
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    try {
	      Object.defineProperty(this._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true
	      });
	    } catch (x) {
	    }
	    this._store.validated = false;
	
	    // We're not allowed to set props directly on the object so we early
	    // return and rely on the prototype membrane to forward to the backing
	    // store.
	    if (useMutationMembrane) {
	      Object.freeze(this);
	      return;
	    }
	  }
	
	  this.props = props;
	};
	
	// We intentionally don't expose the function on the constructor property.
	// ReactElement should be indistinguishable from a plain object.
	ReactElement.prototype = {
	  _isReactElement: true
	};
	
	if ("production" !== process.env.NODE_ENV) {
	  defineMutationMembrane(ReactElement.prototype);
	}
	
	ReactElement.createElement = function(type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	
	  if (config != null) {
	    ref = config.ref === undefined ? null : config.ref;
	    key = config.key === undefined ? null : '' + config.key;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) &&
	          !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (typeof props[propName] === 'undefined') {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	
	  return new ReactElement(
	    type,
	    key,
	    ref,
	    ReactCurrentOwner.current,
	    ReactContext.current,
	    props
	  );
	};
	
	ReactElement.createFactory = function(type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. <Foo />.type === Foo.type.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceProps = function(oldElement, newProps) {
	  var newElement = new ReactElement(
	    oldElement.type,
	    oldElement.key,
	    oldElement.ref,
	    oldElement._owner,
	    oldElement._context,
	    newProps
	  );
	
	  if ("production" !== process.env.NODE_ENV) {
	    // If the key on the original is valid, then the clone is valid
	    newElement._store.validated = oldElement._store.validated;
	  }
	  return newElement;
	};
	
	ReactElement.cloneElement = function(element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (config.ref !== undefined) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (config.key !== undefined) {
	      key = '' + config.key;
	    }
	    // Remaining properties override existing props
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) &&
	          !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return new ReactElement(
	    element.type,
	    key,
	    ref,
	    owner,
	    element._context,
	    props
	  );
	};
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function(object) {
	  // ReactTestUtils is often used outside of beforeEach where as React is
	  // within it. This leads to two different instances of React on the same
	  // page. To identify a element from a different React instance we use
	  // a flag instead of an instanceof check.
	  var isElement = !!(object && object._isReactElement);
	  // if (isElement && !(object instanceof ReactElement)) {
	  // This is an indicator that you're using multiple versions of React at the
	  // same time. This will screw with ownership and stuff. Fix it, please.
	  // TODO: We could possibly warn here.
	  // }
	  return isElement;
	};
	
	module.exports = ReactElement;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactContext
	 */
	
	'use strict';
	
	var assign = __webpack_require__(15);
	var emptyObject = __webpack_require__(16);
	var warning = __webpack_require__(17);
	
	var didWarn = false;
	
	/**
	 * Keeps track of the current context.
	 *
	 * The context is automatically passed down the component ownership hierarchy
	 * and is accessible via `this.context` on ReactCompositeComponents.
	 */
	var ReactContext = {
	
	  /**
	   * @internal
	   * @type {object}
	   */
	  current: emptyObject,
	
	  /**
	   * Temporarily extends the current context while executing scopedCallback.
	   *
	   * A typical use case might look like
	   *
	   *  render: function() {
	   *    var children = ReactContext.withContext({foo: 'foo'}, () => (
	   *
	   *    ));
	   *    return <div>{children}</div>;
	   *  }
	   *
	   * @param {object} newContext New context to merge into the existing context
	   * @param {function} scopedCallback Callback to run with the new context
	   * @return {ReactComponent|array<ReactComponent>}
	   */
	  withContext: function(newContext, scopedCallback) {
	    if ("production" !== process.env.NODE_ENV) {
	      ("production" !== process.env.NODE_ENV ? warning(
	        didWarn,
	        'withContext is deprecated and will be removed in a future version. ' +
	        'Use a wrapper component with getChildContext instead.'
	      ) : null);
	
	      didWarn = true;
	    }
	
	    var result;
	    var previousContext = ReactContext.current;
	    ReactContext.current = assign({}, previousContext, newContext);
	    try {
	      result = scopedCallback();
	    } finally {
	      ReactContext.current = previousContext;
	    }
	    return result;
	  }
	
	};
	
	module.exports = ReactContext;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 15 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Object.assign
	 */
	
	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign
	
	'use strict';
	
	function assign(target, sources) {
	  if (target == null) {
	    throw new TypeError('Object.assign target cannot be null or undefined');
	  }
	
	  var to = Object(target);
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
	    var nextSource = arguments[nextIndex];
	    if (nextSource == null) {
	      continue;
	    }
	
	    var from = Object(nextSource);
	
	    // We don't currently support accessors nor proxies. Therefore this
	    // copy cannot throw. If we ever supported this then we must handle
	    // exceptions and side-effects. We don't support symbols so they won't
	    // be transferred.
	
	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }
	  }
	
	  return to;
	}
	
	module.exports = assign;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyObject
	 */
	
	"use strict";
	
	var emptyObject = {};
	
	if ("production" !== process.env.NODE_ENV) {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */
	
	"use strict";
	
	var emptyFunction = __webpack_require__(18);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if ("production" !== process.env.NODE_ENV) {
	  warning = function(condition, format ) {for (var args=[],$__0=2,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);
	    if (format === undefined) {
	      throw new Error(
	        '`warning(condition, format, ...args)` requires a warning ' +
	        'message argument'
	      );
	    }
	
	    if (format.length < 10 || /^[s\W]*$/.test(format)) {
	      throw new Error(
	        'The warning format should be able to uniquely identify this ' +
	        'warning. Please, use a more descriptive format than: ' + format
	      );
	    }
	
	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function()  {return args[argIndex++];});
	      console.warn(message);
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch(x) {}
	    }
	  };
	}
	
	module.exports = warning;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 18 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */
	
	function makeEmptyFunction(arg) {
	  return function() {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function() { return this; };
	emptyFunction.thatReturnsArgument = function(arg) { return arg; };
	
	module.exports = emptyFunction;


/***/ },
/* 19 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 *
	 * The depth indicate how many composite components are above this render level.
	 */
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	var ReactFragment = __webpack_require__(12);
	var ReactInstanceHandles = __webpack_require__(21);
	
	var getIteratorFn = __webpack_require__(23);
	var invariant = __webpack_require__(9);
	var warning = __webpack_require__(17);
	
	var SEPARATOR = ReactInstanceHandles.SEPARATOR;
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var userProvidedKeyEscaperLookup = {
	  '=': '=0',
	  '.': '=1',
	  ':': '=2'
	};
	
	var userProvidedKeyEscapeRegex = /[=.:]/g;
	
	var didWarnAboutMaps = false;
	
	function userProvidedKeyEscaper(match) {
	  return userProvidedKeyEscaperLookup[match];
	}
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  if (component && component.key != null) {
	    // Explicit key
	    return wrapUserProvidedKey(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * Escape a component key so that it is safe to use in a reactid.
	 *
	 * @param {*} key Component key to be escaped.
	 * @return {string} An escaped string.
	 */
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(
	    userProvidedKeyEscapeRegex,
	    userProvidedKeyEscaper
	  );
	}
	
	/**
	 * Wrap a `key` value explicitly provided by the user to distinguish it from
	 * implicitly-generated keys generated by a component's index in its parent.
	 *
	 * @param {string} key Value of a user-provided `key` attribute
	 * @return {string}
	 */
	function wrapUserProvidedKey(key) {
	  return '$' + escapeUserProvidedKey(key);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!number} indexSoFar Number of children encountered until this point.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(
	  children,
	  nameSoFar,
	  indexSoFar,
	  callback,
	  traverseContext
	) {
	  var type = typeof children;
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null ||
	      type === 'string' ||
	      type === 'number' ||
	      ReactElement.isValidElement(children)) {
	    callback(
	      traverseContext,
	      children,
	      // If it's the only child, treat the name as if it was wrapped in an array
	      // so that it's consistent if the number of children grows.
	      nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,
	      indexSoFar
	    );
	    return 1;
	  }
	
	  var child, nextName, nextIndex;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = (
	        (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) +
	        getComponentKey(child, i)
	      );
	      nextIndex = indexSoFar + subtreeCount;
	      subtreeCount += traverseAllChildrenImpl(
	        child,
	        nextName,
	        nextIndex,
	        callback,
	        traverseContext
	      );
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = (
	            (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) +
	            getComponentKey(child, ii++)
	          );
	          nextIndex = indexSoFar + subtreeCount;
	          subtreeCount += traverseAllChildrenImpl(
	            child,
	            nextName,
	            nextIndex,
	            callback,
	            traverseContext
	          );
	        }
	      } else {
	        if ("production" !== process.env.NODE_ENV) {
	          ("production" !== process.env.NODE_ENV ? warning(
	            didWarnAboutMaps,
	            'Using Maps as children is not yet fully supported. It is an ' +
	            'experimental feature that might be removed. Convert it to a ' +
	            'sequence / iterable of keyed ReactElements instead.'
	          ) : null);
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = (
	              (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) +
	              wrapUserProvidedKey(entry[0]) + SUBSEPARATOR +
	              getComponentKey(child, 0)
	            );
	            nextIndex = indexSoFar + subtreeCount;
	            subtreeCount += traverseAllChildrenImpl(
	              child,
	              nextName,
	              nextIndex,
	              callback,
	              traverseContext
	            );
	          }
	        }
	      }
	    } else if (type === 'object') {
	      ("production" !== process.env.NODE_ENV ? invariant(
	        children.nodeType !== 1,
	        'traverseAllChildren(...): Encountered an invalid child; DOM ' +
	        'elements are not valid children of React components.'
	      ) : invariant(children.nodeType !== 1));
	      var fragment = ReactFragment.extract(children);
	      for (var key in fragment) {
	        if (fragment.hasOwnProperty(key)) {
	          child = fragment[key];
	          nextName = (
	            (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) +
	            wrapUserProvidedKey(key) + SUBSEPARATOR +
	            getComponentKey(child, 0)
	          );
	          nextIndex = indexSoFar + subtreeCount;
	          subtreeCount += traverseAllChildrenImpl(
	            child,
	            nextName,
	            nextIndex,
	            callback,
	            traverseContext
	          );
	        }
	      }
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceHandles
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactRootIndex = __webpack_require__(22);
	
	var invariant = __webpack_require__(9);
	
	var SEPARATOR = '.';
	var SEPARATOR_LENGTH = SEPARATOR.length;
	
	/**
	 * Maximum depth of traversals before we consider the possibility of a bad ID.
	 */
	var MAX_TREE_DEPTH = 100;
	
	/**
	 * Creates a DOM ID prefix to use when mounting React components.
	 *
	 * @param {number} index A unique integer
	 * @return {string} React root ID.
	 * @internal
	 */
	function getReactRootIDString(index) {
	  return SEPARATOR + index.toString(36);
	}
	
	/**
	 * Checks if a character in the supplied ID is a separator or the end.
	 *
	 * @param {string} id A React DOM ID.
	 * @param {number} index Index of the character to check.
	 * @return {boolean} True if the character is a separator or end of the ID.
	 * @private
	 */
	function isBoundary(id, index) {
	  return id.charAt(index) === SEPARATOR || index === id.length;
	}
	
	/**
	 * Checks if the supplied string is a valid React DOM ID.
	 *
	 * @param {string} id A React DOM ID, maybe.
	 * @return {boolean} True if the string is a valid React DOM ID.
	 * @private
	 */
	function isValidID(id) {
	  return id === '' || (
	    id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR
	  );
	}
	
	/**
	 * Checks if the first ID is an ancestor of or equal to the second ID.
	 *
	 * @param {string} ancestorID
	 * @param {string} descendantID
	 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
	 * @internal
	 */
	function isAncestorIDOf(ancestorID, descendantID) {
	  return (
	    descendantID.indexOf(ancestorID) === 0 &&
	    isBoundary(descendantID, ancestorID.length)
	  );
	}
	
	/**
	 * Gets the parent ID of the supplied React DOM ID, `id`.
	 *
	 * @param {string} id ID of a component.
	 * @return {string} ID of the parent, or an empty string.
	 * @private
	 */
	function getParentID(id) {
	  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
	}
	
	/**
	 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
	 * supplied `destinationID`. If they are equal, the ID is returned.
	 *
	 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
	 * @param {string} destinationID ID of the destination node.
	 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
	 * @private
	 */
	function getNextDescendantID(ancestorID, destinationID) {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    isValidID(ancestorID) && isValidID(destinationID),
	    'getNextDescendantID(%s, %s): Received an invalid React DOM ID.',
	    ancestorID,
	    destinationID
	  ) : invariant(isValidID(ancestorID) && isValidID(destinationID)));
	  ("production" !== process.env.NODE_ENV ? invariant(
	    isAncestorIDOf(ancestorID, destinationID),
	    'getNextDescendantID(...): React has made an invalid assumption about ' +
	    'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.',
	    ancestorID,
	    destinationID
	  ) : invariant(isAncestorIDOf(ancestorID, destinationID)));
	  if (ancestorID === destinationID) {
	    return ancestorID;
	  }
	  // Skip over the ancestor and the immediate separator. Traverse until we hit
	  // another separator or we reach the end of `destinationID`.
	  var start = ancestorID.length + SEPARATOR_LENGTH;
	  var i;
	  for (i = start; i < destinationID.length; i++) {
	    if (isBoundary(destinationID, i)) {
	      break;
	    }
	  }
	  return destinationID.substr(0, i);
	}
	
	/**
	 * Gets the nearest common ancestor ID of two IDs.
	 *
	 * Using this ID scheme, the nearest common ancestor ID is the longest common
	 * prefix of the two IDs that immediately preceded a "marker" in both strings.
	 *
	 * @param {string} oneID
	 * @param {string} twoID
	 * @return {string} Nearest common ancestor ID, or the empty string if none.
	 * @private
	 */
	function getFirstCommonAncestorID(oneID, twoID) {
	  var minLength = Math.min(oneID.length, twoID.length);
	  if (minLength === 0) {
	    return '';
	  }
	  var lastCommonMarkerIndex = 0;
	  // Use `<=` to traverse until the "EOL" of the shorter string.
	  for (var i = 0; i <= minLength; i++) {
	    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
	      lastCommonMarkerIndex = i;
	    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
	      break;
	    }
	  }
	  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
	  ("production" !== process.env.NODE_ENV ? invariant(
	    isValidID(longestCommonID),
	    'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s',
	    oneID,
	    twoID,
	    longestCommonID
	  ) : invariant(isValidID(longestCommonID)));
	  return longestCommonID;
	}
	
	/**
	 * Traverses the parent path between two IDs (either up or down). The IDs must
	 * not be the same, and there must exist a parent path between them. If the
	 * callback returns `false`, traversal is stopped.
	 *
	 * @param {?string} start ID at which to start traversal.
	 * @param {?string} stop ID at which to end traversal.
	 * @param {function} cb Callback to invoke each ID with.
	 * @param {?boolean} skipFirst Whether or not to skip the first node.
	 * @param {?boolean} skipLast Whether or not to skip the last node.
	 * @private
	 */
	function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
	  start = start || '';
	  stop = stop || '';
	  ("production" !== process.env.NODE_ENV ? invariant(
	    start !== stop,
	    'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.',
	    start
	  ) : invariant(start !== stop));
	  var traverseUp = isAncestorIDOf(stop, start);
	  ("production" !== process.env.NODE_ENV ? invariant(
	    traverseUp || isAncestorIDOf(start, stop),
	    'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' +
	    'not have a parent path.',
	    start,
	    stop
	  ) : invariant(traverseUp || isAncestorIDOf(start, stop)));
	  // Traverse from `start` to `stop` one depth at a time.
	  var depth = 0;
	  var traverse = traverseUp ? getParentID : getNextDescendantID;
	  for (var id = start; /* until break */; id = traverse(id, stop)) {
	    var ret;
	    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
	      ret = cb(id, traverseUp, arg);
	    }
	    if (ret === false || id === stop) {
	      // Only break //after// visiting `stop`.
	      break;
	    }
	    ("production" !== process.env.NODE_ENV ? invariant(
	      depth++ < MAX_TREE_DEPTH,
	      'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' +
	      'traversing the React DOM ID tree. This may be due to malformed IDs: %s',
	      start, stop
	    ) : invariant(depth++ < MAX_TREE_DEPTH));
	  }
	}
	
	/**
	 * Manages the IDs assigned to DOM representations of React components. This
	 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
	 * order to simulate events).
	 *
	 * @internal
	 */
	var ReactInstanceHandles = {
	
	  /**
	   * Constructs a React root ID
	   * @return {string} A React root ID.
	   */
	  createReactRootID: function() {
	    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
	  },
	
	  /**
	   * Constructs a React ID by joining a root ID with a name.
	   *
	   * @param {string} rootID Root ID of a parent component.
	   * @param {string} name A component's name (as flattened children).
	   * @return {string} A React ID.
	   * @internal
	   */
	  createReactID: function(rootID, name) {
	    return rootID + name;
	  },
	
	  /**
	   * Gets the DOM ID of the React component that is the root of the tree that
	   * contains the React component with the supplied DOM ID.
	   *
	   * @param {string} id DOM ID of a React component.
	   * @return {?string} DOM ID of the React component that is the root.
	   * @internal
	   */
	  getReactRootIDFromNodeID: function(id) {
	    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
	      var index = id.indexOf(SEPARATOR, 1);
	      return index > -1 ? id.substr(0, index) : id;
	    }
	    return null;
	  },
	
	  /**
	   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	   * should would receive a `mouseEnter` or `mouseLeave` event.
	   *
	   * NOTE: Does not invoke the callback on the nearest common ancestor because
	   * nothing "entered" or "left" that element.
	   *
	   * @param {string} leaveID ID being left.
	   * @param {string} enterID ID being entered.
	   * @param {function} cb Callback to invoke on each entered/left ID.
	   * @param {*} upArg Argument to invoke the callback with on left IDs.
	   * @param {*} downArg Argument to invoke the callback with on entered IDs.
	   * @internal
	   */
	  traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {
	    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
	    if (ancestorID !== leaveID) {
	      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
	    }
	    if (ancestorID !== enterID) {
	      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
	    }
	  },
	
	  /**
	   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseTwoPhase: function(targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, false);
	      traverseParentPath(targetID, '', cb, arg, false, true);
	    }
	  },
	
	  /**
	   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
	   * example, passing `.0.$row-0.1` would result in `cb` getting called
	   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseAncestors: function(targetID, cb, arg) {
	    traverseParentPath('', targetID, cb, arg, true, false);
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _getFirstCommonAncestorID: getFirstCommonAncestorID,
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _getNextDescendantID: getNextDescendantID,
	
	  isAncestorIDOf: isAncestorIDOf,
	
	  SEPARATOR: SEPARATOR
	
	};
	
	module.exports = ReactInstanceHandles;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 22 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactRootIndexInjection = {
	  /**
	   * @param {function} _createReactRootIndex
	   */
	  injectCreateReactRootIndex: function(_createReactRootIndex) {
	    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
	  }
	};
	
	var ReactRootIndex = {
	  createReactRootIndex: null,
	  injection: ReactRootIndexInjection
	};
	
	module.exports = ReactRootIndex;


/***/ },
/* 23 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/* global Symbol */
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (
	    (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL])
	  );
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var ReactUpdateQueue = __webpack_require__(25);
	
	var invariant = __webpack_require__(9);
	var warning = __webpack_require__(17);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context) {
	  this.props = props;
	  this.context = context;
	}
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function(partialState, callback) {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    typeof partialState === 'object' ||
	    typeof partialState === 'function' ||
	    partialState == null,
	    'setState(...): takes an object of state variables to update or a ' +
	    'function which returns an object of state variables.'
	  ) : invariant(typeof partialState === 'object' ||
	  typeof partialState === 'function' ||
	  partialState == null));
	  if ("production" !== process.env.NODE_ENV) {
	    ("production" !== process.env.NODE_ENV ? warning(
	      partialState != null,
	      'setState(...): You passed an undefined or null state object; ' +
	      'instead, use forceUpdate().'
	    ) : null);
	  }
	  ReactUpdateQueue.enqueueSetState(this, partialState);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function(callback) {
	  ReactUpdateQueue.enqueueForceUpdate(this);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if ("production" !== process.env.NODE_ENV) {
	  var deprecatedAPIs = {
	    getDOMNode: [
	      'getDOMNode',
	      'Use React.findDOMNode(component) instead.'
	    ],
	    isMounted: [
	      'isMounted',
	      'Instead, make sure to clean up subscriptions and pending requests in ' +
	      'componentWillUnmount to prevent memory leaks.'
	    ],
	    replaceProps: [
	      'replaceProps',
	      'Instead, call React.render again at the top level.'
	    ],
	    replaceState: [
	      'replaceState',
	      'Refactor your code to use setState instead (see ' +
	      'https://github.com/facebook/react/issues/3236).'
	    ],
	    setProps: [
	      'setProps',
	      'Instead, call React.render again at the top level.'
	    ]
	  };
	  var defineDeprecationWarning = function(methodName, info) {
	    try {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function() {
	          ("production" !== process.env.NODE_ENV ? warning(
	            false,
	            '%s(...) is deprecated in plain JavaScript React classes. %s',
	            info[0],
	            info[1]
	          ) : null);
	          return undefined;
	        }
	      });
	    } catch (x) {
	      // IE will fail on defineProperty (es5-shim/sham too)
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var ReactLifeCycle = __webpack_require__(26);
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactElement = __webpack_require__(13);
	var ReactInstanceMap = __webpack_require__(27);
	var ReactUpdates = __webpack_require__(28);
	
	var assign = __webpack_require__(15);
	var invariant = __webpack_require__(9);
	var warning = __webpack_require__(17);
	
	function enqueueUpdate(internalInstance) {
	  if (internalInstance !== ReactLifeCycle.currentlyMountingInstance) {
	    // If we're in a componentWillMount handler, don't enqueue a rerender
	    // because ReactUpdates assumes we're in a browser context (which is
	    // wrong for server rendering) and we're about to do a render anyway.
	    // See bug in #1740.
	    ReactUpdates.enqueueUpdate(internalInstance);
	  }
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    ReactCurrentOwner.current == null,
	    '%s(...): Cannot update during an existing state transition ' +
	    '(such as within `render`). Render methods should be a pure function ' +
	    'of props and state.',
	    callerName
	  ) : invariant(ReactCurrentOwner.current == null));
	
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if ("production" !== process.env.NODE_ENV) {
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      ("production" !== process.env.NODE_ENV ? warning(
	        !callerName,
	        '%s(...): Can only update a mounted or mounting component. ' +
	        'This usually means you called %s() on an unmounted ' +
	        'component. This is a no-op.',
	        callerName,
	        callerName
	      ) : null);
	    }
	    return null;
	  }
	
	  if (internalInstance === ReactLifeCycle.currentlyUnmountingInstance) {
	    return null;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function(publicInstance, callback) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      typeof callback === 'function',
	      'enqueueCallback(...): You called `setProps`, `replaceProps`, ' +
	      '`setState`, `replaceState`, or `forceUpdate` with a callback that ' +
	      'isn\'t callable.'
	    ) : invariant(typeof callback === 'function'));
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance ||
	        internalInstance === ReactLifeCycle.currentlyMountingInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function(internalInstance, callback) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      typeof callback === 'function',
	      'enqueueCallback(...): You called `setProps`, `replaceProps`, ' +
	      '`setState`, `replaceState`, or `forceUpdate` with a callback that ' +
	      'isn\'t callable.'
	    ) : invariant(typeof callback === 'function'));
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldUpdateComponent`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function(publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(
	      publicInstance,
	      'forceUpdate'
	    );
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function(publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(
	      publicInstance,
	      'replaceState'
	    );
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function(publicInstance, partialState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(
	      publicInstance,
	      'setState'
	    );
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue =
	      internalInstance._pendingStateQueue ||
	      (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function(publicInstance, partialProps) {
	    var internalInstance = getInternalInstanceReadyForUpdate(
	      publicInstance,
	      'setProps'
	    );
	
	    if (!internalInstance) {
	      return;
	    }
	
	    ("production" !== process.env.NODE_ENV ? invariant(
	      internalInstance._isTopLevel,
	      'setProps(...): You called `setProps` on a ' +
	      'component with a parent. This is an anti-pattern since props will ' +
	      'get reactively updated when rendered. Instead, change the owner\'s ' +
	      '`render` method to pass the correct value as props to the component ' +
	      'where it is created.'
	    ) : invariant(internalInstance._isTopLevel));
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var element = internalInstance._pendingElement ||
	                  internalInstance._currentElement;
	    var props = assign({}, element.props, partialProps);
	    internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(
	      element,
	      props
	    );
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function(publicInstance, props) {
	    var internalInstance = getInternalInstanceReadyForUpdate(
	      publicInstance,
	      'replaceProps'
	    );
	
	    if (!internalInstance) {
	      return;
	    }
	
	    ("production" !== process.env.NODE_ENV ? invariant(
	      internalInstance._isTopLevel,
	      'replaceProps(...): You called `replaceProps` on a ' +
	      'component with a parent. This is an anti-pattern since props will ' +
	      'get reactively updated when rendered. Instead, change the owner\'s ' +
	      '`render` method to pass the correct value as props to the component ' +
	      'where it is created.'
	    ) : invariant(internalInstance._isTopLevel));
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var element = internalInstance._pendingElement ||
	                  internalInstance._currentElement;
	    internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(
	      element,
	      props
	    );
	
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueElementInternal: function(internalInstance, newElement) {
	    internalInstance._pendingElement = newElement;
	    enqueueUpdate(internalInstance);
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 26 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactLifeCycle
	 */
	
	'use strict';
	
	/**
	 * This module manages the bookkeeping when a component is in the process
	 * of being mounted or being unmounted. This is used as a way to enforce
	 * invariants (or warnings) when it is not recommended to call
	 * setState/forceUpdate.
	 *
	 * currentlyMountingInstance: During the construction phase, it is not possible
	 * to trigger an update since the instance is not fully mounted yet. However, we
	 * currently allow this as a convenience for mutating the initial state.
	 *
	 * currentlyUnmountingInstance: During the unmounting phase, the instance is
	 * still mounted and can therefore schedule an update. However, this is not
	 * recommended and probably an error since it's about to be unmounted.
	 * Therefore we still want to trigger in an error for that case.
	 */
	
	var ReactLifeCycle = {
	  currentlyMountingInstance: null,
	  currentlyUnmountingInstance: null
	};
	
	module.exports = ReactLifeCycle;


/***/ },
/* 27 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function(key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function(key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function(key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function(key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(29);
	var PooledClass = __webpack_require__(11);
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactPerf = __webpack_require__(30);
	var ReactReconciler = __webpack_require__(31);
	var Transaction = __webpack_require__(38);
	
	var assign = __webpack_require__(15);
	var invariant = __webpack_require__(9);
	var warning = __webpack_require__(17);
	
	var dirtyComponents = [];
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    ReactUpdates.ReactReconcileTransaction && batchingStrategy,
	    'ReactUpdates: must inject a reconcile transaction class and batching ' +
	    'strategy'
	  ) : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy));
	}
	
	var NESTED_UPDATES = {
	  initialize: function() {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function() {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function() {
	    this.callbackQueue.reset();
	  },
	  close: function() {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction =
	    ReactUpdates.ReactReconcileTransaction.getPooled();
	}
	
	assign(
	  ReactUpdatesFlushTransaction.prototype,
	  Transaction.Mixin, {
	  getTransactionWrappers: function() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function() {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function(method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(
	      this,
	      this.reconcileTransaction.perform,
	      this.reconcileTransaction,
	      method,
	      scope,
	      a
	    );
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  ("production" !== process.env.NODE_ENV ? invariant(
	    len === dirtyComponents.length,
	    'Expected flush transaction\'s stored dirty-components length (%s) to ' +
	    'match dirty-components array length (%s).',
	    len,
	    dirtyComponents.length
	  ) : invariant(len === dirtyComponents.length));
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    ReactReconciler.performUpdateIfNecessary(
	      component,
	      transaction.reconcileTransaction
	    );
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(
	          callbacks[j],
	          component.getPublicInstance()
	        );
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function() {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	flushBatchedUpdates = ReactPerf.measure(
	  'ReactUpdates',
	  'flushBatchedUpdates',
	  flushBatchedUpdates
	);
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setProps, setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	  ("production" !== process.env.NODE_ENV ? warning(
	    ReactCurrentOwner.current == null,
	    'enqueueUpdate(): Render methods should be a pure function of props ' +
	    'and state; triggering nested component updates from render is not ' +
	    'allowed. If necessary, trigger nested updates in ' +
	    'componentDidUpdate.'
	  ) : null);
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    batchingStrategy.isBatchingUpdates,
	    'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' +
	    'updates are not being batched.'
	  ) : invariant(batchingStrategy.isBatchingUpdates));
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function(ReconcileTransaction) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      ReconcileTransaction,
	      'ReactUpdates: must provide a reconcile transaction class'
	    ) : invariant(ReconcileTransaction));
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function(_batchingStrategy) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      _batchingStrategy,
	      'ReactUpdates: must provide a batching strategy'
	    ) : invariant(_batchingStrategy));
	    ("production" !== process.env.NODE_ENV ? invariant(
	      typeof _batchingStrategy.batchedUpdates === 'function',
	      'ReactUpdates: must provide a batchedUpdates() function'
	    ) : invariant(typeof _batchingStrategy.batchedUpdates === 'function'));
	    ("production" !== process.env.NODE_ENV ? invariant(
	      typeof _batchingStrategy.isBatchingUpdates === 'boolean',
	      'ReactUpdates: must provide an isBatchingUpdates boolean attribute'
	    ) : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean'));
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(11);
	
	var assign = __webpack_require__(15);
	var invariant = __webpack_require__(9);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      ("production" !== process.env.NODE_ENV ? invariant(
	        callbacks.length === contexts.length,
	        'Mismatched list of contexts in callback queue'
	      ) : invariant(callbacks.length === contexts.length));
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0, l = callbacks.length; i < l; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function() {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function() {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * ReactPerf is a general AOP system designed to measure performance. This
	 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
	 */
	var ReactPerf = {
	  /**
	   * Boolean to enable/disable measurement. Set to false by default to prevent
	   * accidental logging and perf loss.
	   */
	  enableMeasure: false,
	
	  /**
	   * Holds onto the measure function in use. By default, don't measure
	   * anything, but we'll override this if we inject a measure function.
	   */
	  storedMeasure: _noMeasure,
	
	  /**
	   * @param {object} object
	   * @param {string} objectName
	   * @param {object<string>} methodNames
	   */
	  measureMethods: function(object, objectName, methodNames) {
	    if ("production" !== process.env.NODE_ENV) {
	      for (var key in methodNames) {
	        if (!methodNames.hasOwnProperty(key)) {
	          continue;
	        }
	        object[key] = ReactPerf.measure(
	          objectName,
	          methodNames[key],
	          object[key]
	        );
	      }
	    }
	  },
	
	  /**
	   * Use this to wrap methods you want to measure. Zero overhead in production.
	   *
	   * @param {string} objName
	   * @param {string} fnName
	   * @param {function} func
	   * @return {function}
	   */
	  measure: function(objName, fnName, func) {
	    if ("production" !== process.env.NODE_ENV) {
	      var measuredFunc = null;
	      var wrapper = function() {
	        if (ReactPerf.enableMeasure) {
	          if (!measuredFunc) {
	            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
	          }
	          return measuredFunc.apply(this, arguments);
	        }
	        return func.apply(this, arguments);
	      };
	      wrapper.displayName = objName + '_' + fnName;
	      return wrapper;
	    }
	    return func;
	  },
	
	  injection: {
	    /**
	     * @param {function} measure
	     */
	    injectMeasure: function(measure) {
	      ReactPerf.storedMeasure = measure;
	    }
	  }
	};
	
	/**
	 * Simply passes through the measured function, without measuring it.
	 *
	 * @param {string} objName
	 * @param {string} fnName
	 * @param {function} func
	 * @return {function}
	 */
	function _noMeasure(objName, fnName, func) {
	  return func;
	}
	
	module.exports = ReactPerf;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(32);
	var ReactElementValidator = __webpack_require__(34);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function(internalInstance, rootID, transaction, context) {
	    var markup = internalInstance.mountComponent(rootID, transaction, context);
	    if ("production" !== process.env.NODE_ENV) {
	      ReactElementValidator.checkAndWarnForMutatedProps(
	        internalInstance._currentElement
	      );
	    }
	    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function(internalInstance) {
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent();
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function(
	    internalInstance, nextElement, transaction, context
	  ) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && nextElement._owner != null) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	      return;
	    }
	
	    if ("production" !== process.env.NODE_ENV) {
	      ReactElementValidator.checkAndWarnForMutatedProps(nextElement);
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(
	      prevElement,
	      nextElement
	    );
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function(
	    internalInstance,
	    transaction
	  ) {
	    internalInstance.performUpdateIfNecessary(transaction);
	  }
	
	};
	
	module.exports = ReactReconciler;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(33);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function(instance, element) {
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function(prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  return (
	    nextElement._owner !== prevElement._owner ||
	    nextElement.ref !== prevElement.ref
	  );
	};
	
	ReactRef.detachRefs = function(instance, element) {
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(9);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function(object) {
	    return !!(
	      (object &&
	      typeof object.attachRef === 'function' && typeof object.detachRef === 'function')
	    );
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function(component, ref, owner) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      ReactOwner.isValidOwner(owner),
	      'addComponentAsRefTo(...): Only a ReactOwner can have refs. This ' +
	      'usually means that you\'re trying to add a ref to a component that ' +
	      'doesn\'t have an owner (that is, was not created inside of another ' +
	      'component\'s `render` method). Try rendering this component inside of ' +
	      'a new top-level component which will hold the ref.'
	    ) : invariant(ReactOwner.isValidOwner(owner)));
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function(component, ref, owner) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      ReactOwner.isValidOwner(owner),
	      'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This ' +
	      'usually means that you\'re trying to remove a ref to a component that ' +
	      'doesn\'t have an owner (that is, was not created inside of another ' +
	      'component\'s `render` method). Try rendering this component inside of ' +
	      'a new top-level component which will hold the ref.'
	    ) : invariant(ReactOwner.isValidOwner(owner)));
	    // Check that `component` is still the current ref because we do not want to
	    // detach the ref if another component stole it.
	    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	var ReactFragment = __webpack_require__(12);
	var ReactPropTypeLocations = __webpack_require__(35);
	var ReactPropTypeLocationNames = __webpack_require__(36);
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactNativeComponent = __webpack_require__(37);
	
	var getIteratorFn = __webpack_require__(23);
	var invariant = __webpack_require__(9);
	var warning = __webpack_require__(17);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	var loggedTypeFailures = {};
	
	var NUMERIC_PROPERTY_REGEX = /^\d+$/;
	
	/**
	 * Gets the instance's name for use in warnings.
	 *
	 * @internal
	 * @return {?string} Display name or undefined
	 */
	function getName(instance) {
	  var publicInstance = instance && instance.getPublicInstance();
	  if (!publicInstance) {
	    return undefined;
	  }
	  var constructor = publicInstance.constructor;
	  if (!constructor) {
	    return undefined;
	  }
	  return constructor.displayName || constructor.name || undefined;
	}
	
	/**
	 * Gets the current owner's displayName for use in warnings.
	 *
	 * @internal
	 * @return {?string} Display name or undefined
	 */
	function getCurrentOwnerDisplayName() {
	  var current = ReactCurrentOwner.current;
	  return (
	    current && getName(current) || undefined
	  );
	}
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  warnAndMonitorForKeyUse(
	    'Each child in an array or iterator should have a unique "key" prop.',
	    element,
	    parentType
	  );
	}
	
	/**
	 * Warn if the key is being defined as an object property but has an incorrect
	 * value.
	 *
	 * @internal
	 * @param {string} name Property name of the key.
	 * @param {ReactElement} element Component that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validatePropertyKey(name, element, parentType) {
	  if (!NUMERIC_PROPERTY_REGEX.test(name)) {
	    return;
	  }
	  warnAndMonitorForKeyUse(
	    'Child objects should have non-numeric keys so ordering is preserved.',
	    element,
	    parentType
	  );
	}
	
	/**
	 * Shared warning and monitoring code for the key warnings.
	 *
	 * @internal
	 * @param {string} message The base warning that gets output.
	 * @param {ReactElement} element Component that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function warnAndMonitorForKeyUse(message, element, parentType) {
	  var ownerName = getCurrentOwnerDisplayName();
	  var parentName = typeof parentType === 'string' ?
	    parentType : parentType.displayName || parentType.name;
	
	  var useName = ownerName || parentName;
	  var memoizer = ownerHasKeyUseWarning[message] || (
	    (ownerHasKeyUseWarning[message] = {})
	  );
	  if (memoizer.hasOwnProperty(useName)) {
	    return;
	  }
	  memoizer[useName] = true;
	
	  var parentOrOwnerAddendum =
	    ownerName ? (" Check the render method of " + ownerName + ".") :
	    parentName ? (" Check the React.render call using <" + parentName + ">.") :
	    '';
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwnerAddendum = '';
	  if (element &&
	      element._owner &&
	      element._owner !== ReactCurrentOwner.current) {
	    // Name of the component that originally created this child.
	    var childOwnerName = getName(element._owner);
	
	    childOwnerAddendum = (" It was passed a child from " + childOwnerName + ".");
	  }
	
	  ("production" !== process.env.NODE_ENV ? warning(
	    false,
	    message + '%s%s See https://fb.me/react-warning-keys for more information.',
	    parentOrOwnerAddendum,
	    childOwnerAddendum
	  ) : null);
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    node._store.validated = true;
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    } else if (typeof node === 'object') {
	      var fragment = ReactFragment.extractIfFragment(node);
	      for (var key in fragment) {
	        if (fragment.hasOwnProperty(key)) {
	          validatePropertyKey(key, fragment[key], parentType);
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Assert that the props are valid
	 *
	 * @param {string} componentName Name of the component for error messages.
	 * @param {object} propTypes Map of prop name to a ReactPropType
	 * @param {object} props
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @private
	 */
	function checkPropTypes(componentName, propTypes, props, location) {
	  for (var propName in propTypes) {
	    if (propTypes.hasOwnProperty(propName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        ("production" !== process.env.NODE_ENV ? invariant(
	          typeof propTypes[propName] === 'function',
	          '%s: %s type `%s` is invalid; it must be a function, usually from ' +
	          'React.PropTypes.',
	          componentName || 'React class',
	          ReactPropTypeLocationNames[location],
	          propName
	        ) : invariant(typeof propTypes[propName] === 'function'));
	        error = propTypes[propName](props, propName, componentName, location);
	      } catch (ex) {
	        error = ex;
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(this);
	        ("production" !== process.env.NODE_ENV ? warning(false, 'Failed propType: %s%s', error.message, addendum) : null);
	      }
	    }
	  }
	}
	
	var warnedPropsMutations = {};
	
	/**
	 * Warn about mutating props when setting `propName` on `element`.
	 *
	 * @param {string} propName The string key within props that was set
	 * @param {ReactElement} element
	 */
	function warnForPropsMutation(propName, element) {
	  var type = element.type;
	  var elementName = typeof type === 'string' ? type : type.displayName;
	  var ownerName = element._owner ?
	    element._owner.getPublicInstance().constructor.displayName : null;
	
	  var warningKey = propName + '|' + elementName + '|' + ownerName;
	  if (warnedPropsMutations.hasOwnProperty(warningKey)) {
	    return;
	  }
	  warnedPropsMutations[warningKey] = true;
	
	  var elementInfo = '';
	  if (elementName) {
	    elementInfo = ' <' + elementName + ' />';
	  }
	  var ownerInfo = '';
	  if (ownerName) {
	    ownerInfo = ' The element was created by ' + ownerName + '.';
	  }
	
	  ("production" !== process.env.NODE_ENV ? warning(
	    false,
	    'Don\'t set .props.%s of the React component%s. Instead, specify the ' +
	    'correct value when initially creating the element or use ' +
	    'React.cloneElement to make a new element with updated props.%s',
	    propName,
	    elementInfo,
	    ownerInfo
	  ) : null);
	}
	
	// Inline Object.is polyfill
	function is(a, b) {
	  if (a !== a) {
	    // NaN
	    return b !== b;
	  }
	  if (a === 0 && b === 0) {
	    // +-0
	    return 1 / a === 1 / b;
	  }
	  return a === b;
	}
	
	/**
	 * Given an element, check if its props have been mutated since element
	 * creation (or the last call to this function). In particular, check if any
	 * new props have been added, which we can't directly catch by defining warning
	 * properties on the props object.
	 *
	 * @param {ReactElement} element
	 */
	function checkAndWarnForMutatedProps(element) {
	  if (!element._store) {
	    // Element was created using `new ReactElement` directly or with
	    // `ReactElement.createElement`; skip mutation checking
	    return;
	  }
	
	  var originalProps = element._store.originalProps;
	  var props = element.props;
	
	  for (var propName in props) {
	    if (props.hasOwnProperty(propName)) {
	      if (!originalProps.hasOwnProperty(propName) ||
	          !is(originalProps[propName], props[propName])) {
	        warnForPropsMutation(propName, element);
	
	        // Copy over the new value so that the two props objects match again
	        originalProps[propName] = props[propName];
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  if (element.type == null) {
	    // This has already warned. Don't throw.
	    return;
	  }
	  // Extract the component class from the element. Converts string types
	  // to a composite class which may have propTypes.
	  // TODO: Validating a string's propTypes is not decoupled from the
	  // rendering target which is problematic.
	  var componentClass = ReactNativeComponent.getComponentClassForElement(
	    element
	  );
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkPropTypes(
	      name,
	      componentClass.propTypes,
	      element.props,
	      ReactPropTypeLocations.prop
	    );
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    ("production" !== process.env.NODE_ENV ? warning(
	      componentClass.getDefaultProps.isReactClassApproved,
	      'getDefaultProps is only used on classic React.createClass ' +
	      'definitions. Use a static property named `defaultProps` instead.'
	    ) : null);
	  }
	}
	
	var ReactElementValidator = {
	
	  checkAndWarnForMutatedProps: checkAndWarnForMutatedProps,
	
	  createElement: function(type, props, children) {
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    ("production" !== process.env.NODE_ENV ? warning(
	      type != null,
	      'React.createElement: type should not be null or undefined. It should ' +
	        'be a string (for DOM elements) or a ReactClass (for composite ' +
	        'components).'
	    ) : null);
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], type);
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function(type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(
	      null,
	      type
	    );
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if ("production" !== process.env.NODE_ENV) {
	      try {
	        Object.defineProperty(
	          validatedFactory,
	          'type',
	          {
	            enumerable: false,
	            get: function() {
	              ("production" !== process.env.NODE_ENV ? warning(
	                false,
	                'Factory.type is deprecated. Access the class directly ' +
	                'before passing it to createFactory.'
	              ) : null);
	              Object.defineProperty(this, 'type', {
	                value: type
	              });
	              return type;
	            }
	          }
	        );
	      } catch (x) {
	        // IE will fail on defineProperty (es5-shim/sham too)
	      }
	    }
	
	
	    return validatedFactory;
	  },
	
	  cloneElement: function(element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(8);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if ("production" !== process.env.NODE_ENV) {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNativeComponent
	 */
	
	'use strict';
	
	var assign = __webpack_require__(15);
	var invariant = __webpack_require__(9);
	
	var autoGenerateWrapperClass = null;
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around native tags
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactNativeComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function(componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function(componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function(componentClasses) {
	    assign(tagToComponentClass, componentClasses);
	  },
	  // Temporary hack since we expect DOM refs to behave like composites,
	  // for this release.
	  injectAutoWrapper: function(wrapperFactory) {
	    autoGenerateWrapperClass = wrapperFactory;
	  }
	};
	
	/**
	 * Get a composite component wrapper class for a specific tag.
	 *
	 * @param {ReactElement} element The tag for which to get the class.
	 * @return {function} The React class constructor function.
	 */
	function getComponentClassForElement(element) {
	  if (typeof element.type === 'function') {
	    return element.type;
	  }
	  var tag = element.type;
	  var componentClass = tagToComponentClass[tag];
	  if (componentClass == null) {
	    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
	  }
	  return componentClass;
	}
	
	/**
	 * Get a native internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    genericComponentClass,
	    'There is no registered component for the tag %s',
	    element.type
	  ) : invariant(genericComponentClass));
	  return new genericComponentClass(element.type, element.props);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactNativeComponent = {
	  getComponentClassForElement: getComponentClassForElement,
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactNativeComponentInjection
	};
	
	module.exports = ReactNativeComponent;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(9);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function() {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (!this.wrapperInitData) {
	      this.wrapperInitData = [];
	    } else {
	      this.wrapperInitData.length = 0;
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function() {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} args... Arguments to pass to the method (optional).
	   *                           Helps prevent need to bind in many cases.
	   * @return Return value from `method`.
	   */
	  perform: function(method, scope, a, b, c, d, e, f) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      !this.isInTransaction(),
	      'Transaction.perform(...): Cannot initialize a transaction when there ' +
	      'is already an outstanding transaction.'
	    ) : invariant(!this.isInTransaction()));
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {
	          }
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function(startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ?
	          wrapper.initialize.call(this) :
	          null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {
	          }
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function(startIndex) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      this.isInTransaction(),
	      'Transaction.closeAll(): Cannot close transaction when none are open.'
	    ) : invariant(this.isInTransaction()));
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {
	          }
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occured.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var ReactComponent = __webpack_require__(24);
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactElement = __webpack_require__(13);
	var ReactErrorUtils = __webpack_require__(40);
	var ReactInstanceMap = __webpack_require__(27);
	var ReactLifeCycle = __webpack_require__(26);
	var ReactPropTypeLocations = __webpack_require__(35);
	var ReactPropTypeLocationNames = __webpack_require__(36);
	var ReactUpdateQueue = __webpack_require__(25);
	
	var assign = __webpack_require__(15);
	var invariant = __webpack_require__(9);
	var keyMirror = __webpack_require__(8);
	var keyOf = __webpack_require__(41);
	var warning = __webpack_require__(17);
	
	var MIXINS_KEY = keyOf({mixins: null});
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	
	var injectedMixins = [];
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or native components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function(Constructor, displayName) {
	    Constructor.displayName = displayName;
	  },
	  mixins: function(Constructor, mixins) {
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function(Constructor, childContextTypes) {
	    if ("production" !== process.env.NODE_ENV) {
	      validateTypeDef(
	        Constructor,
	        childContextTypes,
	        ReactPropTypeLocations.childContext
	      );
	    }
	    Constructor.childContextTypes = assign(
	      {},
	      Constructor.childContextTypes,
	      childContextTypes
	    );
	  },
	  contextTypes: function(Constructor, contextTypes) {
	    if ("production" !== process.env.NODE_ENV) {
	      validateTypeDef(
	        Constructor,
	        contextTypes,
	        ReactPropTypeLocations.context
	      );
	    }
	    Constructor.contextTypes = assign(
	      {},
	      Constructor.contextTypes,
	      contextTypes
	    );
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function(Constructor, getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(
	        Constructor.getDefaultProps,
	        getDefaultProps
	      );
	    } else {
	      Constructor.getDefaultProps = getDefaultProps;
	    }
	  },
	  propTypes: function(Constructor, propTypes) {
	    if ("production" !== process.env.NODE_ENV) {
	      validateTypeDef(
	        Constructor,
	        propTypes,
	        ReactPropTypeLocations.prop
	      );
	    }
	    Constructor.propTypes = assign(
	      {},
	      Constructor.propTypes,
	      propTypes
	    );
	  },
	  statics: function(Constructor, statics) {
	    mixStaticSpecIntoComponent(Constructor, statics);
	  }
	};
	
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but not in __DEV__
	      ("production" !== process.env.NODE_ENV ? warning(
	        typeof typeDef[propName] === 'function',
	        '%s: %s type `%s` is invalid; it must be a function, usually from ' +
	        'React.PropTypes.',
	        Constructor.displayName || 'ReactClass',
	        ReactPropTypeLocationNames[location],
	        propName
	      ) : null);
	    }
	  }
	}
	
	function validateMethodOverride(proto, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ?
	    ReactClassInterface[name] :
	    null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      specPolicy === SpecPolicy.OVERRIDE_BASE,
	      'ReactClassInterface: You are attempting to override ' +
	      '`%s` from your class specification. Ensure that your method names ' +
	      'do not overlap with React methods.',
	      name
	    ) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE));
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (proto.hasOwnProperty(name)) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      specPolicy === SpecPolicy.DEFINE_MANY ||
	      specPolicy === SpecPolicy.DEFINE_MANY_MERGED,
	      'ReactClassInterface: You are attempting to define ' +
	      '`%s` on your component more than once. This conflict may be due ' +
	      'to a mixin.',
	      name
	    ) : invariant(specPolicy === SpecPolicy.DEFINE_MANY ||
	    specPolicy === SpecPolicy.DEFINE_MANY_MERGED));
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classses.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    return;
	  }
	
	  ("production" !== process.env.NODE_ENV ? invariant(
	    typeof spec !== 'function',
	    'ReactClass: You\'re attempting to ' +
	    'use a component class as a mixin. Instead, just use a regular object.'
	  ) : invariant(typeof spec !== 'function'));
	  ("production" !== process.env.NODE_ENV ? invariant(
	    !ReactElement.isValidElement(spec),
	    'ReactClass: You\'re attempting to ' +
	    'use a component as a mixin. Instead, just use a regular object.'
	  ) : invariant(!ReactElement.isValidElement(spec)));
	
	  var proto = Constructor.prototype;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above
	      continue;
	    }
	
	    var property = spec[name];
	    validateMethodOverride(proto, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod =
	        ReactClassInterface.hasOwnProperty(name);
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      var markedDontBind = property && property.__reactDontBind;
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind =
	        isFunction &&
	        !isReactClassMethod &&
	        !isAlreadyDefined &&
	        !markedDontBind;
	
	      if (shouldAutoBind) {
	        if (!proto.__reactAutoBindMap) {
	          proto.__reactAutoBindMap = {};
	        }
	        proto.__reactAutoBindMap[name] = property;
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride
	          ("production" !== process.env.NODE_ENV ? invariant(
	            isReactClassMethod && (
	              (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)
	            ),
	            'ReactClass: Unexpected spec policy %s for key %s ' +
	            'when mixing in component specs.',
	            specPolicy,
	            name
	          ) : invariant(isReactClassMethod && (
	            (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)
	          )));
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if ("production" !== process.env.NODE_ENV) {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    ("production" !== process.env.NODE_ENV ? invariant(
	      !isReserved,
	      'ReactClass: You are attempting to define a reserved ' +
	      'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
	      'as an instance property instead; it will still be accessible on the ' +
	      'constructor.',
	      name
	    ) : invariant(!isReserved));
	
	    var isInherited = name in Constructor;
	    ("production" !== process.env.NODE_ENV ? invariant(
	      !isInherited,
	      'ReactClass: You are attempting to define ' +
	      '`%s` on your component more than once. This conflict may be ' +
	      'due to a mixin.',
	      name
	    ) : invariant(!isInherited));
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    one && two && typeof one === 'object' && typeof two === 'object',
	    'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'
	  ) : invariant(one && two && typeof one === 'object' && typeof two === 'object'));
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      ("production" !== process.env.NODE_ENV ? invariant(
	        one[key] === undefined,
	        'mergeIntoWithNoDuplicateKeys(): ' +
	        'Tried to merge two objects with the same key: `%s`. This conflict ' +
	        'may be due to a mixin; in particular, this may be caused by two ' +
	        'getInitialState() or getDefaultProps() methods returning objects ' +
	        'with clashing keys.',
	        key
	      ) : invariant(one[key] === undefined));
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if ("production" !== process.env.NODE_ENV) {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    /* eslint-disable block-scoped-var, no-undef */
	    boundMethod.bind = function(newThis ) {for (var args=[],$__0=1,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        ("production" !== process.env.NODE_ENV ? warning(
	          false,
	          'bind(): React component methods may only be bound to the ' +
	          'component instance. See %s',
	          componentName
	        ) : null);
	      } else if (!args.length) {
	        ("production" !== process.env.NODE_ENV ? warning(
	          false,
	          'bind(): You are binding a component method to the component. ' +
	          'React does this for you automatically in a high-performance ' +
	          'way, so you can safely remove this call. See %s',
	          componentName
	        ) : null);
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	      /* eslint-enable */
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  for (var autoBindKey in component.__reactAutoBindMap) {
	    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
	      var method = component.__reactAutoBindMap[autoBindKey];
	      component[autoBindKey] = bindAutoBindMethod(
	        component,
	        ReactErrorUtils.guard(
	          method,
	          component.constructor.displayName + '.' + autoBindKey
	        )
	      );
	    }
	  }
	}
	
	var typeDeprecationDescriptor = {
	  enumerable: false,
	  get: function() {
	    var displayName = this.displayName || this.name || 'Component';
	    ("production" !== process.env.NODE_ENV ? warning(
	      false,
	      '%s.type is deprecated. Use %s directly to access the class.',
	      displayName,
	      displayName
	    ) : null);
	    Object.defineProperty(this, 'type', {
	      value: this
	    });
	    return this;
	  }
	};
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function(newState, callback) {
	    ReactUpdateQueue.enqueueReplaceState(this, newState);
	    if (callback) {
	      ReactUpdateQueue.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function() {
	    if ("production" !== process.env.NODE_ENV) {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        ("production" !== process.env.NODE_ENV ? warning(
	          owner._warnedAboutRefsInRender,
	          '%s is accessing isMounted inside its render() function. ' +
	          'render() should be a pure function of props and state. It should ' +
	          'never access something that requires stale data from the previous ' +
	          'render, such as refs. Move this logic to componentDidMount and ' +
	          'componentDidUpdate instead.',
	          owner.getName() || 'A component'
	        ) : null);
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(this);
	    return (
	      internalInstance &&
	      internalInstance !== ReactLifeCycle.currentlyMountingInstance
	    );
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {object} partialProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  setProps: function(partialProps, callback) {
	    ReactUpdateQueue.enqueueSetProps(this, partialProps);
	    if (callback) {
	      ReactUpdateQueue.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Replace all the props.
	   *
	   * @param {object} newProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  replaceProps: function(newProps, callback) {
	    ReactUpdateQueue.enqueueReplaceProps(this, newProps);
	    if (callback) {
	      ReactUpdateQueue.enqueueCallback(this, callback);
	    }
	  }
	};
	
	var ReactClassComponent = function() {};
	assign(
	  ReactClassComponent.prototype,
	  ReactComponent.prototype,
	  ReactClassMixin
	);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function(spec) {
	    var Constructor = function(props, context) {
	      // This constructor is overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if ("production" !== process.env.NODE_ENV) {
	        ("production" !== process.env.NODE_ENV ? warning(
	          this instanceof Constructor,
	          'Something is calling a React component directly. Use a factory or ' +
	          'JSX instead. See: https://fb.me/react-legacyfactory'
	        ) : null);
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindMap) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if ("production" !== process.env.NODE_ENV) {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (typeof initialState === 'undefined' &&
	            this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      ("production" !== process.env.NODE_ENV ? invariant(
	        typeof initialState === 'object' && !Array.isArray(initialState),
	        '%s.getInitialState(): must return an object or null',
	        Constructor.displayName || 'ReactCompositeComponent'
	      ) : invariant(typeof initialState === 'object' && !Array.isArray(initialState)));
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	
	    injectedMixins.forEach(
	      mixSpecIntoComponent.bind(null, Constructor)
	    );
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if ("production" !== process.env.NODE_ENV) {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    ("production" !== process.env.NODE_ENV ? invariant(
	      Constructor.prototype.render,
	      'createClass(...): Class specification must implement a `render` method.'
	    ) : invariant(Constructor.prototype.render));
	
	    if ("production" !== process.env.NODE_ENV) {
	      ("production" !== process.env.NODE_ENV ? warning(
	        !Constructor.prototype.componentShouldUpdate,
	        '%s has a method called ' +
	        'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
	        'The name is phrased as a question because the function is ' +
	        'expected to return a value.',
	        spec.displayName || 'A component'
	      ) : null);
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    // Legacy hook
	    Constructor.type = Constructor;
	    if ("production" !== process.env.NODE_ENV) {
	      try {
	        Object.defineProperty(Constructor, 'type', typeDeprecationDescriptor);
	      } catch (x) {
	        // IE will fail on defineProperty (es5-shim/sham too)
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function(mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 40 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 * @typechecks
	 */
	
	"use strict";
	
	var ReactErrorUtils = {
	  /**
	   * Creates a guarded version of a function. This is supposed to make debugging
	   * of event handlers easier. To aid debugging with the browser's debugger,
	   * this currently simply returns the original function.
	   *
	   * @param {function} func Function to be executed
	   * @param {string} name The name of the guard
	   * @return {function}
	   */
	  guard: function(func, name) {
	    return func;
	  }
	};
	
	module.exports = ReactErrorUtils;


/***/ },
/* 41 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyOf
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without loosing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	var keyOf = function(oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	
	module.exports = keyOf;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	var ReactElementValidator = __webpack_require__(34);
	
	var mapObject = __webpack_require__(43);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @param {string} tag Tag name (e.g. `div`).
	 * @private
	 */
	function createDOMFactory(tag) {
	  if ("production" !== process.env.NODE_ENV) {
	    return ReactElementValidator.createFactory(tag);
	  }
	  return ReactElement.createFactory(tag);
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOM = mapObject({
	  a: 'a',
	  abbr: 'abbr',
	  address: 'address',
	  area: 'area',
	  article: 'article',
	  aside: 'aside',
	  audio: 'audio',
	  b: 'b',
	  base: 'base',
	  bdi: 'bdi',
	  bdo: 'bdo',
	  big: 'big',
	  blockquote: 'blockquote',
	  body: 'body',
	  br: 'br',
	  button: 'button',
	  canvas: 'canvas',
	  caption: 'caption',
	  cite: 'cite',
	  code: 'code',
	  col: 'col',
	  colgroup: 'colgroup',
	  data: 'data',
	  datalist: 'datalist',
	  dd: 'dd',
	  del: 'del',
	  details: 'details',
	  dfn: 'dfn',
	  dialog: 'dialog',
	  div: 'div',
	  dl: 'dl',
	  dt: 'dt',
	  em: 'em',
	  embed: 'embed',
	  fieldset: 'fieldset',
	  figcaption: 'figcaption',
	  figure: 'figure',
	  footer: 'footer',
	  form: 'form',
	  h1: 'h1',
	  h2: 'h2',
	  h3: 'h3',
	  h4: 'h4',
	  h5: 'h5',
	  h6: 'h6',
	  head: 'head',
	  header: 'header',
	  hr: 'hr',
	  html: 'html',
	  i: 'i',
	  iframe: 'iframe',
	  img: 'img',
	  input: 'input',
	  ins: 'ins',
	  kbd: 'kbd',
	  keygen: 'keygen',
	  label: 'label',
	  legend: 'legend',
	  li: 'li',
	  link: 'link',
	  main: 'main',
	  map: 'map',
	  mark: 'mark',
	  menu: 'menu',
	  menuitem: 'menuitem',
	  meta: 'meta',
	  meter: 'meter',
	  nav: 'nav',
	  noscript: 'noscript',
	  object: 'object',
	  ol: 'ol',
	  optgroup: 'optgroup',
	  option: 'option',
	  output: 'output',
	  p: 'p',
	  param: 'param',
	  picture: 'picture',
	  pre: 'pre',
	  progress: 'progress',
	  q: 'q',
	  rp: 'rp',
	  rt: 'rt',
	  ruby: 'ruby',
	  s: 's',
	  samp: 'samp',
	  script: 'script',
	  section: 'section',
	  select: 'select',
	  small: 'small',
	  source: 'source',
	  span: 'span',
	  strong: 'strong',
	  style: 'style',
	  sub: 'sub',
	  summary: 'summary',
	  sup: 'sup',
	  table: 'table',
	  tbody: 'tbody',
	  td: 'td',
	  textarea: 'textarea',
	  tfoot: 'tfoot',
	  th: 'th',
	  thead: 'thead',
	  time: 'time',
	  title: 'title',
	  tr: 'tr',
	  track: 'track',
	  u: 'u',
	  ul: 'ul',
	  'var': 'var',
	  video: 'video',
	  wbr: 'wbr',
	
	  // SVG
	  circle: 'circle',
	  clipPath: 'clipPath',
	  defs: 'defs',
	  ellipse: 'ellipse',
	  g: 'g',
	  line: 'line',
	  linearGradient: 'linearGradient',
	  mask: 'mask',
	  path: 'path',
	  pattern: 'pattern',
	  polygon: 'polygon',
	  polyline: 'polyline',
	  radialGradient: 'radialGradient',
	  rect: 'rect',
	  stop: 'stop',
	  svg: 'svg',
	  text: 'text',
	  tspan: 'tspan'
	
	}, createDOMFactory);
	
	module.exports = ReactDOM;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 43 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule mapObject
	 */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Executes the provided `callback` once for each enumerable own property in the
	 * object and constructs a new object from the results. The `callback` is
	 * invoked with three arguments:
	 *
	 *  - the property value
	 *  - the property name
	 *  - the object being traversed
	 *
	 * Properties that are added after the call to `mapObject` will not be visited
	 * by `callback`. If the values of existing properties are changed, the value
	 * passed to `callback` will be the value at the time `mapObject` visits them.
	 * Properties that are deleted before being visited are not visited.
	 *
	 * @grep function objectMap()
	 * @grep function objMap()
	 *
	 * @param {?object} object
	 * @param {function} callback
	 * @param {*} context
	 * @return {?object}
	 */
	function mapObject(object, callback, context) {
	  if (!object) {
	    return null;
	  }
	  var result = {};
	  for (var name in object) {
	    if (hasOwnProperty.call(object, name)) {
	      result[name] = callback.call(context, object[name], name, object);
	    }
	  }
	  return result;
	}
	
	module.exports = mapObject;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMPropertyOperations = __webpack_require__(45);
	var ReactComponentBrowserEnvironment =
	  __webpack_require__(49);
	var ReactDOMComponent = __webpack_require__(89);
	
	var assign = __webpack_require__(15);
	var escapeTextContentForBrowser = __webpack_require__(48);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings in elements so that they can undergo
	 * the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function(props) {
	  // This constructor and its argument is currently used by mocks.
	};
	
	assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * @param {ReactText} text
	   * @internal
	   */
	  construct: function(text) {
	    // TODO: This is really a ReactText (ReactNode), not a ReactElement
	    this._currentElement = text;
	    this._stringText = '' + text;
	
	    // Properties
	    this._rootNodeID = null;
	    this._mountIndex = 0;
	  },
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function(rootID, transaction, context) {
	    this._rootNodeID = rootID;
	    var escapedText = escapeTextContentForBrowser(this._stringText);
	
	    if (transaction.renderToStaticMarkup) {
	      // Normally we'd wrap this in a `span` for the reasons stated above, but
	      // since this is a situation where React won't take over (static pages),
	      // we can simply return the text as it is.
	      return escapedText;
	    }
	
	    return (
	      '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' +
	        escapedText +
	      '</span>'
	    );
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function(nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        ReactDOMComponent.BackendIDOperations.updateTextContentByID(
	          this._rootNodeID,
	          nextStringText
	        );
	      }
	    }
	  },
	
	  unmountComponent: function() {
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(46);
	
	var quoteAttributeValueForBrowser = __webpack_require__(47);
	var warning = __webpack_require__(17);
	
	function shouldIgnoreValue(name, value) {
	  return value == null ||
	    (DOMProperty.hasBooleanValue[name] && !value) ||
	    (DOMProperty.hasNumericValue[name] && isNaN(value)) ||
	    (DOMProperty.hasPositiveNumericValue[name] && (value < 1)) ||
	    (DOMProperty.hasOverloadedBooleanValue[name] && value === false);
	}
	
	if ("production" !== process.env.NODE_ENV) {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true
	  };
	  var warnedProperties = {};
	
	  var warnUnknownProperty = function(name) {
	    if (reactProps.hasOwnProperty(name) && reactProps[name] ||
	        warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return;
	    }
	
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = (
	      DOMProperty.isCustomAttribute(lowerCasedName) ?
	        lowerCasedName :
	      DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ?
	        DOMProperty.getPossibleStandardName[lowerCasedName] :
	        null
	    );
	
	    // For now, only warn when we have a suggested correction. This prevents
	    // logging too much when using transferPropsTo.
	    ("production" !== process.env.NODE_ENV ? warning(
	      standardName == null,
	      'Unknown DOM property %s. Did you mean %s?',
	      name,
	      standardName
	    ) : null);
	
	  };
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function(id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' +
	      quoteAttributeValueForBrowser(id);
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function(name, value) {
	    if (DOMProperty.isStandardName.hasOwnProperty(name) &&
	        DOMProperty.isStandardName[name]) {
	      if (shouldIgnoreValue(name, value)) {
	        return '';
	      }
	      var attributeName = DOMProperty.getAttributeName[name];
	      if (DOMProperty.hasBooleanValue[name] ||
	          (DOMProperty.hasOverloadedBooleanValue[name] && value === true)) {
	        return attributeName;
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    } else if ("production" !== process.env.NODE_ENV) {
	      warnUnknownProperty(name);
	    }
	    return null;
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function(node, name, value) {
	    if (DOMProperty.isStandardName.hasOwnProperty(name) &&
	        DOMProperty.isStandardName[name]) {
	      var mutationMethod = DOMProperty.getMutationMethod[name];
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(name, value)) {
	        this.deleteValueForProperty(node, name);
	      } else if (DOMProperty.mustUseAttribute[name]) {
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        node.setAttribute(DOMProperty.getAttributeName[name], '' + value);
	      } else {
	        var propName = DOMProperty.getPropertyName[name];
	        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
	        // property type before comparing; only `value` does and is string.
	        if (!DOMProperty.hasSideEffects[name] ||
	            ('' + node[propName]) !== ('' + value)) {
	          // Contrary to `setAttribute`, object properties are properly
	          // `toString`ed by IE8/9.
	          node[propName] = value;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        node.removeAttribute(name);
	      } else {
	        node.setAttribute(name, '' + value);
	      }
	    } else if ("production" !== process.env.NODE_ENV) {
	      warnUnknownProperty(name);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function(node, name) {
	    if (DOMProperty.isStandardName.hasOwnProperty(name) &&
	        DOMProperty.isStandardName[name]) {
	      var mutationMethod = DOMProperty.getMutationMethod[name];
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (DOMProperty.mustUseAttribute[name]) {
	        node.removeAttribute(DOMProperty.getAttributeName[name]);
	      } else {
	        var propName = DOMProperty.getPropertyName[name];
	        var defaultValue = DOMProperty.getDefaultValueForProperty(
	          node.nodeName,
	          propName
	        );
	        if (!DOMProperty.hasSideEffects[name] ||
	            ('' + node[propName]) !== defaultValue) {
	          node[propName] = defaultValue;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    } else if ("production" !== process.env.NODE_ENV) {
	      warnUnknownProperty(name);
	    }
	  }
	
	};
	
	module.exports = DOMPropertyOperations;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 * @typechecks static-only
	 */
	
	/*jslint bitwise: true */
	
	'use strict';
	
	var invariant = __webpack_require__(9);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_ATTRIBUTE: 0x1,
	  MUST_USE_PROPERTY: 0x2,
	  HAS_SIDE_EFFECTS: 0x4,
	  HAS_BOOLEAN_VALUE: 0x8,
	  HAS_NUMERIC_VALUE: 0x10,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function(domPropertyConfig) {
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(
	        domPropertyConfig.isCustomAttribute
	      );
	    }
	
	    for (var propName in Properties) {
	      ("production" !== process.env.NODE_ENV ? invariant(
	        !DOMProperty.isStandardName.hasOwnProperty(propName),
	        'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' +
	        '\'%s\' which has already been injected. You may be accidentally ' +
	        'injecting the same DOM property config twice, or you may be ' +
	        'injecting two configs that have conflicting property names.',
	        propName
	      ) : invariant(!DOMProperty.isStandardName.hasOwnProperty(propName)));
	
	      DOMProperty.isStandardName[propName] = true;
	
	      var lowerCased = propName.toLowerCase();
	      DOMProperty.getPossibleStandardName[lowerCased] = propName;
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        DOMProperty.getPossibleStandardName[attributeName] = propName;
	        DOMProperty.getAttributeName[propName] = attributeName;
	      } else {
	        DOMProperty.getAttributeName[propName] = lowerCased;
	      }
	
	      DOMProperty.getPropertyName[propName] =
	        DOMPropertyNames.hasOwnProperty(propName) ?
	          DOMPropertyNames[propName] :
	          propName;
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName];
	      } else {
	        DOMProperty.getMutationMethod[propName] = null;
	      }
	
	      var propConfig = Properties[propName];
	      DOMProperty.mustUseAttribute[propName] =
	        checkMask(propConfig, DOMPropertyInjection.MUST_USE_ATTRIBUTE);
	      DOMProperty.mustUseProperty[propName] =
	        checkMask(propConfig, DOMPropertyInjection.MUST_USE_PROPERTY);
	      DOMProperty.hasSideEffects[propName] =
	        checkMask(propConfig, DOMPropertyInjection.HAS_SIDE_EFFECTS);
	      DOMProperty.hasBooleanValue[propName] =
	        checkMask(propConfig, DOMPropertyInjection.HAS_BOOLEAN_VALUE);
	      DOMProperty.hasNumericValue[propName] =
	        checkMask(propConfig, DOMPropertyInjection.HAS_NUMERIC_VALUE);
	      DOMProperty.hasPositiveNumericValue[propName] =
	        checkMask(propConfig, DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE);
	      DOMProperty.hasOverloadedBooleanValue[propName] =
	        checkMask(propConfig, DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE);
	
	      ("production" !== process.env.NODE_ENV ? invariant(
	        !DOMProperty.mustUseAttribute[propName] ||
	          !DOMProperty.mustUseProperty[propName],
	        'DOMProperty: Cannot require using both attribute and property: %s',
	        propName
	      ) : invariant(!DOMProperty.mustUseAttribute[propName] ||
	        !DOMProperty.mustUseProperty[propName]));
	      ("production" !== process.env.NODE_ENV ? invariant(
	        DOMProperty.mustUseProperty[propName] ||
	          !DOMProperty.hasSideEffects[propName],
	        'DOMProperty: Properties that have side effects must use property: %s',
	        propName
	      ) : invariant(DOMProperty.mustUseProperty[propName] ||
	        !DOMProperty.hasSideEffects[propName]));
	      ("production" !== process.env.NODE_ENV ? invariant(
	        !!DOMProperty.hasBooleanValue[propName] +
	          !!DOMProperty.hasNumericValue[propName] +
	          !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1,
	        'DOMProperty: Value can be one of boolean, overloaded boolean, or ' +
	        'numeric value, but not a combination: %s',
	        propName
	      ) : invariant(!!DOMProperty.hasBooleanValue[propName] +
	        !!DOMProperty.hasNumericValue[propName] +
	        !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1));
	    }
	  }
	};
	var defaultValueCache = {};
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	
	  /**
	   * Checks whether a property name is a standard property.
	   * @type {Object}
	   */
	  isStandardName: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties.
	   * @type {Object}
	   */
	  getPossibleStandardName: {},
	
	  /**
	   * Mapping from normalized names to attribute names that differ. Attribute
	   * names are used when rendering markup or with `*Attribute()`.
	   * @type {Object}
	   */
	  getAttributeName: {},
	
	  /**
	   * Mapping from normalized names to properties on DOM node instances.
	   * (This includes properties that mutate due to external factors.)
	   * @type {Object}
	   */
	  getPropertyName: {},
	
	  /**
	   * Mapping from normalized names to mutation methods. This will only exist if
	   * mutation cannot be set simply by the property or `setAttribute()`.
	   * @type {Object}
	   */
	  getMutationMethod: {},
	
	  /**
	   * Whether the property must be accessed and mutated as an object property.
	   * @type {Object}
	   */
	  mustUseAttribute: {},
	
	  /**
	   * Whether the property must be accessed and mutated using `*Attribute()`.
	   * (This includes anything that fails `<propName> in <element>`.)
	   * @type {Object}
	   */
	  mustUseProperty: {},
	
	  /**
	   * Whether or not setting a value causes side effects such as triggering
	   * resources to be loaded or text selection changes. We must ensure that
	   * the value is only set if it has changed.
	   * @type {Object}
	   */
	  hasSideEffects: {},
	
	  /**
	   * Whether the property should be removed when set to a falsey value.
	   * @type {Object}
	   */
	  hasBooleanValue: {},
	
	  /**
	   * Whether the property must be numeric or parse as a
	   * numeric and should be removed when set to a falsey value.
	   * @type {Object}
	   */
	  hasNumericValue: {},
	
	  /**
	   * Whether the property must be positive numeric or parse as a positive
	   * numeric and should be removed when set to a falsey value.
	   * @type {Object}
	   */
	  hasPositiveNumericValue: {},
	
	  /**
	   * Whether the property can be used as a flag as well as with a value. Removed
	   * when strictly equal to false; present without a value when strictly equal
	   * to true; present with a value otherwise.
	   * @type {Object}
	   */
	  hasOverloadedBooleanValue: {},
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function(attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  /**
	   * Returns the default property value for a DOM property (i.e., not an
	   * attribute). Most default values are '' or false, but not all. Worse yet,
	   * some (in particular, `type`) vary depending on the type of element.
	   *
	   * TODO: Is it better to grab all the possible properties when creating an
	   * element to avoid having to create the same element twice?
	   */
	  getDefaultValueForProperty: function(nodeName, prop) {
	    var nodeDefaults = defaultValueCache[nodeName];
	    var testElement;
	    if (!nodeDefaults) {
	      defaultValueCache[nodeName] = nodeDefaults = {};
	    }
	    if (!(prop in nodeDefaults)) {
	      testElement = document.createElement(nodeName);
	      nodeDefaults[prop] = testElement[prop];
	    }
	    return nodeDefaults[prop];
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(48);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;


/***/ },
/* 48 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	var ESCAPE_LOOKUP = {
	  '&': '&amp;',
	  '>': '&gt;',
	  '<': '&lt;',
	  '"': '&quot;',
	  '\'': '&#x27;'
	};
	
	var ESCAPE_REGEX = /[&><"']/g;
	
	function escaper(match) {
	  return ESCAPE_LOOKUP[match];
	}
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  return ('' + text).replace(ESCAPE_REGEX, escaper);
	}
	
	module.exports = escapeTextContentForBrowser;


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	/*jslint evil: true */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(50);
	var ReactMount = __webpack_require__(69);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates:
	    ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkupByID:
	    ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
	
	  /**
	   * If a particular environment requires that some resources be cleaned up,
	   * specify this in the injected Mixin. In the DOM, we would likely want to
	   * purge any cached node ID lookups.
	   *
	   * @private
	   */
	  unmountIDFromEnvironment: function(rootNodeID) {
	    ReactMount.purgeID(rootNodeID);
	  }
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 * @typechecks static-only
	 */
	
	/*jslint evil: true */
	
	'use strict';
	
	var CSSPropertyOperations = __webpack_require__(51);
	var DOMChildrenOperations = __webpack_require__(60);
	var DOMPropertyOperations = __webpack_require__(45);
	var ReactMount = __webpack_require__(69);
	var ReactPerf = __webpack_require__(30);
	
	var invariant = __webpack_require__(9);
	var setInnerHTML = __webpack_require__(68);
	
	/**
	 * Errors for properties that should not be updated with `updatePropertyById()`.
	 *
	 * @type {object}
	 * @private
	 */
	var INVALID_PROPERTY_ERRORS = {
	  dangerouslySetInnerHTML:
	    '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
	  style: '`style` must be set using `updateStylesByID()`.'
	};
	
	/**
	 * Operations used to process updates to DOM nodes. This is made injectable via
	 * `ReactDOMComponent.BackendIDOperations`.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a DOM node with new property values. This should only be used to
	   * update DOM properties in `DOMProperty`.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {string} name A valid property name, see `DOMProperty`.
	   * @param {*} value New value of the property.
	   * @internal
	   */
	  updatePropertyByID: function(id, name, value) {
	    var node = ReactMount.getNode(id);
	    ("production" !== process.env.NODE_ENV ? invariant(
	      !INVALID_PROPERTY_ERRORS.hasOwnProperty(name),
	      'updatePropertyByID(...): %s',
	      INVALID_PROPERTY_ERRORS[name]
	    ) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));
	
	    // If we're updating to null or undefined, we should remove the property
	    // from the DOM node instead of inadvertantly setting to a string. This
	    // brings us in line with the same behavior we have on initial render.
	    if (value != null) {
	      DOMPropertyOperations.setValueForProperty(node, name, value);
	    } else {
	      DOMPropertyOperations.deleteValueForProperty(node, name);
	    }
	  },
	
	  /**
	   * Updates a DOM node to remove a property. This should only be used to remove
	   * DOM properties in `DOMProperty`.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {string} name A property name to remove, see `DOMProperty`.
	   * @internal
	   */
	  deletePropertyByID: function(id, name, value) {
	    var node = ReactMount.getNode(id);
	    ("production" !== process.env.NODE_ENV ? invariant(
	      !INVALID_PROPERTY_ERRORS.hasOwnProperty(name),
	      'updatePropertyByID(...): %s',
	      INVALID_PROPERTY_ERRORS[name]
	    ) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));
	    DOMPropertyOperations.deleteValueForProperty(node, name, value);
	  },
	
	  /**
	   * Updates a DOM node with new style values. If a value is specified as '',
	   * the corresponding style property will be unset.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {object} styles Mapping from styles to values.
	   * @internal
	   */
	  updateStylesByID: function(id, styles) {
	    var node = ReactMount.getNode(id);
	    CSSPropertyOperations.setValueForStyles(node, styles);
	  },
	
	  /**
	   * Updates a DOM node's innerHTML.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {string} html An HTML string.
	   * @internal
	   */
	  updateInnerHTMLByID: function(id, html) {
	    var node = ReactMount.getNode(id);
	    setInnerHTML(node, html);
	  },
	
	  /**
	   * Updates a DOM node's text content set by `props.content`.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {string} content Text content.
	   * @internal
	   */
	  updateTextContentByID: function(id, content) {
	    var node = ReactMount.getNode(id);
	    DOMChildrenOperations.updateTextContent(node, content);
	  },
	
	  /**
	   * Replaces a DOM node that exists in the document with markup.
	   *
	   * @param {string} id ID of child to be replaced.
	   * @param {string} markup Dangerous markup to inject in place of child.
	   * @internal
	   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
	   */
	  dangerouslyReplaceNodeWithMarkupByID: function(id, markup) {
	    var node = ReactMount.getNode(id);
	    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
	  },
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markup List of markup strings.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function(updates, markup) {
	    for (var i = 0; i < updates.length; i++) {
	      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
	    }
	    DOMChildrenOperations.processUpdates(updates, markup);
	  }
	};
	
	ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
	  updatePropertyByID: 'updatePropertyByID',
	  deletePropertyByID: 'deletePropertyByID',
	  updateStylesByID: 'updateStylesByID',
	  updateInnerHTMLByID: 'updateInnerHTMLByID',
	  updateTextContentByID: 'updateTextContentByID',
	  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
	  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
	});
	
	module.exports = ReactDOMIDOperations;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(52);
	var ExecutionEnvironment = __webpack_require__(53);
	
	var camelizeStyleName = __webpack_require__(54);
	var dangerousStyleValue = __webpack_require__(56);
	var hyphenateStyleName = __webpack_require__(57);
	var memoizeStringOnly = __webpack_require__(59);
	var warning = __webpack_require__(17);
	
	var processStyleName = memoizeStringOnly(function(styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if ("production" !== process.env.NODE_ENV) {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	
	  var warnHyphenatedStyleName = function(name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    ("production" !== process.env.NODE_ENV ? warning(
	      false,
	      'Unsupported style property %s. Did you mean %s?',
	      name,
	      camelizeStyleName(name)
	    ) : null);
	  };
	
	  var warnBadVendoredStyleName = function(name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    ("production" !== process.env.NODE_ENV ? warning(
	      false,
	      'Unsupported vendor-prefixed style property %s. Did you mean %s?',
	      name,
	      name.charAt(0).toUpperCase() + name.slice(1)
	    ) : null);
	  };
	
	  var warnStyleValueWithSemicolon = function(name, value) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    ("production" !== process.env.NODE_ENV ? warning(
	      false,
	      'Style property values shouldn\'t contain a semicolon. ' +
	      'Try "%s: %s" instead.',
	      name,
	      value.replace(badStyleValueWithSemicolonPattern, '')
	    ) : null);
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   */
	  var warnValidStyle = function(name, value) {
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @return {?string}
	   */
	  createMarkupForStyles: function(styles) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if ("production" !== process.env.NODE_ENV) {
	        warnValidStyle(styleName, styleValue);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   */
	  setValueForStyles: function(node, styles) {
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if ("production" !== process.env.NODE_ENV) {
	        warnValidStyle(styleName, styles[styleName]);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
	      if (styleName === 'float') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = CSSPropertyOperations;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 52 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	var isUnitlessNumber = {
	  boxFlex: true,
	  boxFlexGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  strokeDashoffset: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function(prop) {
	  prefixes.forEach(function(prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundImage: true,
	    backgroundPosition: true,
	    backgroundRepeat: true,
	    backgroundColor: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;


/***/ },
/* 53 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ExecutionEnvironment
	 */
	
	/*jslint evil: true */
	
	"use strict";
	
	var canUseDOM = !!(
	  (typeof window !== 'undefined' &&
	  window.document && window.document.createElement)
	);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners:
	    canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelizeStyleName
	 * @typechecks
	 */
	
	"use strict";
	
	var camelize = __webpack_require__(55);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;


/***/ },
/* 55 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelize
	 * @typechecks
	 */
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function(_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(52);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 ||
	      isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenateStyleName
	 * @typechecks
	 */
	
	"use strict";
	
	var hyphenate = __webpack_require__(58);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;


/***/ },
/* 58 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenate
	 * @typechecks
	 */
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;


/***/ },
/* 59 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule memoizeStringOnly
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 *
	 * @param {function} callback
	 * @return {function}
	 */
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function(string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var Danger = __webpack_require__(61);
	var ReactMultiChildUpdateTypes = __webpack_require__(66);
	
	var setTextContent = __webpack_require__(67);
	var invariant = __webpack_require__(9);
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	function insertChildAt(parentNode, childNode, index) {
	  // By exploiting arrays returning `undefined` for an undefined index, we can
	  // rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. However, using `undefined` is not allowed by all
	  // browsers so we must replace it with `null`.
	  parentNode.insertBefore(
	    childNode,
	    parentNode.childNodes[index] || null
	  );
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
	
	  updateTextContent: setTextContent,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markupList List of markup strings.
	   * @internal
	   */
	  processUpdates: function(updates, markupList) {
	    var update;
	    // Mapping from parent IDs to initial child orderings.
	    var initialChildren = null;
	    // List of children that will be moved or removed.
	    var updatedChildren = null;
	
	    for (var i = 0; i < updates.length; i++) {
	      update = updates[i];
	      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING ||
	          update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
	        var updatedIndex = update.fromIndex;
	        var updatedChild = update.parentNode.childNodes[updatedIndex];
	        var parentID = update.parentID;
	
	        ("production" !== process.env.NODE_ENV ? invariant(
	          updatedChild,
	          'processUpdates(): Unable to find child %s of element. This ' +
	          'probably means the DOM was unexpectedly mutated (e.g., by the ' +
	          'browser), usually due to forgetting a <tbody> when using tables, ' +
	          'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' +
	          'in an <svg> parent. Try inspecting the child nodes of the element ' +
	          'with React ID `%s`.',
	          updatedIndex,
	          parentID
	        ) : invariant(updatedChild));
	
	        initialChildren = initialChildren || {};
	        initialChildren[parentID] = initialChildren[parentID] || [];
	        initialChildren[parentID][updatedIndex] = updatedChild;
	
	        updatedChildren = updatedChildren || [];
	        updatedChildren.push(updatedChild);
	      }
	    }
	
	    var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
	
	    // Remove updated children first so that `toIndex` is consistent.
	    if (updatedChildren) {
	      for (var j = 0; j < updatedChildren.length; j++) {
	        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
	      }
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertChildAt(
	            update.parentNode,
	            renderedMarkup[update.markupIndex],
	            update.toIndex
	          );
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          insertChildAt(
	            update.parentNode,
	            initialChildren[update.parentID][update.fromIndex],
	            update.toIndex
	          );
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(
	            update.parentNode,
	            update.textContent
	          );
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          // Already removed by the for-loop above.
	          break;
	      }
	    }
	  }
	
	};
	
	module.exports = DOMChildrenOperations;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 * @typechecks static-only
	 */
	
	/*jslint evil: true, sub: true */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(53);
	
	var createNodesFromMarkup = __webpack_require__(62);
	var emptyFunction = __webpack_require__(18);
	var getMarkupWrap = __webpack_require__(65);
	var invariant = __webpack_require__(9);
	
	var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
	var RESULT_INDEX_ATTR = 'data-danger-index';
	
	/**
	 * Extracts the `nodeName` from a string of markup.
	 *
	 * NOTE: Extracting the `nodeName` does not require a regular expression match
	 * because we make assumptions about React-generated markup (i.e. there are no
	 * spaces surrounding the opening tag and there is at least one attribute).
	 *
	 * @param {string} markup String of markup.
	 * @return {string} Node name of the supplied markup.
	 * @see http://jsperf.com/extract-nodename
	 */
	function getNodeName(markup) {
	  return markup.substring(1, markup.indexOf(' '));
	}
	
	var Danger = {
	
	  /**
	   * Renders markup into an array of nodes. The markup is expected to render
	   * into a list of root nodes. Also, the length of `resultList` and
	   * `markupList` should be the same.
	   *
	   * @param {array<string>} markupList List of markup strings to render.
	   * @return {array<DOMElement>} List of rendered nodes.
	   * @internal
	   */
	  dangerouslyRenderMarkup: function(markupList) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      ExecutionEnvironment.canUseDOM,
	      'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' +
	      'thread. Make sure `window` and `document` are available globally ' +
	      'before requiring React when unit testing or use ' +
	      'React.renderToString for server rendering.'
	    ) : invariant(ExecutionEnvironment.canUseDOM));
	    var nodeName;
	    var markupByNodeName = {};
	    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
	    for (var i = 0; i < markupList.length; i++) {
	      ("production" !== process.env.NODE_ENV ? invariant(
	        markupList[i],
	        'dangerouslyRenderMarkup(...): Missing markup.'
	      ) : invariant(markupList[i]));
	      nodeName = getNodeName(markupList[i]);
	      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
	      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
	      markupByNodeName[nodeName][i] = markupList[i];
	    }
	    var resultList = [];
	    var resultListAssignmentCount = 0;
	    for (nodeName in markupByNodeName) {
	      if (!markupByNodeName.hasOwnProperty(nodeName)) {
	        continue;
	      }
	      var markupListByNodeName = markupByNodeName[nodeName];
	
	      // This for-in loop skips the holes of the sparse array. The order of
	      // iteration should follow the order of assignment, which happens to match
	      // numerical index order, but we don't rely on that.
	      var resultIndex;
	      for (resultIndex in markupListByNodeName) {
	        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
	          var markup = markupListByNodeName[resultIndex];
	
	          // Push the requested markup with an additional RESULT_INDEX_ATTR
	          // attribute.  If the markup does not start with a < character, it
	          // will be discarded below (with an appropriate console.error).
	          markupListByNodeName[resultIndex] = markup.replace(
	            OPEN_TAG_NAME_EXP,
	            // This index will be parsed back out below.
	            '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" '
	          );
	        }
	      }
	
	      // Render each group of markup with similar wrapping `nodeName`.
	      var renderNodes = createNodesFromMarkup(
	        markupListByNodeName.join(''),
	        emptyFunction // Do nothing special with <script> tags.
	      );
	
	      for (var j = 0; j < renderNodes.length; ++j) {
	        var renderNode = renderNodes[j];
	        if (renderNode.hasAttribute &&
	            renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
	
	          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
	          renderNode.removeAttribute(RESULT_INDEX_ATTR);
	
	          ("production" !== process.env.NODE_ENV ? invariant(
	            !resultList.hasOwnProperty(resultIndex),
	            'Danger: Assigning to an already-occupied result index.'
	          ) : invariant(!resultList.hasOwnProperty(resultIndex)));
	
	          resultList[resultIndex] = renderNode;
	
	          // This should match resultList.length and markupList.length when
	          // we're done.
	          resultListAssignmentCount += 1;
	
	        } else if ("production" !== process.env.NODE_ENV) {
	          console.error(
	            'Danger: Discarding unexpected node:',
	            renderNode
	          );
	        }
	      }
	    }
	
	    // Although resultList was populated out of order, it should now be a dense
	    // array.
	    ("production" !== process.env.NODE_ENV ? invariant(
	      resultListAssignmentCount === resultList.length,
	      'Danger: Did not assign to every index of resultList.'
	    ) : invariant(resultListAssignmentCount === resultList.length));
	
	    ("production" !== process.env.NODE_ENV ? invariant(
	      resultList.length === markupList.length,
	      'Danger: Expected markup to render %s nodes, but rendered %s.',
	      markupList.length,
	      resultList.length
	    ) : invariant(resultList.length === markupList.length));
	
	    return resultList;
	  },
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      ExecutionEnvironment.canUseDOM,
	      'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' +
	      'worker thread. Make sure `window` and `document` are available ' +
	      'globally before requiring React when unit testing or use ' +
	      'React.renderToString for server rendering.'
	    ) : invariant(ExecutionEnvironment.canUseDOM));
	    ("production" !== process.env.NODE_ENV ? invariant(markup, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(markup));
	    ("production" !== process.env.NODE_ENV ? invariant(
	      oldChild.tagName.toLowerCase() !== 'html',
	      'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' +
	      '<html> node. This is because browser quirks make this unreliable ' +
	      'and/or slow. If you want to render to the root you must use ' +
	      'server rendering. See React.renderToString().'
	    ) : invariant(oldChild.tagName.toLowerCase() !== 'html'));
	
	    var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	    oldChild.parentNode.replaceChild(newChild, oldChild);
	  }
	
	};
	
	module.exports = Danger;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createNodesFromMarkup
	 * @typechecks
	 */
	
	/*jslint evil: true, sub: true */
	
	var ExecutionEnvironment = __webpack_require__(53);
	
	var createArrayFromMixed = __webpack_require__(63);
	var getMarkupWrap = __webpack_require__(65);
	var invariant = __webpack_require__(9);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode =
	  ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'createNodesFromMarkup dummy not initialized') : invariant(!!dummyNode));
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      handleScript,
	      'createNodesFromMarkup(...): Unexpected <script> element rendered.'
	    ) : invariant(handleScript));
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = createArrayFromMixed(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createArrayFromMixed
	 * @typechecks
	 */
	
	var toArray = __webpack_require__(64);
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj &&
	    // arrays are objects, NodeLists are functions in Safari
	    (typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    ('length' in obj) &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    (typeof obj.nodeType != 'number') &&
	    (
	      // a real array
	      (// HTMLCollection/NodeList
	      (Array.isArray(obj) ||
	      // arguments
	      ('callee' in obj) || 'item' in obj))
	    )
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule toArray
	 * @typechecks
	 */
	
	var invariant = __webpack_require__(9);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
	  // old versions of Safari).
	  ("production" !== process.env.NODE_ENV ? invariant(
	    !Array.isArray(obj) &&
	    (typeof obj === 'object' || typeof obj === 'function'),
	    'toArray: Array-like object expected'
	  ) : invariant(!Array.isArray(obj) &&
	  (typeof obj === 'object' || typeof obj === 'function')));
	
	  ("production" !== process.env.NODE_ENV ? invariant(
	    typeof length === 'number',
	    'toArray: Object needs a length property'
	  ) : invariant(typeof length === 'number'));
	
	  ("production" !== process.env.NODE_ENV ? invariant(
	    length === 0 ||
	    (length - 1) in obj,
	    'toArray: Object should have keys for indices'
	  ) : invariant(length === 0 ||
	  (length - 1) in obj));
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	module.exports = toArray;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getMarkupWrap
	 */
	
	var ExecutionEnvironment = __webpack_require__(53);
	
	var invariant = __webpack_require__(9);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode =
	  ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	var shouldWrap = {
	  // Force wrapping for SVG elements because if they get created inside a <div>,
	  // they will be initialized in the wrong namespace (and will not display).
	  'circle': true,
	  'clipPath': true,
	  'defs': true,
	  'ellipse': true,
	  'g': true,
	  'line': true,
	  'linearGradient': true,
	  'path': true,
	  'polygon': true,
	  'polyline': true,
	  'radialGradient': true,
	  'rect': true,
	  'stop': true,
	  'text': true
	};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg>', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap,
	
	  'circle': svgWrap,
	  'clipPath': svgWrap,
	  'defs': svgWrap,
	  'ellipse': svgWrap,
	  'g': svgWrap,
	  'line': svgWrap,
	  'linearGradient': svgWrap,
	  'path': svgWrap,
	  'polygon': svgWrap,
	  'polyline': svgWrap,
	  'radialGradient': svgWrap,
	  'rect': svgWrap,
	  'stop': svgWrap,
	  'text': svgWrap
	};
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'Markup wrapping node not initialized') : invariant(!!dummyNode));
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	
	module.exports = getMarkupWrap;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(8);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(53);
	var escapeTextContentForBrowser = __webpack_require__(48);
	var setInnerHTML = __webpack_require__(68);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function(node, text) {
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function(node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(53);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = function(node, html) {
	  node.innerHTML = html;
	};
	
	// Win8 apps: Allow all html to be inserted
	if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	  setInnerHTML = function(node, html) {
	    MSApp.execUnsafeLocalFunction(function() {
	      node.innerHTML = html;
	    });
	  };
	}
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function(node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) ||
	          html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        node.innerHTML = '\uFEFF' + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	}
	
	module.exports = setInnerHTML;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(46);
	var ReactBrowserEventEmitter = __webpack_require__(70);
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactElement = __webpack_require__(13);
	var ReactElementValidator = __webpack_require__(34);
	var ReactEmptyComponent = __webpack_require__(78);
	var ReactInstanceHandles = __webpack_require__(21);
	var ReactInstanceMap = __webpack_require__(27);
	var ReactMarkupChecksum = __webpack_require__(79);
	var ReactPerf = __webpack_require__(30);
	var ReactReconciler = __webpack_require__(31);
	var ReactUpdateQueue = __webpack_require__(25);
	var ReactUpdates = __webpack_require__(28);
	
	var emptyObject = __webpack_require__(16);
	var containsNode = __webpack_require__(81);
	var getReactRootElementInContainer = __webpack_require__(84);
	var instantiateReactComponent = __webpack_require__(85);
	var invariant = __webpack_require__(9);
	var setInnerHTML = __webpack_require__(68);
	var shouldUpdateReactComponent = __webpack_require__(88);
	var warning = __webpack_require__(17);
	
	var SEPARATOR = ReactInstanceHandles.SEPARATOR;
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var nodeCache = {};
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	
	/** Mapping from reactRootID to React component instance. */
	var instancesByReactRootID = {};
	
	/** Mapping from reactRootID to `container` nodes. */
	var containersByReactRootID = {};
	
	if ("production" !== process.env.NODE_ENV) {
	  /** __DEV__-only mapping from reactRootID to root elements. */
	  var rootElementsByReactRootID = {};
	}
	
	// Used to store breadth-first search state in findComponentRoot.
	var findComponentRootReusableArray = [];
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement} container DOM element that may contain a React component.
	 * @return {?string} A "reactRoot" ID, if a React component is rendered.
	 */
	function getReactRootID(container) {
	  var rootElement = getReactRootElementInContainer(container);
	  return rootElement && ReactMount.getID(rootElement);
	}
	
	/**
	 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
	 * element can return its control whose name or ID equals ATTR_NAME. All
	 * DOM nodes support `getAttributeNode` but this can also get called on
	 * other objects so just return '' if we're given something other than a
	 * DOM node (such as window).
	 *
	 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
	 * @return {string} ID of the supplied `domNode`.
	 */
	function getID(node) {
	  var id = internalGetID(node);
	  if (id) {
	    if (nodeCache.hasOwnProperty(id)) {
	      var cached = nodeCache[id];
	      if (cached !== node) {
	        ("production" !== process.env.NODE_ENV ? invariant(
	          !isValid(cached, id),
	          'ReactMount: Two valid but unequal nodes with the same `%s`: %s',
	          ATTR_NAME, id
	        ) : invariant(!isValid(cached, id)));
	
	        nodeCache[id] = node;
	      }
	    } else {
	      nodeCache[id] = node;
	    }
	  }
	
	  return id;
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Sets the React-specific ID of the given node.
	 *
	 * @param {DOMElement} node The DOM node whose ID will be set.
	 * @param {string} id The value of the ID attribute.
	 */
	function setID(node, id) {
	  var oldID = internalGetID(node);
	  if (oldID !== id) {
	    delete nodeCache[oldID];
	  }
	  node.setAttribute(ATTR_NAME, id);
	  nodeCache[id] = node;
	}
	
	/**
	 * Finds the node with the supplied React-generated DOM ID.
	 *
	 * @param {string} id A React-generated DOM ID.
	 * @return {DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNode(id) {
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * Finds the node with the supplied public React instance.
	 *
	 * @param {*} instance A public React instance.
	 * @return {?DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNodeFromInstance(instance) {
	  var id = ReactInstanceMap.get(instance)._rootNodeID;
	  if (ReactEmptyComponent.isNullComponentID(id)) {
	    return null;
	  }
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * A node is "valid" if it is contained by a currently mounted container.
	 *
	 * This means that the node does not have to be contained by a document in
	 * order to be considered valid.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @param {string} id The expected ID of the node.
	 * @return {boolean} Whether the node is contained by a mounted container.
	 */
	function isValid(node, id) {
	  if (node) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      internalGetID(node) === id,
	      'ReactMount: Unexpected modification of `%s`',
	      ATTR_NAME
	    ) : invariant(internalGetID(node) === id));
	
	    var container = ReactMount.findReactContainerForID(id);
	    if (container && containsNode(container, node)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Causes the cache to forget about one React-specific ID.
	 *
	 * @param {string} id The ID to forget.
	 */
	function purgeID(id) {
	  delete nodeCache[id];
	}
	
	var deepestNodeSoFar = null;
	function findDeepestCachedAncestorImpl(ancestorID) {
	  var ancestor = nodeCache[ancestorID];
	  if (ancestor && isValid(ancestor, ancestorID)) {
	    deepestNodeSoFar = ancestor;
	  } else {
	    // This node isn't populated in the cache, so presumably none of its
	    // descendants are. Break out of the loop.
	    return false;
	  }
	}
	
	/**
	 * Return the deepest cached node whose ID is a prefix of `targetID`.
	 */
	function findDeepestCachedAncestor(targetID) {
	  deepestNodeSoFar = null;
	  ReactInstanceHandles.traverseAncestors(
	    targetID,
	    findDeepestCachedAncestorImpl
	  );
	
	  var foundNode = deepestNodeSoFar;
	  deepestNodeSoFar = null;
	  return foundNode;
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(
	    componentInstance,
	    rootID,
	    container,
	    transaction,
	    shouldReuseMarkup) {
	  var markup = ReactReconciler.mountComponent(
	    componentInstance, rootID, transaction, emptyObject
	  );
	  componentInstance._isTopLevel = true;
	  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(
	    componentInstance,
	    rootID,
	    container,
	    shouldReuseMarkup) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
	  transaction.perform(
	    mountComponentIntoNode,
	    null,
	    componentInstance,
	    rootID,
	    container,
	    transaction,
	    shouldReuseMarkup
	  );
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	  /** Exposed for debugging purposes **/
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function(container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function(
	      prevComponent,
	      nextElement,
	      container,
	      callback) {
	    if ("production" !== process.env.NODE_ENV) {
	      ReactElementValidator.checkAndWarnForMutatedProps(nextElement);
	    }
	
	    ReactMount.scrollMonitor(container, function() {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    if ("production" !== process.env.NODE_ENV) {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[getReactRootID(container)] =
	        getReactRootElementInContainer(container);
	    }
	
	    return prevComponent;
	  },
	
	  /**
	   * Register a component into the instance map and starts scroll value
	   * monitoring
	   * @param {ReactComponent} nextComponent component instance to render
	   * @param {DOMElement} container container to render into
	   * @return {string} reactRoot ID prefix
	   */
	  _registerComponent: function(nextComponent, container) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      container && (
	        (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)
	      ),
	      '_registerComponent(...): Target container is not a DOM element.'
	    ) : invariant(container && (
	      (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)
	    )));
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	
	    var reactRootID = ReactMount.registerContainer(container);
	    instancesByReactRootID[reactRootID] = nextComponent;
	    return reactRootID;
	  },
	
	  /**
	   * Render a new component into the DOM.
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function(
	    nextElement,
	    container,
	    shouldReuseMarkup
	  ) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    ("production" !== process.env.NODE_ENV ? warning(
	      ReactCurrentOwner.current == null,
	      '_renderNewRootComponent(): Render methods should be a pure function ' +
	      'of props and state; triggering nested component updates from ' +
	      'render is not allowed. If necessary, trigger nested updates in ' +
	      'componentDidUpdate.'
	    ) : null);
	
	    var componentInstance = instantiateReactComponent(nextElement, null);
	    var reactRootID = ReactMount._registerComponent(
	      componentInstance,
	      container
	    );
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(
	      batchedMountComponentIntoNode,
	      componentInstance,
	      reactRootID,
	      container,
	      shouldReuseMarkup
	    );
	
	    if ("production" !== process.env.NODE_ENV) {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[reactRootID] =
	        getReactRootElementInContainer(container);
	    }
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function(nextElement, container, callback) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      ReactElement.isValidElement(nextElement),
	      'React.render(): Invalid component element.%s',
	      (
	        typeof nextElement === 'string' ?
	          ' Instead of passing an element string, make sure to instantiate ' +
	          'it by passing it to React.createElement.' :
	        typeof nextElement === 'function' ?
	          ' Instead of passing a component class, make sure to instantiate ' +
	          'it by passing it to React.createElement.' :
	        // Check if it quacks like an element
	        nextElement != null && nextElement.props !== undefined ?
	          ' This may be caused by unintentionally loading two independent ' +
	          'copies of React.' :
	          ''
	      )
	    ) : invariant(ReactElement.isValidElement(nextElement)));
	
	    var prevComponent = instancesByReactRootID[getReactRootID(container)];
	
	    if (prevComponent) {
	      var prevElement = prevComponent._currentElement;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        return ReactMount._updateRootComponent(
	          prevComponent,
	          nextElement,
	          container,
	          callback
	        ).getPublicInstance();
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup =
	      reactRootElement && ReactMount.isRenderedByReact(reactRootElement);
	
	    if ("production" !== process.env.NODE_ENV) {
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (ReactMount.isRenderedByReact(rootElementSibling)) {
	            ("production" !== process.env.NODE_ENV ? warning(
	              false,
	              'render(): Target node has markup rendered by React, but there ' +
	              'are unrelated nodes as well. This is most commonly caused by ' +
	              'white-space inserted around server-rendered markup.'
	            ) : null);
	            break;
	          }
	
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;
	
	    var component = ReactMount._renderNewRootComponent(
	      nextElement,
	      container,
	      shouldReuseMarkup
	    ).getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Constructs a component instance of `constructor` with `initialProps` and
	   * renders it into the supplied `container`.
	   *
	   * @param {function} constructor React component constructor.
	   * @param {?object} props Initial props of the component instance.
	   * @param {DOMElement} container DOM element to render into.
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  constructAndRenderComponent: function(constructor, props, container) {
	    var element = ReactElement.createElement(constructor, props);
	    return ReactMount.render(element, container);
	  },
	
	  /**
	   * Constructs a component instance of `constructor` with `initialProps` and
	   * renders it into a container node identified by supplied `id`.
	   *
	   * @param {function} componentConstructor React component constructor
	   * @param {?object} props Initial props of the component instance.
	   * @param {string} id ID of the DOM element to render into.
	   * @return {ReactComponent} Component instance rendered in the container node.
	   */
	  constructAndRenderComponentByID: function(constructor, props, id) {
	    var domNode = document.getElementById(id);
	    ("production" !== process.env.NODE_ENV ? invariant(
	      domNode,
	      'Tried to get element with id of "%s" but it is not present on the page.',
	      id
	    ) : invariant(domNode));
	    return ReactMount.constructAndRenderComponent(constructor, props, domNode);
	  },
	
	  /**
	   * Registers a container node into which React components will be rendered.
	   * This also creates the "reactRoot" ID that will be assigned to the element
	   * rendered within.
	   *
	   * @param {DOMElement} container DOM element to register as a container.
	   * @return {string} The "reactRoot" ID of elements rendered within.
	   */
	  registerContainer: function(container) {
	    var reactRootID = getReactRootID(container);
	    if (reactRootID) {
	      // If one exists, make sure it is a valid "reactRoot" ID.
	      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
	    }
	    if (!reactRootID) {
	      // No valid "reactRoot" ID found, create one.
	      reactRootID = ReactInstanceHandles.createReactRootID();
	    }
	    containersByReactRootID[reactRootID] = container;
	    return reactRootID;
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function(container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    ("production" !== process.env.NODE_ENV ? warning(
	      ReactCurrentOwner.current == null,
	      'unmountComponentAtNode(): Render methods should be a pure function of ' +
	      'props and state; triggering nested component updates from render is ' +
	      'not allowed. If necessary, trigger nested updates in ' +
	      'componentDidUpdate.'
	    ) : null);
	
	    ("production" !== process.env.NODE_ENV ? invariant(
	      container && (
	        (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)
	      ),
	      'unmountComponentAtNode(...): Target container is not a DOM element.'
	    ) : invariant(container && (
	      (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)
	    )));
	
	    var reactRootID = getReactRootID(container);
	    var component = instancesByReactRootID[reactRootID];
	    if (!component) {
	      return false;
	    }
	    ReactMount.unmountComponentFromNode(component, container);
	    delete instancesByReactRootID[reactRootID];
	    delete containersByReactRootID[reactRootID];
	    if ("production" !== process.env.NODE_ENV) {
	      delete rootElementsByReactRootID[reactRootID];
	    }
	    return true;
	  },
	
	  /**
	   * Unmounts a component and removes it from the DOM.
	   *
	   * @param {ReactComponent} instance React component instance.
	   * @param {DOMElement} container DOM element to unmount from.
	   * @final
	   * @internal
	   * @see {ReactMount.unmountComponentAtNode}
	   */
	  unmountComponentFromNode: function(instance, container) {
	    ReactReconciler.unmountComponent(instance);
	
	    if (container.nodeType === DOC_NODE_TYPE) {
	      container = container.documentElement;
	    }
	
	    // http://jsperf.com/emptying-a-node
	    while (container.lastChild) {
	      container.removeChild(container.lastChild);
	    }
	  },
	
	  /**
	   * Finds the container DOM element that contains React component to which the
	   * supplied DOM `id` belongs.
	   *
	   * @param {string} id The ID of an element rendered by a React component.
	   * @return {?DOMElement} DOM element that contains the `id`.
	   */
	  findReactContainerForID: function(id) {
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
	    var container = containersByReactRootID[reactRootID];
	
	    if ("production" !== process.env.NODE_ENV) {
	      var rootElement = rootElementsByReactRootID[reactRootID];
	      if (rootElement && rootElement.parentNode !== container) {
	        ("production" !== process.env.NODE_ENV ? invariant(
	          // Call internalGetID here because getID calls isValid which calls
	          // findReactContainerForID (this function).
	          internalGetID(rootElement) === reactRootID,
	          'ReactMount: Root element ID differed from reactRootID.'
	        ) : invariant(// Call internalGetID here because getID calls isValid which calls
	        // findReactContainerForID (this function).
	        internalGetID(rootElement) === reactRootID));
	
	        var containerChild = container.firstChild;
	        if (containerChild &&
	            reactRootID === internalGetID(containerChild)) {
	          // If the container has a new child with the same ID as the old
	          // root element, then rootElementsByReactRootID[reactRootID] is
	          // just stale and needs to be updated. The case that deserves a
	          // warning is when the container is empty.
	          rootElementsByReactRootID[reactRootID] = containerChild;
	        } else {
	          ("production" !== process.env.NODE_ENV ? warning(
	            false,
	            'ReactMount: Root element has been removed from its original ' +
	            'container. New container:', rootElement.parentNode
	          ) : null);
	        }
	      }
	    }
	
	    return container;
	  },
	
	  /**
	   * Finds an element rendered by React with the supplied ID.
	   *
	   * @param {string} id ID of a DOM node in the React component.
	   * @return {DOMElement} Root DOM node of the React component.
	   */
	  findReactNodeByID: function(id) {
	    var reactRoot = ReactMount.findReactContainerForID(id);
	    return ReactMount.findComponentRoot(reactRoot, id);
	  },
	
	  /**
	   * True if the supplied `node` is rendered by React.
	   *
	   * @param {*} node DOM Element to check.
	   * @return {boolean} True if the DOM Element appears to be rendered by React.
	   * @internal
	   */
	  isRenderedByReact: function(node) {
	    if (node.nodeType !== 1) {
	      // Not a DOMElement, therefore not a React component
	      return false;
	    }
	    var id = ReactMount.getID(node);
	    return id ? id.charAt(0) === SEPARATOR : false;
	  },
	
	  /**
	   * Traverses up the ancestors of the supplied node to find a node that is a
	   * DOM representation of a React component.
	   *
	   * @param {*} node
	   * @return {?DOMEventTarget}
	   * @internal
	   */
	  getFirstReactDOM: function(node) {
	    var current = node;
	    while (current && current.parentNode !== current) {
	      if (ReactMount.isRenderedByReact(current)) {
	        return current;
	      }
	      current = current.parentNode;
	    }
	    return null;
	  },
	
	  /**
	   * Finds a node with the supplied `targetID` inside of the supplied
	   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
	   * quickly.
	   *
	   * @param {DOMEventTarget} ancestorNode Search from this root.
	   * @pararm {string} targetID ID of the DOM representation of the component.
	   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
	   * @internal
	   */
	  findComponentRoot: function(ancestorNode, targetID) {
	    var firstChildren = findComponentRootReusableArray;
	    var childIndex = 0;
	
	    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
	
	    firstChildren[0] = deepestAncestor.firstChild;
	    firstChildren.length = 1;
	
	    while (childIndex < firstChildren.length) {
	      var child = firstChildren[childIndex++];
	      var targetChild;
	
	      while (child) {
	        var childID = ReactMount.getID(child);
	        if (childID) {
	          // Even if we find the node we're looking for, we finish looping
	          // through its siblings to ensure they're cached so that we don't have
	          // to revisit this node again. Otherwise, we make n^2 calls to getID
	          // when visiting the many children of a single node in order.
	
	          if (targetID === childID) {
	            targetChild = child;
	          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
	            // If we find a child whose ID is an ancestor of the given ID,
	            // then we can be sure that we only want to search the subtree
	            // rooted at this child, so we can throw out the rest of the
	            // search state.
	            firstChildren.length = childIndex = 0;
	            firstChildren.push(child.firstChild);
	          }
	
	        } else {
	          // If this child had no ID, then there's a chance that it was
	          // injected automatically by the browser, as when a `<table>`
	          // element sprouts an extra `<tbody>` child as a side effect of
	          // `.innerHTML` parsing. Optimistically continue down this
	          // branch, but not before examining the other siblings.
	          firstChildren.push(child.firstChild);
	        }
	
	        child = child.nextSibling;
	      }
	
	      if (targetChild) {
	        // Emptying firstChildren/findComponentRootReusableArray is
	        // not necessary for correctness, but it helps the GC reclaim
	        // any nodes that were left at the end of the search.
	        firstChildren.length = 0;
	
	        return targetChild;
	      }
	    }
	
	    firstChildren.length = 0;
	
	    ("production" !== process.env.NODE_ENV ? invariant(
	      false,
	      'findComponentRoot(..., %s): Unable to find element. This probably ' +
	      'means the DOM was unexpectedly mutated (e.g., by the browser), ' +
	      'usually due to forgetting a <tbody> when using tables, nesting tags ' +
	      'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' +
	      'parent. ' +
	      'Try inspecting the child nodes of the element with React ID `%s`.',
	      targetID,
	      ReactMount.getID(ancestorNode)
	    ) : invariant(false));
	  },
	
	  _mountImageIntoNode: function(markup, container, shouldReuseMarkup) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      container && (
	        (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)
	      ),
	      'mountComponentIntoNode(...): Target container is not valid.'
	    ) : invariant(container && (
	      (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)
	    )));
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(
	          ReactMarkupChecksum.CHECKSUM_ATTR_NAME
	        );
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(
	          ReactMarkupChecksum.CHECKSUM_ATTR_NAME,
	          checksum
	        );
	
	        var diffIndex = firstDifferenceIndex(markup, rootMarkup);
	        var difference = ' (client) ' +
	          markup.substring(diffIndex - 20, diffIndex + 20) +
	          '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        ("production" !== process.env.NODE_ENV ? invariant(
	          container.nodeType !== DOC_NODE_TYPE,
	          'You\'re trying to render a component to the document using ' +
	          'server rendering but the checksum was invalid. This usually ' +
	          'means you rendered a different component type or props on ' +
	          'the client from the one on the server, or your render() ' +
	          'methods are impure. React cannot handle this case due to ' +
	          'cross-browser quirks by rendering at the document root. You ' +
	          'should look for environment dependent code in your components ' +
	          'and ensure the props are the same client and server side:\n%s',
	          difference
	        ) : invariant(container.nodeType !== DOC_NODE_TYPE));
	
	        if ("production" !== process.env.NODE_ENV) {
	          ("production" !== process.env.NODE_ENV ? warning(
	            false,
	            'React attempted to reuse markup in a container but the ' +
	            'checksum was invalid. This generally means that you are ' +
	            'using server rendering and the markup generated on the ' +
	            'server was not what the client was expecting. React injected ' +
	            'new markup to compensate which works but you have lost many ' +
	            'of the benefits of server rendering. Instead, figure out ' +
	            'why the markup being generated is different on the client ' +
	            'or server:\n%s',
	            difference
	          ) : null);
	        }
	      }
	    }
	
	    ("production" !== process.env.NODE_ENV ? invariant(
	      container.nodeType !== DOC_NODE_TYPE,
	      'You\'re trying to render a component to the document but ' +
	        'you didn\'t use server rendering. We can\'t do this ' +
	        'without using server rendering due to cross-browser quirks. ' +
	        'See React.renderToString() for server rendering.'
	    ) : invariant(container.nodeType !== DOC_NODE_TYPE));
	
	    setInnerHTML(container, markup);
	  },
	
	  /**
	   * React ID utilities.
	   */
	
	  getReactRootID: getReactRootID,
	
	  getID: getID,
	
	  setID: setID,
	
	  getNode: getNode,
	
	  getNodeFromInstance: getNodeFromInstance,
	
	  purgeID: purgeID
	};
	
	ReactPerf.measureMethods(ReactMount, 'ReactMount', {
	  _renderNewRootComponent: '_renderNewRootComponent',
	  _mountImageIntoNode: '_mountImageIntoNode'
	});
	
	module.exports = ReactMount;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(7);
	var EventPluginHub = __webpack_require__(71);
	var EventPluginRegistry = __webpack_require__(72);
	var ReactEventEmitterMixin = __webpack_require__(75);
	var ViewportMetrics = __webpack_require__(76);
	
	var assign = __webpack_require__(15);
	var isEventSupported = __webpack_require__(77);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topBlur: 'blur',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topScroll: 'scroll',
	  topSelectionChange: 'selectionchange',
	  topTextInput: 'textInput',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function(ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(
	        ReactBrowserEventEmitter.handleTopLevel
	      );
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function(enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function() {
	    return !!(
	      (ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled())
	    );
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function(registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.
	      registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0, l = dependencies.length; i < l; i++) {
	      var dependency = dependencies[i];
	      if (!(
	            (isListening.hasOwnProperty(dependency) && isListening[dependency])
	          )) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
	              topLevelTypes.topWheel,
	              'wheel',
	              mountAt
	            );
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
	              topLevelTypes.topWheel,
	              'mousewheel',
	              mountAt
	            );
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
	              topLevelTypes.topWheel,
	              'DOMMouseScroll',
	              mountAt
	            );
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
	              topLevelTypes.topScroll,
	              'scroll',
	              mountAt
	            );
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
	              topLevelTypes.topScroll,
	              'scroll',
	              ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE
	            );
	          }
	        } else if (dependency === topLevelTypes.topFocus ||
	            dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
	              topLevelTypes.topFocus,
	              'focus',
	              mountAt
	            );
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
	              topLevelTypes.topBlur,
	              'blur',
	              mountAt
	            );
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
	              topLevelTypes.topFocus,
	              'focusin',
	              mountAt
	            );
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
	              topLevelTypes.topBlur,
	              'focusout',
	              mountAt
	            );
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
	            dependency,
	            topEventMapping[dependency],
	            mountAt
	          );
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
	      topLevelType,
	      handlerBaseName,
	      handle
	    );
	  },
	
	  trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
	      topLevelType,
	      handlerBaseName,
	      handle
	    );
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function() {
	    if (!isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  },
	
	  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginHub.registrationNameModules,
	
	  putListener: EventPluginHub.putListener,
	
	  getListener: EventPluginHub.getListener,
	
	  deleteListener: EventPluginHub.deleteListener,
	
	  deleteAllListeners: EventPluginHub.deleteAllListeners
	
	});
	
	module.exports = ReactBrowserEventEmitter;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var EventPluginRegistry = __webpack_require__(72);
	var EventPluginUtils = __webpack_require__(6);
	
	var accumulateInto = __webpack_require__(73);
	var forEachAccumulated = __webpack_require__(74);
	var invariant = __webpack_require__(9);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @private
	 */
	var executeDispatchesAndRelease = function(event) {
	  if (event) {
	    var executeDispatch = EventPluginUtils.executeDispatch;
	    // Plugins can provide custom behavior when dispatching events.
	    var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
	    if (PluginModule && PluginModule.executeDispatch) {
	      executeDispatch = PluginModule.executeDispatch;
	    }
	    EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	
	/**
	 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
	 *   hierarchy given ids of the logical DOM elements involved.
	 */
	var InstanceHandle = null;
	
	function validateInstanceHandle() {
	  var valid =
	    InstanceHandle &&
	    InstanceHandle.traverseTwoPhase &&
	    InstanceHandle.traverseEnterLeave;
	  ("production" !== process.env.NODE_ENV ? invariant(
	    valid,
	    'InstanceHandle not injected before use!'
	  ) : invariant(valid));
	}
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {object} InjectedMount
	     * @public
	     */
	    injectMount: EventPluginUtils.injection.injectMount,
	
	    /**
	     * @param {object} InjectedInstanceHandle
	     * @public
	     */
	    injectInstanceHandle: function(InjectedInstanceHandle) {
	      InstanceHandle = InjectedInstanceHandle;
	      if ("production" !== process.env.NODE_ENV) {
	        validateInstanceHandle();
	      }
	    },
	
	    getInstanceHandle: function() {
	      if ("production" !== process.env.NODE_ENV) {
	        validateInstanceHandle();
	      }
	      return InstanceHandle;
	    },
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginRegistry.registrationNameModules,
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {?function} listener The callback to store.
	   */
	  putListener: function(id, registrationName, listener) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      !listener || typeof listener === 'function',
	      'Expected %s listener to be a function, instead got type %s',
	      registrationName, typeof listener
	    ) : invariant(!listener || typeof listener === 'function'));
	
	    var bankForRegistrationName =
	      listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[id] = listener;
	  },
	
	  /**
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function(id, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    return bankForRegistrationName && bankForRegistrationName[id];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function(id, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    if (bankForRegistrationName) {
	      delete bankForRegistrationName[id];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {string} id ID of the DOM element.
	   */
	  deleteAllListeners: function(id) {
	    for (var registrationName in listenerBank) {
	      delete listenerBank[registrationName][id];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function(
	      topLevelType,
	      topLevelTarget,
	      topLevelTargetID,
	      nativeEvent) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0, l = plugins.length; i < l; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(
	          topLevelType,
	          topLevelTarget,
	          topLevelTargetID,
	          nativeEvent
	        );
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function(events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function() {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
	    ("production" !== process.env.NODE_ENV ? invariant(
	      !eventQueue,
	      'processEventQueue(): Additional events were enqueued while processing ' +
	      'an event queue. Support for this has not yet been implemented.'
	    ) : invariant(!eventQueue));
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function() {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function() {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(9);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    ("production" !== process.env.NODE_ENV ? invariant(
	      pluginIndex > -1,
	      'EventPluginRegistry: Cannot inject event plugins that do not exist in ' +
	      'the plugin ordering, `%s`.',
	      pluginName
	    ) : invariant(pluginIndex > -1));
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    ("production" !== process.env.NODE_ENV ? invariant(
	      PluginModule.extractEvents,
	      'EventPluginRegistry: Event plugins must implement an `extractEvents` ' +
	      'method, but `%s` does not.',
	      pluginName
	    ) : invariant(PluginModule.extractEvents));
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      ("production" !== process.env.NODE_ENV ? invariant(
	        publishEventForPlugin(
	          publishedEvents[eventName],
	          PluginModule,
	          eventName
	        ),
	        'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',
	        eventName,
	        pluginName
	      ) : invariant(publishEventForPlugin(
	        publishedEvents[eventName],
	        PluginModule,
	        eventName
	      )));
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    !EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName),
	    'EventPluginHub: More than one plugin attempted to publish the same ' +
	    'event name, `%s`.',
	    eventName
	  ) : invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName)));
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(
	          phasedRegistrationName,
	          PluginModule,
	          eventName
	        );
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(
	      dispatchConfig.registrationName,
	      PluginModule,
	      eventName
	    );
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    !EventPluginRegistry.registrationNameModules[registrationName],
	    'EventPluginHub: More than one plugin attempted to publish the same ' +
	    'registration name, `%s`.',
	    registrationName
	  ) : invariant(!EventPluginRegistry.registrationNameModules[registrationName]));
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] =
	    PluginModule.eventTypes[eventName].dependencies;
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function(InjectedEventPluginOrder) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      !EventPluginOrder,
	      'EventPluginRegistry: Cannot inject event plugin ordering more than ' +
	      'once. You are likely trying to load more than one copy of React.'
	    ) : invariant(!EventPluginOrder));
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function(injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) ||
	          namesToPlugins[pluginName] !== PluginModule) {
	        ("production" !== process.env.NODE_ENV ? invariant(
	          !namesToPlugins[pluginName],
	          'EventPluginRegistry: Cannot inject two different event plugins ' +
	          'using the same name, `%s`.',
	          pluginName
	        ) : invariant(!namesToPlugins[pluginName]));
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function(event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[
	        dispatchConfig.registrationName
	      ] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[
	        dispatchConfig.phasedRegistrationNames[phase]
	      ];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function() {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(9);
	
	/**
	 *
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    next != null,
	    'accumulateInto(...): Accumulated items must not be null or undefined.'
	  ) : invariant(next != null));
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  var currentIsArray = Array.isArray(current);
	  var nextIsArray = Array.isArray(next);
	
	  if (currentIsArray && nextIsArray) {
	    current.push.apply(current, next);
	    return current;
	  }
	
	  if (currentIsArray) {
	    current.push(next);
	    return current;
	  }
	
	  if (nextIsArray) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 74 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 */
	
	'use strict';
	
	/**
	 * @param {array} an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	var forEachAccumulated = function(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	};
	
	module.exports = forEachAccumulated;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(71);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue();
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {object} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native environment event.
	   */
	  handleTopLevel: function(
	      topLevelType,
	      topLevelTarget,
	      topLevelTargetID,
	      nativeEvent) {
	    var events = EventPluginHub.extractEvents(
	      topLevelType,
	      topLevelTarget,
	      topLevelTargetID,
	      nativeEvent
	    );
	
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;


/***/ },
/* 76 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function(scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(53);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature =
	    document.implementation &&
	    document.implementation.hasFeature &&
	    // always returns true in newer browsers as per the standard.
	    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	    document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM ||
	      capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	var ReactInstanceMap = __webpack_require__(27);
	
	var invariant = __webpack_require__(9);
	
	var component;
	// This registry keeps track of the React IDs of the components that rendered to
	// `null` (in reality a placeholder such as `noscript`)
	var nullComponentIDsRegistry = {};
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponent: function(emptyComponent) {
	    component = ReactElement.createFactory(emptyComponent);
	  }
	};
	
	var ReactEmptyComponentType = function() {};
	ReactEmptyComponentType.prototype.componentDidMount = function() {
	  var internalInstance = ReactInstanceMap.get(this);
	  // TODO: Make sure we run these methods in the correct order, we shouldn't
	  // need this check. We're going to assume if we're here it means we ran
	  // componentWillUnmount already so there is no internal instance (it gets
	  // removed as part of the unmounting process).
	  if (!internalInstance) {
	    return;
	  }
	  registerNullComponentID(internalInstance._rootNodeID);
	};
	ReactEmptyComponentType.prototype.componentWillUnmount = function() {
	  var internalInstance = ReactInstanceMap.get(this);
	  // TODO: Get rid of this check. See TODO in componentDidMount.
	  if (!internalInstance) {
	    return;
	  }
	  deregisterNullComponentID(internalInstance._rootNodeID);
	};
	ReactEmptyComponentType.prototype.render = function() {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    component,
	    'Trying to return null from a render, but no null placeholder component ' +
	    'was injected.'
	  ) : invariant(component));
	  return component();
	};
	
	var emptyElement = ReactElement.createElement(ReactEmptyComponentType);
	
	/**
	 * Mark the component as having rendered to null.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function registerNullComponentID(id) {
	  nullComponentIDsRegistry[id] = true;
	}
	
	/**
	 * Unmark the component as having rendered to null: it renders to something now.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function deregisterNullComponentID(id) {
	  delete nullComponentIDsRegistry[id];
	}
	
	/**
	 * @param {string} id Component's `_rootNodeID`.
	 * @return {boolean} True if the component is rendered to null.
	 */
	function isNullComponentID(id) {
	  return !!nullComponentIDsRegistry[id];
	}
	
	var ReactEmptyComponent = {
	  emptyElement: emptyElement,
	  injection: ReactEmptyComponentInjection,
	  isNullComponentID: isNullComponentID
	};
	
	module.exports = ReactEmptyComponent;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(80);
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function(markup) {
	    var checksum = adler32(markup);
	    return markup.replace(
	      '>',
	      ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '">'
	    );
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function(markup, element) {
	    var existingChecksum = element.getAttribute(
	      ReactMarkupChecksum.CHECKSUM_ATTR_NAME
	    );
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;


/***/ },
/* 80 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 */
	
	/* jslint bitwise:true */
	
	'use strict';
	
	var MOD = 65521;
	
	// This is a clean-room implementation of adler32 designed for detecting
	// if markup is not what we expect it to be. It does not need to be
	// cryptographically strong, only reasonably good at detecting if markup
	// generated on the server is different than that on the client.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  for (var i = 0; i < data.length; i++) {
	    a = (a + data.charCodeAt(i)) % MOD;
	    b = (b + a) % MOD;
	  }
	  return a | (b << 16);
	}
	
	module.exports = adler32;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule containsNode
	 * @typechecks
	 */
	
	var isTextNode = __webpack_require__(82);
	
	/*jslint bitwise:true */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 *
	 * @param {?DOMNode} outerNode Outer DOM node.
	 * @param {?DOMNode} innerNode Inner DOM node.
	 * @return {boolean} True if `outerNode` contains or is `innerNode`.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if (outerNode.contains) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}
	
	module.exports = containsNode;


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextNode
	 * @typechecks
	 */
	
	var isNode = __webpack_require__(83);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;


/***/ },
/* 83 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isNode
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	function isNode(object) {
	  return !!(object && (
	    ((typeof Node === 'function' ? object instanceof Node : typeof object === 'object' &&
	    typeof object.nodeType === 'number' &&
	    typeof object.nodeName === 'string'))
	  ));
	}
	
	module.exports = isNode;


/***/ },
/* 84 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getReactRootElementInContainer
	 */
	
	'use strict';
	
	var DOC_NODE_TYPE = 9;
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 *                                           a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	module.exports = getReactRootElementInContainer;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactCompositeComponent = __webpack_require__(86);
	var ReactEmptyComponent = __webpack_require__(78);
	var ReactNativeComponent = __webpack_require__(37);
	
	var assign = __webpack_require__(15);
	var invariant = __webpack_require__(9);
	var warning = __webpack_require__(17);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function() { };
	assign(
	  ReactCompositeComponentWrapper.prototype,
	  ReactCompositeComponent.Mixin,
	  {
	    _instantiateReactComponent: instantiateReactComponent
	  }
	);
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return (
	    typeof type === 'function' &&
	    typeof type.prototype !== 'undefined' &&
	    typeof type.prototype.mountComponent === 'function' &&
	    typeof type.prototype.receiveComponent === 'function'
	  );
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {*} parentCompositeType The composite type that resolved this.
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, parentCompositeType) {
	  var instance;
	
	  if (node === null || node === false) {
	    node = ReactEmptyComponent.emptyElement;
	  }
	
	  if (typeof node === 'object') {
	    var element = node;
	    if ("production" !== process.env.NODE_ENV) {
	      ("production" !== process.env.NODE_ENV ? warning(
	        element && (typeof element.type === 'function' ||
	                    typeof element.type === 'string'),
	        'Only functions or strings can be mounted as React components.'
	      ) : null);
	    }
	
	    // Special case string values
	    if (parentCompositeType === element.type &&
	        typeof element.type === 'string') {
	      // Avoid recursion if the wrapper renders itself.
	      instance = ReactNativeComponent.createInternalComponent(element);
	      // All native components are currently wrapped in a composite so we're
	      // safe to assume that this is what we should instantiate.
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // represenations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	    } else {
	      instance = new ReactCompositeComponentWrapper();
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactNativeComponent.createInstanceForText(node);
	  } else {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      false,
	      'Encountered invalid React node of type %s',
	      typeof node
	    ) : invariant(false));
	  }
	
	  if ("production" !== process.env.NODE_ENV) {
	    ("production" !== process.env.NODE_ENV ? warning(
	      typeof instance.construct === 'function' &&
	      typeof instance.mountComponent === 'function' &&
	      typeof instance.receiveComponent === 'function' &&
	      typeof instance.unmountComponent === 'function',
	      'Only React Components can be mounted.'
	    ) : null);
	  }
	
	  // Sets up the instance. This can probably just move into the constructor now.
	  instance.construct(node);
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if ("production" !== process.env.NODE_ENV) {
	    instance._isOwnerNecessary = false;
	    instance._warnedAboutRefsInRender = false;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if ("production" !== process.env.NODE_ENV) {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var ReactComponentEnvironment = __webpack_require__(87);
	var ReactContext = __webpack_require__(14);
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactElement = __webpack_require__(13);
	var ReactElementValidator = __webpack_require__(34);
	var ReactInstanceMap = __webpack_require__(27);
	var ReactLifeCycle = __webpack_require__(26);
	var ReactNativeComponent = __webpack_require__(37);
	var ReactPerf = __webpack_require__(30);
	var ReactPropTypeLocations = __webpack_require__(35);
	var ReactPropTypeLocationNames = __webpack_require__(36);
	var ReactReconciler = __webpack_require__(31);
	var ReactUpdates = __webpack_require__(28);
	
	var assign = __webpack_require__(15);
	var emptyObject = __webpack_require__(16);
	var invariant = __webpack_require__(9);
	var shouldUpdateReactComponent = __webpack_require__(88);
	var warning = __webpack_require__(17);
	
	function getDeclarationErrorAddendum(component) {
	  var owner = component._currentElement._owner || null;
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function(element) {
	    this._currentElement = element;
	    this._rootNodeID = null;
	    this._instance = null;
	
	    // See ReactUpdateQueue
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedComponent = null;
	
	    this._context = null;
	    this._mountOrder = 0;
	    this._isTopLevel = false;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function(rootID, transaction, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._rootNodeID = rootID;
	
	    var publicProps = this._processProps(this._currentElement.props);
	    var publicContext = this._processContext(this._currentElement._context);
	
	    var Component = ReactNativeComponent.getComponentClassForElement(
	      this._currentElement
	    );
	
	    // Initialize the public class
	    var inst = new Component(publicProps, publicContext);
	
	    if ("production" !== process.env.NODE_ENV) {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      ("production" !== process.env.NODE_ENV ? warning(
	        inst.render != null,
	        '%s(...): No `render` method found on the returned component ' +
	        'instance: you may have forgotten to define `render` in your ' +
	        'component or you may have accidentally tried to render an element ' +
	        'whose type is a function that isn\'t a React component.',
	        Component.displayName || Component.name || 'Component'
	      ) : null);
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if ("production" !== process.env.NODE_ENV) {
	      this._warnIfContextsDiffer(this._currentElement._context, context);
	    }
	
	    if ("production" !== process.env.NODE_ENV) {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      ("production" !== process.env.NODE_ENV ? warning(
	        !inst.getInitialState ||
	        inst.getInitialState.isReactClassApproved,
	        'getInitialState was defined on %s, a plain JavaScript class. ' +
	        'This is only supported for classes created using React.createClass. ' +
	        'Did you mean to define a state property instead?',
	        this.getName() || 'a component'
	      ) : null);
	      ("production" !== process.env.NODE_ENV ? warning(
	        !inst.getDefaultProps ||
	        inst.getDefaultProps.isReactClassApproved,
	        'getDefaultProps was defined on %s, a plain JavaScript class. ' +
	        'This is only supported for classes created using React.createClass. ' +
	        'Use a static property to define defaultProps instead.',
	        this.getName() || 'a component'
	      ) : null);
	      ("production" !== process.env.NODE_ENV ? warning(
	        !inst.propTypes,
	        'propTypes was defined as an instance property on %s. Use a static ' +
	        'property to define propTypes instead.',
	        this.getName() || 'a component'
	      ) : null);
	      ("production" !== process.env.NODE_ENV ? warning(
	        !inst.contextTypes,
	        'contextTypes was defined as an instance property on %s. Use a ' +
	        'static property to define contextTypes instead.',
	        this.getName() || 'a component'
	      ) : null);
	      ("production" !== process.env.NODE_ENV ? warning(
	        typeof inst.componentShouldUpdate !== 'function',
	        '%s has a method called ' +
	        'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
	        'The name is phrased as a question because the function is ' +
	        'expected to return a value.',
	        (this.getName() || 'A component')
	      ) : null);
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    ("production" !== process.env.NODE_ENV ? invariant(
	      typeof initialState === 'object' && !Array.isArray(initialState),
	      '%s.state: must be set to an object or null',
	      this.getName() || 'ReactCompositeComponent'
	    ) : invariant(typeof initialState === 'object' && !Array.isArray(initialState)));
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    var childContext;
	    var renderedElement;
	
	    var previouslyMounting = ReactLifeCycle.currentlyMountingInstance;
	    ReactLifeCycle.currentlyMountingInstance = this;
	    try {
	      if (inst.componentWillMount) {
	        inst.componentWillMount();
	        // When mounting, calls to `setState` by `componentWillMount` will set
	        // `this._pendingStateQueue` without triggering a re-render.
	        if (this._pendingStateQueue) {
	          inst.state = this._processPendingState(inst.props, inst.context);
	        }
	      }
	
	      childContext = this._getValidatedChildContext(context);
	      renderedElement = this._renderValidatedComponent(childContext);
	    } finally {
	      ReactLifeCycle.currentlyMountingInstance = previouslyMounting;
	    }
	
	    this._renderedComponent = this._instantiateReactComponent(
	      renderedElement,
	      this._currentElement.type // The wrapping type
	    );
	
	    var markup = ReactReconciler.mountComponent(
	      this._renderedComponent,
	      rootID,
	      transaction,
	      this._mergeChildContext(context, childContext)
	    );
	    if (inst.componentDidMount) {
	      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	    }
	
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function() {
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount) {
	      var previouslyUnmounting = ReactLifeCycle.currentlyUnmountingInstance;
	      ReactLifeCycle.currentlyUnmountingInstance = this;
	      try {
	        inst.componentWillUnmount();
	      } finally {
	        ReactLifeCycle.currentlyUnmountingInstance = previouslyUnmounting;
	      }
	    }
	
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    this._renderedComponent = null;
	
	    // Reset pending fields
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Schedule a partial update to the props. Only used for internal testing.
	   *
	   * @param {object} partialProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @internal
	   */
	  _setPropsInternal: function(partialProps, callback) {
	    // This is a deoptimized path. We optimize for always having an element.
	    // This creates an extra internal element.
	    var element = this._pendingElement || this._currentElement;
	    this._pendingElement = ReactElement.cloneAndReplaceProps(
	      element,
	      assign({}, element.props, partialProps)
	    );
	    ReactUpdates.enqueueUpdate(this, callback);
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function(context) {
	    var maskedContext = null;
	    // This really should be getting the component class for the element,
	    // but we know that we're not going to need it for built-ins.
	    if (typeof this._currentElement.type === 'string') {
	      return emptyObject;
	    }
	    var contextTypes = this._currentElement.type.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function(context) {
	    var maskedContext = this._maskContext(context);
	    if ("production" !== process.env.NODE_ENV) {
	      var Component = ReactNativeComponent.getComponentClassForElement(
	        this._currentElement
	      );
	      if (Component.contextTypes) {
	        this._checkPropTypes(
	          Component.contextTypes,
	          maskedContext,
	          ReactPropTypeLocations.context
	        );
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _getValidatedChildContext: function(currentContext) {
	    var inst = this._instance;
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (childContext) {
	      ("production" !== process.env.NODE_ENV ? invariant(
	        typeof inst.constructor.childContextTypes === 'object',
	        '%s.getChildContext(): childContextTypes must be defined in order to ' +
	        'use getChildContext().',
	        this.getName() || 'ReactCompositeComponent'
	      ) : invariant(typeof inst.constructor.childContextTypes === 'object'));
	      if ("production" !== process.env.NODE_ENV) {
	        this._checkPropTypes(
	          inst.constructor.childContextTypes,
	          childContext,
	          ReactPropTypeLocations.childContext
	        );
	      }
	      for (var name in childContext) {
	        ("production" !== process.env.NODE_ENV ? invariant(
	          name in inst.constructor.childContextTypes,
	          '%s.getChildContext(): key "%s" is not defined in childContextTypes.',
	          this.getName() || 'ReactCompositeComponent',
	          name
	        ) : invariant(name in inst.constructor.childContextTypes));
	      }
	      return childContext;
	    }
	    return null;
	  },
	
	  _mergeChildContext: function(currentContext, childContext) {
	    if (childContext) {
	      return assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Processes props by setting default values for unspecified props and
	   * asserting that the props are valid. Does not mutate its argument; returns
	   * a new props object with defaults merged in.
	   *
	   * @param {object} newProps
	   * @return {object}
	   * @private
	   */
	  _processProps: function(newProps) {
	    if ("production" !== process.env.NODE_ENV) {
	      var Component = ReactNativeComponent.getComponentClassForElement(
	        this._currentElement
	      );
	      if (Component.propTypes) {
	        this._checkPropTypes(
	          Component.propTypes,
	          newProps,
	          ReactPropTypeLocations.prop
	        );
	      }
	    }
	    return newProps;
	  },
	
	  /**
	   * Assert that the props are valid
	   *
	   * @param {object} propTypes Map of prop name to a ReactPropType
	   * @param {object} props
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkPropTypes: function(propTypes, props, location) {
	    // TODO: Stop validating prop types here and only use the element
	    // validation.
	    var componentName = this.getName();
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error;
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          ("production" !== process.env.NODE_ENV ? invariant(
	            typeof propTypes[propName] === 'function',
	            '%s: %s type `%s` is invalid; it must be a function, usually ' +
	            'from React.PropTypes.',
	            componentName || 'React class',
	            ReactPropTypeLocationNames[location],
	            propName
	          ) : invariant(typeof propTypes[propName] === 'function'));
	          error = propTypes[propName](props, propName, componentName, location);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error instanceof Error) {
	          // We may want to extend this logic for similar errors in
	          // React.render calls, so I'm abstracting it away into
	          // a function to minimize refactoring in the future
	          var addendum = getDeclarationErrorAddendum(this);
	
	          if (location === ReactPropTypeLocations.prop) {
	            // Preface gives us something to blacklist in warning module
	            ("production" !== process.env.NODE_ENV ? warning(
	              false,
	              'Failed Composite propType: %s%s',
	              error.message,
	              addendum
	            ) : null);
	          } else {
	            ("production" !== process.env.NODE_ENV ? warning(
	              false,
	              'Failed Context Types: %s%s',
	              error.message,
	              addendum
	            ) : null);
	          }
	        }
	      }
	    }
	  },
	
	  receiveComponent: function(nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(
	      transaction,
	      prevElement,
	      nextElement,
	      prevContext,
	      nextContext
	    );
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function(transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(
	        this,
	        this._pendingElement || this._currentElement,
	        transaction,
	        this._context
	      );
	    }
	
	    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      if ("production" !== process.env.NODE_ENV) {
	        ReactElementValidator.checkAndWarnForMutatedProps(
	          this._currentElement
	        );
	      }
	
	      this.updateComponent(
	        transaction,
	        this._currentElement,
	        this._currentElement,
	        this._context,
	        this._context
	      );
	    }
	  },
	
	  /**
	   * Compare two contexts, warning if they are different
	   * TODO: Remove this check when owner-context is removed
	   */
	   _warnIfContextsDiffer: function(ownerBasedContext, parentBasedContext) {
	    ownerBasedContext = this._maskContext(ownerBasedContext);
	    parentBasedContext = this._maskContext(parentBasedContext);
	    var parentKeys = Object.keys(parentBasedContext).sort();
	    var displayName = this.getName() || 'ReactCompositeComponent';
	    for (var i = 0; i < parentKeys.length; i++) {
	      var key = parentKeys[i];
	      ("production" !== process.env.NODE_ENV ? warning(
	        ownerBasedContext[key] === parentBasedContext[key],
	        'owner-based and parent-based contexts differ '  +
	        '(values: `%s` vs `%s`) for key (%s) while mounting %s ' +
	        '(see: http://fb.me/react-context-by-parent)',
	        ownerBasedContext[key],
	        parentBasedContext[key],
	        key,
	        displayName
	      ) : null);
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function(
	    transaction,
	    prevParentElement,
	    nextParentElement,
	    prevUnmaskedContext,
	    nextUnmaskedContext
	  ) {
	    var inst = this._instance;
	
	    var nextContext = inst.context;
	    var nextProps = inst.props;
	
	    // Distinguish between a props update versus a simple state update
	    if (prevParentElement !== nextParentElement) {
	      nextContext = this._processContext(nextParentElement._context);
	      nextProps = this._processProps(nextParentElement.props);
	
	      if ("production" !== process.env.NODE_ENV) {
	        if (nextUnmaskedContext != null) {
	          this._warnIfContextsDiffer(
	            nextParentElement._context,
	            nextUnmaskedContext
	          );
	        }
	      }
	
	      // An update here will schedule an update but immediately set
	      // _pendingStateQueue which will ensure that any state updates gets
	      // immediately reconciled instead of waiting for the next batch.
	
	      if (inst.componentWillReceiveProps) {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	
	    var shouldUpdate =
	      this._pendingForceUpdate ||
	      !inst.shouldComponentUpdate ||
	      inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	
	    if ("production" !== process.env.NODE_ENV) {
	      ("production" !== process.env.NODE_ENV ? warning(
	        typeof shouldUpdate !== 'undefined',
	        '%s.shouldComponentUpdate(): Returned undefined instead of a ' +
	        'boolean value. Make sure to return true or false.',
	        this.getName() || 'ReactCompositeComponent'
	      ) : null);
	    }
	
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(
	        nextParentElement,
	        nextProps,
	        nextState,
	        nextContext,
	        transaction,
	        nextUnmaskedContext
	      );
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function(props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      assign(
	        nextState,
	        typeof partial === 'function' ?
	          partial.call(inst, nextState, props, context) :
	          partial
	      );
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function(
	    nextElement,
	    nextProps,
	    nextState,
	    nextContext,
	    transaction,
	    unmaskedContext
	  ) {
	    var inst = this._instance;
	
	    var prevProps = inst.props;
	    var prevState = inst.state;
	    var prevContext = inst.context;
	
	    if (inst.componentWillUpdate) {
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (inst.componentDidUpdate) {
	      transaction.getReactMountReady().enqueue(
	        inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext),
	        inst
	      );
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function(transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var childContext = this._getValidatedChildContext();
	    var nextRenderedElement = this._renderValidatedComponent(childContext);
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(
	        prevComponentInstance,
	        nextRenderedElement,
	        transaction,
	        this._mergeChildContext(context, childContext)
	      );
	    } else {
	      // These two IDs are actually the same! But nothing should rely on that.
	      var thisID = this._rootNodeID;
	      var prevComponentID = prevComponentInstance._rootNodeID;
	      ReactReconciler.unmountComponent(prevComponentInstance);
	
	      this._renderedComponent = this._instantiateReactComponent(
	        nextRenderedElement,
	        this._currentElement.type
	      );
	      var nextMarkup = ReactReconciler.mountComponent(
	        this._renderedComponent,
	        thisID,
	        transaction,
	        this._mergeChildContext(context, childContext)
	      );
	      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	    }
	  },
	
	  /**
	   * @protected
	   */
	  _replaceNodeWithMarkupByID: function(prevComponentID, nextMarkup) {
	    ReactComponentEnvironment.replaceNodeWithMarkupByID(
	      prevComponentID,
	      nextMarkup
	    );
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function() {
	    var inst = this._instance;
	    var renderedComponent = inst.render();
	    if ("production" !== process.env.NODE_ENV) {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (typeof renderedComponent === 'undefined' &&
	          inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function(childContext) {
	    var renderedComponent;
	    var previousContext = ReactContext.current;
	    ReactContext.current = this._mergeChildContext(
	      this._currentElement._context,
	      childContext
	    );
	    ReactCurrentOwner.current = this;
	    try {
	      renderedComponent =
	        this._renderValidatedComponentWithoutOwnerOrContext();
	    } finally {
	      ReactContext.current = previousContext;
	      ReactCurrentOwner.current = null;
	    }
	    ("production" !== process.env.NODE_ENV ? invariant(
	      // TODO: An `isValidNode` function would probably be more appropriate
	      renderedComponent === null || renderedComponent === false ||
	      ReactElement.isValidElement(renderedComponent),
	      '%s.render(): A valid ReactComponent must be returned. You may have ' +
	        'returned undefined, an array or some other invalid object.',
	      this.getName() || 'ReactCompositeComponent'
	    ) : invariant(// TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false ||
	    ReactElement.isValidElement(renderedComponent)));
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function(ref, component) {
	    var inst = this.getPublicInstance();
	    var refs = inst.refs === emptyObject ? (inst.refs = {}) : inst.refs;
	    refs[ref] = component.getPublicInstance();
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function(ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function() {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return (
	      type.displayName || (constructor && constructor.displayName) ||
	      type.name || (constructor && constructor.name) ||
	      null
	    );
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by React.render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function() {
	    return this._instance;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	ReactPerf.measureMethods(
	  ReactCompositeComponentMixin,
	  'ReactCompositeComponent',
	  {
	    mountComponent: 'mountComponent',
	    updateComponent: 'updateComponent',
	    _renderValidatedComponent: '_renderValidatedComponent'
	  }
	);
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(9);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable environment dependent cleanup hook. (server vs.
	   * browser etc). Example: A browser system caches DOM nodes based on component
	   * ID and must remove that cache entry when this instance is unmounted.
	   */
	  unmountIDFromEnvironment: null,
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkupByID: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function(environment) {
	      ("production" !== process.env.NODE_ENV ? invariant(
	        !injected,
	        'ReactCompositeComponent: injectEnvironment() can only be called once.'
	      ) : invariant(!injected));
	      ReactComponentEnvironment.unmountIDFromEnvironment =
	        environment.unmountIDFromEnvironment;
	      ReactComponentEnvironment.replaceNodeWithMarkupByID =
	        environment.replaceNodeWithMarkupByID;
	      ReactComponentEnvironment.processChildrenUpdates =
	        environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var warning = __webpack_require__(17);
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  if (prevElement != null && nextElement != null) {
	    var prevType = typeof prevElement;
	    var nextType = typeof nextElement;
	    if (prevType === 'string' || prevType === 'number') {
	      return (nextType === 'string' || nextType === 'number');
	    } else {
	      if (nextType === 'object' &&
	          prevElement.type === nextElement.type &&
	          prevElement.key === nextElement.key) {
	        var ownersMatch = prevElement._owner === nextElement._owner;
	        var prevName = null;
	        var nextName = null;
	        var nextDisplayName = null;
	        if ("production" !== process.env.NODE_ENV) {
	          if (!ownersMatch) {
	            if (prevElement._owner != null &&
	                prevElement._owner.getPublicInstance() != null &&
	                prevElement._owner.getPublicInstance().constructor != null) {
	              prevName =
	                prevElement._owner.getPublicInstance().constructor.displayName;
	            }
	            if (nextElement._owner != null &&
	                nextElement._owner.getPublicInstance() != null &&
	                nextElement._owner.getPublicInstance().constructor != null) {
	              nextName =
	                nextElement._owner.getPublicInstance().constructor.displayName;
	            }
	            if (nextElement.type != null &&
	                nextElement.type.displayName != null) {
	              nextDisplayName = nextElement.type.displayName;
	            }
	            if (nextElement.type != null && typeof nextElement.type === 'string') {
	              nextDisplayName = nextElement.type;
	            }
	            if (typeof nextElement.type !== 'string' ||
	                nextElement.type === 'input' ||
	                nextElement.type === 'textarea') {
	              if ((prevElement._owner != null &&
	                  prevElement._owner._isOwnerNecessary === false) ||
	                  (nextElement._owner != null &&
	                  nextElement._owner._isOwnerNecessary === false)) {
	                if (prevElement._owner != null) {
	                  prevElement._owner._isOwnerNecessary = true;
	                }
	                if (nextElement._owner != null) {
	                  nextElement._owner._isOwnerNecessary = true;
	                }
	                ("production" !== process.env.NODE_ENV ? warning(
	                  false,
	                  '<%s /> is being rendered by both %s and %s using the same ' +
	                  'key (%s) in the same place. Currently, this means that ' +
	                  'they don\'t preserve state. This behavior should be very ' +
	                  'rare so we\'re considering deprecating it. Please contact ' +
	                  'the React team and explain your use case so that we can ' +
	                  'take that into consideration.',
	                  nextDisplayName || 'Unknown Component',
	                  prevName || '[Unknown]',
	                  nextName || '[Unknown]',
	                  prevElement.key
	                ) : null);
	              }
	            }
	          }
	        }
	        return ownersMatch;
	      }
	    }
	  }
	  return false;
	}
	
	module.exports = shouldUpdateReactComponent;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 * @typechecks static-only
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var CSSPropertyOperations = __webpack_require__(51);
	var DOMProperty = __webpack_require__(46);
	var DOMPropertyOperations = __webpack_require__(45);
	var ReactBrowserEventEmitter = __webpack_require__(70);
	var ReactComponentBrowserEnvironment =
	  __webpack_require__(49);
	var ReactMount = __webpack_require__(69);
	var ReactMultiChild = __webpack_require__(90);
	var ReactPerf = __webpack_require__(30);
	
	var assign = __webpack_require__(15);
	var escapeTextContentForBrowser = __webpack_require__(48);
	var invariant = __webpack_require__(9);
	var isEventSupported = __webpack_require__(77);
	var keyOf = __webpack_require__(41);
	var warning = __webpack_require__(17);
	
	var deleteListener = ReactBrowserEventEmitter.deleteListener;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = {'string': true, 'number': true};
	
	var STYLE = keyOf({style: null});
	
	var ELEMENT_NODE_TYPE = 1;
	
	/**
	 * Optionally injectable operations for mutating the DOM
	 */
	var BackendIDOperations = null;
	
	/**
	 * @param {?object} props
	 */
	function assertValidProps(props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (props.dangerouslySetInnerHTML != null) {
	    ("production" !== process.env.NODE_ENV ? invariant(
	      props.children == null,
	      'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'
	    ) : invariant(props.children == null));
	    ("production" !== process.env.NODE_ENV ? invariant(
	      typeof props.dangerouslySetInnerHTML === 'object' &&
	      '__html' in props.dangerouslySetInnerHTML,
	      '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' +
	      'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' +
	      'for more information.'
	    ) : invariant(typeof props.dangerouslySetInnerHTML === 'object' &&
	    '__html' in props.dangerouslySetInnerHTML));
	  }
	  if ("production" !== process.env.NODE_ENV) {
	    ("production" !== process.env.NODE_ENV ? warning(
	      props.innerHTML == null,
	      'Directly setting property `innerHTML` is not permitted. ' +
	      'For more information, lookup documentation on `dangerouslySetInnerHTML`.'
	    ) : null);
	    ("production" !== process.env.NODE_ENV ? warning(
	      !props.contentEditable || props.children == null,
	      'A component is `contentEditable` and contains `children` managed by ' +
	      'React. It is now your responsibility to guarantee that none of ' +
	      'those nodes are unexpectedly modified or duplicated. This is ' +
	      'probably not intentional.'
	    ) : null);
	  }
	  ("production" !== process.env.NODE_ENV ? invariant(
	    props.style == null || typeof props.style === 'object',
	    'The `style` prop expects a mapping from style properties to values, ' +
	    'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' +
	    'using JSX.'
	  ) : invariant(props.style == null || typeof props.style === 'object'));
	}
	
	function putListener(id, registrationName, listener, transaction) {
	  if ("production" !== process.env.NODE_ENV) {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    ("production" !== process.env.NODE_ENV ? warning(
	      registrationName !== 'onScroll' || isEventSupported('scroll', true),
	      'This browser doesn\'t support the `onScroll` event'
	    ) : null);
	  }
	  var container = ReactMount.findReactContainerForID(id);
	  if (container) {
	    var doc = container.nodeType === ELEMENT_NODE_TYPE ?
	      container.ownerDocument :
	      container;
	    listenTo(registrationName, doc);
	  }
	  transaction.getPutListenerQueue().enqueuePutListener(
	    id,
	    registrationName,
	    listener
	  );
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special cased tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	  // NOTE: menuitem's close tag should be omitted, but that causes problems.
	};
	
	// We accept any tag to be rendered but since this gets injected into abitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    ("production" !== process.env.NODE_ENV ? invariant(VALID_TAG_REGEX.test(tag), 'Invalid tag: %s', tag) : invariant(VALID_TAG_REGEX.test(tag)));
	    validatedTagCache[tag] = true;
	  }
	}
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(tag) {
	  validateDangerousTag(tag);
	  this._tag = tag;
	  this._renderedChildren = null;
	  this._previousStyleCopy = null;
	  this._rootNodeID = null;
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  construct: function(element) {
	    this._currentElement = element;
	  },
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {string} rootID The root DOM ID for this node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} The computed markup.
	   */
	  mountComponent: function(rootID, transaction, context) {
	    this._rootNodeID = rootID;
	    assertValidProps(this._currentElement.props);
	    var closeTag = omittedCloseTags[this._tag] ? '' : '</' + this._tag + '>';
	    return (
	      this._createOpenTagMarkupAndPutListeners(transaction) +
	      this._createContentMarkup(transaction, context) +
	      closeTag
	    );
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function(transaction) {
	    var props = this._currentElement.props;
	    var ret = '<' + this._tag;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        putListener(this._rootNodeID, propKey, propValue, transaction);
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            propValue = this._previousStyleCopy = assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
	        }
	        var markup =
	          DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret + '>';
	    }
	
	    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
	    return ret + ' ' + markupForID + '>';
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function(transaction, context) {
	    var prefix = '';
	    if (this._tag === 'listing' ||
	        this._tag === 'pre' ||
	        this._tag === 'textarea') {
	      // Add an initial newline because browsers ignore the first newline in
	      // a <listing>, <pre>, or <textarea> as an "authoring convenience" -- see
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody.
	      prefix = '\n';
	    }
	
	    var props = this._currentElement.props;
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        return prefix + innerHTML.__html;
	      }
	    } else {
	      var contentToUse =
	        CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        return prefix + escapeTextContentForBrowser(contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(
	          childrenToUse,
	          transaction,
	          context
	        );
	        return prefix + mountImages.join('');
	      }
	    }
	    return prefix;
	  },
	
	  receiveComponent: function(nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a native DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function(transaction, prevElement, nextElement, context) {
	    assertValidProps(this._currentElement.props);
	    this._updateDOMProperties(prevElement.props, transaction);
	    this._updateDOMChildren(prevElement.props, transaction, context);
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {ReactReconcileTransaction} transaction
	   */
	  _updateDOMProperties: function(lastProps, transaction) {
	    var nextProps = this._currentElement.props;
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) ||
	         !lastProps.hasOwnProperty(propKey)) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        deleteListener(this._rootNodeID, propKey);
	      } else if (
	          DOMProperty.isStandardName[propKey] ||
	          DOMProperty.isCustomAttribute(propKey)) {
	        BackendIDOperations.deletePropertyByID(
	          this._rootNodeID,
	          propKey
	        );
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ?
	        this._previousStyleCopy :
	        lastProps[propKey];
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          nextProp = this._previousStyleCopy = assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) &&
	                (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) &&
	                lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        putListener(this._rootNodeID, propKey, nextProp, transaction);
	      } else if (
	          DOMProperty.isStandardName[propKey] ||
	          DOMProperty.isCustomAttribute(propKey)) {
	        BackendIDOperations.updatePropertyByID(
	          this._rootNodeID,
	          propKey,
	          nextProp
	        );
	      }
	    }
	    if (styleUpdates) {
	      BackendIDOperations.updateStylesByID(
	        this._rootNodeID,
	        styleUpdates
	      );
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {ReactReconcileTransaction} transaction
	   */
	  _updateDOMChildren: function(lastProps, transaction, context) {
	    var nextProps = this._currentElement.props;
	
	    var lastContent =
	      CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent =
	      CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
	
	    var lastHtml =
	      lastProps.dangerouslySetInnerHTML &&
	      lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml =
	      nextProps.dangerouslySetInnerHTML &&
	      nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        BackendIDOperations.updateInnerHTMLByID(
	          this._rootNodeID,
	          nextHtml
	        );
	      }
	    } else if (nextChildren != null) {
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function() {
	    this.unmountChildren();
	    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	    this._rootNodeID = null;
	  }
	
	};
	
	ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent'
	});
	
	assign(
	  ReactDOMComponent.prototype,
	  ReactDOMComponent.Mixin,
	  ReactMultiChild.Mixin
	);
	
	ReactDOMComponent.injection = {
	  injectIDOperations: function(IDOperations) {
	    ReactDOMComponent.BackendIDOperations = BackendIDOperations = IDOperations;
	  }
	};
	
	module.exports = ReactDOMComponent;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactComponentEnvironment = __webpack_require__(87);
	var ReactMultiChildUpdateTypes = __webpack_require__(66);
	
	var ReactReconciler = __webpack_require__(31);
	var ReactChildReconciler = __webpack_require__(91);
	
	/**
	 * Updating children of a component may trigger recursive updates. The depth is
	 * used to batch recursive updates to render markup more efficiently.
	 *
	 * @type {number}
	 * @private
	 */
	var updateDepth = 0;
	
	/**
	 * Queue of update configuration objects.
	 *
	 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
	 *
	 * @type {array<object>}
	 * @private
	 */
	var updateQueue = [];
	
	/**
	 * Queue of markup to be rendered.
	 *
	 * @type {array<string>}
	 * @private
	 */
	var markupQueue = [];
	
	/**
	 * Enqueues markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function enqueueMarkup(parentID, markup, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    markupIndex: markupQueue.push(markup) - 1,
	    textContent: null,
	    fromIndex: null,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues moving an existing element to another index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function enqueueMove(parentID, fromIndex, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    markupIndex: null,
	    textContent: null,
	    fromIndex: fromIndex,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues removing an element at an index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function enqueueRemove(parentID, fromIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    markupIndex: null,
	    textContent: null,
	    fromIndex: fromIndex,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the text content.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function enqueueTextContent(parentID, textContent) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    markupIndex: null,
	    textContent: textContent,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue() {
	  if (updateQueue.length) {
	    ReactComponentEnvironment.processChildrenUpdates(
	      updateQueue,
	      markupQueue
	    );
	    clearQueue();
	  }
	}
	
	/**
	 * Clears any enqueued updates.
	 *
	 * @private
	 */
	function clearQueue() {
	  updateQueue.length = 0;
	  markupQueue.length = 0;
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function(nestedChildren, transaction, context) {
	      var children = ReactChildReconciler.instantiateChildren(
	        nestedChildren, transaction, context
	      );
	      this._renderedChildren = children;
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	          var rootID = this._rootNodeID + name;
	          var mountImage = ReactReconciler.mountComponent(
	            child,
	            rootID,
	            transaction,
	            context
	          );
	          child._mountIndex = index;
	          mountImages.push(mountImage);
	          index++;
	        }
	      }
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function(nextContent) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        // TODO: The setTextContent operation should be enough
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChildByName(prevChildren[name], name);
	          }
	        }
	        // Set new text content.
	        this.setTextContent(nextContent);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildren Nested child maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function(nextNestedChildren, transaction, context) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        this._updateChildren(nextNestedChildren, transaction, context);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	
	      }
	    },
	
	    /**
	     * Improve performance by isolating this hot code path from the try/catch
	     * block in `updateChildren`.
	     *
	     * @param {?object} nextNestedChildren Nested child maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function(nextNestedChildren, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var nextChildren = ReactChildReconciler.updateChildren(
	        prevChildren, nextNestedChildren, transaction, context
	      );
	      this._renderedChildren = nextChildren;
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var lastIndex = 0;
	      var nextIndex = 0;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          this.moveChild(prevChild, nextIndex, lastIndex);
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            this._unmountChildByName(prevChild, name);
	          }
	          // The child must be instantiated before it's mounted.
	          this._mountChildByNameAtIndex(
	            nextChild, name, nextIndex, transaction, context
	          );
	        }
	        nextIndex++;
	      }
	      // Remove children that are no longer present.
	      for (name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name) &&
	            !(nextChildren && nextChildren.hasOwnProperty(name))) {
	          this._unmountChildByName(prevChildren[name], name);
	        }
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted.
	     *
	     * @internal
	     */
	    unmountChildren: function() {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function(child, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function(child, mountImage) {
	      enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function(child) {
	      enqueueRemove(this._rootNodeID, child._mountIndex);
	    },
	
	    /**
	     * Sets this text content string.
	     *
	     * @param {string} textContent Text content to set.
	     * @protected
	     */
	    setTextContent: function(textContent) {
	      enqueueTextContent(this._rootNodeID, textContent);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildByNameAtIndex: function(
	      child,
	      name,
	      index,
	      transaction,
	      context) {
	      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	      var rootID = this._rootNodeID + name;
	      var mountImage = ReactReconciler.mountComponent(
	        child,
	        rootID,
	        transaction,
	        context
	      );
	      child._mountIndex = index;
	      this.createChild(child, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child by name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @param {string} name Name of the child in `this._renderedChildren`.
	     * @private
	     */
	    _unmountChildByName: function(child, name) {
	      this.removeChild(child);
	      child._mountIndex = null;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(31);
	
	var flattenChildren = __webpack_require__(92);
	var instantiateReactComponent = __webpack_require__(85);
	var shouldUpdateReactComponent = __webpack_require__(88);
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function(nestedChildNodes, transaction, context) {
	    var children = flattenChildren(nestedChildNodes);
	    for (var name in children) {
	      if (children.hasOwnProperty(name)) {
	        var child = children[name];
	        // The rendered children must be turned into instances as they're
	        // mounted.
	        var childInstance = instantiateReactComponent(child, null);
	        children[name] = childInstance;
	      }
	    }
	    return children;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextNestedChildNodes Nested child maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function(
	    prevChildren,
	    nextNestedChildNodes,
	    transaction,
	    context) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    var nextChildren = flattenChildren(nextNestedChildNodes);
	    if (!nextChildren && !prevChildren) {
	      return null;
	    }
	    var name;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      var prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(
	          prevChild, nextElement, transaction, context
	        );
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          ReactReconciler.unmountComponent(prevChild, name);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(
	          nextElement,
	          null
	        );
	        nextChildren[name] = nextChildInstance;
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) &&
	          !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        ReactReconciler.unmountComponent(prevChildren[name]);
	      }
	    }
	    return nextChildren;
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function(renderedChildren) {
	    for (var name in renderedChildren) {
	      var renderedChild = renderedChildren[name];
	      ReactReconciler.unmountComponent(renderedChild);
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 */
	
	'use strict';
	
	var traverseAllChildren = __webpack_require__(20);
	var warning = __webpack_require__(17);
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name) {
	  // We found a component instance.
	  var result = traverseContext;
	  var keyUnique = !result.hasOwnProperty(name);
	  if ("production" !== process.env.NODE_ENV) {
	    ("production" !== process.env.NODE_ENV ? warning(
	      keyUnique,
	      'flattenChildren(...): Encountered two children with the same key, ' +
	      '`%s`. Child keys must be unique; when two children share a key, only ' +
	      'the first child will be used.',
	      name
	    ) : null);
	  }
	  if (keyUnique && child != null) {
	    result[name] = child;
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	  traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  return result;
	}
	
	module.exports = flattenChildren;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(94);
	var ChangeEventPlugin = __webpack_require__(102);
	var ClientReactRootIndex = __webpack_require__(104);
	var DefaultEventPluginOrder = __webpack_require__(105);
	var EnterLeaveEventPlugin = __webpack_require__(106);
	var ExecutionEnvironment = __webpack_require__(53);
	var HTMLDOMPropertyConfig = __webpack_require__(110);
	var MobileSafariClickEventPlugin = __webpack_require__(111);
	var ReactBrowserComponentMixin = __webpack_require__(112);
	var ReactClass = __webpack_require__(39);
	var ReactComponentBrowserEnvironment =
	  __webpack_require__(49);
	var ReactDefaultBatchingStrategy = __webpack_require__(114);
	var ReactDOMComponent = __webpack_require__(89);
	var ReactDOMButton = __webpack_require__(115);
	var ReactDOMForm = __webpack_require__(118);
	var ReactDOMImg = __webpack_require__(120);
	var ReactDOMIDOperations = __webpack_require__(50);
	var ReactDOMIframe = __webpack_require__(121);
	var ReactDOMInput = __webpack_require__(122);
	var ReactDOMOption = __webpack_require__(125);
	var ReactDOMSelect = __webpack_require__(126);
	var ReactDOMTextarea = __webpack_require__(127);
	var ReactDOMTextComponent = __webpack_require__(44);
	var ReactElement = __webpack_require__(13);
	var ReactEventListener = __webpack_require__(128);
	var ReactInjection = __webpack_require__(131);
	var ReactInstanceHandles = __webpack_require__(21);
	var ReactMount = __webpack_require__(69);
	var ReactReconcileTransaction = __webpack_require__(132);
	var SelectEventPlugin = __webpack_require__(138);
	var ServerReactRootIndex = __webpack_require__(140);
	var SimpleEventPlugin = __webpack_require__(141);
	var SVGDOMPropertyConfig = __webpack_require__(150);
	
	var createFullPageComponent = __webpack_require__(151);
	
	function autoGenerateWrapperClass(type) {
	  return ReactClass.createClass({
	    tagName: type.toUpperCase(),
	    render: function() {
	      return new ReactElement(
	        type,
	        null,
	        null,
	        null,
	        null,
	        this.props
	      );
	    }
	  });
	}
	
	function inject() {
	  ReactInjection.EventEmitter.injectReactEventListener(
	    ReactEventListener
	  );
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
	  ReactInjection.EventPluginHub.injectMount(ReactMount);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    MobileSafariClickEventPlugin: MobileSafariClickEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.NativeComponent.injectGenericComponentClass(
	    ReactDOMComponent
	  );
	
	  ReactInjection.NativeComponent.injectTextComponentClass(
	    ReactDOMTextComponent
	  );
	
	  ReactInjection.NativeComponent.injectAutoWrapper(
	    autoGenerateWrapperClass
	  );
	
	  // This needs to happen before createFullPageComponent() otherwise the mixin
	  // won't be included.
	  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);
	
	  ReactInjection.NativeComponent.injectComponentClasses({
	    'button': ReactDOMButton,
	    'form': ReactDOMForm,
	    'iframe': ReactDOMIframe,
	    'img': ReactDOMImg,
	    'input': ReactDOMInput,
	    'option': ReactDOMOption,
	    'select': ReactDOMSelect,
	    'textarea': ReactDOMTextarea,
	
	    'html': createFullPageComponent('html'),
	    'head': createFullPageComponent('head'),
	    'body': createFullPageComponent('body')
	  });
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
	
	  ReactInjection.Updates.injectReconcileTransaction(
	    ReactReconcileTransaction
	  );
	  ReactInjection.Updates.injectBatchingStrategy(
	    ReactDefaultBatchingStrategy
	  );
	
	  ReactInjection.RootIndex.injectCreateReactRootIndex(
	    ExecutionEnvironment.canUseDOM ?
	      ClientReactRootIndex.createReactRootIndex :
	      ServerReactRootIndex.createReactRootIndex
	  );
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	  ReactInjection.DOMComponent.injectIDOperations(ReactDOMIDOperations);
	
	  if ("production" !== process.env.NODE_ENV) {
	    var url = (ExecutionEnvironment.canUseDOM && window.location.href) || '';
	    if ((/[?&]react_perf\b/).test(url)) {
	      var ReactDefaultPerf = __webpack_require__(152);
	      ReactDefaultPerf.start();
	    }
	  }
	}
	
	module.exports = {
	  inject: inject
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015 Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(7);
	var EventPropagators = __webpack_require__(95);
	var ExecutionEnvironment = __webpack_require__(53);
	var FallbackCompositionState = __webpack_require__(96);
	var SyntheticCompositionEvent = __webpack_require__(98);
	var SyntheticInputEvent = __webpack_require__(101);
	
	var keyOf = __webpack_require__(41);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = (
	  ExecutionEnvironment.canUseDOM &&
	  'CompositionEvent' in window
	);
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = (
	  ExecutionEnvironment.canUseDOM &&
	  'TextEvent' in window &&
	  !documentMode &&
	  !isPresto()
	);
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = (
	  ExecutionEnvironment.canUseDOM &&
	  (
	    (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11)
	  )
	);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return (
	    typeof opera === 'object' &&
	    typeof opera.version === 'function' &&
	    parseInt(opera.version(), 10) <= 12
	  );
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onBeforeInput: null}),
	      captured: keyOf({onBeforeInputCapture: null})
	    },
	    dependencies: [
	      topLevelTypes.topCompositionEnd,
	      topLevelTypes.topKeyPress,
	      topLevelTypes.topTextInput,
	      topLevelTypes.topPaste
	    ]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onCompositionEnd: null}),
	      captured: keyOf({onCompositionEndCapture: null})
	    },
	    dependencies: [
	      topLevelTypes.topBlur,
	      topLevelTypes.topCompositionEnd,
	      topLevelTypes.topKeyDown,
	      topLevelTypes.topKeyPress,
	      topLevelTypes.topKeyUp,
	      topLevelTypes.topMouseDown
	    ]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onCompositionStart: null}),
	      captured: keyOf({onCompositionStartCapture: null})
	    },
	    dependencies: [
	      topLevelTypes.topBlur,
	      topLevelTypes.topCompositionStart,
	      topLevelTypes.topKeyDown,
	      topLevelTypes.topKeyPress,
	      topLevelTypes.topKeyUp,
	      topLevelTypes.topMouseDown
	    ]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onCompositionUpdate: null}),
	      captured: keyOf({onCompositionUpdateCapture: null})
	    },
	    dependencies: [
	      topLevelTypes.topBlur,
	      topLevelTypes.topCompositionUpdate,
	      topLevelTypes.topKeyDown,
	      topLevelTypes.topKeyPress,
	      topLevelTypes.topKeyUp,
	      topLevelTypes.topMouseDown
	    ]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (
	    (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	    // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	    !(nativeEvent.ctrlKey && nativeEvent.altKey)
	  );
	}
	
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return (
	    topLevelType === topLevelTypes.topKeyDown &&
	    nativeEvent.keyCode === START_KEYCODE
	  );
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return (END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1);
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return (nativeEvent.keyCode !== START_KEYCODE);
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(
	  topLevelType,
	  topLevelTarget,
	  topLevelTargetID,
	  nativeEvent
	) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(
	    eventType,
	    topLevelTargetID,
	    nativeEvent
	  );
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (
	      topLevelType === topLevelTypes.topCompositionEnd ||
	      isFallbackCompositionEnd(topLevelType, nativeEvent)
	    ) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(
	  topLevelType,
	  topLevelTarget,
	  topLevelTargetID,
	  nativeEvent
	) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(
	    eventTypes.beforeInput,
	    topLevelTargetID,
	    nativeEvent
	  );
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function(
	    topLevelType,
	    topLevelTarget,
	    topLevelTargetID,
	    nativeEvent
	  ) {
	    return [
	      extractCompositionEvent(
	        topLevelType,
	        topLevelTarget,
	        topLevelTargetID,
	        nativeEvent
	      ),
	      extractBeforeInputEvent(
	        topLevelType,
	        topLevelTarget,
	        topLevelTargetID,
	        nativeEvent
	      )
	    ];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(7);
	var EventPluginHub = __webpack_require__(71);
	
	var accumulateInto = __webpack_require__(73);
	var forEachAccumulated = __webpack_require__(74);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(id, event, propagationPhase) {
	  var registrationName =
	    event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(id, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(domID, upwards, event) {
	  if ("production" !== process.env.NODE_ENV) {
	    if (!domID) {
	      throw new Error('Dispatching id must not be null');
	    }
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(domID, event, phase);
	  if (listener) {
	    event._dispatchListeners =
	      accumulateInto(event._dispatchListeners, listener);
	    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We can not perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(
	      event.dispatchMarker,
	      accumulateDirectionalDispatches,
	      event
	    );
	  }
	}
	
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(id, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(id, registrationName);
	    if (listener) {
	      event._dispatchListeners =
	        accumulateInto(event._dispatchListeners, listener);
	      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event.dispatchMarker, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
	  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(
	    fromID,
	    toID,
	    accumulateDispatches,
	    leave,
	    enter
	  );
	}
	
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(11);
	
	var assign = __webpack_require__(15);
	var getTextContentAccessor = __webpack_require__(97);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	assign(FallbackCompositionState.prototype, {
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function() {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function() {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(53);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ?
	      'textContent' :
	      'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(99);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(
	  dispatchConfig,
	  dispatchMarker,
	  nativeEvent) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
	}
	
	SyntheticEvent.augmentClass(
	  SyntheticCompositionEvent,
	  CompositionEventInterface
	);
	
	module.exports = SyntheticCompositionEvent;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(11);
	
	var assign = __webpack_require__(15);
	var emptyFunction = __webpack_require__(18);
	var getEventTarget = __webpack_require__(100);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: getEventTarget,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function(event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 */
	function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
	  this.dispatchConfig = dispatchConfig;
	  this.dispatchMarker = dispatchMarker;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      this[propName] = nativeEvent[propName];
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ?
	    nativeEvent.defaultPrevented :
	    nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	}
	
	assign(SyntheticEvent.prototype, {
	
	  preventDefault: function() {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function() {
	    var event = this.nativeEvent;
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else {
	      event.cancelBubble = true;
	    }
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function() {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function() {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      this[propName] = null;
	    }
	    this.dispatchConfig = null;
	    this.dispatchMarker = null;
	    this.nativeEvent = null;
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function(Class, Interface) {
	  var Super = this;
	
	  var prototype = Object.create(Super.prototype);
	  assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);
	
	module.exports = SyntheticEvent;


/***/ },
/* 100 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(99);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(
	  dispatchConfig,
	  dispatchMarker,
	  nativeEvent) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
	}
	
	SyntheticEvent.augmentClass(
	  SyntheticInputEvent,
	  InputEventInterface
	);
	
	module.exports = SyntheticInputEvent;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(7);
	var EventPluginHub = __webpack_require__(71);
	var EventPropagators = __webpack_require__(95);
	var ExecutionEnvironment = __webpack_require__(53);
	var ReactUpdates = __webpack_require__(28);
	var SyntheticEvent = __webpack_require__(99);
	
	var isEventSupported = __webpack_require__(77);
	var isTextInputElement = __webpack_require__(103);
	var keyOf = __webpack_require__(41);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onChange: null}),
	      captured: keyOf({onChangeCapture: null})
	    },
	    dependencies: [
	      topLevelTypes.topBlur,
	      topLevelTypes.topChange,
	      topLevelTypes.topClick,
	      topLevelTypes.topFocus,
	      topLevelTypes.topInput,
	      topLevelTypes.topKeyDown,
	      topLevelTypes.topKeyUp,
	      topLevelTypes.topSelectionChange
	    ]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementID = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  return (
	    elem.nodeName === 'SELECT' ||
	    (elem.nodeName === 'INPUT' && elem.type === 'file')
	  );
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (
	    (!('documentMode' in document) || document.documentMode > 8)
	  );
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(
	    eventTypes.change,
	    activeElementID,
	    nativeEvent
	  );
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue();
	}
	
	function startWatchingForChangeEventIE8(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementID = null;
	}
	
	function getTargetIDForChangeEvent(
	    topLevelType,
	    topLevelTarget,
	    topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return topLevelTargetID;
	  }
	}
	function handleEventsForChangeEventIE8(
	    topLevelType,
	    topLevelTarget,
	    topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events
	  isInputEventSupported = isEventSupported('input') && (
	    (!('documentMode' in document) || document.documentMode > 9)
	  );
	}
	
	/**
	 * (For old IE.) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp =  {
	  get: function() {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function(val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For old IE.) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(
	    target.constructor.prototype,
	    'value'
	  );
	
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}
	
	/**
	 * (For old IE.) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);
	
	  activeElement = null;
	  activeElementID = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For old IE.) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetIDForInputEvent(
	    topLevelType,
	    topLevelTarget,
	    topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return topLevelTargetID;
	  }
	}
	
	// For IE8 and IE9.
	function handleEventsForInputEventIE(
	    topLevelType,
	    topLevelTarget,
	    topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetIDForInputEventIE(
	    topLevelType,
	    topLevelTarget,
	    topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topSelectionChange ||
	      topLevelType === topLevelTypes.topKeyUp ||
	      topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementID;
	    }
	  }
	}
	
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return (
	    elem.nodeName === 'INPUT' &&
	    (elem.type === 'checkbox' || elem.type === 'radio')
	  );
	}
	
	function getTargetIDForClickEvent(
	    topLevelType,
	    topLevelTarget,
	    topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return topLevelTargetID;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function(
	      topLevelType,
	      topLevelTarget,
	      topLevelTargetID,
	      nativeEvent) {
	
	    var getTargetIDFunc, handleEventFunc;
	    if (shouldUseChangeEvent(topLevelTarget)) {
	      if (doesChangeEventBubble) {
	        getTargetIDFunc = getTargetIDForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(topLevelTarget)) {
	      if (isInputEventSupported) {
	        getTargetIDFunc = getTargetIDForInputEvent;
	      } else {
	        getTargetIDFunc = getTargetIDForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(topLevelTarget)) {
	      getTargetIDFunc = getTargetIDForClickEvent;
	    }
	
	    if (getTargetIDFunc) {
	      var targetID = getTargetIDFunc(
	        topLevelType,
	        topLevelTarget,
	        topLevelTargetID
	      );
	      if (targetID) {
	        var event = SyntheticEvent.getPooled(
	          eventTypes.change,
	          targetID,
	          nativeEvent
	        );
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(
	        topLevelType,
	        topLevelTarget,
	        topLevelTargetID
	      );
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;


/***/ },
/* 103 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  return elem && (
	    (elem.nodeName === 'INPUT' && supportedInputTypes[elem.type] || elem.nodeName === 'TEXTAREA')
	  );
	}
	
	module.exports = isTextInputElement;


/***/ },
/* 104 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ClientReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var nextReactRootIndex = 0;
	
	var ClientReactRootIndex = {
	  createReactRootIndex: function() {
	    return nextReactRootIndex++;
	  }
	};
	
	module.exports = ClientReactRootIndex;


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(41);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [
	  keyOf({ResponderEventPlugin: null}),
	  keyOf({SimpleEventPlugin: null}),
	  keyOf({TapEventPlugin: null}),
	  keyOf({EnterLeaveEventPlugin: null}),
	  keyOf({ChangeEventPlugin: null}),
	  keyOf({SelectEventPlugin: null}),
	  keyOf({BeforeInputEventPlugin: null}),
	  keyOf({AnalyticsEventPlugin: null}),
	  keyOf({MobileSafariClickEventPlugin: null})
	];
	
	module.exports = DefaultEventPluginOrder;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(7);
	var EventPropagators = __webpack_require__(95);
	var SyntheticMouseEvent = __webpack_require__(107);
	
	var ReactMount = __webpack_require__(69);
	var keyOf = __webpack_require__(41);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	var getFirstReactDOM = ReactMount.getFirstReactDOM;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({onMouseEnter: null}),
	    dependencies: [
	      topLevelTypes.topMouseOut,
	      topLevelTypes.topMouseOver
	    ]
	  },
	  mouseLeave: {
	    registrationName: keyOf({onMouseLeave: null}),
	    dependencies: [
	      topLevelTypes.topMouseOut,
	      topLevelTypes.topMouseOver
	    ]
	  }
	};
	
	var extractedEvents = [null, null];
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function(
	      topLevelType,
	      topLevelTarget,
	      topLevelTargetID,
	      nativeEvent) {
	    if (topLevelType === topLevelTypes.topMouseOver &&
	        (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut &&
	        topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (topLevelTarget.window === topLevelTarget) {
	      // `topLevelTarget` is probably a window object.
	      win = topLevelTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = topLevelTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from, to;
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = topLevelTarget;
	      to =
	        getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) ||
	        win;
	    } else {
	      from = win;
	      to = topLevelTarget;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var fromID = from ? ReactMount.getID(from) : '';
	    var toID = to ? ReactMount.getID(to) : '';
	
	    var leave = SyntheticMouseEvent.getPooled(
	      eventTypes.mouseLeave,
	      fromID,
	      nativeEvent
	    );
	    leave.type = 'mouseleave';
	    leave.target = from;
	    leave.relatedTarget = to;
	
	    var enter = SyntheticMouseEvent.getPooled(
	      eventTypes.mouseEnter,
	      toID,
	      nativeEvent
	    );
	    enter.type = 'mouseenter';
	    enter.target = to;
	    enter.relatedTarget = from;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
	
	    extractedEvents[0] = leave;
	    extractedEvents[1] = enter;
	
	    return extractedEvents;
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(108);
	var ViewportMetrics = __webpack_require__(76);
	
	var getEventModifierState = __webpack_require__(109);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function(event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function(event) {
	    return event.relatedTarget || (
	      ((event.fromElement === event.srcElement ? event.toElement : event.fromElement))
	    );
	  },
	  // "Proprietary" Interface.
	  pageX: function(event) {
	    return 'pageX' in event ?
	      event.pageX :
	      event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function(event) {
	    return 'pageY' in event ?
	      event.pageY :
	      event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(99);
	
	var getEventTarget = __webpack_require__(100);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function(event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target != null && target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function(event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;


/***/ },
/* 109 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  /*jshint validthis:true */
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	/*jslint bitwise: true*/
	
	'use strict';
	
	var DOMProperty = __webpack_require__(46);
	var ExecutionEnvironment = __webpack_require__(53);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE =
	  DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE =
	  DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var hasSVG;
	if (ExecutionEnvironment.canUseDOM) {
	  var implementation = document.implementation;
	  hasSVG = (
	    implementation &&
	    implementation.hasFeature &&
	    implementation.hasFeature(
	      'http://www.w3.org/TR/SVG11/feature#BasicStructure',
	      '1.1'
	    )
	  );
	}
	
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(
	    /^(data|aria)-[a-z_][a-z\d_.\-]*$/
	  ),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: null,
	    acceptCharset: null,
	    accessKey: null,
	    action: null,
	    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    allowTransparency: MUST_USE_ATTRIBUTE,
	    alt: null,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: null,
	    // autoFocus is polyfilled/normalized by AutoFocusMixin
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    cellPadding: null,
	    cellSpacing: null,
	    charSet: MUST_USE_ATTRIBUTE,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    classID: MUST_USE_ATTRIBUTE,
	    // To set className on SVG elements, it's necessary to use .setAttribute;
	    // this works on HTML elements too in all browsers except IE8. Conveniently,
	    // IE8 doesn't support SVG and so we can simply use the attribute in
	    // browsers that support SVG and the property in browsers that don't,
	    // regardless of whether the element is HTML or SVG.
	    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
	    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: null,
	    content: null,
	    contentEditable: null,
	    contextMenu: MUST_USE_ATTRIBUTE,
	    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    coords: null,
	    crossOrigin: null,
	    data: null, // For `<object />` acts as `src`.
	    dateTime: MUST_USE_ATTRIBUTE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: null,
	    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: null,
	    encType: null,
	    form: MUST_USE_ATTRIBUTE,
	    formAction: MUST_USE_ATTRIBUTE,
	    formEncType: MUST_USE_ATTRIBUTE,
	    formMethod: MUST_USE_ATTRIBUTE,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: MUST_USE_ATTRIBUTE,
	    frameBorder: MUST_USE_ATTRIBUTE,
	    headers: null,
	    height: MUST_USE_ATTRIBUTE,
	    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    high: null,
	    href: null,
	    hrefLang: null,
	    htmlFor: null,
	    httpEquiv: null,
	    icon: null,
	    id: MUST_USE_PROPERTY,
	    label: null,
	    lang: null,
	    list: MUST_USE_ATTRIBUTE,
	    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    low: null,
	    manifest: MUST_USE_ATTRIBUTE,
	    marginHeight: null,
	    marginWidth: null,
	    max: null,
	    maxLength: MUST_USE_ATTRIBUTE,
	    media: MUST_USE_ATTRIBUTE,
	    mediaGroup: null,
	    method: null,
	    min: null,
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: null,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: null,
	    pattern: null,
	    placeholder: null,
	    poster: null,
	    preload: null,
	    radioGroup: null,
	    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    rel: null,
	    required: HAS_BOOLEAN_VALUE,
	    role: MUST_USE_ATTRIBUTE,
	    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: null,
	    sandbox: null,
	    scope: null,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: null,
	    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: null,
	    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: MUST_USE_ATTRIBUTE,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: null,
	    src: null,
	    srcDoc: MUST_USE_PROPERTY,
	    srcSet: MUST_USE_ATTRIBUTE,
	    start: HAS_NUMERIC_VALUE,
	    step: null,
	    style: null,
	    tabIndex: null,
	    target: null,
	    title: null,
	    type: null,
	    useMap: null,
	    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
	    width: MUST_USE_ATTRIBUTE,
	    wmode: MUST_USE_ATTRIBUTE,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: null,
	    autoCorrect: null,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: MUST_USE_ATTRIBUTE,
	    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    itemType: MUST_USE_ATTRIBUTE,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: MUST_USE_ATTRIBUTE,
	    itemRef: MUST_USE_ATTRIBUTE,
	    // property is supported for OpenGraph in meta tags.
	    property: null,
	    // IE-only attribute that controls focus behavior
	    unselectable: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {
	    autoCapitalize: 'autocapitalize',
	    autoComplete: 'autocomplete',
	    autoCorrect: 'autocorrect',
	    autoFocus: 'autofocus',
	    autoPlay: 'autoplay',
	    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
	    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
	    encType: 'encoding',
	    hrefLang: 'hreflang',
	    radioGroup: 'radiogroup',
	    spellCheck: 'spellcheck',
	    srcDoc: 'srcdoc',
	    srcSet: 'srcset'
	  }
	};
	
	module.exports = HTMLDOMPropertyConfig;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule MobileSafariClickEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(7);
	
	var emptyFunction = __webpack_require__(18);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	/**
	 * Mobile Safari does not fire properly bubble click events on non-interactive
	 * elements, which means delegated click listeners do not fire. The workaround
	 * for this bug involves attaching an empty click listener on the target node.
	 *
	 * This particular plugin works around the bug by attaching an empty click
	 * listener on `touchstart` (which does fire on every element).
	 */
	var MobileSafariClickEventPlugin = {
	
	  eventTypes: null,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function(
	      topLevelType,
	      topLevelTarget,
	      topLevelTargetID,
	      nativeEvent) {
	    if (topLevelType === topLevelTypes.topTouchStart) {
	      var target = nativeEvent.target;
	      if (target && !target.onclick) {
	        target.onclick = emptyFunction;
	      }
	    }
	  }
	
	};
	
	module.exports = MobileSafariClickEventPlugin;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserComponentMixin
	 */
	
	'use strict';
	
	var findDOMNode = __webpack_require__(113);
	
	var ReactBrowserComponentMixin = {
	  /**
	   * Returns the DOM node rendered by this component.
	   *
	   * @return {DOMElement} The root node of this component.
	   * @final
	   * @protected
	   */
	  getDOMNode: function() {
	    return findDOMNode(this);
	  }
	};
	
	module.exports = ReactBrowserComponentMixin;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactInstanceMap = __webpack_require__(27);
	var ReactMount = __webpack_require__(69);
	
	var invariant = __webpack_require__(9);
	var isNode = __webpack_require__(83);
	var warning = __webpack_require__(17);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if ("production" !== process.env.NODE_ENV) {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      ("production" !== process.env.NODE_ENV ? warning(
	        owner._warnedAboutRefsInRender,
	        '%s is accessing getDOMNode or findDOMNode inside its render(). ' +
	        'render() should be a pure function of props and state. It should ' +
	        'never access something that requires stale data from the previous ' +
	        'render, such as refs. Move this logic to componentDidMount and ' +
	        'componentDidUpdate instead.',
	        owner.getName() || 'A component'
	      ) : null);
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (isNode(componentOrElement)) {
	    return componentOrElement;
	  }
	  if (ReactInstanceMap.has(componentOrElement)) {
	    return ReactMount.getNodeFromInstance(componentOrElement);
	  }
	  ("production" !== process.env.NODE_ENV ? invariant(
	    componentOrElement.render == null ||
	    typeof componentOrElement.render !== 'function',
	    'Component (with keys: %s) contains `render` method ' +
	    'but is not mounted in the DOM',
	    Object.keys(componentOrElement)
	  ) : invariant(componentOrElement.render == null ||
	  typeof componentOrElement.render !== 'function'));
	  ("production" !== process.env.NODE_ENV ? invariant(
	    false,
	    'Element appears to be neither ReactComponent nor DOMNode (keys: %s)',
	    Object.keys(componentOrElement)
	  ) : invariant(false));
	}
	
	module.exports = findDOMNode;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var ReactUpdates = __webpack_require__(28);
	var Transaction = __webpack_require__(38);
	
	var assign = __webpack_require__(15);
	var emptyFunction = __webpack_require__(18);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function() {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	assign(
	  ReactDefaultBatchingStrategyTransaction.prototype,
	  Transaction.Mixin,
	  {
	    getTransactionWrappers: function() {
	      return TRANSACTION_WRAPPERS;
	    }
	  }
	);
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function(callback, a, b, c, d) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d);
	    } else {
	      transaction.perform(callback, null, a, b, c, d);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var AutoFocusMixin = __webpack_require__(116);
	var ReactBrowserComponentMixin = __webpack_require__(112);
	var ReactClass = __webpack_require__(39);
	var ReactElement = __webpack_require__(13);
	
	var keyMirror = __webpack_require__(8);
	
	var button = ReactElement.createFactory('button');
	
	var mouseListenerNames = keyMirror({
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	});
	
	/**
	 * Implements a <button> native component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = ReactClass.createClass({
	  displayName: 'ReactDOMButton',
	  tagName: 'BUTTON',
	
	  mixins: [AutoFocusMixin, ReactBrowserComponentMixin],
	
	  render: function() {
	    var props = {};
	
	    // Copy the props; except the mouse listeners if we're disabled
	    for (var key in this.props) {
	      if (this.props.hasOwnProperty(key) &&
	          (!this.props.disabled || !mouseListenerNames[key])) {
	        props[key] = this.props[key];
	      }
	    }
	
	    return button(props, this.props.children);
	  }
	
	});
	
	module.exports = ReactDOMButton;


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusMixin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var focusNode = __webpack_require__(117);
	
	var AutoFocusMixin = {
	  componentDidMount: function() {
	    if (this.props.autoFocus) {
	      focusNode(this.getDOMNode());
	    }
	  }
	};
	
	module.exports = AutoFocusMixin;


/***/ },
/* 117 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule focusNode
	 */
	
	"use strict";
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch(e) {
	  }
	}
	
	module.exports = focusNode;


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMForm
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(7);
	var LocalEventTrapMixin = __webpack_require__(119);
	var ReactBrowserComponentMixin = __webpack_require__(112);
	var ReactClass = __webpack_require__(39);
	var ReactElement = __webpack_require__(13);
	
	var form = ReactElement.createFactory('form');
	
	/**
	 * Since onSubmit doesn't bubble OR capture on the top level in IE8, we need
	 * to capture it on the <form> element itself. There are lots of hacks we could
	 * do to accomplish this, but the most reliable is to make <form> a
	 * composite component and use `componentDidMount` to attach the event handlers.
	 */
	var ReactDOMForm = ReactClass.createClass({
	  displayName: 'ReactDOMForm',
	  tagName: 'FORM',
	
	  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
	
	  render: function() {
	    // TODO: Instead of using `ReactDOM` directly, we should use JSX. However,
	    // `jshint` fails to parse JSX so in order for linting to work in the open
	    // source repo, we need to just use `ReactDOM.form`.
	    return form(this.props);
	  },
	
	  componentDidMount: function() {
	    this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset');
	    this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit');
	  }
	});
	
	module.exports = ReactDOMForm;


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LocalEventTrapMixin
	 */
	
	'use strict';
	
	var ReactBrowserEventEmitter = __webpack_require__(70);
	
	var accumulateInto = __webpack_require__(73);
	var forEachAccumulated = __webpack_require__(74);
	var invariant = __webpack_require__(9);
	
	function remove(event) {
	  event.remove();
	}
	
	var LocalEventTrapMixin = {
	  trapBubbledEvent:function(topLevelType, handlerBaseName) {
	    ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'Must be mounted to trap events') : invariant(this.isMounted()));
	    // If a component renders to null or if another component fatals and causes
	    // the state of the tree to be corrupted, `node` here can be null.
	    var node = this.getDOMNode();
	    ("production" !== process.env.NODE_ENV ? invariant(
	      node,
	      'LocalEventTrapMixin.trapBubbledEvent(...): Requires node to be rendered.'
	    ) : invariant(node));
	    var listener = ReactBrowserEventEmitter.trapBubbledEvent(
	      topLevelType,
	      handlerBaseName,
	      node
	    );
	    this._localEventListeners =
	      accumulateInto(this._localEventListeners, listener);
	  },
	
	  // trapCapturedEvent would look nearly identical. We don't implement that
	  // method because it isn't currently needed.
	
	  componentWillUnmount:function() {
	    if (this._localEventListeners) {
	      forEachAccumulated(this._localEventListeners, remove);
	    }
	  }
	};
	
	module.exports = LocalEventTrapMixin;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMImg
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(7);
	var LocalEventTrapMixin = __webpack_require__(119);
	var ReactBrowserComponentMixin = __webpack_require__(112);
	var ReactClass = __webpack_require__(39);
	var ReactElement = __webpack_require__(13);
	
	var img = ReactElement.createFactory('img');
	
	/**
	 * Since onLoad doesn't bubble OR capture on the top level in IE8, we need to
	 * capture it on the <img> element itself. There are lots of hacks we could do
	 * to accomplish this, but the most reliable is to make <img> a composite
	 * component and use `componentDidMount` to attach the event handlers.
	 */
	var ReactDOMImg = ReactClass.createClass({
	  displayName: 'ReactDOMImg',
	  tagName: 'IMG',
	
	  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
	
	  render: function() {
	    return img(this.props);
	  },
	
	  componentDidMount: function() {
	    this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');
	    this.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error');
	  }
	});
	
	module.exports = ReactDOMImg;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIframe
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(7);
	var LocalEventTrapMixin = __webpack_require__(119);
	var ReactBrowserComponentMixin = __webpack_require__(112);
	var ReactClass = __webpack_require__(39);
	var ReactElement = __webpack_require__(13);
	
	var iframe = ReactElement.createFactory('iframe');
	
	/**
	 * Since onLoad doesn't bubble OR capture on the top level in IE8, we need to
	 * capture it on the <iframe> element itself. There are lots of hacks we could
	 * do to accomplish this, but the most reliable is to make <iframe> a composite
	 * component and use `componentDidMount` to attach the event handlers.
	 */
	var ReactDOMIframe = ReactClass.createClass({
	  displayName: 'ReactDOMIframe',
	  tagName: 'IFRAME',
	
	  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
	
	  render: function() {
	    return iframe(this.props);
	  },
	
	  componentDidMount: function() {
	    this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');
	  }
	});
	
	module.exports = ReactDOMIframe;


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var AutoFocusMixin = __webpack_require__(116);
	var DOMPropertyOperations = __webpack_require__(45);
	var LinkedValueUtils = __webpack_require__(123);
	var ReactBrowserComponentMixin = __webpack_require__(112);
	var ReactClass = __webpack_require__(39);
	var ReactElement = __webpack_require__(13);
	var ReactMount = __webpack_require__(69);
	var ReactUpdates = __webpack_require__(28);
	
	var assign = __webpack_require__(15);
	var invariant = __webpack_require__(9);
	
	var input = ReactElement.createFactory('input');
	
	var instancesByReactID = {};
	
	function forceUpdateIfMounted() {
	  /*jshint validthis:true */
	  if (this.isMounted()) {
	    this.forceUpdate();
	  }
	}
	
	/**
	 * Implements an <input> native component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = ReactClass.createClass({
	  displayName: 'ReactDOMInput',
	  tagName: 'INPUT',
	
	  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
	
	  getInitialState: function() {
	    var defaultValue = this.props.defaultValue;
	    return {
	      initialChecked: this.props.defaultChecked || false,
	      initialValue: defaultValue != null ? defaultValue : null
	    };
	  },
	
	  render: function() {
	    // Clone `this.props` so we don't mutate the input.
	    var props = assign({}, this.props);
	
	    props.defaultChecked = null;
	    props.defaultValue = null;
	
	    var value = LinkedValueUtils.getValue(this);
	    props.value = value != null ? value : this.state.initialValue;
	
	    var checked = LinkedValueUtils.getChecked(this);
	    props.checked = checked != null ? checked : this.state.initialChecked;
	
	    props.onChange = this._handleChange;
	
	    return input(props, this.props.children);
	  },
	
	  componentDidMount: function() {
	    var id = ReactMount.getID(this.getDOMNode());
	    instancesByReactID[id] = this;
	  },
	
	  componentWillUnmount: function() {
	    var rootNode = this.getDOMNode();
	    var id = ReactMount.getID(rootNode);
	    delete instancesByReactID[id];
	  },
	
	  componentDidUpdate: function(prevProps, prevState, prevContext) {
	    var rootNode = this.getDOMNode();
	    if (this.props.checked != null) {
	      DOMPropertyOperations.setValueForProperty(
	        rootNode,
	        'checked',
	        this.props.checked || false
	      );
	    }
	
	    var value = LinkedValueUtils.getValue(this);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
	    }
	  },
	
	  _handleChange: function(event) {
	    var returnValue;
	    var onChange = LinkedValueUtils.getOnChange(this);
	    if (onChange) {
	      returnValue = onChange.call(this, event);
	    }
	    // Here we use asap to wait until all updates have propagated, which
	    // is important when using controlled components within layers:
	    // https://github.com/facebook/react/issues/1698
	    ReactUpdates.asap(forceUpdateIfMounted, this);
	
	    var name = this.props.name;
	    if (this.props.type === 'radio' && name != null) {
	      var rootNode = this.getDOMNode();
	      var queryRoot = rootNode;
	
	      while (queryRoot.parentNode) {
	        queryRoot = queryRoot.parentNode;
	      }
	
	      // If `rootNode.form` was non-null, then we could try `form.elements`,
	      // but that sometimes behaves strangely in IE8. We could also try using
	      // `form.getElementsByName`, but that will only return direct children
	      // and won't include inputs that use the HTML5 `form=` attribute. Since
	      // the input might not even be in a form, let's just use the global
	      // `querySelectorAll` to ensure we don't miss anything.
	      var group = queryRoot.querySelectorAll(
	        'input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	      for (var i = 0, groupLen = group.length; i < groupLen; i++) {
	        var otherNode = group[i];
	        if (otherNode === rootNode ||
	            otherNode.form !== rootNode.form) {
	          continue;
	        }
	        var otherID = ReactMount.getID(otherNode);
	        ("production" !== process.env.NODE_ENV ? invariant(
	          otherID,
	          'ReactDOMInput: Mixing React and non-React radio inputs with the ' +
	          'same `name` is not supported.'
	        ) : invariant(otherID));
	        var otherInstance = instancesByReactID[otherID];
	        ("production" !== process.env.NODE_ENV ? invariant(
	          otherInstance,
	          'ReactDOMInput: Unknown radio button ID %s.',
	          otherID
	        ) : invariant(otherInstance));
	        // If this is a controlled radio button group, forcing the input that
	        // was previously checked to update will cause it to be come re-checked
	        // as appropriate.
	        ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	      }
	    }
	
	    return returnValue;
	  }
	
	});
	
	module.exports = ReactDOMInput;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactPropTypes = __webpack_require__(124);
	
	var invariant = __webpack_require__(9);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(input) {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    input.props.checkedLink == null || input.props.valueLink == null,
	    'Cannot provide a checkedLink and a valueLink. If you want to use ' +
	    'checkedLink, you probably don\'t want to use valueLink and vice versa.'
	  ) : invariant(input.props.checkedLink == null || input.props.valueLink == null));
	}
	function _assertValueLink(input) {
	  _assertSingleLink(input);
	  ("production" !== process.env.NODE_ENV ? invariant(
	    input.props.value == null && input.props.onChange == null,
	    'Cannot provide a valueLink and a value or onChange event. If you want ' +
	    'to use value or onChange, you probably don\'t want to use valueLink.'
	  ) : invariant(input.props.value == null && input.props.onChange == null));
	}
	
	function _assertCheckedLink(input) {
	  _assertSingleLink(input);
	  ("production" !== process.env.NODE_ENV ? invariant(
	    input.props.checked == null && input.props.onChange == null,
	    'Cannot provide a checkedLink and a checked property or onChange event. ' +
	    'If you want to use checked or onChange, you probably don\'t want to ' +
	    'use checkedLink'
	  ) : invariant(input.props.checked == null && input.props.onChange == null));
	}
	
	/**
	 * @param {SyntheticEvent} e change event to handle
	 */
	function _handleLinkedValueChange(e) {
	  /*jshint validthis:true */
	  this.props.valueLink.requestChange(e.target.value);
	}
	
	/**
	  * @param {SyntheticEvent} e change event to handle
	  */
	function _handleLinkedCheckChange(e) {
	  /*jshint validthis:true */
	  this.props.checkedLink.requestChange(e.target.checked);
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  Mixin: {
	    propTypes: {
	      value: function(props, propName, componentName) {
	        if (!props[propName] ||
	            hasReadOnlyValue[props.type] ||
	            props.onChange ||
	            props.readOnly ||
	            props.disabled) {
	          return null;
	        }
	        return new Error(
	          'You provided a `value` prop to a form field without an ' +
	          '`onChange` handler. This will render a read-only field. If ' +
	          'the field should be mutable use `defaultValue`. Otherwise, ' +
	          'set either `onChange` or `readOnly`.'
	        );
	      },
	      checked: function(props, propName, componentName) {
	        if (!props[propName] ||
	            props.onChange ||
	            props.readOnly ||
	            props.disabled) {
	          return null;
	        }
	        return new Error(
	          'You provided a `checked` prop to a form field without an ' +
	          '`onChange` handler. This will render a read-only field. If ' +
	          'the field should be mutable use `defaultChecked`. Otherwise, ' +
	          'set either `onChange` or `readOnly`.'
	        );
	      },
	      onChange: ReactPropTypes.func
	    }
	  },
	
	  /**
	   * @param {ReactComponent} input Form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function(input) {
	    if (input.props.valueLink) {
	      _assertValueLink(input);
	      return input.props.valueLink.value;
	    }
	    return input.props.value;
	  },
	
	  /**
	   * @param {ReactComponent} input Form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function(input) {
	    if (input.props.checkedLink) {
	      _assertCheckedLink(input);
	      return input.props.checkedLink.value;
	    }
	    return input.props.checked;
	  },
	
	  /**
	   * @param {ReactComponent} input Form component
	   * @return {function} change callback either from onChange prop or link.
	   */
	  getOnChange: function(input) {
	    if (input.props.valueLink) {
	      _assertValueLink(input);
	      return _handleLinkedValueChange;
	    } else if (input.props.checkedLink) {
	      _assertCheckedLink(input);
	      return _handleLinkedCheckChange;
	    }
	    return input.props.onChange;
	  }
	};
	
	module.exports = LinkedValueUtils;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	var ReactFragment = __webpack_require__(12);
	var ReactPropTypeLocationNames = __webpack_require__(36);
	
	var emptyFunction = __webpack_require__(18);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var elementTypeChecker = createElementTypeChecker();
	var nodeTypeChecker = createNodeChecker();
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: elementTypeChecker,
	  instanceOf: createInstanceTypeChecker,
	  node: nodeTypeChecker,
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location) {
	    componentName = componentName || ANONYMOUS;
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new Error(
	          ("Required " + locationName + " `" + propName + "` was not specified in ") +
	          ("`" + componentName + "`.")
	        );
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new Error(
	        ("Invalid " + locationName + " `" + propName + "` of type `" + preciseType + "` ") +
	        ("supplied to `" + componentName + "`, expected `" + expectedType + "`.")
	      );
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location) {
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new Error(
	        ("Invalid " + locationName + " `" + propName + "` of type ") +
	        ("`" + propType + "` supplied to `" + componentName + "`, expected an array.")
	      );
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location);
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location) {
	    if (!ReactElement.isValidElement(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error(
	        ("Invalid " + locationName + " `" + propName + "` supplied to ") +
	        ("`" + componentName + "`, expected a ReactElement.")
	      );
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      return new Error(
	        ("Invalid " + locationName + " `" + propName + "` supplied to ") +
	        ("`" + componentName + "`, expected instance of `" + expectedClassName + "`.")
	      );
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  function validate(props, propName, componentName, location) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (propValue === expectedValues[i]) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new Error(
	      ("Invalid " + locationName + " `" + propName + "` of value `" + propValue + "` ") +
	      ("supplied to `" + componentName + "`, expected one of " + valuesString + ".")
	    );
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error(
	        ("Invalid " + locationName + " `" + propName + "` of type ") +
	        ("`" + propType + "` supplied to `" + componentName + "`, expected an object.")
	      );
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  function validate(props, propName, componentName, location) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new Error(
	      ("Invalid " + locationName + " `" + propName + "` supplied to ") +
	      ("`" + componentName + "`.")
	    );
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error(
	        ("Invalid " + locationName + " `" + propName + "` supplied to ") +
	        ("`" + componentName + "`, expected a ReactNode.")
	      );
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error(
	        ("Invalid " + locationName + " `" + propName + "` of type `" + propType + "` ") +
	        ("supplied to `" + componentName + "`, expected `object`.")
	      );
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	      propValue = ReactFragment.extractIfFragment(propValue);
	      for (var k in propValue) {
	        if (!isNode(propValue[k])) {
	          return false;
	        }
	      }
	      return true;
	    default:
	      return false;
	  }
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	module.exports = ReactPropTypes;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var ReactBrowserComponentMixin = __webpack_require__(112);
	var ReactClass = __webpack_require__(39);
	var ReactElement = __webpack_require__(13);
	
	var warning = __webpack_require__(17);
	
	var option = ReactElement.createFactory('option');
	
	/**
	 * Implements an <option> native component that warns when `selected` is set.
	 */
	var ReactDOMOption = ReactClass.createClass({
	  displayName: 'ReactDOMOption',
	  tagName: 'OPTION',
	
	  mixins: [ReactBrowserComponentMixin],
	
	  componentWillMount: function() {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if ("production" !== process.env.NODE_ENV) {
	      ("production" !== process.env.NODE_ENV ? warning(
	        this.props.selected == null,
	        'Use the `defaultValue` or `value` props on <select> instead of ' +
	        'setting `selected` on <option>.'
	      ) : null);
	    }
	  },
	
	  render: function() {
	    return option(this.props, this.props.children);
	  }
	
	});
	
	module.exports = ReactDOMOption;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var AutoFocusMixin = __webpack_require__(116);
	var LinkedValueUtils = __webpack_require__(123);
	var ReactBrowserComponentMixin = __webpack_require__(112);
	var ReactClass = __webpack_require__(39);
	var ReactElement = __webpack_require__(13);
	var ReactUpdates = __webpack_require__(28);
	
	var assign = __webpack_require__(15);
	
	var select = ReactElement.createFactory('select');
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  /*jshint validthis:true */
	  if (this._pendingUpdate) {
	    this._pendingUpdate = false;
	    var value = LinkedValueUtils.getValue(this);
	    if (value != null && this.isMounted()) {
	      updateOptions(this, value);
	    }
	  }
	}
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function selectValueType(props, propName, componentName) {
	  if (props[propName] == null) {
	    return null;
	  }
	  if (props.multiple) {
	    if (!Array.isArray(props[propName])) {
	      return new Error(
	        ("The `" + propName + "` prop supplied to <select> must be an array if ") +
	        ("`multiple` is true.")
	      );
	    }
	  } else {
	    if (Array.isArray(props[propName])) {
	      return new Error(
	        ("The `" + propName + "` prop supplied to <select> must be a scalar ") +
	        ("value if `multiple` is false.")
	      );
	    }
	  }
	}
	
	/**
	 * @param {ReactComponent} component Instance of ReactDOMSelect
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(component, propValue) {
	  var selectedValue, i, l;
	  var options = component.getDOMNode().options;
	
	  if (component.props.multiple) {
	    selectedValue = {};
	    for (i = 0, l = propValue.length; i < l; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0, l = options.length; i < l; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0, l = options.length; i < l; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> native component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = ReactClass.createClass({
	  displayName: 'ReactDOMSelect',
	  tagName: 'SELECT',
	
	  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
	
	  propTypes: {
	    defaultValue: selectValueType,
	    value: selectValueType
	  },
	
	  render: function() {
	    // Clone `this.props` so we don't mutate the input.
	    var props = assign({}, this.props);
	
	    props.onChange = this._handleChange;
	    props.value = null;
	
	    return select(props, this.props.children);
	  },
	
	  componentWillMount: function() {
	    this._pendingUpdate = false;
	  },
	
	  componentDidMount: function() {
	    var value = LinkedValueUtils.getValue(this);
	    if (value != null) {
	      updateOptions(this, value);
	    } else if (this.props.defaultValue != null) {
	      updateOptions(this, this.props.defaultValue);
	    }
	  },
	
	  componentDidUpdate: function(prevProps) {
	    var value = LinkedValueUtils.getValue(this);
	    if (value != null) {
	      this._pendingUpdate = false;
	      updateOptions(this, value);
	    } else if (!prevProps.multiple !== !this.props.multiple) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (this.props.defaultValue != null) {
	        updateOptions(this, this.props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(this, this.props.multiple ? [] : '');
	      }
	    }
	  },
	
	  _handleChange: function(event) {
	    var returnValue;
	    var onChange = LinkedValueUtils.getOnChange(this);
	    if (onChange) {
	      returnValue = onChange.call(this, event);
	    }
	
	    this._pendingUpdate = true;
	    ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	    return returnValue;
	  }
	
	});
	
	module.exports = ReactDOMSelect;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var AutoFocusMixin = __webpack_require__(116);
	var DOMPropertyOperations = __webpack_require__(45);
	var LinkedValueUtils = __webpack_require__(123);
	var ReactBrowserComponentMixin = __webpack_require__(112);
	var ReactClass = __webpack_require__(39);
	var ReactElement = __webpack_require__(13);
	var ReactUpdates = __webpack_require__(28);
	
	var assign = __webpack_require__(15);
	var invariant = __webpack_require__(9);
	
	var warning = __webpack_require__(17);
	
	var textarea = ReactElement.createFactory('textarea');
	
	function forceUpdateIfMounted() {
	  /*jshint validthis:true */
	  if (this.isMounted()) {
	    this.forceUpdate();
	  }
	}
	
	/**
	 * Implements a <textarea> native component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = ReactClass.createClass({
	  displayName: 'ReactDOMTextarea',
	  tagName: 'TEXTAREA',
	
	  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
	
	  getInitialState: function() {
	    var defaultValue = this.props.defaultValue;
	    // TODO (yungsters): Remove support for children content in <textarea>.
	    var children = this.props.children;
	    if (children != null) {
	      if ("production" !== process.env.NODE_ENV) {
	        ("production" !== process.env.NODE_ENV ? warning(
	          false,
	          'Use the `defaultValue` or `value` props instead of setting ' +
	          'children on <textarea>.'
	        ) : null);
	      }
	      ("production" !== process.env.NODE_ENV ? invariant(
	        defaultValue == null,
	        'If you supply `defaultValue` on a <textarea>, do not pass children.'
	      ) : invariant(defaultValue == null));
	      if (Array.isArray(children)) {
	        ("production" !== process.env.NODE_ENV ? invariant(
	          children.length <= 1,
	          '<textarea> can only have at most one child.'
	        ) : invariant(children.length <= 1));
	        children = children[0];
	      }
	
	      defaultValue = '' + children;
	    }
	    if (defaultValue == null) {
	      defaultValue = '';
	    }
	    var value = LinkedValueUtils.getValue(this);
	    return {
	      // We save the initial value so that `ReactDOMComponent` doesn't update
	      // `textContent` (unnecessary since we update value).
	      // The initial value can be a boolean or object so that's why it's
	      // forced to be a string.
	      initialValue: '' + (value != null ? value : defaultValue)
	    };
	  },
	
	  render: function() {
	    // Clone `this.props` so we don't mutate the input.
	    var props = assign({}, this.props);
	
	    ("production" !== process.env.NODE_ENV ? invariant(
	      props.dangerouslySetInnerHTML == null,
	      '`dangerouslySetInnerHTML` does not make sense on <textarea>.'
	    ) : invariant(props.dangerouslySetInnerHTML == null));
	
	    props.defaultValue = null;
	    props.value = null;
	    props.onChange = this._handleChange;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.
	    return textarea(props, this.state.initialValue);
	  },
	
	  componentDidUpdate: function(prevProps, prevState, prevContext) {
	    var value = LinkedValueUtils.getValue(this);
	    if (value != null) {
	      var rootNode = this.getDOMNode();
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
	    }
	  },
	
	  _handleChange: function(event) {
	    var returnValue;
	    var onChange = LinkedValueUtils.getOnChange(this);
	    if (onChange) {
	      returnValue = onChange.call(this, event);
	    }
	    ReactUpdates.asap(forceUpdateIfMounted, this);
	    return returnValue;
	  }
	
	});
	
	module.exports = ReactDOMTextarea;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventListener = __webpack_require__(129);
	var ExecutionEnvironment = __webpack_require__(53);
	var PooledClass = __webpack_require__(11);
	var ReactInstanceHandles = __webpack_require__(21);
	var ReactMount = __webpack_require__(69);
	var ReactUpdates = __webpack_require__(28);
	
	var assign = __webpack_require__(15);
	var getEventTarget = __webpack_require__(100);
	var getUnboundedScrollPosition = __webpack_require__(130);
	
	/**
	 * Finds the parent React component of `node`.
	 *
	 * @param {*} node
	 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
	 *                           is not nested.
	 */
	function findParent(node) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  var nodeID = ReactMount.getID(node);
	  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	  var container = ReactMount.findReactContainerForID(rootID);
	  var parent = ReactMount.getFirstReactDOM(container);
	  return parent;
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function() {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(
	  TopLevelCallbackBookKeeping,
	  PooledClass.twoArgumentPooler
	);
	
	function handleTopLevelImpl(bookKeeping) {
	  var topLevelTarget = ReactMount.getFirstReactDOM(
	    getEventTarget(bookKeeping.nativeEvent)
	  ) || window;
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = topLevelTarget;
	  while (ancestor) {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = findParent(ancestor);
	  }
	
	  for (var i = 0, l = bookKeeping.ancestors.length; i < l; i++) {
	    topLevelTarget = bookKeeping.ancestors[i];
	    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
	    ReactEventListener._handleTopLevel(
	      bookKeeping.topLevelType,
	      topLevelTarget,
	      topLevelTargetID,
	      bookKeeping.nativeEvent
	    );
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function(handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function(enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function() {
	    return ReactEventListener._enabled;
	  },
	
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(
	      element,
	      handlerBaseName,
	      ReactEventListener.dispatchEvent.bind(null, topLevelType)
	    );
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(
	      element,
	      handlerBaseName,
	      ReactEventListener.dispatchEvent.bind(null, topLevelType)
	    );
	  },
	
	  monitorScrollValue: function(refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function(topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(
	      topLevelType,
	      nativeEvent
	    );
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @providesModule EventListener
	 * @typechecks
	 */
	
	var emptyFunction = __webpack_require__(18);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function(target, eventType, callback) {
	    if (!target.addEventListener) {
	      if ("production" !== process.env.NODE_ENV) {
	        console.error(
	          'Attempted to listen to events during the capture phase on a ' +
	          'browser that does not support the capture phase. Your application ' +
	          'will not receive some events.'
	        );
	      }
	      return {
	        remove: emptyFunction
	      };
	    } else {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    }
	  },
	
	  registerDefault: function() {}
	};
	
	module.exports = EventListener;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 130 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getUnboundedScrollPosition
	 * @typechecks
	 */
	
	"use strict";
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(46);
	var EventPluginHub = __webpack_require__(71);
	var ReactComponentEnvironment = __webpack_require__(87);
	var ReactClass = __webpack_require__(39);
	var ReactEmptyComponent = __webpack_require__(78);
	var ReactBrowserEventEmitter = __webpack_require__(70);
	var ReactNativeComponent = __webpack_require__(37);
	var ReactDOMComponent = __webpack_require__(89);
	var ReactPerf = __webpack_require__(30);
	var ReactRootIndex = __webpack_require__(22);
	var ReactUpdates = __webpack_require__(28);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMComponent: ReactDOMComponent.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  NativeComponent: ReactNativeComponent.injection,
	  Perf: ReactPerf.injection,
	  RootIndex: ReactRootIndex.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(29);
	var PooledClass = __webpack_require__(11);
	var ReactBrowserEventEmitter = __webpack_require__(70);
	var ReactInputSelection = __webpack_require__(133);
	var ReactPutListenerQueue = __webpack_require__(137);
	var Transaction = __webpack_require__(38);
	
	var assign = __webpack_require__(15);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function() {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occured. `close`
	   *   restores the previous value.
	   */
	  close: function(previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function() {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function() {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	var PUT_LISTENER_QUEUEING = {
	  initialize: function() {
	    this.putListenerQueue.reset();
	  },
	
	  close: function() {
	    this.putListenerQueue.putListeners();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [
	  PUT_LISTENER_QUEUEING,
	  SELECTION_RESTORATION,
	  EVENT_SUPPRESSION,
	  ON_DOM_READY_QUEUEING
	];
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction() {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.putListenerQueue = ReactPutListenerQueue.getPooled();
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap proceedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function() {
	    return this.reactMountReady;
	  },
	
	  getPutListenerQueue: function() {
	    return this.putListenerQueue;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be resused.
	   */
	  destructor: function() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	
	    ReactPutListenerQueue.release(this.putListenerQueue);
	    this.putListenerQueue = null;
	  }
	};
	
	
	assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(134);
	
	var containsNode = __webpack_require__(81);
	var focusNode = __webpack_require__(117);
	var getActiveElement = __webpack_require__(136);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function(elem) {
	    return elem && (
	      ((elem.nodeName === 'INPUT' && elem.type === 'text') ||
	      elem.nodeName === 'TEXTAREA' || elem.contentEditable === 'true')
	    );
	  },
	
	  getSelectionInformation: function() {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange:
	          ReactInputSelection.hasSelectionCapabilities(focusedElem) ?
	          ReactInputSelection.getSelection(focusedElem) :
	          null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function(priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem &&
	        isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(
	          priorFocusedElem,
	          priorSelectionRange
	        );
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function(input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName === 'INPUT') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || {start: 0, end: 0};
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function(input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (typeof end === 'undefined') {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName === 'INPUT') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(53);
	
	var getNodeForCharacterOffset = __webpack_require__(135);
	var getTextContentAccessor = __webpack_require__(97);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(
	    selection.anchorNode,
	    selection.anchorOffset,
	    selection.focusNode,
	    selection.focusOffset
	  );
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(
	    tempRange.startContainer,
	    tempRange.startOffset,
	    tempRange.endContainer,
	    tempRange.endOffset
	  );
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (typeof offsets.end === 'undefined') {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = typeof offsets.end === 'undefined' ?
	            start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = (
	  ExecutionEnvironment.canUseDOM &&
	  'selection' in document &&
	  !('getSelection' in window)
	);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;


/***/ },
/* 135 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;


/***/ },
/* 136 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getActiveElement
	 * @typechecks
	 */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document body is not yet defined.
	 */
	function getActiveElement() /*?DOMElement*/ {
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPutListenerQueue
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(11);
	var ReactBrowserEventEmitter = __webpack_require__(70);
	
	var assign = __webpack_require__(15);
	
	function ReactPutListenerQueue() {
	  this.listenersToPut = [];
	}
	
	assign(ReactPutListenerQueue.prototype, {
	  enqueuePutListener: function(rootNodeID, propKey, propValue) {
	    this.listenersToPut.push({
	      rootNodeID: rootNodeID,
	      propKey: propKey,
	      propValue: propValue
	    });
	  },
	
	  putListeners: function() {
	    for (var i = 0; i < this.listenersToPut.length; i++) {
	      var listenerToPut = this.listenersToPut[i];
	      ReactBrowserEventEmitter.putListener(
	        listenerToPut.rootNodeID,
	        listenerToPut.propKey,
	        listenerToPut.propValue
	      );
	    }
	  },
	
	  reset: function() {
	    this.listenersToPut.length = 0;
	  },
	
	  destructor: function() {
	    this.reset();
	  }
	});
	
	PooledClass.addPoolingTo(ReactPutListenerQueue);
	
	module.exports = ReactPutListenerQueue;


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(7);
	var EventPropagators = __webpack_require__(95);
	var ReactInputSelection = __webpack_require__(133);
	var SyntheticEvent = __webpack_require__(99);
	
	var getActiveElement = __webpack_require__(136);
	var isTextInputElement = __webpack_require__(103);
	var keyOf = __webpack_require__(41);
	var shallowEqual = __webpack_require__(139);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onSelect: null}),
	      captured: keyOf({onSelectCapture: null})
	    },
	    dependencies: [
	      topLevelTypes.topBlur,
	      topLevelTypes.topContextMenu,
	      topLevelTypes.topFocus,
	      topLevelTypes.topKeyDown,
	      topLevelTypes.topMouseDown,
	      topLevelTypes.topMouseUp,
	      topLevelTypes.topSelectionChange
	    ]
	  }
	};
	
	var activeElement = null;
	var activeElementID = null;
	var lastSelection = null;
	var mouseDown = false;
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @param {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node &&
	      ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown ||
	      activeElement == null ||
	      activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(
	      eventTypes.select,
	      activeElementID,
	      nativeEvent
	    );
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function(
	      topLevelType,
	      topLevelTarget,
	      topLevelTargetID,
	      nativeEvent) {
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(topLevelTarget) ||
	            topLevelTarget.contentEditable === 'true') {
	          activeElement = topLevelTarget;
	          activeElementID = topLevelTargetID;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementID = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't).
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      case topLevelTypes.topSelectionChange:
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent);
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;


/***/ },
/* 139 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shallowEqual
	 */
	
	'use strict';
	
	/**
	 * Performs equality by iterating through keys on an object and returning
	 * false when any key has values which are not strictly equal between
	 * objA and objB. Returns true when the values of all keys are strictly equal.
	 *
	 * @return {boolean}
	 */
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	  var key;
	  // Test for A's keys different from B.
	  for (key in objA) {
	    if (objA.hasOwnProperty(key) &&
	        (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
	      return false;
	    }
	  }
	  // Test for B's keys missing from A.
	  for (key in objB) {
	    if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
	      return false;
	    }
	  }
	  return true;
	}
	
	module.exports = shallowEqual;


/***/ },
/* 140 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ServerReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Size of the reactRoot ID space. We generate random numbers for React root
	 * IDs and if there's a collision the events and DOM update system will
	 * get confused. In the future we need a way to generate GUIDs but for
	 * now this will work on a smaller scale.
	 */
	var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
	
	var ServerReactRootIndex = {
	  createReactRootIndex: function() {
	    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
	  }
	};
	
	module.exports = ServerReactRootIndex;


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(7);
	var EventPluginUtils = __webpack_require__(6);
	var EventPropagators = __webpack_require__(95);
	var SyntheticClipboardEvent = __webpack_require__(142);
	var SyntheticEvent = __webpack_require__(99);
	var SyntheticFocusEvent = __webpack_require__(143);
	var SyntheticKeyboardEvent = __webpack_require__(144);
	var SyntheticMouseEvent = __webpack_require__(107);
	var SyntheticDragEvent = __webpack_require__(147);
	var SyntheticTouchEvent = __webpack_require__(148);
	var SyntheticUIEvent = __webpack_require__(108);
	var SyntheticWheelEvent = __webpack_require__(149);
	
	var getEventCharCode = __webpack_require__(145);
	
	var invariant = __webpack_require__(9);
	var keyOf = __webpack_require__(41);
	var warning = __webpack_require__(17);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onBlur: true}),
	      captured: keyOf({onBlurCapture: true})
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onClick: true}),
	      captured: keyOf({onClickCapture: true})
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onContextMenu: true}),
	      captured: keyOf({onContextMenuCapture: true})
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onCopy: true}),
	      captured: keyOf({onCopyCapture: true})
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onCut: true}),
	      captured: keyOf({onCutCapture: true})
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onDoubleClick: true}),
	      captured: keyOf({onDoubleClickCapture: true})
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onDrag: true}),
	      captured: keyOf({onDragCapture: true})
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onDragEnd: true}),
	      captured: keyOf({onDragEndCapture: true})
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onDragEnter: true}),
	      captured: keyOf({onDragEnterCapture: true})
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onDragExit: true}),
	      captured: keyOf({onDragExitCapture: true})
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onDragLeave: true}),
	      captured: keyOf({onDragLeaveCapture: true})
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onDragOver: true}),
	      captured: keyOf({onDragOverCapture: true})
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onDragStart: true}),
	      captured: keyOf({onDragStartCapture: true})
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onDrop: true}),
	      captured: keyOf({onDropCapture: true})
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onFocus: true}),
	      captured: keyOf({onFocusCapture: true})
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onInput: true}),
	      captured: keyOf({onInputCapture: true})
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onKeyDown: true}),
	      captured: keyOf({onKeyDownCapture: true})
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onKeyPress: true}),
	      captured: keyOf({onKeyPressCapture: true})
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onKeyUp: true}),
	      captured: keyOf({onKeyUpCapture: true})
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onLoad: true}),
	      captured: keyOf({onLoadCapture: true})
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onError: true}),
	      captured: keyOf({onErrorCapture: true})
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onMouseDown: true}),
	      captured: keyOf({onMouseDownCapture: true})
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onMouseMove: true}),
	      captured: keyOf({onMouseMoveCapture: true})
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onMouseOut: true}),
	      captured: keyOf({onMouseOutCapture: true})
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onMouseOver: true}),
	      captured: keyOf({onMouseOverCapture: true})
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onMouseUp: true}),
	      captured: keyOf({onMouseUpCapture: true})
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onPaste: true}),
	      captured: keyOf({onPasteCapture: true})
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onReset: true}),
	      captured: keyOf({onResetCapture: true})
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onScroll: true}),
	      captured: keyOf({onScrollCapture: true})
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onSubmit: true}),
	      captured: keyOf({onSubmitCapture: true})
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onTouchCancel: true}),
	      captured: keyOf({onTouchCancelCapture: true})
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onTouchEnd: true}),
	      captured: keyOf({onTouchEndCapture: true})
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onTouchMove: true}),
	      captured: keyOf({onTouchMoveCapture: true})
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onTouchStart: true}),
	      captured: keyOf({onTouchStartCapture: true})
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({onWheel: true}),
	      captured: keyOf({onWheelCapture: true})
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topBlur:        eventTypes.blur,
	  topClick:       eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy:        eventTypes.copy,
	  topCut:         eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag:        eventTypes.drag,
	  topDragEnd:     eventTypes.dragEnd,
	  topDragEnter:   eventTypes.dragEnter,
	  topDragExit:    eventTypes.dragExit,
	  topDragLeave:   eventTypes.dragLeave,
	  topDragOver:    eventTypes.dragOver,
	  topDragStart:   eventTypes.dragStart,
	  topDrop:        eventTypes.drop,
	  topError:       eventTypes.error,
	  topFocus:       eventTypes.focus,
	  topInput:       eventTypes.input,
	  topKeyDown:     eventTypes.keyDown,
	  topKeyPress:    eventTypes.keyPress,
	  topKeyUp:       eventTypes.keyUp,
	  topLoad:        eventTypes.load,
	  topMouseDown:   eventTypes.mouseDown,
	  topMouseMove:   eventTypes.mouseMove,
	  topMouseOut:    eventTypes.mouseOut,
	  topMouseOver:   eventTypes.mouseOver,
	  topMouseUp:     eventTypes.mouseUp,
	  topPaste:       eventTypes.paste,
	  topReset:       eventTypes.reset,
	  topScroll:      eventTypes.scroll,
	  topSubmit:      eventTypes.submit,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd:    eventTypes.touchEnd,
	  topTouchMove:   eventTypes.touchMove,
	  topTouchStart:  eventTypes.touchStart,
	  topWheel:       eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * Same as the default implementation, except cancels the event when return
	   * value is false. This behavior will be disabled in a future release.
	   *
	   * @param {object} Event to be dispatched.
	   * @param {function} Application-level callback.
	   * @param {string} domID DOM ID to pass to the callback.
	   */
	  executeDispatch: function(event, listener, domID) {
	    var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);
	
	    ("production" !== process.env.NODE_ENV ? warning(
	      typeof returnValue !== 'boolean',
	      'Returning `false` from an event handler is deprecated and will be ' +
	      'ignored in a future release. Instead, manually call ' +
	      'e.stopPropagation() or e.preventDefault(), as appropriate.'
	    ) : null);
	
	    if (returnValue === false) {
	      event.stopPropagation();
	      event.preventDefault();
	    }
	  },
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function(
	      topLevelType,
	      topLevelTarget,
	      topLevelTargetID,
	      nativeEvent) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topInput:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topError:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSubmit:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // FireFox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	        /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	        /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    ("production" !== process.env.NODE_ENV ? invariant(
	      EventConstructor,
	      'SimpleEventPlugin: Unhandled event type, `%s`.',
	      topLevelType
	    ) : invariant(EventConstructor));
	    var event = EventConstructor.getPooled(
	      dispatchConfig,
	      topLevelTargetID,
	      nativeEvent
	    );
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(99);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function(event) {
	    return (
	      'clipboardData' in event ?
	        event.clipboardData :
	        window.clipboardData
	    );
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(108);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(108);
	
	var getEventCharCode = __webpack_require__(145);
	var getEventKey = __webpack_require__(146);
	var getEventModifierState = __webpack_require__(109);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function(event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function(event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function(event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;


/***/ },
/* 145 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `charCode` property.
	 */
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(145);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(107);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(108);
	
	var getEventModifierState = __webpack_require__(109);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(107);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function(event) {
	    return (
	      'deltaX' in event ? event.deltaX :
	      // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	      'wheelDeltaX' in event ? -event.wheelDeltaX : 0
	    );
	  },
	  deltaY: function(event) {
	    return (
	      'deltaY' in event ? event.deltaY :
	      // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	      'wheelDeltaY' in event ? -event.wheelDeltaY :
	      // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	      'wheelDelta' in event ? -event.wheelDelta : 0
	    );
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	/*jslint bitwise: true*/
	
	'use strict';
	
	var DOMProperty = __webpack_require__(46);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	
	var SVGDOMPropertyConfig = {
	  Properties: {
	    clipPath: MUST_USE_ATTRIBUTE,
	    cx: MUST_USE_ATTRIBUTE,
	    cy: MUST_USE_ATTRIBUTE,
	    d: MUST_USE_ATTRIBUTE,
	    dx: MUST_USE_ATTRIBUTE,
	    dy: MUST_USE_ATTRIBUTE,
	    fill: MUST_USE_ATTRIBUTE,
	    fillOpacity: MUST_USE_ATTRIBUTE,
	    fontFamily: MUST_USE_ATTRIBUTE,
	    fontSize: MUST_USE_ATTRIBUTE,
	    fx: MUST_USE_ATTRIBUTE,
	    fy: MUST_USE_ATTRIBUTE,
	    gradientTransform: MUST_USE_ATTRIBUTE,
	    gradientUnits: MUST_USE_ATTRIBUTE,
	    markerEnd: MUST_USE_ATTRIBUTE,
	    markerMid: MUST_USE_ATTRIBUTE,
	    markerStart: MUST_USE_ATTRIBUTE,
	    offset: MUST_USE_ATTRIBUTE,
	    opacity: MUST_USE_ATTRIBUTE,
	    patternContentUnits: MUST_USE_ATTRIBUTE,
	    patternUnits: MUST_USE_ATTRIBUTE,
	    points: MUST_USE_ATTRIBUTE,
	    preserveAspectRatio: MUST_USE_ATTRIBUTE,
	    r: MUST_USE_ATTRIBUTE,
	    rx: MUST_USE_ATTRIBUTE,
	    ry: MUST_USE_ATTRIBUTE,
	    spreadMethod: MUST_USE_ATTRIBUTE,
	    stopColor: MUST_USE_ATTRIBUTE,
	    stopOpacity: MUST_USE_ATTRIBUTE,
	    stroke: MUST_USE_ATTRIBUTE,
	    strokeDasharray: MUST_USE_ATTRIBUTE,
	    strokeLinecap: MUST_USE_ATTRIBUTE,
	    strokeOpacity: MUST_USE_ATTRIBUTE,
	    strokeWidth: MUST_USE_ATTRIBUTE,
	    textAnchor: MUST_USE_ATTRIBUTE,
	    transform: MUST_USE_ATTRIBUTE,
	    version: MUST_USE_ATTRIBUTE,
	    viewBox: MUST_USE_ATTRIBUTE,
	    x1: MUST_USE_ATTRIBUTE,
	    x2: MUST_USE_ATTRIBUTE,
	    x: MUST_USE_ATTRIBUTE,
	    y1: MUST_USE_ATTRIBUTE,
	    y2: MUST_USE_ATTRIBUTE,
	    y: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNames: {
	    clipPath: 'clip-path',
	    fillOpacity: 'fill-opacity',
	    fontFamily: 'font-family',
	    fontSize: 'font-size',
	    gradientTransform: 'gradientTransform',
	    gradientUnits: 'gradientUnits',
	    markerEnd: 'marker-end',
	    markerMid: 'marker-mid',
	    markerStart: 'marker-start',
	    patternContentUnits: 'patternContentUnits',
	    patternUnits: 'patternUnits',
	    preserveAspectRatio: 'preserveAspectRatio',
	    spreadMethod: 'spreadMethod',
	    stopColor: 'stop-color',
	    stopOpacity: 'stop-opacity',
	    strokeDasharray: 'stroke-dasharray',
	    strokeLinecap: 'stroke-linecap',
	    strokeOpacity: 'stroke-opacity',
	    strokeWidth: 'stroke-width',
	    textAnchor: 'text-anchor',
	    viewBox: 'viewBox'
	  }
	};
	
	module.exports = SVGDOMPropertyConfig;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createFullPageComponent
	 * @typechecks
	 */
	
	'use strict';
	
	// Defeat circular references by requiring this directly.
	var ReactClass = __webpack_require__(39);
	var ReactElement = __webpack_require__(13);
	
	var invariant = __webpack_require__(9);
	
	/**
	 * Create a component that will throw an exception when unmounted.
	 *
	 * Components like <html> <head> and <body> can't be removed or added
	 * easily in a cross-browser way, however it's valuable to be able to
	 * take advantage of React's reconciliation for styling and <title>
	 * management. So we just document it and throw in dangerous cases.
	 *
	 * @param {string} tag The tag to wrap
	 * @return {function} convenience constructor of new component
	 */
	function createFullPageComponent(tag) {
	  var elementFactory = ReactElement.createFactory(tag);
	
	  var FullPageComponent = ReactClass.createClass({
	    tagName: tag.toUpperCase(),
	    displayName: 'ReactFullPageComponent' + tag,
	
	    componentWillUnmount: function() {
	      ("production" !== process.env.NODE_ENV ? invariant(
	        false,
	        '%s tried to unmount. Because of cross-browser quirks it is ' +
	        'impossible to unmount some top-level components (eg <html>, <head>, ' +
	        'and <body>) reliably and efficiently. To fix this, have a single ' +
	        'top-level component that never unmounts render these elements.',
	        this.constructor.displayName
	      ) : invariant(false));
	    },
	
	    render: function() {
	      return elementFactory(this.props);
	    }
	  });
	
	  return FullPageComponent;
	}
	
	module.exports = createFullPageComponent;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(46);
	var ReactDefaultPerfAnalysis = __webpack_require__(153);
	var ReactMount = __webpack_require__(69);
	var ReactPerf = __webpack_require__(30);
	
	var performanceNow = __webpack_require__(154);
	
	function roundFloat(val) {
	  return Math.floor(val * 100) / 100;
	}
	
	function addValue(obj, key, val) {
	  obj[key] = (obj[key] || 0) + val;
	}
	
	var ReactDefaultPerf = {
	  _allMeasurements: [], // last item in the list is the current one
	  _mountStack: [0],
	  _injected: false,
	
	  start: function() {
	    if (!ReactDefaultPerf._injected) {
	      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
	    }
	
	    ReactDefaultPerf._allMeasurements.length = 0;
	    ReactPerf.enableMeasure = true;
	  },
	
	  stop: function() {
	    ReactPerf.enableMeasure = false;
	  },
	
	  getLastMeasurements: function() {
	    return ReactDefaultPerf._allMeasurements;
	  },
	
	  printExclusive: function(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
	    console.table(summary.map(function(item) {
	      return {
	        'Component class name': item.componentName,
	        'Total inclusive time (ms)': roundFloat(item.inclusive),
	        'Exclusive mount time (ms)': roundFloat(item.exclusive),
	        'Exclusive render time (ms)': roundFloat(item.render),
	        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
	        'Render time per instance (ms)': roundFloat(item.render / item.count),
	        'Instances': item.count
	      };
	    }));
	    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
	    // number.
	  },
	
	  printInclusive: function(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
	    console.table(summary.map(function(item) {
	      return {
	        'Owner > component': item.componentName,
	        'Inclusive time (ms)': roundFloat(item.time),
	        'Instances': item.count
	      };
	    }));
	    console.log(
	      'Total time:',
	      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'
	    );
	  },
	
	  getMeasurementsSummaryMap: function(measurements) {
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(
	      measurements,
	      true
	    );
	    return summary.map(function(item) {
	      return {
	        'Owner > component': item.componentName,
	        'Wasted time (ms)': item.time,
	        'Instances': item.count
	      };
	    });
	  },
	
	  printWasted: function(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
	    console.log(
	      'Total time:',
	      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'
	    );
	  },
	
	  printDOM: function(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
	    console.table(summary.map(function(item) {
	      var result = {};
	      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
	      result['type'] = item.type;
	      result['args'] = JSON.stringify(item.args);
	      return result;
	    }));
	    console.log(
	      'Total time:',
	      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'
	    );
	  },
	
	  _recordWrite: function(id, fnName, totalTime, args) {
	    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
	    var writes =
	      ReactDefaultPerf
	        ._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1]
	        .writes;
	    writes[id] = writes[id] || [];
	    writes[id].push({
	      type: fnName,
	      time: totalTime,
	      args: args
	    });
	  },
	
	  measure: function(moduleName, fnName, func) {
	    return function() {for (var args=[],$__0=0,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);
	      var totalTime;
	      var rv;
	      var start;
	
	      if (fnName === '_renderNewRootComponent' ||
	          fnName === 'flushBatchedUpdates') {
	        // A "measurement" is a set of metrics recorded for each flush. We want
	        // to group the metrics for a given flush together so we can look at the
	        // components that rendered and the DOM operations that actually
	        // happened to determine the amount of "wasted work" performed.
	        ReactDefaultPerf._allMeasurements.push({
	          exclusive: {},
	          inclusive: {},
	          render: {},
	          counts: {},
	          writes: {},
	          displayNames: {},
	          totalTime: 0
	        });
	        start = performanceNow();
	        rv = func.apply(this, args);
	        ReactDefaultPerf._allMeasurements[
	          ReactDefaultPerf._allMeasurements.length - 1
	        ].totalTime = performanceNow() - start;
	        return rv;
	      } else if (fnName === '_mountImageIntoNode' ||
	          moduleName === 'ReactDOMIDOperations') {
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;
	
	        if (fnName === '_mountImageIntoNode') {
	          var mountID = ReactMount.getID(args[1]);
	          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
	        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
	          // special format
	          args[0].forEach(function(update) {
	            var writeArgs = {};
	            if (update.fromIndex !== null) {
	              writeArgs.fromIndex = update.fromIndex;
	            }
	            if (update.toIndex !== null) {
	              writeArgs.toIndex = update.toIndex;
	            }
	            if (update.textContent !== null) {
	              writeArgs.textContent = update.textContent;
	            }
	            if (update.markupIndex !== null) {
	              writeArgs.markup = args[1][update.markupIndex];
	            }
	            ReactDefaultPerf._recordWrite(
	              update.parentID,
	              update.type,
	              totalTime,
	              writeArgs
	            );
	          });
	        } else {
	          // basic format
	          ReactDefaultPerf._recordWrite(
	            args[0],
	            fnName,
	            totalTime,
	            Array.prototype.slice.call(args, 1)
	          );
	        }
	        return rv;
	      } else if (moduleName === 'ReactCompositeComponent' && (
	        (// TODO: receiveComponent()?
	        (fnName === 'mountComponent' ||
	        fnName === 'updateComponent' || fnName === '_renderValidatedComponent')))) {
	
	        if (typeof this._currentElement.type === 'string') {
	          return func.apply(this, args);
	        }
	
	        var rootNodeID = fnName === 'mountComponent' ?
	          args[0] :
	          this._rootNodeID;
	        var isRender = fnName === '_renderValidatedComponent';
	        var isMount = fnName === 'mountComponent';
	
	        var mountStack = ReactDefaultPerf._mountStack;
	        var entry = ReactDefaultPerf._allMeasurements[
	          ReactDefaultPerf._allMeasurements.length - 1
	        ];
	
	        if (isRender) {
	          addValue(entry.counts, rootNodeID, 1);
	        } else if (isMount) {
	          mountStack.push(0);
	        }
	
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;
	
	        if (isRender) {
	          addValue(entry.render, rootNodeID, totalTime);
	        } else if (isMount) {
	          var subMountTime = mountStack.pop();
	          mountStack[mountStack.length - 1] += totalTime;
	          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        } else {
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        }
	
	        entry.displayNames[rootNodeID] = {
	          current: this.getName(),
	          owner: this._currentElement._owner ?
	            this._currentElement._owner.getName() :
	            '<root>'
	        };
	
	        return rv;
	      } else {
	        return func.apply(this, args);
	      }
	    };
	  }
	};
	
	module.exports = ReactDefaultPerf;


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerfAnalysis
	 */
	
	var assign = __webpack_require__(15);
	
	// Don't try to save users less than 1.2ms (a number I made up)
	var DONT_CARE_THRESHOLD = 1.2;
	var DOM_OPERATION_TYPES = {
	  '_mountImageIntoNode': 'set innerHTML',
	  INSERT_MARKUP: 'set innerHTML',
	  MOVE_EXISTING: 'move',
	  REMOVE_NODE: 'remove',
	  TEXT_CONTENT: 'set textContent',
	  'updatePropertyByID': 'update attribute',
	  'deletePropertyByID': 'delete attribute',
	  'updateStylesByID': 'update styles',
	  'updateInnerHTMLByID': 'set innerHTML',
	  'dangerouslyReplaceNodeWithMarkupByID': 'replace'
	};
	
	function getTotalTime(measurements) {
	  // TODO: return number of DOM ops? could be misleading.
	  // TODO: measure dropped frames after reconcile?
	  // TODO: log total time of each reconcile and the top-level component
	  // class that triggered it.
	  var totalTime = 0;
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    totalTime += measurement.totalTime;
	  }
	  return totalTime;
	}
	
	function getDOMSummary(measurements) {
	  var items = [];
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var id;
	
	    for (id in measurement.writes) {
	      measurement.writes[id].forEach(function(write) {
	        items.push({
	          id: id,
	          type: DOM_OPERATION_TYPES[write.type] || write.type,
	          args: write.args
	        });
	      });
	    }
	  }
	  return items;
	}
	
	function getExclusiveSummary(measurements) {
	  var candidates = {};
	  var displayName;
	
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign(
	      {},
	      measurement.exclusive,
	      measurement.inclusive
	    );
	
	    for (var id in allIDs) {
	      displayName = measurement.displayNames[id].current;
	
	      candidates[displayName] = candidates[displayName] || {
	        componentName: displayName,
	        inclusive: 0,
	        exclusive: 0,
	        render: 0,
	        count: 0
	      };
	      if (measurement.render[id]) {
	        candidates[displayName].render += measurement.render[id];
	      }
	      if (measurement.exclusive[id]) {
	        candidates[displayName].exclusive += measurement.exclusive[id];
	      }
	      if (measurement.inclusive[id]) {
	        candidates[displayName].inclusive += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[displayName].count += measurement.counts[id];
	      }
	    }
	  }
	
	  // Now make a sorted array with the results.
	  var arr = [];
	  for (displayName in candidates) {
	    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[displayName]);
	    }
	  }
	
	  arr.sort(function(a, b) {
	    return b.exclusive - a.exclusive;
	  });
	
	  return arr;
	}
	
	function getInclusiveSummary(measurements, onlyClean) {
	  var candidates = {};
	  var inclusiveKey;
	
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign(
	      {},
	      measurement.exclusive,
	      measurement.inclusive
	    );
	    var cleanComponents;
	
	    if (onlyClean) {
	      cleanComponents = getUnchangedComponents(measurement);
	    }
	
	    for (var id in allIDs) {
	      if (onlyClean && !cleanComponents[id]) {
	        continue;
	      }
	
	      var displayName = measurement.displayNames[id];
	
	      // Inclusive time is not useful for many components without knowing where
	      // they are instantiated. So we aggregate inclusive time with both the
	      // owner and current displayName as the key.
	      inclusiveKey = displayName.owner + ' > ' + displayName.current;
	
	      candidates[inclusiveKey] = candidates[inclusiveKey] || {
	        componentName: inclusiveKey,
	        time: 0,
	        count: 0
	      };
	
	      if (measurement.inclusive[id]) {
	        candidates[inclusiveKey].time += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[inclusiveKey].count += measurement.counts[id];
	      }
	    }
	  }
	
	  // Now make a sorted array with the results.
	  var arr = [];
	  for (inclusiveKey in candidates) {
	    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[inclusiveKey]);
	    }
	  }
	
	  arr.sort(function(a, b) {
	    return b.time - a.time;
	  });
	
	  return arr;
	}
	
	function getUnchangedComponents(measurement) {
	  // For a given reconcile, look at which components did not actually
	  // render anything to the DOM and return a mapping of their ID to
	  // the amount of time it took to render the entire subtree.
	  var cleanComponents = {};
	  var dirtyLeafIDs = Object.keys(measurement.writes);
	  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	
	  for (var id in allIDs) {
	    var isDirty = false;
	    // For each component that rendered, see if a component that triggered
	    // a DOM op is in its subtree.
	    for (var i = 0; i < dirtyLeafIDs.length; i++) {
	      if (dirtyLeafIDs[i].indexOf(id) === 0) {
	        isDirty = true;
	        break;
	      }
	    }
	    if (!isDirty && measurement.counts[id] > 0) {
	      cleanComponents[id] = true;
	    }
	  }
	  return cleanComponents;
	}
	
	var ReactDefaultPerfAnalysis = {
	  getExclusiveSummary: getExclusiveSummary,
	  getInclusiveSummary: getInclusiveSummary,
	  getDOMSummary: getDOMSummary,
	  getTotalTime: getTotalTime
	};
	
	module.exports = ReactDefaultPerfAnalysis;


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performanceNow
	 * @typechecks
	 */
	
	var performance = __webpack_require__(155);
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (!performance || !performance.now) {
	  performance = Date;
	}
	
	var performanceNow = performance.now.bind(performance);
	
	module.exports = performanceNow;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performance
	 * @typechecks
	 */
	
	"use strict";
	
	var ExecutionEnvironment = __webpack_require__(53);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance =
	    window.performance ||
	    window.msPerformance ||
	    window.webkitPerformance;
	}
	
	module.exports = performance || {};


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 * @providesModule ReactServerRendering
	 */
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	var ReactInstanceHandles = __webpack_require__(21);
	var ReactMarkupChecksum = __webpack_require__(79);
	var ReactServerRenderingTransaction =
	  __webpack_require__(157);
	
	var emptyObject = __webpack_require__(16);
	var instantiateReactComponent = __webpack_require__(85);
	var invariant = __webpack_require__(9);
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup
	 */
	function renderToString(element) {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    ReactElement.isValidElement(element),
	    'renderToString(): You must pass a valid ReactElement.'
	  ) : invariant(ReactElement.isValidElement(element)));
	
	  var transaction;
	  try {
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(false);
	
	    return transaction.perform(function() {
	      var componentInstance = instantiateReactComponent(element, null);
	      var markup =
	        componentInstance.mountComponent(id, transaction, emptyObject);
	      return ReactMarkupChecksum.addChecksumToMarkup(markup);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	  }
	}
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup, without the extra React ID and checksum
	 * (for generating static pages)
	 */
	function renderToStaticMarkup(element) {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    ReactElement.isValidElement(element),
	    'renderToStaticMarkup(): You must pass a valid ReactElement.'
	  ) : invariant(ReactElement.isValidElement(element)));
	
	  var transaction;
	  try {
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(true);
	
	    return transaction.perform(function() {
	      var componentInstance = instantiateReactComponent(element, null);
	      return componentInstance.mountComponent(id, transaction, emptyObject);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	  }
	}
	
	module.exports = {
	  renderToString: renderToString,
	  renderToStaticMarkup: renderToStaticMarkup
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 * @typechecks
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(11);
	var CallbackQueue = __webpack_require__(29);
	var ReactPutListenerQueue = __webpack_require__(137);
	var Transaction = __webpack_require__(38);
	
	var assign = __webpack_require__(15);
	var emptyFunction = __webpack_require__(18);
	
	/**
	 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
	 * during the performing of the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function() {
	    this.reactMountReady.reset();
	  },
	
	  close: emptyFunction
	};
	
	var PUT_LISTENER_QUEUEING = {
	  initialize: function() {
	    this.putListenerQueue.reset();
	  },
	
	  close: emptyFunction
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [
	  PUT_LISTENER_QUEUEING,
	  ON_DOM_READY_QUEUEING
	];
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.putListenerQueue = ReactPutListenerQueue.getPooled();
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap proceedures.
	   */
	  getTransactionWrappers: function() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function() {
	    return this.reactMountReady;
	  },
	
	  getPutListenerQueue: function() {
	    return this.putListenerQueue;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be resused.
	   */
	  destructor: function() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	
	    ReactPutListenerQueue.release(this.putListenerQueue);
	    this.putListenerQueue = null;
	  }
	};
	
	
	assign(
	  ReactServerRenderingTransaction.prototype,
	  Transaction.Mixin,
	  Mixin
	);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	
	var invariant = __webpack_require__(9);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection. The current implementation of this
	 * function assumes that a single child gets passed without a wrapper, but the
	 * purpose of this helper function is to abstract away the particular structure
	 * of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactComponent} The first and only `ReactComponent` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  ("production" !== process.env.NODE_ENV ? invariant(
	    ReactElement.isValidElement(children),
	    'onlyChild must be passed a children with exactly one child.'
	  ) : invariant(ReactElement.isValidElement(children)));
	  return children;
	}
	
	module.exports = onlyChild;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(160);
	
	var Counter = (function (_Component) {
	  _inherits(Counter, _Component);
	
	  function Counter() {
	    _classCallCheck(this, Counter);
	
	    _get(Object.getPrototypeOf(Counter.prototype), "constructor", this).apply(this, arguments);
	  }
	
	  _createClass(Counter, [{
	    key: "render",
	    value: function render() {
	      var _props = this.props;
	      var value = _props.value;
	      var actions = _props.actions;
	
	      return _react2["default"].createElement(
	        "p",
	        { className: "example-counter" },
	        _react2["default"].createElement("i", { className: "glyphicon glyphicon-minus", onClick: function (e) {
	            return actions.decCounter();
	          } }),
	        " ",
	        value,
	        " ",
	        _react2["default"].createElement("i", { className: "glyphicon glyphicon-plus", onClick: function (e) {
	            return actions.incCounter();
	          } })
	      );
	    }
	  }]);
	
	  return Counter;
	})(_react.Component);
	
	exports["default"] = Counter;
	
	Counter.propTypes = {
	  actions: _react.PropTypes.shape({
	    incCounter: _react.PropTypes.func.isRequired,
	    decCounter: _react.PropTypes.func.isRequired
	  }).isRequired
	};
	module.exports = exports["default"];

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(161);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(163)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/less-loader/index.js!./style.less", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/less-loader/index.js!./style.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(162)();
	// imports
	
	
	// module
	exports.push([module.id, ".example-counter .glyphicon {\n  cursor: pointer;\n}\n", ""]);
	
	// exports


/***/ },
/* 162 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0;
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function createStyleElement() {
		var styleElement = document.createElement("style");
		var head = getHeadElement();
		styleElement.type = "text/css";
		head.appendChild(styleElement);
		return styleElement;
	}
	
	function createLinkElement() {
		var linkElement = document.createElement("link");
		var head = getHeadElement();
		linkElement.rel = "stylesheet";
		head.appendChild(linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement());
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement();
			update = updateLink.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement();
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(165);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(163)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./style.less", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./style.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(162)();
	// imports
	
	
	// module
	exports.push([module.id, ".jumbotron {\n  margin-top: 10px;\n}\n", ""]);
	
	// exports


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _dispatcher = __webpack_require__(167);
	
	var _dispatcher2 = _interopRequireDefault(_dispatcher);
	
	var _actions = __webpack_require__(169);
	
	var _actions2 = _interopRequireDefault(_actions);
	
	var _storesGlobalState = __webpack_require__(171);
	
	var _storesGlobalState2 = _interopRequireDefault(_storesGlobalState);
	
	_dispatcher2["default"].registerStores({
	  globalState: _storesGlobalState2["default"]
	});
	
	exports["default"] = {
	  actions: _actions2["default"],
	  onUpdate: function onUpdate(cb) {
	    var trigger = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	    _dispatcher2["default"].observe([], cb);
	    if (trigger) cb(_dispatcher2["default"].evaluate([]));
	  }
	};
	module.exports = exports["default"];

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _nuclearJs = __webpack_require__(168);
	
	exports["default"] = new _nuclearJs.Reactor({
	  debug: localStorage && !!localStorage.debug
	});
	module.exports = exports["default"];

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define(factory);
		else if(typeof exports === 'object')
			exports["Nuclear"] = factory();
		else
			root["Nuclear"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	
	
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		var helpers = __webpack_require__(1)
	
		/**
		 * @return {Reactor}
		 */
		exports.Reactor = __webpack_require__(4)
	
		/**
		 * @return {Store}
		 */
		exports.Store = __webpack_require__(13)
	
		// export the immutable library
		exports.Immutable = __webpack_require__(2)
	
		/**
		 * @return {boolean}
		 */
		exports.isKeyPath = __webpack_require__(10).isKeyPath
	
		/**
		 * @return {boolean}
		 */
		exports.isGetter = __webpack_require__(9).isGetter
	
		// expose helper functions
		exports.toJS = helpers.toJS
		exports.toImmutable = helpers.toImmutable
		exports.isImmutable = helpers.isImmutable
	
		exports.createReactMixin = __webpack_require__(12)
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Immutable = __webpack_require__(2)
		var isObject = __webpack_require__(3).isObject
	
		/**
		 * A collection of helpers for the ImmutableJS library
		 */
	
		/**
		 * @param {*} obj
		 * @return {boolean}
		 */
		function isImmutable(obj) {
		  return Immutable.Iterable.isIterable(obj)
		}
	
		/**
		 * Returns true if the value is an ImmutableJS data structure
		 * or a JavaScript primitive that is immutable (string, number, etc)
		 * @param {*} obj
		 * @return {boolean}
		 */
		function isImmutableValue(obj) {
		  return (
		    isImmutable(obj) ||
		    !isObject(obj)
		  )
		}
	
		/**
		 * Converts an Immutable Sequence to JS object
		 * Can be called on any type
		 */
		function toJS(arg) {
		  // arg instanceof Immutable.Sequence is unreliable
		  return (isImmutable(arg))
		    ? arg.toJS()
		    : arg
		}
	
		/**
		 * Converts a JS object to an Immutable object, if it's
		 * already Immutable its a no-op
		 */
		function toImmutable(arg) {
		  return (isImmutable(arg))
		    ? arg
		    : Immutable.fromJS(arg)
		}
	
		exports.toJS = toJS
		exports.toImmutable = toImmutable
		exports.isImmutable = isImmutable
		exports.isImmutableValue = isImmutableValue
	
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 *  Copyright (c) 2014-2015, Facebook, Inc.
		 *  All rights reserved.
		 *
		 *  This source code is licensed under the BSD-style license found in the
		 *  LICENSE file in the root directory of this source tree. An additional grant
		 *  of patent rights can be found in the PATENTS file in the same directory.
		 */
		(function (global, factory) {
		  true ? module.exports = factory() :
		  typeof define === 'function' && define.amd ? define(factory) :
		  global.Immutable = factory()
		}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;
	
		  function createClass(ctor, superClass) {
		    if (superClass) {
		      ctor.prototype = Object.create(superClass.prototype);
		    }
		    ctor.prototype.constructor = ctor;
		  }
	
		  // Used for setting prototype methods that IE8 chokes on.
		  var DELETE = 'delete';
	
		  // Constants describing the size of trie nodes.
		  var SHIFT = 5; // Resulted in best performance after ______?
		  var SIZE = 1 << SHIFT;
		  var MASK = SIZE - 1;
	
		  // A consistent shared value representing "not set" which equals nothing other
		  // than itself, and nothing that could be provided externally.
		  var NOT_SET = {};
	
		  // Boolean references, Rough equivalent of `bool &`.
		  var CHANGE_LENGTH = { value: false };
		  var DID_ALTER = { value: false };
	
		  function MakeRef(ref) {
		    ref.value = false;
		    return ref;
		  }
	
		  function SetRef(ref) {
		    ref && (ref.value = true);
		  }
	
		  // A function which returns a value representing an "owner" for transient writes
		  // to tries. The return value will only ever equal itself, and will not equal
		  // the return of any subsequent call of this function.
		  function OwnerID() {}
	
		  // http://jsperf.com/copy-array-inline
		  function arrCopy(arr, offset) {
		    offset = offset || 0;
		    var len = Math.max(0, arr.length - offset);
		    var newArr = new Array(len);
		    for (var ii = 0; ii < len; ii++) {
		      newArr[ii] = arr[ii + offset];
		    }
		    return newArr;
		  }
	
		  function ensureSize(iter) {
		    if (iter.size === undefined) {
		      iter.size = iter.__iterate(returnTrue);
		    }
		    return iter.size;
		  }
	
		  function wrapIndex(iter, index) {
		    return index >= 0 ? (+index) : ensureSize(iter) + (+index);
		  }
	
		  function returnTrue() {
		    return true;
		  }
	
		  function wholeSlice(begin, end, size) {
		    return (begin === 0 || (size !== undefined && begin <= -size)) &&
		      (end === undefined || (size !== undefined && end >= size));
		  }
	
		  function resolveBegin(begin, size) {
		    return resolveIndex(begin, size, 0);
		  }
	
		  function resolveEnd(end, size) {
		    return resolveIndex(end, size, size);
		  }
	
		  function resolveIndex(index, size, defaultIndex) {
		    return index === undefined ?
		      defaultIndex :
		      index < 0 ?
		        Math.max(0, size + index) :
		        size === undefined ?
		          index :
		          Math.min(size, index);
		  }
	
		  function Iterable(value) {
		      return isIterable(value) ? value : Seq(value);
		    }
	
	
		  createClass(KeyedIterable, Iterable);
		    function KeyedIterable(value) {
		      return isKeyed(value) ? value : KeyedSeq(value);
		    }
	
	
		  createClass(IndexedIterable, Iterable);
		    function IndexedIterable(value) {
		      return isIndexed(value) ? value : IndexedSeq(value);
		    }
	
	
		  createClass(SetIterable, Iterable);
		    function SetIterable(value) {
		      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
		    }
	
	
	
		  function isIterable(maybeIterable) {
		    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
		  }
	
		  function isKeyed(maybeKeyed) {
		    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
		  }
	
		  function isIndexed(maybeIndexed) {
		    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
		  }
	
		  function isAssociative(maybeAssociative) {
		    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
		  }
	
		  function isOrdered(maybeOrdered) {
		    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
		  }
	
		  Iterable.isIterable = isIterable;
		  Iterable.isKeyed = isKeyed;
		  Iterable.isIndexed = isIndexed;
		  Iterable.isAssociative = isAssociative;
		  Iterable.isOrdered = isOrdered;
	
		  Iterable.Keyed = KeyedIterable;
		  Iterable.Indexed = IndexedIterable;
		  Iterable.Set = SetIterable;
	
	
		  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
		  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
		  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
		  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
		  /* global Symbol */
	
		  var ITERATE_KEYS = 0;
		  var ITERATE_VALUES = 1;
		  var ITERATE_ENTRIES = 2;
	
		  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
		  var FAUX_ITERATOR_SYMBOL = '@@iterator';
	
		  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
	
	
		  function src_Iterator__Iterator(next) {
		      this.next = next;
		    }
	
		    src_Iterator__Iterator.prototype.toString = function() {
		      return '[Iterator]';
		    };
	
	
		  src_Iterator__Iterator.KEYS = ITERATE_KEYS;
		  src_Iterator__Iterator.VALUES = ITERATE_VALUES;
		  src_Iterator__Iterator.ENTRIES = ITERATE_ENTRIES;
	
		  src_Iterator__Iterator.prototype.inspect =
		  src_Iterator__Iterator.prototype.toSource = function () { return this.toString(); }
		  src_Iterator__Iterator.prototype[ITERATOR_SYMBOL] = function () {
		    return this;
		  };
	
	
		  function iteratorValue(type, k, v, iteratorResult) {
		    var value = type === 0 ? k : type === 1 ? v : [k, v];
		    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
		      value: value, done: false
		    });
		    return iteratorResult;
		  }
	
		  function iteratorDone() {
		    return { value: undefined, done: true };
		  }
	
		  function hasIterator(maybeIterable) {
		    return !!getIteratorFn(maybeIterable);
		  }
	
		  function isIterator(maybeIterator) {
		    return maybeIterator && typeof maybeIterator.next === 'function';
		  }
	
		  function getIterator(iterable) {
		    var iteratorFn = getIteratorFn(iterable);
		    return iteratorFn && iteratorFn.call(iterable);
		  }
	
		  function getIteratorFn(iterable) {
		    var iteratorFn = iterable && (
		      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
		      iterable[FAUX_ITERATOR_SYMBOL]
		    );
		    if (typeof iteratorFn === 'function') {
		      return iteratorFn;
		    }
		  }
	
		  function isArrayLike(value) {
		    return value && typeof value.length === 'number';
		  }
	
		  createClass(Seq, Iterable);
		    function Seq(value) {
		      return value === null || value === undefined ? emptySequence() :
		        isIterable(value) ? value.toSeq() : seqFromValue(value);
		    }
	
		    Seq.of = function(/*...values*/) {
		      return Seq(arguments);
		    };
	
		    Seq.prototype.toSeq = function() {
		      return this;
		    };
	
		    Seq.prototype.toString = function() {
		      return this.__toString('Seq {', '}');
		    };
	
		    Seq.prototype.cacheResult = function() {
		      if (!this._cache && this.__iterateUncached) {
		        this._cache = this.entrySeq().toArray();
		        this.size = this._cache.length;
		      }
		      return this;
		    };
	
		    // abstract __iterateUncached(fn, reverse)
	
		    Seq.prototype.__iterate = function(fn, reverse) {
		      return seqIterate(this, fn, reverse, true);
		    };
	
		    // abstract __iteratorUncached(type, reverse)
	
		    Seq.prototype.__iterator = function(type, reverse) {
		      return seqIterator(this, type, reverse, true);
		    };
	
	
	
		  createClass(KeyedSeq, Seq);
		    function KeyedSeq(value) {
		      return value === null || value === undefined ?
		        emptySequence().toKeyedSeq() :
		        isIterable(value) ?
		          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
		          keyedSeqFromValue(value);
		    }
	
		    KeyedSeq.prototype.toKeyedSeq = function() {
		      return this;
		    };
	
	
	
		  createClass(IndexedSeq, Seq);
		    function IndexedSeq(value) {
		      return value === null || value === undefined ? emptySequence() :
		        !isIterable(value) ? indexedSeqFromValue(value) :
		        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
		    }
	
		    IndexedSeq.of = function(/*...values*/) {
		      return IndexedSeq(arguments);
		    };
	
		    IndexedSeq.prototype.toIndexedSeq = function() {
		      return this;
		    };
	
		    IndexedSeq.prototype.toString = function() {
		      return this.__toString('Seq [', ']');
		    };
	
		    IndexedSeq.prototype.__iterate = function(fn, reverse) {
		      return seqIterate(this, fn, reverse, false);
		    };
	
		    IndexedSeq.prototype.__iterator = function(type, reverse) {
		      return seqIterator(this, type, reverse, false);
		    };
	
	
	
		  createClass(SetSeq, Seq);
		    function SetSeq(value) {
		      return (
		        value === null || value === undefined ? emptySequence() :
		        !isIterable(value) ? indexedSeqFromValue(value) :
		        isKeyed(value) ? value.entrySeq() : value
		      ).toSetSeq();
		    }
	
		    SetSeq.of = function(/*...values*/) {
		      return SetSeq(arguments);
		    };
	
		    SetSeq.prototype.toSetSeq = function() {
		      return this;
		    };
	
	
	
		  Seq.isSeq = isSeq;
		  Seq.Keyed = KeyedSeq;
		  Seq.Set = SetSeq;
		  Seq.Indexed = IndexedSeq;
	
		  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
	
		  Seq.prototype[IS_SEQ_SENTINEL] = true;
	
	
	
		  // #pragma Root Sequences
	
		  createClass(ArraySeq, IndexedSeq);
		    function ArraySeq(array) {
		      this._array = array;
		      this.size = array.length;
		    }
	
		    ArraySeq.prototype.get = function(index, notSetValue) {
		      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
		    };
	
		    ArraySeq.prototype.__iterate = function(fn, reverse) {
		      var array = this._array;
		      var maxIndex = array.length - 1;
		      for (var ii = 0; ii <= maxIndex; ii++) {
		        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
		          return ii + 1;
		        }
		      }
		      return ii;
		    };
	
		    ArraySeq.prototype.__iterator = function(type, reverse) {
		      var array = this._array;
		      var maxIndex = array.length - 1;
		      var ii = 0;
		      return new src_Iterator__Iterator(function() 
		        {return ii > maxIndex ?
		          iteratorDone() :
		          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
		      );
		    };
	
	
	
		  createClass(ObjectSeq, KeyedSeq);
		    function ObjectSeq(object) {
		      var keys = Object.keys(object);
		      this._object = object;
		      this._keys = keys;
		      this.size = keys.length;
		    }
	
		    ObjectSeq.prototype.get = function(key, notSetValue) {
		      if (notSetValue !== undefined && !this.has(key)) {
		        return notSetValue;
		      }
		      return this._object[key];
		    };
	
		    ObjectSeq.prototype.has = function(key) {
		      return this._object.hasOwnProperty(key);
		    };
	
		    ObjectSeq.prototype.__iterate = function(fn, reverse) {
		      var object = this._object;
		      var keys = this._keys;
		      var maxIndex = keys.length - 1;
		      for (var ii = 0; ii <= maxIndex; ii++) {
		        var key = keys[reverse ? maxIndex - ii : ii];
		        if (fn(object[key], key, this) === false) {
		          return ii + 1;
		        }
		      }
		      return ii;
		    };
	
		    ObjectSeq.prototype.__iterator = function(type, reverse) {
		      var object = this._object;
		      var keys = this._keys;
		      var maxIndex = keys.length - 1;
		      var ii = 0;
		      return new src_Iterator__Iterator(function()  {
		        var key = keys[reverse ? maxIndex - ii : ii];
		        return ii++ > maxIndex ?
		          iteratorDone() :
		          iteratorValue(type, key, object[key]);
		      });
		    };
	
		  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
	
	
		  createClass(IterableSeq, IndexedSeq);
		    function IterableSeq(iterable) {
		      this._iterable = iterable;
		      this.size = iterable.length || iterable.size;
		    }
	
		    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var iterable = this._iterable;
		      var iterator = getIterator(iterable);
		      var iterations = 0;
		      if (isIterator(iterator)) {
		        var step;
		        while (!(step = iterator.next()).done) {
		          if (fn(step.value, iterations++, this) === false) {
		            break;
		          }
		        }
		      }
		      return iterations;
		    };
	
		    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
		      if (reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      var iterable = this._iterable;
		      var iterator = getIterator(iterable);
		      if (!isIterator(iterator)) {
		        return new src_Iterator__Iterator(iteratorDone);
		      }
		      var iterations = 0;
		      return new src_Iterator__Iterator(function()  {
		        var step = iterator.next();
		        return step.done ? step : iteratorValue(type, iterations++, step.value);
		      });
		    };
	
	
	
		  createClass(IteratorSeq, IndexedSeq);
		    function IteratorSeq(iterator) {
		      this._iterator = iterator;
		      this._iteratorCache = [];
		    }
	
		    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var iterator = this._iterator;
		      var cache = this._iteratorCache;
		      var iterations = 0;
		      while (iterations < cache.length) {
		        if (fn(cache[iterations], iterations++, this) === false) {
		          return iterations;
		        }
		      }
		      var step;
		      while (!(step = iterator.next()).done) {
		        var val = step.value;
		        cache[iterations] = val;
		        if (fn(val, iterations++, this) === false) {
		          break;
		        }
		      }
		      return iterations;
		    };
	
		    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
		      if (reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      var iterator = this._iterator;
		      var cache = this._iteratorCache;
		      var iterations = 0;
		      return new src_Iterator__Iterator(function()  {
		        if (iterations >= cache.length) {
		          var step = iterator.next();
		          if (step.done) {
		            return step;
		          }
		          cache[iterations] = step.value;
		        }
		        return iteratorValue(type, iterations, cache[iterations++]);
		      });
		    };
	
	
	
	
		  // # pragma Helper functions
	
		  function isSeq(maybeSeq) {
		    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
		  }
	
		  var EMPTY_SEQ;
	
		  function emptySequence() {
		    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
		  }
	
		  function keyedSeqFromValue(value) {
		    var seq =
		      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
		      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
		      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
		      typeof value === 'object' ? new ObjectSeq(value) :
		      undefined;
		    if (!seq) {
		      throw new TypeError(
		        'Expected Array or iterable object of [k, v] entries, '+
		        'or keyed object: ' + value
		      );
		    }
		    return seq;
		  }
	
		  function indexedSeqFromValue(value) {
		    var seq = maybeIndexedSeqFromValue(value);
		    if (!seq) {
		      throw new TypeError(
		        'Expected Array or iterable object of values: ' + value
		      );
		    }
		    return seq;
		  }
	
		  function seqFromValue(value) {
		    var seq = maybeIndexedSeqFromValue(value) ||
		      (typeof value === 'object' && new ObjectSeq(value));
		    if (!seq) {
		      throw new TypeError(
		        'Expected Array or iterable object of values, or keyed object: ' + value
		      );
		    }
		    return seq;
		  }
	
		  function maybeIndexedSeqFromValue(value) {
		    return (
		      isArrayLike(value) ? new ArraySeq(value) :
		      isIterator(value) ? new IteratorSeq(value) :
		      hasIterator(value) ? new IterableSeq(value) :
		      undefined
		    );
		  }
	
		  function seqIterate(seq, fn, reverse, useKeys) {
		    var cache = seq._cache;
		    if (cache) {
		      var maxIndex = cache.length - 1;
		      for (var ii = 0; ii <= maxIndex; ii++) {
		        var entry = cache[reverse ? maxIndex - ii : ii];
		        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
		          return ii + 1;
		        }
		      }
		      return ii;
		    }
		    return seq.__iterateUncached(fn, reverse);
		  }
	
		  function seqIterator(seq, type, reverse, useKeys) {
		    var cache = seq._cache;
		    if (cache) {
		      var maxIndex = cache.length - 1;
		      var ii = 0;
		      return new src_Iterator__Iterator(function()  {
		        var entry = cache[reverse ? maxIndex - ii : ii];
		        return ii++ > maxIndex ?
		          iteratorDone() :
		          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
		      });
		    }
		    return seq.__iteratorUncached(type, reverse);
		  }
	
		  createClass(Collection, Iterable);
		    function Collection() {
		      throw TypeError('Abstract');
		    }
	
	
		  createClass(KeyedCollection, Collection);function KeyedCollection() {}
	
		  createClass(IndexedCollection, Collection);function IndexedCollection() {}
	
		  createClass(SetCollection, Collection);function SetCollection() {}
	
	
		  Collection.Keyed = KeyedCollection;
		  Collection.Indexed = IndexedCollection;
		  Collection.Set = SetCollection;
	
		  /**
		   * An extension of the "same-value" algorithm as [described for use by ES6 Map
		   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
		   *
		   * NaN is considered the same as NaN, however -0 and 0 are considered the same
		   * value, which is different from the algorithm described by
		   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
		   *
		   * This is extended further to allow Objects to describe the values they
		   * represent, by way of `valueOf` or `equals` (and `hashCode`).
		   *
		   * Note: because of this extension, the key equality of Immutable.Map and the
		   * value equality of Immutable.Set will differ from ES6 Map and Set.
		   *
		   * ### Defining custom values
		   *
		   * The easiest way to describe the value an object represents is by implementing
		   * `valueOf`. For example, `Date` represents a value by returning a unix
		   * timestamp for `valueOf`:
		   *
		   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
		   *     var date2 = new Date(1234567890000);
		   *     date1.valueOf(); // 1234567890000
		   *     assert( date1 !== date2 );
		   *     assert( Immutable.is( date1, date2 ) );
		   *
		   * Note: overriding `valueOf` may have other implications if you use this object
		   * where JavaScript expects a primitive, such as implicit string coercion.
		   *
		   * For more complex types, especially collections, implementing `valueOf` may
		   * not be performant. An alternative is to implement `equals` and `hashCode`.
		   *
		   * `equals` takes another object, presumably of similar type, and returns true
		   * if the it is equal. Equality is symmetrical, so the same result should be
		   * returned if this and the argument are flipped.
		   *
		   *     assert( a.equals(b) === b.equals(a) );
		   *
		   * `hashCode` returns a 32bit integer number representing the object which will
		   * be used to determine how to store the value object in a Map or Set. You must
		   * provide both or neither methods, one must not exist without the other.
		   *
		   * Also, an important relationship between these methods must be upheld: if two
		   * values are equal, they *must* return the same hashCode. If the values are not
		   * equal, they might have the same hashCode; this is called a hash collision,
		   * and while undesirable for performance reasons, it is acceptable.
		   *
		   *     if (a.equals(b)) {
		   *       assert( a.hashCode() === b.hashCode() );
		   *     }
		   *
		   * All Immutable collections implement `equals` and `hashCode`.
		   *
		   */
		  function is(valueA, valueB) {
		    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
		      return true;
		    }
		    if (!valueA || !valueB) {
		      return false;
		    }
		    if (typeof valueA.valueOf === 'function' &&
		        typeof valueB.valueOf === 'function') {
		      valueA = valueA.valueOf();
		      valueB = valueB.valueOf();
		      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
		        return true;
		      }
		      if (!valueA || !valueB) {
		        return false;
		      }
		    }
		    if (typeof valueA.equals === 'function' &&
		        typeof valueB.equals === 'function' &&
		        valueA.equals(valueB)) {
		      return true;
		    }
		    return false;
		  }
	
		  function fromJS(json, converter) {
		    return converter ?
		      fromJSWith(converter, json, '', {'': json}) :
		      fromJSDefault(json);
		  }
	
		  function fromJSWith(converter, json, key, parentJSON) {
		    if (Array.isArray(json)) {
		      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
		    }
		    if (isPlainObj(json)) {
		      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
		    }
		    return json;
		  }
	
		  function fromJSDefault(json) {
		    if (Array.isArray(json)) {
		      return IndexedSeq(json).map(fromJSDefault).toList();
		    }
		    if (isPlainObj(json)) {
		      return KeyedSeq(json).map(fromJSDefault).toMap();
		    }
		    return json;
		  }
	
		  function isPlainObj(value) {
		    return value && (value.constructor === Object || value.constructor === undefined);
		  }
	
		  var src_Math__imul =
		    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
		    Math.imul :
		    function src_Math__imul(a, b) {
		      a = a | 0; // int
		      b = b | 0; // int
		      var c = a & 0xffff;
		      var d = b & 0xffff;
		      // Shift by 0 fixes the sign on the high part.
		      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
		    };
	
		  // v8 has an optimization for storing 31-bit signed numbers.
		  // Values which have either 00 or 11 as the high order bits qualify.
		  // This function drops the highest order bit in a signed number, maintaining
		  // the sign bit.
		  function smi(i32) {
		    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
		  }
	
		  function hash(o) {
		    if (o === false || o === null || o === undefined) {
		      return 0;
		    }
		    if (typeof o.valueOf === 'function') {
		      o = o.valueOf();
		      if (o === false || o === null || o === undefined) {
		        return 0;
		      }
		    }
		    if (o === true) {
		      return 1;
		    }
		    var type = typeof o;
		    if (type === 'number') {
		      var h = o | 0;
		      if (h !== o) {
		        h ^= o * 0xFFFFFFFF;
		      }
		      while (o > 0xFFFFFFFF) {
		        o /= 0xFFFFFFFF;
		        h ^= o;
		      }
		      return smi(h);
		    }
		    if (type === 'string') {
		      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
		    }
		    if (typeof o.hashCode === 'function') {
		      return o.hashCode();
		    }
		    return hashJSObj(o);
		  }
	
		  function cachedHashString(string) {
		    var hash = stringHashCache[string];
		    if (hash === undefined) {
		      hash = hashString(string);
		      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
		        STRING_HASH_CACHE_SIZE = 0;
		        stringHashCache = {};
		      }
		      STRING_HASH_CACHE_SIZE++;
		      stringHashCache[string] = hash;
		    }
		    return hash;
		  }
	
		  // http://jsperf.com/hashing-strings
		  function hashString(string) {
		    // This is the hash from JVM
		    // The hash code for a string is computed as
		    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
		    // where s[i] is the ith character of the string and n is the length of
		    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
		    // (exclusive) by dropping high bits.
		    var hash = 0;
		    for (var ii = 0; ii < string.length; ii++) {
		      hash = 31 * hash + string.charCodeAt(ii) | 0;
		    }
		    return smi(hash);
		  }
	
		  function hashJSObj(obj) {
		    var hash;
		    if (usingWeakMap) {
		      hash = weakMap.get(obj);
		      if (hash !== undefined) {
		        return hash;
		      }
		    }
	
		    hash = obj[UID_HASH_KEY];
		    if (hash !== undefined) {
		      return hash;
		    }
	
		    if (!canDefineProperty) {
		      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
		      if (hash !== undefined) {
		        return hash;
		      }
	
		      hash = getIENodeHash(obj);
		      if (hash !== undefined) {
		        return hash;
		      }
		    }
	
		    hash = ++objHashUID;
		    if (objHashUID & 0x40000000) {
		      objHashUID = 0;
		    }
	
		    if (usingWeakMap) {
		      weakMap.set(obj, hash);
		    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
		      throw new Error('Non-extensible objects are not allowed as keys.');
		    } else if (canDefineProperty) {
		      Object.defineProperty(obj, UID_HASH_KEY, {
		        'enumerable': false,
		        'configurable': false,
		        'writable': false,
		        'value': hash
		      });
		    } else if (obj.propertyIsEnumerable !== undefined &&
		               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
		      // Since we can't define a non-enumerable property on the object
		      // we'll hijack one of the less-used non-enumerable properties to
		      // save our hash on it. Since this is a function it will not show up in
		      // `JSON.stringify` which is what we want.
		      obj.propertyIsEnumerable = function() {
		        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
		      };
		      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
		    } else if (obj.nodeType !== undefined) {
		      // At this point we couldn't get the IE `uniqueID` to use as a hash
		      // and we couldn't use a non-enumerable property to exploit the
		      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
		      // itself.
		      obj[UID_HASH_KEY] = hash;
		    } else {
		      throw new Error('Unable to set a non-enumerable property on object.');
		    }
	
		    return hash;
		  }
	
		  // Get references to ES5 object methods.
		  var isExtensible = Object.isExtensible;
	
		  // True if Object.defineProperty works as expected. IE8 fails this test.
		  var canDefineProperty = (function() {
		    try {
		      Object.defineProperty({}, '@', {});
		      return true;
		    } catch (e) {
		      return false;
		    }
		  }());
	
		  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
		  // and avoid memory leaks from the IE cloneNode bug.
		  function getIENodeHash(node) {
		    if (node && node.nodeType > 0) {
		      switch (node.nodeType) {
		        case 1: // Element
		          return node.uniqueID;
		        case 9: // Document
		          return node.documentElement && node.documentElement.uniqueID;
		      }
		    }
		  }
	
		  // If possible, use a WeakMap.
		  var usingWeakMap = typeof WeakMap === 'function';
		  var weakMap;
		  if (usingWeakMap) {
		    weakMap = new WeakMap();
		  }
	
		  var objHashUID = 0;
	
		  var UID_HASH_KEY = '__immutablehash__';
		  if (typeof Symbol === 'function') {
		    UID_HASH_KEY = Symbol(UID_HASH_KEY);
		  }
	
		  var STRING_HASH_CACHE_MIN_STRLEN = 16;
		  var STRING_HASH_CACHE_MAX_SIZE = 255;
		  var STRING_HASH_CACHE_SIZE = 0;
		  var stringHashCache = {};
	
		  function invariant(condition, error) {
		    if (!condition) throw new Error(error);
		  }
	
		  function assertNotInfinite(size) {
		    invariant(
		      size !== Infinity,
		      'Cannot perform this action with an infinite size.'
		    );
		  }
	
		  createClass(ToKeyedSequence, KeyedSeq);
		    function ToKeyedSequence(indexed, useKeys) {
		      this._iter = indexed;
		      this._useKeys = useKeys;
		      this.size = indexed.size;
		    }
	
		    ToKeyedSequence.prototype.get = function(key, notSetValue) {
		      return this._iter.get(key, notSetValue);
		    };
	
		    ToKeyedSequence.prototype.has = function(key) {
		      return this._iter.has(key);
		    };
	
		    ToKeyedSequence.prototype.valueSeq = function() {
		      return this._iter.valueSeq();
		    };
	
		    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
		      var reversedSequence = reverseFactory(this, true);
		      if (!this._useKeys) {
		        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
		      }
		      return reversedSequence;
		    };
	
		    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
		      var mappedSequence = mapFactory(this, mapper, context);
		      if (!this._useKeys) {
		        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
		      }
		      return mappedSequence;
		    };
	
		    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      var ii;
		      return this._iter.__iterate(
		        this._useKeys ?
		          function(v, k)  {return fn(v, k, this$0)} :
		          ((ii = reverse ? resolveSize(this) : 0),
		            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
		        reverse
		      );
		    };
	
		    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
		      if (this._useKeys) {
		        return this._iter.__iterator(type, reverse);
		      }
		      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
		      var ii = reverse ? resolveSize(this) : 0;
		      return new src_Iterator__Iterator(function()  {
		        var step = iterator.next();
		        return step.done ? step :
		          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
		      });
		    };
	
		  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
	
	
		  createClass(ToIndexedSequence, IndexedSeq);
		    function ToIndexedSequence(iter) {
		      this._iter = iter;
		      this.size = iter.size;
		    }
	
		    ToIndexedSequence.prototype.includes = function(value) {
		      return this._iter.includes(value);
		    };
	
		    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      var iterations = 0;
		      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
		    };
	
		    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
		      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
		      var iterations = 0;
		      return new src_Iterator__Iterator(function()  {
		        var step = iterator.next();
		        return step.done ? step :
		          iteratorValue(type, iterations++, step.value, step)
		      });
		    };
	
	
	
		  createClass(ToSetSequence, SetSeq);
		    function ToSetSequence(iter) {
		      this._iter = iter;
		      this.size = iter.size;
		    }
	
		    ToSetSequence.prototype.has = function(key) {
		      return this._iter.includes(key);
		    };
	
		    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
		    };
	
		    ToSetSequence.prototype.__iterator = function(type, reverse) {
		      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
		      return new src_Iterator__Iterator(function()  {
		        var step = iterator.next();
		        return step.done ? step :
		          iteratorValue(type, step.value, step.value, step);
		      });
		    };
	
	
	
		  createClass(FromEntriesSequence, KeyedSeq);
		    function FromEntriesSequence(entries) {
		      this._iter = entries;
		      this.size = entries.size;
		    }
	
		    FromEntriesSequence.prototype.entrySeq = function() {
		      return this._iter.toSeq();
		    };
	
		    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return this._iter.__iterate(function(entry ) {
		        // Check if entry exists first so array access doesn't throw for holes
		        // in the parent iteration.
		        if (entry) {
		          validateEntry(entry);
		          var indexedIterable = isIterable(entry);
		          return fn(
		            indexedIterable ? entry.get(1) : entry[1],
		            indexedIterable ? entry.get(0) : entry[0],
		            this$0
		          );
		        }
		      }, reverse);
		    };
	
		    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
		      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
		      return new src_Iterator__Iterator(function()  {
		        while (true) {
		          var step = iterator.next();
		          if (step.done) {
		            return step;
		          }
		          var entry = step.value;
		          // Check if entry exists first so array access doesn't throw for holes
		          // in the parent iteration.
		          if (entry) {
		            validateEntry(entry);
		            var indexedIterable = isIterable(entry);
		            return iteratorValue(
		              type,
		              indexedIterable ? entry.get(0) : entry[0],
		              indexedIterable ? entry.get(1) : entry[1],
		              step
		            );
		          }
		        }
		      });
		    };
	
	
		  ToIndexedSequence.prototype.cacheResult =
		  ToKeyedSequence.prototype.cacheResult =
		  ToSetSequence.prototype.cacheResult =
		  FromEntriesSequence.prototype.cacheResult =
		    cacheResultThrough;
	
	
		  function flipFactory(iterable) {
		    var flipSequence = makeSequence(iterable);
		    flipSequence._iter = iterable;
		    flipSequence.size = iterable.size;
		    flipSequence.flip = function()  {return iterable};
		    flipSequence.reverse = function () {
		      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
		      reversedSequence.flip = function()  {return iterable.reverse()};
		      return reversedSequence;
		    };
		    flipSequence.has = function(key ) {return iterable.includes(key)};
		    flipSequence.includes = function(key ) {return iterable.has(key)};
		    flipSequence.cacheResult = cacheResultThrough;
		    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
		      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
		    }
		    flipSequence.__iteratorUncached = function(type, reverse) {
		      if (type === ITERATE_ENTRIES) {
		        var iterator = iterable.__iterator(type, reverse);
		        return new src_Iterator__Iterator(function()  {
		          var step = iterator.next();
		          if (!step.done) {
		            var k = step.value[0];
		            step.value[0] = step.value[1];
		            step.value[1] = k;
		          }
		          return step;
		        });
		      }
		      return iterable.__iterator(
		        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
		        reverse
		      );
		    }
		    return flipSequence;
		  }
	
	
		  function mapFactory(iterable, mapper, context) {
		    var mappedSequence = makeSequence(iterable);
		    mappedSequence.size = iterable.size;
		    mappedSequence.has = function(key ) {return iterable.has(key)};
		    mappedSequence.get = function(key, notSetValue)  {
		      var v = iterable.get(key, NOT_SET);
		      return v === NOT_SET ?
		        notSetValue :
		        mapper.call(context, v, key, iterable);
		    };
		    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
		      return iterable.__iterate(
		        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
		        reverse
		      );
		    }
		    mappedSequence.__iteratorUncached = function (type, reverse) {
		      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
		      return new src_Iterator__Iterator(function()  {
		        var step = iterator.next();
		        if (step.done) {
		          return step;
		        }
		        var entry = step.value;
		        var key = entry[0];
		        return iteratorValue(
		          type,
		          key,
		          mapper.call(context, entry[1], key, iterable),
		          step
		        );
		      });
		    }
		    return mappedSequence;
		  }
	
	
		  function reverseFactory(iterable, useKeys) {
		    var reversedSequence = makeSequence(iterable);
		    reversedSequence._iter = iterable;
		    reversedSequence.size = iterable.size;
		    reversedSequence.reverse = function()  {return iterable};
		    if (iterable.flip) {
		      reversedSequence.flip = function () {
		        var flipSequence = flipFactory(iterable);
		        flipSequence.reverse = function()  {return iterable.flip()};
		        return flipSequence;
		      };
		    }
		    reversedSequence.get = function(key, notSetValue) 
		      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
		    reversedSequence.has = function(key )
		      {return iterable.has(useKeys ? key : -1 - key)};
		    reversedSequence.includes = function(value ) {return iterable.includes(value)};
		    reversedSequence.cacheResult = cacheResultThrough;
		    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
		      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
		    };
		    reversedSequence.__iterator =
		      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
		    return reversedSequence;
		  }
	
	
		  function filterFactory(iterable, predicate, context, useKeys) {
		    var filterSequence = makeSequence(iterable);
		    if (useKeys) {
		      filterSequence.has = function(key ) {
		        var v = iterable.get(key, NOT_SET);
		        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
		      };
		      filterSequence.get = function(key, notSetValue)  {
		        var v = iterable.get(key, NOT_SET);
		        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
		          v : notSetValue;
		      };
		    }
		    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
		      var iterations = 0;
		      iterable.__iterate(function(v, k, c)  {
		        if (predicate.call(context, v, k, c)) {
		          iterations++;
		          return fn(v, useKeys ? k : iterations - 1, this$0);
		        }
		      }, reverse);
		      return iterations;
		    };
		    filterSequence.__iteratorUncached = function (type, reverse) {
		      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
		      var iterations = 0;
		      return new src_Iterator__Iterator(function()  {
		        while (true) {
		          var step = iterator.next();
		          if (step.done) {
		            return step;
		          }
		          var entry = step.value;
		          var key = entry[0];
		          var value = entry[1];
		          if (predicate.call(context, value, key, iterable)) {
		            return iteratorValue(type, useKeys ? key : iterations++, value, step);
		          }
		        }
		      });
		    }
		    return filterSequence;
		  }
	
	
		  function countByFactory(iterable, grouper, context) {
		    var groups = src_Map__Map().asMutable();
		    iterable.__iterate(function(v, k)  {
		      groups.update(
		        grouper.call(context, v, k, iterable),
		        0,
		        function(a ) {return a + 1}
		      );
		    });
		    return groups.asImmutable();
		  }
	
	
		  function groupByFactory(iterable, grouper, context) {
		    var isKeyedIter = isKeyed(iterable);
		    var groups = (isOrdered(iterable) ? OrderedMap() : src_Map__Map()).asMutable();
		    iterable.__iterate(function(v, k)  {
		      groups.update(
		        grouper.call(context, v, k, iterable),
		        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
		      );
		    });
		    var coerce = iterableClass(iterable);
		    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
		  }
	
	
		  function sliceFactory(iterable, begin, end, useKeys) {
		    var originalSize = iterable.size;
	
		    if (wholeSlice(begin, end, originalSize)) {
		      return iterable;
		    }
	
		    var resolvedBegin = resolveBegin(begin, originalSize);
		    var resolvedEnd = resolveEnd(end, originalSize);
	
		    // begin or end will be NaN if they were provided as negative numbers and
		    // this iterable's size is unknown. In that case, cache first so there is
		    // a known size and these do not resolve to NaN.
		    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
		      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
		    }
	
		    // Note: resolvedEnd is undefined when the original sequence's length is
		    // unknown and this slice did not supply an end and should contain all
		    // elements after resolvedBegin.
		    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
		    var resolvedSize = resolvedEnd - resolvedBegin;
		    var sliceSize;
		    if (resolvedSize === resolvedSize) {
		      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
		    }
	
		    var sliceSeq = makeSequence(iterable);
	
		    sliceSeq.size = sliceSize;
	
		    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
		      sliceSeq.get = function (index, notSetValue) {
		        index = wrapIndex(this, index);
		        return index >= 0 && index < sliceSize ?
		          iterable.get(index + resolvedBegin, notSetValue) :
		          notSetValue;
		      }
		    }
	
		    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
		      if (sliceSize === 0) {
		        return 0;
		      }
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var skipped = 0;
		      var isSkipping = true;
		      var iterations = 0;
		      iterable.__iterate(function(v, k)  {
		        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
		          iterations++;
		          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
		                 iterations !== sliceSize;
		        }
		      });
		      return iterations;
		    };
	
		    sliceSeq.__iteratorUncached = function(type, reverse) {
		      if (sliceSize !== 0 && reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      // Don't bother instantiating parent iterator if taking 0.
		      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
		      var skipped = 0;
		      var iterations = 0;
		      return new src_Iterator__Iterator(function()  {
		        while (skipped++ < resolvedBegin) {
		          iterator.next();
		        }
		        if (++iterations > sliceSize) {
		          return iteratorDone();
		        }
		        var step = iterator.next();
		        if (useKeys || type === ITERATE_VALUES) {
		          return step;
		        } else if (type === ITERATE_KEYS) {
		          return iteratorValue(type, iterations - 1, undefined, step);
		        } else {
		          return iteratorValue(type, iterations - 1, step.value[1], step);
		        }
		      });
		    }
	
		    return sliceSeq;
		  }
	
	
		  function takeWhileFactory(iterable, predicate, context) {
		    var takeSequence = makeSequence(iterable);
		    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var iterations = 0;
		      iterable.__iterate(function(v, k, c) 
		        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
		      );
		      return iterations;
		    };
		    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
		      if (reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
		      var iterating = true;
		      return new src_Iterator__Iterator(function()  {
		        if (!iterating) {
		          return iteratorDone();
		        }
		        var step = iterator.next();
		        if (step.done) {
		          return step;
		        }
		        var entry = step.value;
		        var k = entry[0];
		        var v = entry[1];
		        if (!predicate.call(context, v, k, this$0)) {
		          iterating = false;
		          return iteratorDone();
		        }
		        return type === ITERATE_ENTRIES ? step :
		          iteratorValue(type, k, v, step);
		      });
		    };
		    return takeSequence;
		  }
	
	
		  function skipWhileFactory(iterable, predicate, context, useKeys) {
		    var skipSequence = makeSequence(iterable);
		    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var isSkipping = true;
		      var iterations = 0;
		      iterable.__iterate(function(v, k, c)  {
		        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
		          iterations++;
		          return fn(v, useKeys ? k : iterations - 1, this$0);
		        }
		      });
		      return iterations;
		    };
		    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
		      if (reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
		      var skipping = true;
		      var iterations = 0;
		      return new src_Iterator__Iterator(function()  {
		        var step, k, v;
		        do {
		          step = iterator.next();
		          if (step.done) {
		            if (useKeys || type === ITERATE_VALUES) {
		              return step;
		            } else if (type === ITERATE_KEYS) {
		              return iteratorValue(type, iterations++, undefined, step);
		            } else {
		              return iteratorValue(type, iterations++, step.value[1], step);
		            }
		          }
		          var entry = step.value;
		          k = entry[0];
		          v = entry[1];
		          skipping && (skipping = predicate.call(context, v, k, this$0));
		        } while (skipping);
		        return type === ITERATE_ENTRIES ? step :
		          iteratorValue(type, k, v, step);
		      });
		    };
		    return skipSequence;
		  }
	
	
		  function concatFactory(iterable, values) {
		    var isKeyedIterable = isKeyed(iterable);
		    var iters = [iterable].concat(values).map(function(v ) {
		      if (!isIterable(v)) {
		        v = isKeyedIterable ?
		          keyedSeqFromValue(v) :
		          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
		      } else if (isKeyedIterable) {
		        v = KeyedIterable(v);
		      }
		      return v;
		    }).filter(function(v ) {return v.size !== 0});
	
		    if (iters.length === 0) {
		      return iterable;
		    }
	
		    if (iters.length === 1) {
		      var singleton = iters[0];
		      if (singleton === iterable ||
		          isKeyedIterable && isKeyed(singleton) ||
		          isIndexed(iterable) && isIndexed(singleton)) {
		        return singleton;
		      }
		    }
	
		    var concatSeq = new ArraySeq(iters);
		    if (isKeyedIterable) {
		      concatSeq = concatSeq.toKeyedSeq();
		    } else if (!isIndexed(iterable)) {
		      concatSeq = concatSeq.toSetSeq();
		    }
		    concatSeq = concatSeq.flatten(true);
		    concatSeq.size = iters.reduce(
		      function(sum, seq)  {
		        if (sum !== undefined) {
		          var size = seq.size;
		          if (size !== undefined) {
		            return sum + size;
		          }
		        }
		      },
		      0
		    );
		    return concatSeq;
		  }
	
	
		  function flattenFactory(iterable, depth, useKeys) {
		    var flatSequence = makeSequence(iterable);
		    flatSequence.__iterateUncached = function(fn, reverse) {
		      var iterations = 0;
		      var stopped = false;
		      function flatDeep(iter, currentDepth) {var this$0 = this;
		        iter.__iterate(function(v, k)  {
		          if ((!depth || currentDepth < depth) && isIterable(v)) {
		            flatDeep(v, currentDepth + 1);
		          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
		            stopped = true;
		          }
		          return !stopped;
		        }, reverse);
		      }
		      flatDeep(iterable, 0);
		      return iterations;
		    }
		    flatSequence.__iteratorUncached = function(type, reverse) {
		      var iterator = iterable.__iterator(type, reverse);
		      var stack = [];
		      var iterations = 0;
		      return new src_Iterator__Iterator(function()  {
		        while (iterator) {
		          var step = iterator.next();
		          if (step.done !== false) {
		            iterator = stack.pop();
		            continue;
		          }
		          var v = step.value;
		          if (type === ITERATE_ENTRIES) {
		            v = v[1];
		          }
		          if ((!depth || stack.length < depth) && isIterable(v)) {
		            stack.push(iterator);
		            iterator = v.__iterator(type, reverse);
		          } else {
		            return useKeys ? step : iteratorValue(type, iterations++, v, step);
		          }
		        }
		        return iteratorDone();
		      });
		    }
		    return flatSequence;
		  }
	
	
		  function flatMapFactory(iterable, mapper, context) {
		    var coerce = iterableClass(iterable);
		    return iterable.toSeq().map(
		      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
		    ).flatten(true);
		  }
	
	
		  function interposeFactory(iterable, separator) {
		    var interposedSequence = makeSequence(iterable);
		    interposedSequence.size = iterable.size && iterable.size * 2 -1;
		    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
		      var iterations = 0;
		      iterable.__iterate(function(v, k) 
		        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
		        fn(v, iterations++, this$0) !== false},
		        reverse
		      );
		      return iterations;
		    };
		    interposedSequence.__iteratorUncached = function(type, reverse) {
		      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
		      var iterations = 0;
		      var step;
		      return new src_Iterator__Iterator(function()  {
		        if (!step || iterations % 2) {
		          step = iterator.next();
		          if (step.done) {
		            return step;
		          }
		        }
		        return iterations % 2 ?
		          iteratorValue(type, iterations++, separator) :
		          iteratorValue(type, iterations++, step.value, step);
		      });
		    };
		    return interposedSequence;
		  }
	
	
		  function sortFactory(iterable, comparator, mapper) {
		    if (!comparator) {
		      comparator = defaultComparator;
		    }
		    var isKeyedIterable = isKeyed(iterable);
		    var index = 0;
		    var entries = iterable.toSeq().map(
		      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
		    ).toArray();
		    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
		      isKeyedIterable ?
		      function(v, i)  { entries[i].length = 2; } :
		      function(v, i)  { entries[i] = v[1]; }
		    );
		    return isKeyedIterable ? KeyedSeq(entries) :
		      isIndexed(iterable) ? IndexedSeq(entries) :
		      SetSeq(entries);
		  }
	
	
		  function maxFactory(iterable, comparator, mapper) {
		    if (!comparator) {
		      comparator = defaultComparator;
		    }
		    if (mapper) {
		      var entry = iterable.toSeq()
		        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
		        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
		      return entry && entry[0];
		    } else {
		      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
		    }
		  }
	
		  function maxCompare(comparator, a, b) {
		    var comp = comparator(b, a);
		    // b is considered the new max if the comparator declares them equal, but
		    // they are not equal and b is in fact a nullish value.
		    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
		  }
	
	
		  function zipWithFactory(keyIter, zipper, iters) {
		    var zipSequence = makeSequence(keyIter);
		    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
		    // Note: this a generic base implementation of __iterate in terms of
		    // __iterator which may be more generically useful in the future.
		    zipSequence.__iterate = function(fn, reverse) {
		      /* generic:
		      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
		      var step;
		      var iterations = 0;
		      while (!(step = iterator.next()).done) {
		        iterations++;
		        if (fn(step.value[1], step.value[0], this) === false) {
		          break;
		        }
		      }
		      return iterations;
		      */
		      // indexed:
		      var iterator = this.__iterator(ITERATE_VALUES, reverse);
		      var step;
		      var iterations = 0;
		      while (!(step = iterator.next()).done) {
		        if (fn(step.value, iterations++, this) === false) {
		          break;
		        }
		      }
		      return iterations;
		    };
		    zipSequence.__iteratorUncached = function(type, reverse) {
		      var iterators = iters.map(function(i )
		        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
		      );
		      var iterations = 0;
		      var isDone = false;
		      return new src_Iterator__Iterator(function()  {
		        var steps;
		        if (!isDone) {
		          steps = iterators.map(function(i ) {return i.next()});
		          isDone = steps.some(function(s ) {return s.done});
		        }
		        if (isDone) {
		          return iteratorDone();
		        }
		        return iteratorValue(
		          type,
		          iterations++,
		          zipper.apply(null, steps.map(function(s ) {return s.value}))
		        );
		      });
		    };
		    return zipSequence
		  }
	
	
		  // #pragma Helper Functions
	
		  function reify(iter, seq) {
		    return isSeq(iter) ? seq : iter.constructor(seq);
		  }
	
		  function validateEntry(entry) {
		    if (entry !== Object(entry)) {
		      throw new TypeError('Expected [K, V] tuple: ' + entry);
		    }
		  }
	
		  function resolveSize(iter) {
		    assertNotInfinite(iter.size);
		    return ensureSize(iter);
		  }
	
		  function iterableClass(iterable) {
		    return isKeyed(iterable) ? KeyedIterable :
		      isIndexed(iterable) ? IndexedIterable :
		      SetIterable;
		  }
	
		  function makeSequence(iterable) {
		    return Object.create(
		      (
		        isKeyed(iterable) ? KeyedSeq :
		        isIndexed(iterable) ? IndexedSeq :
		        SetSeq
		      ).prototype
		    );
		  }
	
		  function cacheResultThrough() {
		    if (this._iter.cacheResult) {
		      this._iter.cacheResult();
		      this.size = this._iter.size;
		      return this;
		    } else {
		      return Seq.prototype.cacheResult.call(this);
		    }
		  }
	
		  function defaultComparator(a, b) {
		    return a > b ? 1 : a < b ? -1 : 0;
		  }
	
		  function forceIterator(keyPath) {
		    var iter = getIterator(keyPath);
		    if (!iter) {
		      // Array might not be iterable in this environment, so we need a fallback
		      // to our wrapped type.
		      if (!isArrayLike(keyPath)) {
		        throw new TypeError('Expected iterable or array-like: ' + keyPath);
		      }
		      iter = getIterator(Iterable(keyPath));
		    }
		    return iter;
		  }
	
		  createClass(src_Map__Map, KeyedCollection);
	
		    // @pragma Construction
	
		    function src_Map__Map(value) {
		      return value === null || value === undefined ? emptyMap() :
		        isMap(value) ? value :
		        emptyMap().withMutations(function(map ) {
		          var iter = KeyedIterable(value);
		          assertNotInfinite(iter.size);
		          iter.forEach(function(v, k)  {return map.set(k, v)});
		        });
		    }
	
		    src_Map__Map.prototype.toString = function() {
		      return this.__toString('Map {', '}');
		    };
	
		    // @pragma Access
	
		    src_Map__Map.prototype.get = function(k, notSetValue) {
		      return this._root ?
		        this._root.get(0, undefined, k, notSetValue) :
		        notSetValue;
		    };
	
		    // @pragma Modification
	
		    src_Map__Map.prototype.set = function(k, v) {
		      return updateMap(this, k, v);
		    };
	
		    src_Map__Map.prototype.setIn = function(keyPath, v) {
		      return this.updateIn(keyPath, NOT_SET, function()  {return v});
		    };
	
		    src_Map__Map.prototype.remove = function(k) {
		      return updateMap(this, k, NOT_SET);
		    };
	
		    src_Map__Map.prototype.deleteIn = function(keyPath) {
		      return this.updateIn(keyPath, function()  {return NOT_SET});
		    };
	
		    src_Map__Map.prototype.update = function(k, notSetValue, updater) {
		      return arguments.length === 1 ?
		        k(this) :
		        this.updateIn([k], notSetValue, updater);
		    };
	
		    src_Map__Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
		      if (!updater) {
		        updater = notSetValue;
		        notSetValue = undefined;
		      }
		      var updatedValue = updateInDeepMap(
		        this,
		        forceIterator(keyPath),
		        notSetValue,
		        updater
		      );
		      return updatedValue === NOT_SET ? undefined : updatedValue;
		    };
	
		    src_Map__Map.prototype.clear = function() {
		      if (this.size === 0) {
		        return this;
		      }
		      if (this.__ownerID) {
		        this.size = 0;
		        this._root = null;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return emptyMap();
		    };
	
		    // @pragma Composition
	
		    src_Map__Map.prototype.merge = function(/*...iters*/) {
		      return mergeIntoMapWith(this, undefined, arguments);
		    };
	
		    src_Map__Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return mergeIntoMapWith(this, merger, iters);
		    };
	
		    src_Map__Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
		      return this.updateIn(
		        keyPath,
		        emptyMap(),
		        function(m ) {return typeof m.merge === 'function' ?
		          m.merge.apply(m, iters) :
		          iters[iters.length - 1]}
		      );
		    };
	
		    src_Map__Map.prototype.mergeDeep = function(/*...iters*/) {
		      return mergeIntoMapWith(this, deepMerger(undefined), arguments);
		    };
	
		    src_Map__Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return mergeIntoMapWith(this, deepMerger(merger), iters);
		    };
	
		    src_Map__Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
		      return this.updateIn(
		        keyPath,
		        emptyMap(),
		        function(m ) {return typeof m.mergeDeep === 'function' ?
		          m.mergeDeep.apply(m, iters) :
		          iters[iters.length - 1]}
		      );
		    };
	
		    src_Map__Map.prototype.sort = function(comparator) {
		      // Late binding
		      return OrderedMap(sortFactory(this, comparator));
		    };
	
		    src_Map__Map.prototype.sortBy = function(mapper, comparator) {
		      // Late binding
		      return OrderedMap(sortFactory(this, comparator, mapper));
		    };
	
		    // @pragma Mutability
	
		    src_Map__Map.prototype.withMutations = function(fn) {
		      var mutable = this.asMutable();
		      fn(mutable);
		      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
		    };
	
		    src_Map__Map.prototype.asMutable = function() {
		      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
		    };
	
		    src_Map__Map.prototype.asImmutable = function() {
		      return this.__ensureOwner();
		    };
	
		    src_Map__Map.prototype.wasAltered = function() {
		      return this.__altered;
		    };
	
		    src_Map__Map.prototype.__iterator = function(type, reverse) {
		      return new MapIterator(this, type, reverse);
		    };
	
		    src_Map__Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      var iterations = 0;
		      this._root && this._root.iterate(function(entry ) {
		        iterations++;
		        return fn(entry[1], entry[0], this$0);
		      }, reverse);
		      return iterations;
		    };
	
		    src_Map__Map.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this.__altered = false;
		        return this;
		      }
		      return makeMap(this.size, this._root, ownerID, this.__hash);
		    };
	
	
		  function isMap(maybeMap) {
		    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
		  }
	
		  src_Map__Map.isMap = isMap;
	
		  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
	
		  var MapPrototype = src_Map__Map.prototype;
		  MapPrototype[IS_MAP_SENTINEL] = true;
		  MapPrototype[DELETE] = MapPrototype.remove;
		  MapPrototype.removeIn = MapPrototype.deleteIn;
	
	
		  // #pragma Trie Nodes
	
	
	
		    function ArrayMapNode(ownerID, entries) {
		      this.ownerID = ownerID;
		      this.entries = entries;
		    }
	
		    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      var entries = this.entries;
		      for (var ii = 0, len = entries.length; ii < len; ii++) {
		        if (is(key, entries[ii][0])) {
		          return entries[ii][1];
		        }
		      }
		      return notSetValue;
		    };
	
		    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      var removed = value === NOT_SET;
	
		      var entries = this.entries;
		      var idx = 0;
		      for (var len = entries.length; idx < len; idx++) {
		        if (is(key, entries[idx][0])) {
		          break;
		        }
		      }
		      var exists = idx < len;
	
		      if (exists ? entries[idx][1] === value : removed) {
		        return this;
		      }
	
		      SetRef(didAlter);
		      (removed || !exists) && SetRef(didChangeSize);
	
		      if (removed && entries.length === 1) {
		        return; // undefined
		      }
	
		      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
		        return createNodes(ownerID, entries, key, value);
		      }
	
		      var isEditable = ownerID && ownerID === this.ownerID;
		      var newEntries = isEditable ? entries : arrCopy(entries);
	
		      if (exists) {
		        if (removed) {
		          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
		        } else {
		          newEntries[idx] = [key, value];
		        }
		      } else {
		        newEntries.push([key, value]);
		      }
	
		      if (isEditable) {
		        this.entries = newEntries;
		        return this;
		      }
	
		      return new ArrayMapNode(ownerID, newEntries);
		    };
	
	
	
	
		    function BitmapIndexedNode(ownerID, bitmap, nodes) {
		      this.ownerID = ownerID;
		      this.bitmap = bitmap;
		      this.nodes = nodes;
		    }
	
		    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }
		      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
		      var bitmap = this.bitmap;
		      return (bitmap & bit) === 0 ? notSetValue :
		        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
		    };
	
		    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }
		      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
		      var bit = 1 << keyHashFrag;
		      var bitmap = this.bitmap;
		      var exists = (bitmap & bit) !== 0;
	
		      if (!exists && value === NOT_SET) {
		        return this;
		      }
	
		      var idx = popCount(bitmap & (bit - 1));
		      var nodes = this.nodes;
		      var node = exists ? nodes[idx] : undefined;
		      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	
		      if (newNode === node) {
		        return this;
		      }
	
		      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
		        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
		      }
	
		      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
		        return nodes[idx ^ 1];
		      }
	
		      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
		        return newNode;
		      }
	
		      var isEditable = ownerID && ownerID === this.ownerID;
		      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
		      var newNodes = exists ? newNode ?
		        setIn(nodes, idx, newNode, isEditable) :
		        spliceOut(nodes, idx, isEditable) :
		        spliceIn(nodes, idx, newNode, isEditable);
	
		      if (isEditable) {
		        this.bitmap = newBitmap;
		        this.nodes = newNodes;
		        return this;
		      }
	
		      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
		    };
	
	
	
	
		    function HashArrayMapNode(ownerID, count, nodes) {
		      this.ownerID = ownerID;
		      this.count = count;
		      this.nodes = nodes;
		    }
	
		    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }
		      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
		      var node = this.nodes[idx];
		      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
		    };
	
		    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }
		      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
		      var removed = value === NOT_SET;
		      var nodes = this.nodes;
		      var node = nodes[idx];
	
		      if (removed && !node) {
		        return this;
		      }
	
		      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
		      if (newNode === node) {
		        return this;
		      }
	
		      var newCount = this.count;
		      if (!node) {
		        newCount++;
		      } else if (!newNode) {
		        newCount--;
		        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
		          return packNodes(ownerID, nodes, newCount, idx);
		        }
		      }
	
		      var isEditable = ownerID && ownerID === this.ownerID;
		      var newNodes = setIn(nodes, idx, newNode, isEditable);
	
		      if (isEditable) {
		        this.count = newCount;
		        this.nodes = newNodes;
		        return this;
		      }
	
		      return new HashArrayMapNode(ownerID, newCount, newNodes);
		    };
	
	
	
	
		    function HashCollisionNode(ownerID, keyHash, entries) {
		      this.ownerID = ownerID;
		      this.keyHash = keyHash;
		      this.entries = entries;
		    }
	
		    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      var entries = this.entries;
		      for (var ii = 0, len = entries.length; ii < len; ii++) {
		        if (is(key, entries[ii][0])) {
		          return entries[ii][1];
		        }
		      }
		      return notSetValue;
		    };
	
		    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }
	
		      var removed = value === NOT_SET;
	
		      if (keyHash !== this.keyHash) {
		        if (removed) {
		          return this;
		        }
		        SetRef(didAlter);
		        SetRef(didChangeSize);
		        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
		      }
	
		      var entries = this.entries;
		      var idx = 0;
		      for (var len = entries.length; idx < len; idx++) {
		        if (is(key, entries[idx][0])) {
		          break;
		        }
		      }
		      var exists = idx < len;
	
		      if (exists ? entries[idx][1] === value : removed) {
		        return this;
		      }
	
		      SetRef(didAlter);
		      (removed || !exists) && SetRef(didChangeSize);
	
		      if (removed && len === 2) {
		        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
		      }
	
		      var isEditable = ownerID && ownerID === this.ownerID;
		      var newEntries = isEditable ? entries : arrCopy(entries);
	
		      if (exists) {
		        if (removed) {
		          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
		        } else {
		          newEntries[idx] = [key, value];
		        }
		      } else {
		        newEntries.push([key, value]);
		      }
	
		      if (isEditable) {
		        this.entries = newEntries;
		        return this;
		      }
	
		      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
		    };
	
	
	
	
		    function ValueNode(ownerID, keyHash, entry) {
		      this.ownerID = ownerID;
		      this.keyHash = keyHash;
		      this.entry = entry;
		    }
	
		    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
		    };
	
		    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      var removed = value === NOT_SET;
		      var keyMatch = is(key, this.entry[0]);
		      if (keyMatch ? value === this.entry[1] : removed) {
		        return this;
		      }
	
		      SetRef(didAlter);
	
		      if (removed) {
		        SetRef(didChangeSize);
		        return; // undefined
		      }
	
		      if (keyMatch) {
		        if (ownerID && ownerID === this.ownerID) {
		          this.entry[1] = value;
		          return this;
		        }
		        return new ValueNode(ownerID, this.keyHash, [key, value]);
		      }
	
		      SetRef(didChangeSize);
		      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
		    };
	
	
	
		  // #pragma Iterators
	
		  ArrayMapNode.prototype.iterate =
		  HashCollisionNode.prototype.iterate = function (fn, reverse) {
		    var entries = this.entries;
		    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
		      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
		        return false;
		      }
		    }
		  }
	
		  BitmapIndexedNode.prototype.iterate =
		  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
		    var nodes = this.nodes;
		    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
		      var node = nodes[reverse ? maxIndex - ii : ii];
		      if (node && node.iterate(fn, reverse) === false) {
		        return false;
		      }
		    }
		  }
	
		  ValueNode.prototype.iterate = function (fn, reverse) {
		    return fn(this.entry);
		  }
	
		  createClass(MapIterator, src_Iterator__Iterator);
	
		    function MapIterator(map, type, reverse) {
		      this._type = type;
		      this._reverse = reverse;
		      this._stack = map._root && mapIteratorFrame(map._root);
		    }
	
		    MapIterator.prototype.next = function() {
		      var type = this._type;
		      var stack = this._stack;
		      while (stack) {
		        var node = stack.node;
		        var index = stack.index++;
		        var maxIndex;
		        if (node.entry) {
		          if (index === 0) {
		            return mapIteratorValue(type, node.entry);
		          }
		        } else if (node.entries) {
		          maxIndex = node.entries.length - 1;
		          if (index <= maxIndex) {
		            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
		          }
		        } else {
		          maxIndex = node.nodes.length - 1;
		          if (index <= maxIndex) {
		            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
		            if (subNode) {
		              if (subNode.entry) {
		                return mapIteratorValue(type, subNode.entry);
		              }
		              stack = this._stack = mapIteratorFrame(subNode, stack);
		            }
		            continue;
		          }
		        }
		        stack = this._stack = this._stack.__prev;
		      }
		      return iteratorDone();
		    };
	
	
		  function mapIteratorValue(type, entry) {
		    return iteratorValue(type, entry[0], entry[1]);
		  }
	
		  function mapIteratorFrame(node, prev) {
		    return {
		      node: node,
		      index: 0,
		      __prev: prev
		    };
		  }
	
		  function makeMap(size, root, ownerID, hash) {
		    var map = Object.create(MapPrototype);
		    map.size = size;
		    map._root = root;
		    map.__ownerID = ownerID;
		    map.__hash = hash;
		    map.__altered = false;
		    return map;
		  }
	
		  var EMPTY_MAP;
		  function emptyMap() {
		    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
		  }
	
		  function updateMap(map, k, v) {
		    var newRoot;
		    var newSize;
		    if (!map._root) {
		      if (v === NOT_SET) {
		        return map;
		      }
		      newSize = 1;
		      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
		    } else {
		      var didChangeSize = MakeRef(CHANGE_LENGTH);
		      var didAlter = MakeRef(DID_ALTER);
		      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
		      if (!didAlter.value) {
		        return map;
		      }
		      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
		    }
		    if (map.__ownerID) {
		      map.size = newSize;
		      map._root = newRoot;
		      map.__hash = undefined;
		      map.__altered = true;
		      return map;
		    }
		    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
		  }
	
		  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		    if (!node) {
		      if (value === NOT_SET) {
		        return node;
		      }
		      SetRef(didAlter);
		      SetRef(didChangeSize);
		      return new ValueNode(ownerID, keyHash, [key, value]);
		    }
		    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
		  }
	
		  function isLeafNode(node) {
		    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
		  }
	
		  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
		    if (node.keyHash === keyHash) {
		      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
		    }
	
		    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
		    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	
		    var newNode;
		    var nodes = idx1 === idx2 ?
		      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
		      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);
	
		    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
		  }
	
		  function createNodes(ownerID, entries, key, value) {
		    if (!ownerID) {
		      ownerID = new OwnerID();
		    }
		    var node = new ValueNode(ownerID, hash(key), [key, value]);
		    for (var ii = 0; ii < entries.length; ii++) {
		      var entry = entries[ii];
		      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
		    }
		    return node;
		  }
	
		  function packNodes(ownerID, nodes, count, excluding) {
		    var bitmap = 0;
		    var packedII = 0;
		    var packedNodes = new Array(count);
		    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
		      var node = nodes[ii];
		      if (node !== undefined && ii !== excluding) {
		        bitmap |= bit;
		        packedNodes[packedII++] = node;
		      }
		    }
		    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
		  }
	
		  function expandNodes(ownerID, nodes, bitmap, including, node) {
		    var count = 0;
		    var expandedNodes = new Array(SIZE);
		    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
		      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
		    }
		    expandedNodes[including] = node;
		    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
		  }
	
		  function mergeIntoMapWith(map, merger, iterables) {
		    var iters = [];
		    for (var ii = 0; ii < iterables.length; ii++) {
		      var value = iterables[ii];
		      var iter = KeyedIterable(value);
		      if (!isIterable(value)) {
		        iter = iter.map(function(v ) {return fromJS(v)});
		      }
		      iters.push(iter);
		    }
		    return mergeIntoCollectionWith(map, merger, iters);
		  }
	
		  function deepMerger(merger) {
		    return function(existing, value, key) 
		      {return existing && existing.mergeDeepWith && isIterable(value) ?
		        existing.mergeDeepWith(merger, value) :
		        merger ? merger(existing, value, key) : value};
		  }
	
		  function mergeIntoCollectionWith(collection, merger, iters) {
		    iters = iters.filter(function(x ) {return x.size !== 0});
		    if (iters.length === 0) {
		      return collection;
		    }
		    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
		      return collection.constructor(iters[0]);
		    }
		    return collection.withMutations(function(collection ) {
		      var mergeIntoMap = merger ?
		        function(value, key)  {
		          collection.update(key, NOT_SET, function(existing )
		            {return existing === NOT_SET ? value : merger(existing, value, key)}
		          );
		        } :
		        function(value, key)  {
		          collection.set(key, value);
		        }
		      for (var ii = 0; ii < iters.length; ii++) {
		        iters[ii].forEach(mergeIntoMap);
		      }
		    });
		  }
	
		  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
		    var isNotSet = existing === NOT_SET;
		    var step = keyPathIter.next();
		    if (step.done) {
		      var existingValue = isNotSet ? notSetValue : existing;
		      var newValue = updater(existingValue);
		      return newValue === existingValue ? existing : newValue;
		    }
		    invariant(
		      isNotSet || (existing && existing.set),
		      'invalid keyPath'
		    );
		    var key = step.value;
		    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
		    var nextUpdated = updateInDeepMap(
		      nextExisting,
		      keyPathIter,
		      notSetValue,
		      updater
		    );
		    return nextUpdated === nextExisting ? existing :
		      nextUpdated === NOT_SET ? existing.remove(key) :
		      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
		  }
	
		  function popCount(x) {
		    x = x - ((x >> 1) & 0x55555555);
		    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
		    x = (x + (x >> 4)) & 0x0f0f0f0f;
		    x = x + (x >> 8);
		    x = x + (x >> 16);
		    return x & 0x7f;
		  }
	
		  function setIn(array, idx, val, canEdit) {
		    var newArray = canEdit ? array : arrCopy(array);
		    newArray[idx] = val;
		    return newArray;
		  }
	
		  function spliceIn(array, idx, val, canEdit) {
		    var newLen = array.length + 1;
		    if (canEdit && idx + 1 === newLen) {
		      array[idx] = val;
		      return array;
		    }
		    var newArray = new Array(newLen);
		    var after = 0;
		    for (var ii = 0; ii < newLen; ii++) {
		      if (ii === idx) {
		        newArray[ii] = val;
		        after = -1;
		      } else {
		        newArray[ii] = array[ii + after];
		      }
		    }
		    return newArray;
		  }
	
		  function spliceOut(array, idx, canEdit) {
		    var newLen = array.length - 1;
		    if (canEdit && idx === newLen) {
		      array.pop();
		      return array;
		    }
		    var newArray = new Array(newLen);
		    var after = 0;
		    for (var ii = 0; ii < newLen; ii++) {
		      if (ii === idx) {
		        after = 1;
		      }
		      newArray[ii] = array[ii + after];
		    }
		    return newArray;
		  }
	
		  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
		  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
		  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
	
		  createClass(List, IndexedCollection);
	
		    // @pragma Construction
	
		    function List(value) {
		      var empty = emptyList();
		      if (value === null || value === undefined) {
		        return empty;
		      }
		      if (isList(value)) {
		        return value;
		      }
		      var iter = IndexedIterable(value);
		      var size = iter.size;
		      if (size === 0) {
		        return empty;
		      }
		      assertNotInfinite(size);
		      if (size > 0 && size < SIZE) {
		        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
		      }
		      return empty.withMutations(function(list ) {
		        list.setSize(size);
		        iter.forEach(function(v, i)  {return list.set(i, v)});
		      });
		    }
	
		    List.of = function(/*...values*/) {
		      return this(arguments);
		    };
	
		    List.prototype.toString = function() {
		      return this.__toString('List [', ']');
		    };
	
		    // @pragma Access
	
		    List.prototype.get = function(index, notSetValue) {
		      index = wrapIndex(this, index);
		      if (index < 0 || index >= this.size) {
		        return notSetValue;
		      }
		      index += this._origin;
		      var node = listNodeFor(this, index);
		      return node && node.array[index & MASK];
		    };
	
		    // @pragma Modification
	
		    List.prototype.set = function(index, value) {
		      return updateList(this, index, value);
		    };
	
		    List.prototype.remove = function(index) {
		      return !this.has(index) ? this :
		        index === 0 ? this.shift() :
		        index === this.size - 1 ? this.pop() :
		        this.splice(index, 1);
		    };
	
		    List.prototype.clear = function() {
		      if (this.size === 0) {
		        return this;
		      }
		      if (this.__ownerID) {
		        this.size = this._origin = this._capacity = 0;
		        this._level = SHIFT;
		        this._root = this._tail = null;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return emptyList();
		    };
	
		    List.prototype.push = function(/*...values*/) {
		      var values = arguments;
		      var oldSize = this.size;
		      return this.withMutations(function(list ) {
		        setListBounds(list, 0, oldSize + values.length);
		        for (var ii = 0; ii < values.length; ii++) {
		          list.set(oldSize + ii, values[ii]);
		        }
		      });
		    };
	
		    List.prototype.pop = function() {
		      return setListBounds(this, 0, -1);
		    };
	
		    List.prototype.unshift = function(/*...values*/) {
		      var values = arguments;
		      return this.withMutations(function(list ) {
		        setListBounds(list, -values.length);
		        for (var ii = 0; ii < values.length; ii++) {
		          list.set(ii, values[ii]);
		        }
		      });
		    };
	
		    List.prototype.shift = function() {
		      return setListBounds(this, 1);
		    };
	
		    // @pragma Composition
	
		    List.prototype.merge = function(/*...iters*/) {
		      return mergeIntoListWith(this, undefined, arguments);
		    };
	
		    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return mergeIntoListWith(this, merger, iters);
		    };
	
		    List.prototype.mergeDeep = function(/*...iters*/) {
		      return mergeIntoListWith(this, deepMerger(undefined), arguments);
		    };
	
		    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return mergeIntoListWith(this, deepMerger(merger), iters);
		    };
	
		    List.prototype.setSize = function(size) {
		      return setListBounds(this, 0, size);
		    };
	
		    // @pragma Iteration
	
		    List.prototype.slice = function(begin, end) {
		      var size = this.size;
		      if (wholeSlice(begin, end, size)) {
		        return this;
		      }
		      return setListBounds(
		        this,
		        resolveBegin(begin, size),
		        resolveEnd(end, size)
		      );
		    };
	
		    List.prototype.__iterator = function(type, reverse) {
		      var index = 0;
		      var values = iterateList(this, reverse);
		      return new src_Iterator__Iterator(function()  {
		        var value = values();
		        return value === DONE ?
		          iteratorDone() :
		          iteratorValue(type, index++, value);
		      });
		    };
	
		    List.prototype.__iterate = function(fn, reverse) {
		      var index = 0;
		      var values = iterateList(this, reverse);
		      var value;
		      while ((value = values()) !== DONE) {
		        if (fn(value, index++, this) === false) {
		          break;
		        }
		      }
		      return index;
		    };
	
		    List.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        return this;
		      }
		      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
		    };
	
	
		  function isList(maybeList) {
		    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
		  }
	
		  List.isList = isList;
	
		  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
	
		  var ListPrototype = List.prototype;
		  ListPrototype[IS_LIST_SENTINEL] = true;
		  ListPrototype[DELETE] = ListPrototype.remove;
		  ListPrototype.setIn = MapPrototype.setIn;
		  ListPrototype.deleteIn =
		  ListPrototype.removeIn = MapPrototype.removeIn;
		  ListPrototype.update = MapPrototype.update;
		  ListPrototype.updateIn = MapPrototype.updateIn;
		  ListPrototype.mergeIn = MapPrototype.mergeIn;
		  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
		  ListPrototype.withMutations = MapPrototype.withMutations;
		  ListPrototype.asMutable = MapPrototype.asMutable;
		  ListPrototype.asImmutable = MapPrototype.asImmutable;
		  ListPrototype.wasAltered = MapPrototype.wasAltered;
	
	
	
		    function VNode(array, ownerID) {
		      this.array = array;
		      this.ownerID = ownerID;
		    }
	
		    // TODO: seems like these methods are very similar
	
		    VNode.prototype.removeBefore = function(ownerID, level, index) {
		      if (index === level ? 1 << level : 0 || this.array.length === 0) {
		        return this;
		      }
		      var originIndex = (index >>> level) & MASK;
		      if (originIndex >= this.array.length) {
		        return new VNode([], ownerID);
		      }
		      var removingFirst = originIndex === 0;
		      var newChild;
		      if (level > 0) {
		        var oldChild = this.array[originIndex];
		        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
		        if (newChild === oldChild && removingFirst) {
		          return this;
		        }
		      }
		      if (removingFirst && !newChild) {
		        return this;
		      }
		      var editable = editableVNode(this, ownerID);
		      if (!removingFirst) {
		        for (var ii = 0; ii < originIndex; ii++) {
		          editable.array[ii] = undefined;
		        }
		      }
		      if (newChild) {
		        editable.array[originIndex] = newChild;
		      }
		      return editable;
		    };
	
		    VNode.prototype.removeAfter = function(ownerID, level, index) {
		      if (index === level ? 1 << level : 0 || this.array.length === 0) {
		        return this;
		      }
		      var sizeIndex = ((index - 1) >>> level) & MASK;
		      if (sizeIndex >= this.array.length) {
		        return this;
		      }
		      var removingLast = sizeIndex === this.array.length - 1;
		      var newChild;
		      if (level > 0) {
		        var oldChild = this.array[sizeIndex];
		        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
		        if (newChild === oldChild && removingLast) {
		          return this;
		        }
		      }
		      if (removingLast && !newChild) {
		        return this;
		      }
		      var editable = editableVNode(this, ownerID);
		      if (!removingLast) {
		        editable.array.pop();
		      }
		      if (newChild) {
		        editable.array[sizeIndex] = newChild;
		      }
		      return editable;
		    };
	
	
	
		  var DONE = {};
	
		  function iterateList(list, reverse) {
		    var left = list._origin;
		    var right = list._capacity;
		    var tailPos = getTailOffset(right);
		    var tail = list._tail;
	
		    return iterateNodeOrLeaf(list._root, list._level, 0);
	
		    function iterateNodeOrLeaf(node, level, offset) {
		      return level === 0 ?
		        iterateLeaf(node, offset) :
		        iterateNode(node, level, offset);
		    }
	
		    function iterateLeaf(node, offset) {
		      var array = offset === tailPos ? tail && tail.array : node && node.array;
		      var from = offset > left ? 0 : left - offset;
		      var to = right - offset;
		      if (to > SIZE) {
		        to = SIZE;
		      }
		      return function()  {
		        if (from === to) {
		          return DONE;
		        }
		        var idx = reverse ? --to : from++;
		        return array && array[idx];
		      };
		    }
	
		    function iterateNode(node, level, offset) {
		      var values;
		      var array = node && node.array;
		      var from = offset > left ? 0 : (left - offset) >> level;
		      var to = ((right - offset) >> level) + 1;
		      if (to > SIZE) {
		        to = SIZE;
		      }
		      return function()  {
		        do {
		          if (values) {
		            var value = values();
		            if (value !== DONE) {
		              return value;
		            }
		            values = null;
		          }
		          if (from === to) {
		            return DONE;
		          }
		          var idx = reverse ? --to : from++;
		          values = iterateNodeOrLeaf(
		            array && array[idx], level - SHIFT, offset + (idx << level)
		          );
		        } while (true);
		      };
		    }
		  }
	
		  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
		    var list = Object.create(ListPrototype);
		    list.size = capacity - origin;
		    list._origin = origin;
		    list._capacity = capacity;
		    list._level = level;
		    list._root = root;
		    list._tail = tail;
		    list.__ownerID = ownerID;
		    list.__hash = hash;
		    list.__altered = false;
		    return list;
		  }
	
		  var EMPTY_LIST;
		  function emptyList() {
		    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
		  }
	
		  function updateList(list, index, value) {
		    index = wrapIndex(list, index);
	
		    if (index >= list.size || index < 0) {
		      return list.withMutations(function(list ) {
		        index < 0 ?
		          setListBounds(list, index).set(0, value) :
		          setListBounds(list, 0, index + 1).set(index, value)
		      });
		    }
	
		    index += list._origin;
	
		    var newTail = list._tail;
		    var newRoot = list._root;
		    var didAlter = MakeRef(DID_ALTER);
		    if (index >= getTailOffset(list._capacity)) {
		      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
		    } else {
		      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
		    }
	
		    if (!didAlter.value) {
		      return list;
		    }
	
		    if (list.__ownerID) {
		      list._root = newRoot;
		      list._tail = newTail;
		      list.__hash = undefined;
		      list.__altered = true;
		      return list;
		    }
		    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
		  }
	
		  function updateVNode(node, ownerID, level, index, value, didAlter) {
		    var idx = (index >>> level) & MASK;
		    var nodeHas = node && idx < node.array.length;
		    if (!nodeHas && value === undefined) {
		      return node;
		    }
	
		    var newNode;
	
		    if (level > 0) {
		      var lowerNode = node && node.array[idx];
		      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
		      if (newLowerNode === lowerNode) {
		        return node;
		      }
		      newNode = editableVNode(node, ownerID);
		      newNode.array[idx] = newLowerNode;
		      return newNode;
		    }
	
		    if (nodeHas && node.array[idx] === value) {
		      return node;
		    }
	
		    SetRef(didAlter);
	
		    newNode = editableVNode(node, ownerID);
		    if (value === undefined && idx === newNode.array.length - 1) {
		      newNode.array.pop();
		    } else {
		      newNode.array[idx] = value;
		    }
		    return newNode;
		  }
	
		  function editableVNode(node, ownerID) {
		    if (ownerID && node && ownerID === node.ownerID) {
		      return node;
		    }
		    return new VNode(node ? node.array.slice() : [], ownerID);
		  }
	
		  function listNodeFor(list, rawIndex) {
		    if (rawIndex >= getTailOffset(list._capacity)) {
		      return list._tail;
		    }
		    if (rawIndex < 1 << (list._level + SHIFT)) {
		      var node = list._root;
		      var level = list._level;
		      while (node && level > 0) {
		        node = node.array[(rawIndex >>> level) & MASK];
		        level -= SHIFT;
		      }
		      return node;
		    }
		  }
	
		  function setListBounds(list, begin, end) {
		    var owner = list.__ownerID || new OwnerID();
		    var oldOrigin = list._origin;
		    var oldCapacity = list._capacity;
		    var newOrigin = oldOrigin + begin;
		    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
		    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
		      return list;
		    }
	
		    // If it's going to end after it starts, it's empty.
		    if (newOrigin >= newCapacity) {
		      return list.clear();
		    }
	
		    var newLevel = list._level;
		    var newRoot = list._root;
	
		    // New origin might need creating a higher root.
		    var offsetShift = 0;
		    while (newOrigin + offsetShift < 0) {
		      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
		      newLevel += SHIFT;
		      offsetShift += 1 << newLevel;
		    }
		    if (offsetShift) {
		      newOrigin += offsetShift;
		      oldOrigin += offsetShift;
		      newCapacity += offsetShift;
		      oldCapacity += offsetShift;
		    }
	
		    var oldTailOffset = getTailOffset(oldCapacity);
		    var newTailOffset = getTailOffset(newCapacity);
	
		    // New size might need creating a higher root.
		    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
		      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
		      newLevel += SHIFT;
		    }
	
		    // Locate or create the new tail.
		    var oldTail = list._tail;
		    var newTail = newTailOffset < oldTailOffset ?
		      listNodeFor(list, newCapacity - 1) :
		      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
	
		    // Merge Tail into tree.
		    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
		      newRoot = editableVNode(newRoot, owner);
		      var node = newRoot;
		      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
		        var idx = (oldTailOffset >>> level) & MASK;
		        node = node.array[idx] = editableVNode(node.array[idx], owner);
		      }
		      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
		    }
	
		    // If the size has been reduced, there's a chance the tail needs to be trimmed.
		    if (newCapacity < oldCapacity) {
		      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
		    }
	
		    // If the new origin is within the tail, then we do not need a root.
		    if (newOrigin >= newTailOffset) {
		      newOrigin -= newTailOffset;
		      newCapacity -= newTailOffset;
		      newLevel = SHIFT;
		      newRoot = null;
		      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
	
		    // Otherwise, if the root has been trimmed, garbage collect.
		    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
		      offsetShift = 0;
	
		      // Identify the new top root node of the subtree of the old root.
		      while (newRoot) {
		        var beginIndex = (newOrigin >>> newLevel) & MASK;
		        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
		          break;
		        }
		        if (beginIndex) {
		          offsetShift += (1 << newLevel) * beginIndex;
		        }
		        newLevel -= SHIFT;
		        newRoot = newRoot.array[beginIndex];
		      }
	
		      // Trim the new sides of the new root.
		      if (newRoot && newOrigin > oldOrigin) {
		        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
		      }
		      if (newRoot && newTailOffset < oldTailOffset) {
		        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
		      }
		      if (offsetShift) {
		        newOrigin -= offsetShift;
		        newCapacity -= offsetShift;
		      }
		    }
	
		    if (list.__ownerID) {
		      list.size = newCapacity - newOrigin;
		      list._origin = newOrigin;
		      list._capacity = newCapacity;
		      list._level = newLevel;
		      list._root = newRoot;
		      list._tail = newTail;
		      list.__hash = undefined;
		      list.__altered = true;
		      return list;
		    }
		    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
		  }
	
		  function mergeIntoListWith(list, merger, iterables) {
		    var iters = [];
		    var maxSize = 0;
		    for (var ii = 0; ii < iterables.length; ii++) {
		      var value = iterables[ii];
		      var iter = IndexedIterable(value);
		      if (iter.size > maxSize) {
		        maxSize = iter.size;
		      }
		      if (!isIterable(value)) {
		        iter = iter.map(function(v ) {return fromJS(v)});
		      }
		      iters.push(iter);
		    }
		    if (maxSize > list.size) {
		      list = list.setSize(maxSize);
		    }
		    return mergeIntoCollectionWith(list, merger, iters);
		  }
	
		  function getTailOffset(size) {
		    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
		  }
	
		  createClass(OrderedMap, src_Map__Map);
	
		    // @pragma Construction
	
		    function OrderedMap(value) {
		      return value === null || value === undefined ? emptyOrderedMap() :
		        isOrderedMap(value) ? value :
		        emptyOrderedMap().withMutations(function(map ) {
		          var iter = KeyedIterable(value);
		          assertNotInfinite(iter.size);
		          iter.forEach(function(v, k)  {return map.set(k, v)});
		        });
		    }
	
		    OrderedMap.of = function(/*...values*/) {
		      return this(arguments);
		    };
	
		    OrderedMap.prototype.toString = function() {
		      return this.__toString('OrderedMap {', '}');
		    };
	
		    // @pragma Access
	
		    OrderedMap.prototype.get = function(k, notSetValue) {
		      var index = this._map.get(k);
		      return index !== undefined ? this._list.get(index)[1] : notSetValue;
		    };
	
		    // @pragma Modification
	
		    OrderedMap.prototype.clear = function() {
		      if (this.size === 0) {
		        return this;
		      }
		      if (this.__ownerID) {
		        this.size = 0;
		        this._map.clear();
		        this._list.clear();
		        return this;
		      }
		      return emptyOrderedMap();
		    };
	
		    OrderedMap.prototype.set = function(k, v) {
		      return updateOrderedMap(this, k, v);
		    };
	
		    OrderedMap.prototype.remove = function(k) {
		      return updateOrderedMap(this, k, NOT_SET);
		    };
	
		    OrderedMap.prototype.wasAltered = function() {
		      return this._map.wasAltered() || this._list.wasAltered();
		    };
	
		    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return this._list.__iterate(
		        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
		        reverse
		      );
		    };
	
		    OrderedMap.prototype.__iterator = function(type, reverse) {
		      return this._list.fromEntrySeq().__iterator(type, reverse);
		    };
	
		    OrderedMap.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      var newMap = this._map.__ensureOwner(ownerID);
		      var newList = this._list.__ensureOwner(ownerID);
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this._map = newMap;
		        this._list = newList;
		        return this;
		      }
		      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
		    };
	
	
		  function isOrderedMap(maybeOrderedMap) {
		    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
		  }
	
		  OrderedMap.isOrderedMap = isOrderedMap;
	
		  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
		  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
	
	
	
		  function makeOrderedMap(map, list, ownerID, hash) {
		    var omap = Object.create(OrderedMap.prototype);
		    omap.size = map ? map.size : 0;
		    omap._map = map;
		    omap._list = list;
		    omap.__ownerID = ownerID;
		    omap.__hash = hash;
		    return omap;
		  }
	
		  var EMPTY_ORDERED_MAP;
		  function emptyOrderedMap() {
		    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
		  }
	
		  function updateOrderedMap(omap, k, v) {
		    var map = omap._map;
		    var list = omap._list;
		    var i = map.get(k);
		    var has = i !== undefined;
		    var newMap;
		    var newList;
		    if (v === NOT_SET) { // removed
		      if (!has) {
		        return omap;
		      }
		      if (list.size >= SIZE && list.size >= map.size * 2) {
		        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
		        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
		        if (omap.__ownerID) {
		          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
		        }
		      } else {
		        newMap = map.remove(k);
		        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
		      }
		    } else {
		      if (has) {
		        if (v === list.get(i)[1]) {
		          return omap;
		        }
		        newMap = map;
		        newList = list.set(i, [k, v]);
		      } else {
		        newMap = map.set(k, list.size);
		        newList = list.set(list.size, [k, v]);
		      }
		    }
		    if (omap.__ownerID) {
		      omap.size = newMap.size;
		      omap._map = newMap;
		      omap._list = newList;
		      omap.__hash = undefined;
		      return omap;
		    }
		    return makeOrderedMap(newMap, newList);
		  }
	
		  createClass(Stack, IndexedCollection);
	
		    // @pragma Construction
	
		    function Stack(value) {
		      return value === null || value === undefined ? emptyStack() :
		        isStack(value) ? value :
		        emptyStack().unshiftAll(value);
		    }
	
		    Stack.of = function(/*...values*/) {
		      return this(arguments);
		    };
	
		    Stack.prototype.toString = function() {
		      return this.__toString('Stack [', ']');
		    };
	
		    // @pragma Access
	
		    Stack.prototype.get = function(index, notSetValue) {
		      var head = this._head;
		      index = wrapIndex(this, index);
		      while (head && index--) {
		        head = head.next;
		      }
		      return head ? head.value : notSetValue;
		    };
	
		    Stack.prototype.peek = function() {
		      return this._head && this._head.value;
		    };
	
		    // @pragma Modification
	
		    Stack.prototype.push = function(/*...values*/) {
		      if (arguments.length === 0) {
		        return this;
		      }
		      var newSize = this.size + arguments.length;
		      var head = this._head;
		      for (var ii = arguments.length - 1; ii >= 0; ii--) {
		        head = {
		          value: arguments[ii],
		          next: head
		        };
		      }
		      if (this.__ownerID) {
		        this.size = newSize;
		        this._head = head;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return makeStack(newSize, head);
		    };
	
		    Stack.prototype.pushAll = function(iter) {
		      iter = IndexedIterable(iter);
		      if (iter.size === 0) {
		        return this;
		      }
		      assertNotInfinite(iter.size);
		      var newSize = this.size;
		      var head = this._head;
		      iter.reverse().forEach(function(value ) {
		        newSize++;
		        head = {
		          value: value,
		          next: head
		        };
		      });
		      if (this.__ownerID) {
		        this.size = newSize;
		        this._head = head;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return makeStack(newSize, head);
		    };
	
		    Stack.prototype.pop = function() {
		      return this.slice(1);
		    };
	
		    Stack.prototype.unshift = function(/*...values*/) {
		      return this.push.apply(this, arguments);
		    };
	
		    Stack.prototype.unshiftAll = function(iter) {
		      return this.pushAll(iter);
		    };
	
		    Stack.prototype.shift = function() {
		      return this.pop.apply(this, arguments);
		    };
	
		    Stack.prototype.clear = function() {
		      if (this.size === 0) {
		        return this;
		      }
		      if (this.__ownerID) {
		        this.size = 0;
		        this._head = undefined;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return emptyStack();
		    };
	
		    Stack.prototype.slice = function(begin, end) {
		      if (wholeSlice(begin, end, this.size)) {
		        return this;
		      }
		      var resolvedBegin = resolveBegin(begin, this.size);
		      var resolvedEnd = resolveEnd(end, this.size);
		      if (resolvedEnd !== this.size) {
		        // super.slice(begin, end);
		        return IndexedCollection.prototype.slice.call(this, begin, end);
		      }
		      var newSize = this.size - resolvedBegin;
		      var head = this._head;
		      while (resolvedBegin--) {
		        head = head.next;
		      }
		      if (this.__ownerID) {
		        this.size = newSize;
		        this._head = head;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return makeStack(newSize, head);
		    };
	
		    // @pragma Mutability
	
		    Stack.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this.__altered = false;
		        return this;
		      }
		      return makeStack(this.size, this._head, ownerID, this.__hash);
		    };
	
		    // @pragma Iteration
	
		    Stack.prototype.__iterate = function(fn, reverse) {
		      if (reverse) {
		        return this.reverse().__iterate(fn);
		      }
		      var iterations = 0;
		      var node = this._head;
		      while (node) {
		        if (fn(node.value, iterations++, this) === false) {
		          break;
		        }
		        node = node.next;
		      }
		      return iterations;
		    };
	
		    Stack.prototype.__iterator = function(type, reverse) {
		      if (reverse) {
		        return this.reverse().__iterator(type);
		      }
		      var iterations = 0;
		      var node = this._head;
		      return new src_Iterator__Iterator(function()  {
		        if (node) {
		          var value = node.value;
		          node = node.next;
		          return iteratorValue(type, iterations++, value);
		        }
		        return iteratorDone();
		      });
		    };
	
	
		  function isStack(maybeStack) {
		    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
		  }
	
		  Stack.isStack = isStack;
	
		  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
	
		  var StackPrototype = Stack.prototype;
		  StackPrototype[IS_STACK_SENTINEL] = true;
		  StackPrototype.withMutations = MapPrototype.withMutations;
		  StackPrototype.asMutable = MapPrototype.asMutable;
		  StackPrototype.asImmutable = MapPrototype.asImmutable;
		  StackPrototype.wasAltered = MapPrototype.wasAltered;
	
	
		  function makeStack(size, head, ownerID, hash) {
		    var map = Object.create(StackPrototype);
		    map.size = size;
		    map._head = head;
		    map.__ownerID = ownerID;
		    map.__hash = hash;
		    map.__altered = false;
		    return map;
		  }
	
		  var EMPTY_STACK;
		  function emptyStack() {
		    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
		  }
	
		  createClass(src_Set__Set, SetCollection);
	
		    // @pragma Construction
	
		    function src_Set__Set(value) {
		      return value === null || value === undefined ? emptySet() :
		        isSet(value) ? value :
		        emptySet().withMutations(function(set ) {
		          var iter = SetIterable(value);
		          assertNotInfinite(iter.size);
		          iter.forEach(function(v ) {return set.add(v)});
		        });
		    }
	
		    src_Set__Set.of = function(/*...values*/) {
		      return this(arguments);
		    };
	
		    src_Set__Set.fromKeys = function(value) {
		      return this(KeyedIterable(value).keySeq());
		    };
	
		    src_Set__Set.prototype.toString = function() {
		      return this.__toString('Set {', '}');
		    };
	
		    // @pragma Access
	
		    src_Set__Set.prototype.has = function(value) {
		      return this._map.has(value);
		    };
	
		    // @pragma Modification
	
		    src_Set__Set.prototype.add = function(value) {
		      return updateSet(this, this._map.set(value, true));
		    };
	
		    src_Set__Set.prototype.remove = function(value) {
		      return updateSet(this, this._map.remove(value));
		    };
	
		    src_Set__Set.prototype.clear = function() {
		      return updateSet(this, this._map.clear());
		    };
	
		    // @pragma Composition
	
		    src_Set__Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
		      iters = iters.filter(function(x ) {return x.size !== 0});
		      if (iters.length === 0) {
		        return this;
		      }
		      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
		        return this.constructor(iters[0]);
		      }
		      return this.withMutations(function(set ) {
		        for (var ii = 0; ii < iters.length; ii++) {
		          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
		        }
		      });
		    };
	
		    src_Set__Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
		      if (iters.length === 0) {
		        return this;
		      }
		      iters = iters.map(function(iter ) {return SetIterable(iter)});
		      var originalSet = this;
		      return this.withMutations(function(set ) {
		        originalSet.forEach(function(value ) {
		          if (!iters.every(function(iter ) {return iter.includes(value)})) {
		            set.remove(value);
		          }
		        });
		      });
		    };
	
		    src_Set__Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
		      if (iters.length === 0) {
		        return this;
		      }
		      iters = iters.map(function(iter ) {return SetIterable(iter)});
		      var originalSet = this;
		      return this.withMutations(function(set ) {
		        originalSet.forEach(function(value ) {
		          if (iters.some(function(iter ) {return iter.includes(value)})) {
		            set.remove(value);
		          }
		        });
		      });
		    };
	
		    src_Set__Set.prototype.merge = function() {
		      return this.union.apply(this, arguments);
		    };
	
		    src_Set__Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return this.union.apply(this, iters);
		    };
	
		    src_Set__Set.prototype.sort = function(comparator) {
		      // Late binding
		      return OrderedSet(sortFactory(this, comparator));
		    };
	
		    src_Set__Set.prototype.sortBy = function(mapper, comparator) {
		      // Late binding
		      return OrderedSet(sortFactory(this, comparator, mapper));
		    };
	
		    src_Set__Set.prototype.wasAltered = function() {
		      return this._map.wasAltered();
		    };
	
		    src_Set__Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
		    };
	
		    src_Set__Set.prototype.__iterator = function(type, reverse) {
		      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
		    };
	
		    src_Set__Set.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      var newMap = this._map.__ensureOwner(ownerID);
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this._map = newMap;
		        return this;
		      }
		      return this.__make(newMap, ownerID);
		    };
	
	
		  function isSet(maybeSet) {
		    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
		  }
	
		  src_Set__Set.isSet = isSet;
	
		  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
	
		  var SetPrototype = src_Set__Set.prototype;
		  SetPrototype[IS_SET_SENTINEL] = true;
		  SetPrototype[DELETE] = SetPrototype.remove;
		  SetPrototype.mergeDeep = SetPrototype.merge;
		  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
		  SetPrototype.withMutations = MapPrototype.withMutations;
		  SetPrototype.asMutable = MapPrototype.asMutable;
		  SetPrototype.asImmutable = MapPrototype.asImmutable;
	
		  SetPrototype.__empty = emptySet;
		  SetPrototype.__make = makeSet;
	
		  function updateSet(set, newMap) {
		    if (set.__ownerID) {
		      set.size = newMap.size;
		      set._map = newMap;
		      return set;
		    }
		    return newMap === set._map ? set :
		      newMap.size === 0 ? set.__empty() :
		      set.__make(newMap);
		  }
	
		  function makeSet(map, ownerID) {
		    var set = Object.create(SetPrototype);
		    set.size = map ? map.size : 0;
		    set._map = map;
		    set.__ownerID = ownerID;
		    return set;
		  }
	
		  var EMPTY_SET;
		  function emptySet() {
		    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
		  }
	
		  createClass(OrderedSet, src_Set__Set);
	
		    // @pragma Construction
	
		    function OrderedSet(value) {
		      return value === null || value === undefined ? emptyOrderedSet() :
		        isOrderedSet(value) ? value :
		        emptyOrderedSet().withMutations(function(set ) {
		          var iter = SetIterable(value);
		          assertNotInfinite(iter.size);
		          iter.forEach(function(v ) {return set.add(v)});
		        });
		    }
	
		    OrderedSet.of = function(/*...values*/) {
		      return this(arguments);
		    };
	
		    OrderedSet.fromKeys = function(value) {
		      return this(KeyedIterable(value).keySeq());
		    };
	
		    OrderedSet.prototype.toString = function() {
		      return this.__toString('OrderedSet {', '}');
		    };
	
	
		  function isOrderedSet(maybeOrderedSet) {
		    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
		  }
	
		  OrderedSet.isOrderedSet = isOrderedSet;
	
		  var OrderedSetPrototype = OrderedSet.prototype;
		  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
	
		  OrderedSetPrototype.__empty = emptyOrderedSet;
		  OrderedSetPrototype.__make = makeOrderedSet;
	
		  function makeOrderedSet(map, ownerID) {
		    var set = Object.create(OrderedSetPrototype);
		    set.size = map ? map.size : 0;
		    set._map = map;
		    set.__ownerID = ownerID;
		    return set;
		  }
	
		  var EMPTY_ORDERED_SET;
		  function emptyOrderedSet() {
		    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
		  }
	
		  createClass(Record, KeyedCollection);
	
		    function Record(defaultValues, name) {
		      var hasInitialized;
	
		      var RecordType = function Record(values) {
		        if (values instanceof RecordType) {
		          return values;
		        }
		        if (!(this instanceof RecordType)) {
		          return new RecordType(values);
		        }
		        if (!hasInitialized) {
		          hasInitialized = true;
		          var keys = Object.keys(defaultValues);
		          setProps(RecordTypePrototype, keys);
		          RecordTypePrototype.size = keys.length;
		          RecordTypePrototype._name = name;
		          RecordTypePrototype._keys = keys;
		          RecordTypePrototype._defaultValues = defaultValues;
		        }
		        this._map = src_Map__Map(values);
		      };
	
		      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
		      RecordTypePrototype.constructor = RecordType;
	
		      return RecordType;
		    }
	
		    Record.prototype.toString = function() {
		      return this.__toString(recordName(this) + ' {', '}');
		    };
	
		    // @pragma Access
	
		    Record.prototype.has = function(k) {
		      return this._defaultValues.hasOwnProperty(k);
		    };
	
		    Record.prototype.get = function(k, notSetValue) {
		      if (!this.has(k)) {
		        return notSetValue;
		      }
		      var defaultVal = this._defaultValues[k];
		      return this._map ? this._map.get(k, defaultVal) : defaultVal;
		    };
	
		    // @pragma Modification
	
		    Record.prototype.clear = function() {
		      if (this.__ownerID) {
		        this._map && this._map.clear();
		        return this;
		      }
		      var RecordType = this.constructor;
		      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
		    };
	
		    Record.prototype.set = function(k, v) {
		      if (!this.has(k)) {
		        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
		      }
		      var newMap = this._map && this._map.set(k, v);
		      if (this.__ownerID || newMap === this._map) {
		        return this;
		      }
		      return makeRecord(this, newMap);
		    };
	
		    Record.prototype.remove = function(k) {
		      if (!this.has(k)) {
		        return this;
		      }
		      var newMap = this._map && this._map.remove(k);
		      if (this.__ownerID || newMap === this._map) {
		        return this;
		      }
		      return makeRecord(this, newMap);
		    };
	
		    Record.prototype.wasAltered = function() {
		      return this._map.wasAltered();
		    };
	
		    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
		      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
		    };
	
		    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
		    };
	
		    Record.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      var newMap = this._map && this._map.__ensureOwner(ownerID);
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this._map = newMap;
		        return this;
		      }
		      return makeRecord(this, newMap, ownerID);
		    };
	
	
		  var RecordPrototype = Record.prototype;
		  RecordPrototype[DELETE] = RecordPrototype.remove;
		  RecordPrototype.deleteIn =
		  RecordPrototype.removeIn = MapPrototype.removeIn;
		  RecordPrototype.merge = MapPrototype.merge;
		  RecordPrototype.mergeWith = MapPrototype.mergeWith;
		  RecordPrototype.mergeIn = MapPrototype.mergeIn;
		  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
		  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
		  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
		  RecordPrototype.setIn = MapPrototype.setIn;
		  RecordPrototype.update = MapPrototype.update;
		  RecordPrototype.updateIn = MapPrototype.updateIn;
		  RecordPrototype.withMutations = MapPrototype.withMutations;
		  RecordPrototype.asMutable = MapPrototype.asMutable;
		  RecordPrototype.asImmutable = MapPrototype.asImmutable;
	
	
		  function makeRecord(likeRecord, map, ownerID) {
		    var record = Object.create(Object.getPrototypeOf(likeRecord));
		    record._map = map;
		    record.__ownerID = ownerID;
		    return record;
		  }
	
		  function recordName(record) {
		    return record._name || record.constructor.name || 'Record';
		  }
	
		  function setProps(prototype, names) {
		    try {
		      names.forEach(setProp.bind(undefined, prototype));
		    } catch (error) {
		      // Object.defineProperty failed. Probably IE8.
		    }
		  }
	
		  function setProp(prototype, name) {
		    Object.defineProperty(prototype, name, {
		      get: function() {
		        return this.get(name);
		      },
		      set: function(value) {
		        invariant(this.__ownerID, 'Cannot set on an immutable record.');
		        this.set(name, value);
		      }
		    });
		  }
	
		  function deepEqual(a, b) {
		    if (a === b) {
		      return true;
		    }
	
		    if (
		      !isIterable(b) ||
		      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
		      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
		      isKeyed(a) !== isKeyed(b) ||
		      isIndexed(a) !== isIndexed(b) ||
		      isOrdered(a) !== isOrdered(b)
		    ) {
		      return false;
		    }
	
		    if (a.size === 0 && b.size === 0) {
		      return true;
		    }
	
		    var notAssociative = !isAssociative(a);
	
		    if (isOrdered(a)) {
		      var entries = a.entries();
		      return b.every(function(v, k)  {
		        var entry = entries.next().value;
		        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
		      }) && entries.next().done;
		    }
	
		    var flipped = false;
	
		    if (a.size === undefined) {
		      if (b.size === undefined) {
		        if (typeof a.cacheResult === 'function') {
		          a.cacheResult();
		        }
		      } else {
		        flipped = true;
		        var _ = a;
		        a = b;
		        b = _;
		      }
		    }
	
		    var allEqual = true;
		    var bSize = b.__iterate(function(v, k)  {
		      if (notAssociative ? !a.has(v) :
		          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
		        allEqual = false;
		        return false;
		      }
		    });
	
		    return allEqual && a.size === bSize;
		  }
	
		  createClass(Range, IndexedSeq);
	
		    function Range(start, end, step) {
		      if (!(this instanceof Range)) {
		        return new Range(start, end, step);
		      }
		      invariant(step !== 0, 'Cannot step a Range by 0');
		      start = start || 0;
		      if (end === undefined) {
		        end = Infinity;
		      }
		      step = step === undefined ? 1 : Math.abs(step);
		      if (end < start) {
		        step = -step;
		      }
		      this._start = start;
		      this._end = end;
		      this._step = step;
		      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
		      if (this.size === 0) {
		        if (EMPTY_RANGE) {
		          return EMPTY_RANGE;
		        }
		        EMPTY_RANGE = this;
		      }
		    }
	
		    Range.prototype.toString = function() {
		      if (this.size === 0) {
		        return 'Range []';
		      }
		      return 'Range [ ' +
		        this._start + '...' + this._end +
		        (this._step > 1 ? ' by ' + this._step : '') +
		      ' ]';
		    };
	
		    Range.prototype.get = function(index, notSetValue) {
		      return this.has(index) ?
		        this._start + wrapIndex(this, index) * this._step :
		        notSetValue;
		    };
	
		    Range.prototype.includes = function(searchValue) {
		      var possibleIndex = (searchValue - this._start) / this._step;
		      return possibleIndex >= 0 &&
		        possibleIndex < this.size &&
		        possibleIndex === Math.floor(possibleIndex);
		    };
	
		    Range.prototype.slice = function(begin, end) {
		      if (wholeSlice(begin, end, this.size)) {
		        return this;
		      }
		      begin = resolveBegin(begin, this.size);
		      end = resolveEnd(end, this.size);
		      if (end <= begin) {
		        return new Range(0, 0);
		      }
		      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
		    };
	
		    Range.prototype.indexOf = function(searchValue) {
		      var offsetValue = searchValue - this._start;
		      if (offsetValue % this._step === 0) {
		        var index = offsetValue / this._step;
		        if (index >= 0 && index < this.size) {
		          return index
		        }
		      }
		      return -1;
		    };
	
		    Range.prototype.lastIndexOf = function(searchValue) {
		      return this.indexOf(searchValue);
		    };
	
		    Range.prototype.__iterate = function(fn, reverse) {
		      var maxIndex = this.size - 1;
		      var step = this._step;
		      var value = reverse ? this._start + maxIndex * step : this._start;
		      for (var ii = 0; ii <= maxIndex; ii++) {
		        if (fn(value, ii, this) === false) {
		          return ii + 1;
		        }
		        value += reverse ? -step : step;
		      }
		      return ii;
		    };
	
		    Range.prototype.__iterator = function(type, reverse) {
		      var maxIndex = this.size - 1;
		      var step = this._step;
		      var value = reverse ? this._start + maxIndex * step : this._start;
		      var ii = 0;
		      return new src_Iterator__Iterator(function()  {
		        var v = value;
		        value += reverse ? -step : step;
		        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
		      });
		    };
	
		    Range.prototype.equals = function(other) {
		      return other instanceof Range ?
		        this._start === other._start &&
		        this._end === other._end &&
		        this._step === other._step :
		        deepEqual(this, other);
		    };
	
	
		  var EMPTY_RANGE;
	
		  createClass(Repeat, IndexedSeq);
	
		    function Repeat(value, times) {
		      if (!(this instanceof Repeat)) {
		        return new Repeat(value, times);
		      }
		      this._value = value;
		      this.size = times === undefined ? Infinity : Math.max(0, times);
		      if (this.size === 0) {
		        if (EMPTY_REPEAT) {
		          return EMPTY_REPEAT;
		        }
		        EMPTY_REPEAT = this;
		      }
		    }
	
		    Repeat.prototype.toString = function() {
		      if (this.size === 0) {
		        return 'Repeat []';
		      }
		      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
		    };
	
		    Repeat.prototype.get = function(index, notSetValue) {
		      return this.has(index) ? this._value : notSetValue;
		    };
	
		    Repeat.prototype.includes = function(searchValue) {
		      return is(this._value, searchValue);
		    };
	
		    Repeat.prototype.slice = function(begin, end) {
		      var size = this.size;
		      return wholeSlice(begin, end, size) ? this :
		        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
		    };
	
		    Repeat.prototype.reverse = function() {
		      return this;
		    };
	
		    Repeat.prototype.indexOf = function(searchValue) {
		      if (is(this._value, searchValue)) {
		        return 0;
		      }
		      return -1;
		    };
	
		    Repeat.prototype.lastIndexOf = function(searchValue) {
		      if (is(this._value, searchValue)) {
		        return this.size;
		      }
		      return -1;
		    };
	
		    Repeat.prototype.__iterate = function(fn, reverse) {
		      for (var ii = 0; ii < this.size; ii++) {
		        if (fn(this._value, ii, this) === false) {
		          return ii + 1;
		        }
		      }
		      return ii;
		    };
	
		    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
		      var ii = 0;
		      return new src_Iterator__Iterator(function() 
		        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
		      );
		    };
	
		    Repeat.prototype.equals = function(other) {
		      return other instanceof Repeat ?
		        is(this._value, other._value) :
		        deepEqual(other);
		    };
	
	
		  var EMPTY_REPEAT;
	
		  /**
		   * Contributes additional methods to a constructor
		   */
		  function mixin(ctor, methods) {
		    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
		    Object.keys(methods).forEach(keyCopier);
		    Object.getOwnPropertySymbols &&
		      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
		    return ctor;
		  }
	
		  Iterable.Iterator = src_Iterator__Iterator;
	
		  mixin(Iterable, {
	
		    // ### Conversion to other types
	
		    toArray: function() {
		      assertNotInfinite(this.size);
		      var array = new Array(this.size || 0);
		      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
		      return array;
		    },
	
		    toIndexedSeq: function() {
		      return new ToIndexedSequence(this);
		    },
	
		    toJS: function() {
		      return this.toSeq().map(
		        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
		      ).__toJS();
		    },
	
		    toJSON: function() {
		      return this.toSeq().map(
		        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
		      ).__toJS();
		    },
	
		    toKeyedSeq: function() {
		      return new ToKeyedSequence(this, true);
		    },
	
		    toMap: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return src_Map__Map(this.toKeyedSeq());
		    },
	
		    toObject: function() {
		      assertNotInfinite(this.size);
		      var object = {};
		      this.__iterate(function(v, k)  { object[k] = v; });
		      return object;
		    },
	
		    toOrderedMap: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return OrderedMap(this.toKeyedSeq());
		    },
	
		    toOrderedSet: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
		    },
	
		    toSet: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return src_Set__Set(isKeyed(this) ? this.valueSeq() : this);
		    },
	
		    toSetSeq: function() {
		      return new ToSetSequence(this);
		    },
	
		    toSeq: function() {
		      return isIndexed(this) ? this.toIndexedSeq() :
		        isKeyed(this) ? this.toKeyedSeq() :
		        this.toSetSeq();
		    },
	
		    toStack: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return Stack(isKeyed(this) ? this.valueSeq() : this);
		    },
	
		    toList: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return List(isKeyed(this) ? this.valueSeq() : this);
		    },
	
	
		    // ### Common JavaScript methods and properties
	
		    toString: function() {
		      return '[Iterable]';
		    },
	
		    __toString: function(head, tail) {
		      if (this.size === 0) {
		        return head + tail;
		      }
		      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
		    },
	
	
		    // ### ES6 Collection methods (ES6 Array and Map)
	
		    concat: function() {var values = SLICE$0.call(arguments, 0);
		      return reify(this, concatFactory(this, values));
		    },
	
		    contains: function(searchValue) {
		      return this.includes(searchValue);
		    },
	
		    includes: function(searchValue) {
		      return this.some(function(value ) {return is(value, searchValue)});
		    },
	
		    entries: function() {
		      return this.__iterator(ITERATE_ENTRIES);
		    },
	
		    every: function(predicate, context) {
		      assertNotInfinite(this.size);
		      var returnValue = true;
		      this.__iterate(function(v, k, c)  {
		        if (!predicate.call(context, v, k, c)) {
		          returnValue = false;
		          return false;
		        }
		      });
		      return returnValue;
		    },
	
		    filter: function(predicate, context) {
		      return reify(this, filterFactory(this, predicate, context, true));
		    },
	
		    find: function(predicate, context, notSetValue) {
		      var entry = this.findEntry(predicate, context);
		      return entry ? entry[1] : notSetValue;
		    },
	
		    findEntry: function(predicate, context) {
		      var found;
		      this.__iterate(function(v, k, c)  {
		        if (predicate.call(context, v, k, c)) {
		          found = [k, v];
		          return false;
		        }
		      });
		      return found;
		    },
	
		    findLastEntry: function(predicate, context) {
		      return this.toSeq().reverse().findEntry(predicate, context);
		    },
	
		    forEach: function(sideEffect, context) {
		      assertNotInfinite(this.size);
		      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
		    },
	
		    join: function(separator) {
		      assertNotInfinite(this.size);
		      separator = separator !== undefined ? '' + separator : ',';
		      var joined = '';
		      var isFirst = true;
		      this.__iterate(function(v ) {
		        isFirst ? (isFirst = false) : (joined += separator);
		        joined += v !== null && v !== undefined ? v.toString() : '';
		      });
		      return joined;
		    },
	
		    keys: function() {
		      return this.__iterator(ITERATE_KEYS);
		    },
	
		    map: function(mapper, context) {
		      return reify(this, mapFactory(this, mapper, context));
		    },
	
		    reduce: function(reducer, initialReduction, context) {
		      assertNotInfinite(this.size);
		      var reduction;
		      var useFirst;
		      if (arguments.length < 2) {
		        useFirst = true;
		      } else {
		        reduction = initialReduction;
		      }
		      this.__iterate(function(v, k, c)  {
		        if (useFirst) {
		          useFirst = false;
		          reduction = v;
		        } else {
		          reduction = reducer.call(context, reduction, v, k, c);
		        }
		      });
		      return reduction;
		    },
	
		    reduceRight: function(reducer, initialReduction, context) {
		      var reversed = this.toKeyedSeq().reverse();
		      return reversed.reduce.apply(reversed, arguments);
		    },
	
		    reverse: function() {
		      return reify(this, reverseFactory(this, true));
		    },
	
		    slice: function(begin, end) {
		      return reify(this, sliceFactory(this, begin, end, true));
		    },
	
		    some: function(predicate, context) {
		      return !this.every(not(predicate), context);
		    },
	
		    sort: function(comparator) {
		      return reify(this, sortFactory(this, comparator));
		    },
	
		    values: function() {
		      return this.__iterator(ITERATE_VALUES);
		    },
	
	
		    // ### More sequential methods
	
		    butLast: function() {
		      return this.slice(0, -1);
		    },
	
		    isEmpty: function() {
		      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
		    },
	
		    count: function(predicate, context) {
		      return ensureSize(
		        predicate ? this.toSeq().filter(predicate, context) : this
		      );
		    },
	
		    countBy: function(grouper, context) {
		      return countByFactory(this, grouper, context);
		    },
	
		    equals: function(other) {
		      return deepEqual(this, other);
		    },
	
		    entrySeq: function() {
		      var iterable = this;
		      if (iterable._cache) {
		        // We cache as an entries array, so we can just return the cache!
		        return new ArraySeq(iterable._cache);
		      }
		      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
		      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
		      return entriesSequence;
		    },
	
		    filterNot: function(predicate, context) {
		      return this.filter(not(predicate), context);
		    },
	
		    findLast: function(predicate, context, notSetValue) {
		      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
		    },
	
		    first: function() {
		      return this.find(returnTrue);
		    },
	
		    flatMap: function(mapper, context) {
		      return reify(this, flatMapFactory(this, mapper, context));
		    },
	
		    flatten: function(depth) {
		      return reify(this, flattenFactory(this, depth, true));
		    },
	
		    fromEntrySeq: function() {
		      return new FromEntriesSequence(this);
		    },
	
		    get: function(searchKey, notSetValue) {
		      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
		    },
	
		    getIn: function(searchKeyPath, notSetValue) {
		      var nested = this;
		      // Note: in an ES6 environment, we would prefer:
		      // for (var key of searchKeyPath) {
		      var iter = forceIterator(searchKeyPath);
		      var step;
		      while (!(step = iter.next()).done) {
		        var key = step.value;
		        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
		        if (nested === NOT_SET) {
		          return notSetValue;
		        }
		      }
		      return nested;
		    },
	
		    groupBy: function(grouper, context) {
		      return groupByFactory(this, grouper, context);
		    },
	
		    has: function(searchKey) {
		      return this.get(searchKey, NOT_SET) !== NOT_SET;
		    },
	
		    hasIn: function(searchKeyPath) {
		      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
		    },
	
		    isSubset: function(iter) {
		      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
		      return this.every(function(value ) {return iter.includes(value)});
		    },
	
		    isSuperset: function(iter) {
		      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
		      return iter.isSubset(this);
		    },
	
		    keySeq: function() {
		      return this.toSeq().map(keyMapper).toIndexedSeq();
		    },
	
		    last: function() {
		      return this.toSeq().reverse().first();
		    },
	
		    max: function(comparator) {
		      return maxFactory(this, comparator);
		    },
	
		    maxBy: function(mapper, comparator) {
		      return maxFactory(this, comparator, mapper);
		    },
	
		    min: function(comparator) {
		      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
		    },
	
		    minBy: function(mapper, comparator) {
		      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
		    },
	
		    rest: function() {
		      return this.slice(1);
		    },
	
		    skip: function(amount) {
		      return this.slice(Math.max(0, amount));
		    },
	
		    skipLast: function(amount) {
		      return reify(this, this.toSeq().reverse().skip(amount).reverse());
		    },
	
		    skipWhile: function(predicate, context) {
		      return reify(this, skipWhileFactory(this, predicate, context, true));
		    },
	
		    skipUntil: function(predicate, context) {
		      return this.skipWhile(not(predicate), context);
		    },
	
		    sortBy: function(mapper, comparator) {
		      return reify(this, sortFactory(this, comparator, mapper));
		    },
	
		    take: function(amount) {
		      return this.slice(0, Math.max(0, amount));
		    },
	
		    takeLast: function(amount) {
		      return reify(this, this.toSeq().reverse().take(amount).reverse());
		    },
	
		    takeWhile: function(predicate, context) {
		      return reify(this, takeWhileFactory(this, predicate, context));
		    },
	
		    takeUntil: function(predicate, context) {
		      return this.takeWhile(not(predicate), context);
		    },
	
		    valueSeq: function() {
		      return this.toIndexedSeq();
		    },
	
	
		    // ### Hashable Object
	
		    hashCode: function() {
		      return this.__hash || (this.__hash = hashIterable(this));
		    },
	
	
		    // ### Internal
	
		    // abstract __iterate(fn, reverse)
	
		    // abstract __iterator(type, reverse)
		  });
	
		  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
		  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
		  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
		  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
		  var IterablePrototype = Iterable.prototype;
		  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
		  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
		  IterablePrototype.__toJS = IterablePrototype.toArray;
		  IterablePrototype.__toStringMapper = quoteString;
		  IterablePrototype.inspect =
		  IterablePrototype.toSource = function() { return this.toString(); };
		  IterablePrototype.chain = IterablePrototype.flatMap;
	
		  // Temporary warning about using length
		  (function () {
		    try {
		      Object.defineProperty(IterablePrototype, 'length', {
		        get: function () {
		          if (!Iterable.noLengthWarning) {
		            var stack;
		            try {
		              throw new Error();
		            } catch (error) {
		              stack = error.stack;
		            }
		            if (stack.indexOf('_wrapObject') === -1) {
		              console && console.warn && console.warn(
		                'iterable.length has been deprecated, '+
		                'use iterable.size or iterable.count(). '+
		                'This warning will become a silent error in a future version. ' +
		                stack
		              );
		              return this.size;
		            }
		          }
		        }
		      });
		    } catch (e) {}
		  })();
	
	
	
		  mixin(KeyedIterable, {
	
		    // ### More sequential methods
	
		    flip: function() {
		      return reify(this, flipFactory(this));
		    },
	
		    findKey: function(predicate, context) {
		      var entry = this.findEntry(predicate, context);
		      return entry && entry[0];
		    },
	
		    findLastKey: function(predicate, context) {
		      return this.toSeq().reverse().findKey(predicate, context);
		    },
	
		    keyOf: function(searchValue) {
		      return this.findKey(function(value ) {return is(value, searchValue)});
		    },
	
		    lastKeyOf: function(searchValue) {
		      return this.findLastKey(function(value ) {return is(value, searchValue)});
		    },
	
		    mapEntries: function(mapper, context) {var this$0 = this;
		      var iterations = 0;
		      return reify(this,
		        this.toSeq().map(
		          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
		        ).fromEntrySeq()
		      );
		    },
	
		    mapKeys: function(mapper, context) {var this$0 = this;
		      return reify(this,
		        this.toSeq().flip().map(
		          function(k, v)  {return mapper.call(context, k, v, this$0)}
		        ).flip()
		      );
		    },
	
		  });
	
		  var KeyedIterablePrototype = KeyedIterable.prototype;
		  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
		  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
		  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
		  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};
	
	
	
		  mixin(IndexedIterable, {
	
		    // ### Conversion to other types
	
		    toKeyedSeq: function() {
		      return new ToKeyedSequence(this, false);
		    },
	
	
		    // ### ES6 Collection methods (ES6 Array and Map)
	
		    filter: function(predicate, context) {
		      return reify(this, filterFactory(this, predicate, context, false));
		    },
	
		    findIndex: function(predicate, context) {
		      var entry = this.findEntry(predicate, context);
		      return entry ? entry[0] : -1;
		    },
	
		    indexOf: function(searchValue) {
		      var key = this.toKeyedSeq().keyOf(searchValue);
		      return key === undefined ? -1 : key;
		    },
	
		    lastIndexOf: function(searchValue) {
		      return this.toSeq().reverse().indexOf(searchValue);
		    },
	
		    reverse: function() {
		      return reify(this, reverseFactory(this, false));
		    },
	
		    slice: function(begin, end) {
		      return reify(this, sliceFactory(this, begin, end, false));
		    },
	
		    splice: function(index, removeNum /*, ...values*/) {
		      var numArgs = arguments.length;
		      removeNum = Math.max(removeNum | 0, 0);
		      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
		        return this;
		      }
		      index = resolveBegin(index, this.size);
		      var spliced = this.slice(0, index);
		      return reify(
		        this,
		        numArgs === 1 ?
		          spliced :
		          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
		      );
		    },
	
	
		    // ### More collection methods
	
		    findLastIndex: function(predicate, context) {
		      var key = this.toKeyedSeq().findLastKey(predicate, context);
		      return key === undefined ? -1 : key;
		    },
	
		    first: function() {
		      return this.get(0);
		    },
	
		    flatten: function(depth) {
		      return reify(this, flattenFactory(this, depth, false));
		    },
	
		    get: function(index, notSetValue) {
		      index = wrapIndex(this, index);
		      return (index < 0 || (this.size === Infinity ||
		          (this.size !== undefined && index > this.size))) ?
		        notSetValue :
		        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
		    },
	
		    has: function(index) {
		      index = wrapIndex(this, index);
		      return index >= 0 && (this.size !== undefined ?
		        this.size === Infinity || index < this.size :
		        this.indexOf(index) !== -1
		      );
		    },
	
		    interpose: function(separator) {
		      return reify(this, interposeFactory(this, separator));
		    },
	
		    interleave: function(/*...iterables*/) {
		      var iterables = [this].concat(arrCopy(arguments));
		      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
		      var interleaved = zipped.flatten(true);
		      if (zipped.size) {
		        interleaved.size = zipped.size * iterables.length;
		      }
		      return reify(this, interleaved);
		    },
	
		    last: function() {
		      return this.get(-1);
		    },
	
		    skipWhile: function(predicate, context) {
		      return reify(this, skipWhileFactory(this, predicate, context, false));
		    },
	
		    zip: function(/*, ...iterables */) {
		      var iterables = [this].concat(arrCopy(arguments));
		      return reify(this, zipWithFactory(this, defaultZipper, iterables));
		    },
	
		    zipWith: function(zipper/*, ...iterables */) {
		      var iterables = arrCopy(arguments);
		      iterables[0] = this;
		      return reify(this, zipWithFactory(this, zipper, iterables));
		    },
	
		  });
	
		  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
		  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	
		  mixin(SetIterable, {
	
		    // ### ES6 Collection methods (ES6 Array and Map)
	
		    get: function(value, notSetValue) {
		      return this.has(value) ? value : notSetValue;
		    },
	
		    includes: function(value) {
		      return this.has(value);
		    },
	
	
		    // ### More sequential methods
	
		    keySeq: function() {
		      return this.valueSeq();
		    },
	
		  });
	
		  SetIterable.prototype.has = IterablePrototype.includes;
	
	
		  // Mixin subclasses
	
		  mixin(KeyedSeq, KeyedIterable.prototype);
		  mixin(IndexedSeq, IndexedIterable.prototype);
		  mixin(SetSeq, SetIterable.prototype);
	
		  mixin(KeyedCollection, KeyedIterable.prototype);
		  mixin(IndexedCollection, IndexedIterable.prototype);
		  mixin(SetCollection, SetIterable.prototype);
	
	
		  // #pragma Helper functions
	
		  function keyMapper(v, k) {
		    return k;
		  }
	
		  function entryMapper(v, k) {
		    return [k, v];
		  }
	
		  function not(predicate) {
		    return function() {
		      return !predicate.apply(this, arguments);
		    }
		  }
	
		  function neg(predicate) {
		    return function() {
		      return -predicate.apply(this, arguments);
		    }
		  }
	
		  function quoteString(value) {
		    return typeof value === 'string' ? JSON.stringify(value) : value;
		  }
	
		  function defaultZipper() {
		    return arrCopy(arguments);
		  }
	
		  function defaultNegComparator(a, b) {
		    return a < b ? 1 : a > b ? -1 : 0;
		  }
	
		  function hashIterable(iterable) {
		    if (iterable.size === Infinity) {
		      return 0;
		    }
		    var ordered = isOrdered(iterable);
		    var keyed = isKeyed(iterable);
		    var h = ordered ? 1 : 0;
		    var size = iterable.__iterate(
		      keyed ?
		        ordered ?
		          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
		          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
		        ordered ?
		          function(v ) { h = 31 * h + hash(v) | 0; } :
		          function(v ) { h = h + hash(v) | 0; }
		    );
		    return murmurHashOfSize(size, h);
		  }
	
		  function murmurHashOfSize(size, h) {
		    h = src_Math__imul(h, 0xCC9E2D51);
		    h = src_Math__imul(h << 15 | h >>> -15, 0x1B873593);
		    h = src_Math__imul(h << 13 | h >>> -13, 5);
		    h = (h + 0xE6546B64 | 0) ^ size;
		    h = src_Math__imul(h ^ h >>> 16, 0x85EBCA6B);
		    h = src_Math__imul(h ^ h >>> 13, 0xC2B2AE35);
		    h = smi(h ^ h >>> 16);
		    return h;
		  }
	
		  function hashMerge(a, b) {
		    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
		  }
	
		  var Immutable = {
	
		    Iterable: Iterable,
	
		    Seq: Seq,
		    Collection: Collection,
		    Map: src_Map__Map,
		    OrderedMap: OrderedMap,
		    List: List,
		    Stack: Stack,
		    Set: src_Set__Set,
		    OrderedSet: OrderedSet,
	
		    Record: Record,
		    Range: Range,
		    Repeat: Repeat,
	
		    is: is,
		    fromJS: fromJS,
	
		  };
	
		  return Immutable;
	
		}));
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
		/**
		 * Checks if the passed in value is a string
		 * @param {*} val
		 * @return {boolean}
		 */
		exports.isString = function(val) {
		  return typeof val === 'string' || objectToString(val) === '[object String]'
		}
	
		/**
		 * Checks if the passed in value is an array
		 * @param {*} val
		 * @return {boolean}
		 */
		exports.isArray = Array.isArray /* istanbul ignore next */|| function(val) {
		  return objectToString(val) === '[object Array]'
		}
	
		// taken from underscore source to account for browser discrepancy
		/* istanbul ignore if  */
		if (typeof /./ !== 'function' && typeof Int8Array !== 'object') {
		  /**
		   * Checks if the passed in value is a function
		   * @param {*} val
		   * @return {boolean}
		   */
		  exports.isFunction = function(obj) {
		    return typeof obj === 'function' || false
		  }
		} else {
		  /**
		   * Checks if the passed in value is a function
		   * @param {*} val
		   * @return {boolean}
		   */
		  exports.isFunction = function(val) {
		    return toString.call(val) === '[object Function]'
		  }
		}
	
		/**
		 * Checks if the passed in value is of type Object
		 * @param {*} val
		 * @return {boolean}
		 */
		exports.isObject = function(obj) {
		  var type = typeof obj
		  return type === 'function' || type === 'object' && !!obj
		}
	
		/**
		 * Extends an object with the properties of additional objects
		 * @param {object} obj
		 * @param {object} objects
		 * @return {object}
		 */
		exports.extend = function(obj) {
		  var length = arguments.length
	
		  if (!obj || length < 2) {
		    return obj || {}
		  }
	
		  for (var index = 1; index < length; index++) {
		    var source = arguments[index]
		    var keys = Object.keys(source)
		    var l = keys.length
	
		    for (var i = 0; i < l; i++) {
		      var key = keys[i]
		      obj[key] = source[key]
		    }
		  }
	
		  return obj
		}
	
		/**
		 * Creates a shallow clone of an object
		 * @param {object} obj
		 * @return {object}
		 */
		exports.clone = function(obj) {
		  if (!exports.isObject(obj)) {
		    return obj
		  }
		  return exports.isArray(obj) ? obj.slice() : exports.extend({}, obj)
		}
	
		/**
		 * Iterates over a collection of elements yielding each iteration to an
		 * iteratee. The iteratee may be bound to the context argument and is invoked
		 * each time with three arguments (value, index|key, collection). Iteration may
		 * be exited early by explicitly returning false.
		 * @param {array|object|string} collection
		 * @param {function} iteratee
		 * @param {*} context
		 * @return {array|object|string}
		 */
		exports.each = function(collection, iteratee, context) {
		  var length = collection ? collection.length : 0
		  var i = -1
		  var keys
		  var origIteratee
	
		  if (context) {
		    origIteratee = iteratee
		    iteratee = function(value, index, innerCollection) {
		      return origIteratee.call(context, value, index, innerCollection)
		    }
		  }
	
		  if (isLength(length)) {
		    while (++i < length) {
		      if (iteratee(collection[i], i, collection) === false) {
		        break
		      }
		    }
		  } else {
		    keys = Object.keys(collection)
		    length = keys.length
		    while (++i < length) {
		      if (iteratee(collection[keys[i]], keys[i], collection) === false) {
		        break
		      }
		    }
		  }
	
		  return collection
		}
	
		/**
		 * Returns a new function the invokes `func` with `partialArgs` prepended to
		 * any passed into the new function. Acts like `Array.prototype.bind`, except
		 * it does not alter `this` context.
		 * @param {function} func
		 * @param {*} partialArgs
		 * @return {function}
		 */
		exports.partial = function(func) {
		  var slice = Array.prototype.slice
		  var partialArgs = slice.call(arguments, 1)
	
		  return function() {
		    return func.apply(this, partialArgs.concat(slice.call(arguments)))
		  }
		}
	
		/**
		 * Returns the text value representation of an object
		 * @private
		 * @param {*} obj
		 * @return {string}
		 */
		function objectToString(obj) {
		  return obj && typeof obj === 'object' && toString.call(obj)
		}
	
		/**
		 * Checks if the value is a valid array-like length.
		 * @private
		 * @param {*} val
		 * @return {bool}
		 */
		function isLength(val) {
		  return typeof val === 'number'
		    && val > -1
		    && val % 1 === 0
		    && val <= Number.MAX_VALUE
		}
	
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Immutable = __webpack_require__(2)
		var logging = __webpack_require__(5)
		var ChangeObserver = __webpack_require__(6)
		var Getter = __webpack_require__(9)
		var KeyPath = __webpack_require__(10)
		var Evaluator = __webpack_require__(11)
		var createReactMixin = __webpack_require__(12)
	
		// helper fns
		var toJS = __webpack_require__(1).toJS
		var toImmutable = __webpack_require__(1).toImmutable
		var isImmutableValue = __webpack_require__(1).isImmutableValue
		var each = __webpack_require__(3).each
	
	
		/**
		 * State is stored in NuclearJS Reactors.  Reactors
		 * contain a 'state' object which is an Immutable.Map
		 *
		 * The only way Reactors can change state is by reacting to
		 * messages.  To update state, Reactor's dispatch messages to
		 * all registered cores, and the core returns it's new
		 * state based on the message
		 */
	
		  function Reactor(config) {"use strict";
		    if (!(this instanceof Reactor)) {
		      return new Reactor(config)
		    }
		    config = config || {}
	
		    this.debug = !!config.debug
	
		    this.ReactMixin = createReactMixin(this)
		    /**
		     * The state for the whole cluster
		     */
		    this.state = Immutable.Map({})
		    /**
		     * Holds a map of id => store instance
		     */
		    this.__stores = Immutable.Map({})
	
		    this.__evaluator = new Evaluator()
		    /**
		     * Change observer interface to observe certain keypaths
		     * Created after __initialize so it starts with initialState
		     */
		    this.__changeObserver = new ChangeObserver(this.state, this.__evaluator)
	
		    // keep track of the depth of batch nesting
		    this.__batchDepth = 0
		    // number of dispatches in the top most batch cycle
		    this.__batchDispatchCount = 0
	
		    // keep track if we are currently dispatching
		    this.__isDispatching = false
		  }
	
		  /**
		   * Evaluates a KeyPath or Getter in context of the reactor state
		   * @param {KeyPath|Getter} keyPathOrGetter
		   * @return {*}
		   */
		  Object.defineProperty(Reactor.prototype,"evaluate",{writable:true,configurable:true,value:function(keyPathOrGetter) {"use strict";
		    return this.__evaluator.evaluate(this.state, keyPathOrGetter)
		  }});
	
		  /**
		   * Gets the coerced state (to JS object) of the reactor.evaluate
		   * @param {KeyPath|Getter} keyPathOrGetter
		   * @return {*}
		   */
		  Object.defineProperty(Reactor.prototype,"evaluateToJS",{writable:true,configurable:true,value:function(keyPathOrGetter) {"use strict";
		    return toJS(this.evaluate(keyPathOrGetter))
		  }});
	
		  /**
		   * Adds a change observer whenever a certain part of the reactor state changes
		   *
		   * 1. observe(handlerFn) - 1 argument, called anytime reactor.state changes
		   * 2. observe(keyPath, handlerFn) same as above
		   * 3. observe(getter, handlerFn) called whenever any getter dependencies change with
		   *    the value of the getter
		   *
		   * Adds a change handler whenever certain deps change
		   * If only one argument is passed invoked the handler whenever
		   * the reactor state changes
		   *
		   * @param {KeyPath|Getter} getter
		   * @param {function} handler
		   * @return {function} unwatch function
		   */
		  Object.defineProperty(Reactor.prototype,"observe",{writable:true,configurable:true,value:function(getter, handler) {"use strict";
		    if (arguments.length === 1) {
		      handler = getter
		      getter = Getter.fromKeyPath([])
		    } else if (KeyPath.isKeyPath(getter)) {
		      getter = Getter.fromKeyPath(getter)
		    }
		    return this.__changeObserver.onChange(getter, handler)
		  }});
	
	
		  /**
		   * Dispatches a single message
		   * @param {string} actionType
		   * @param {object|undefined} payload
		   */
		  Object.defineProperty(Reactor.prototype,"dispatch",{writable:true,configurable:true,value:function(actionType, payload) {"use strict";
		    if (this.__batchDepth === 0) {
		      if (this.__isDispatching) {
		        this.__isDispatching = false
		        throw new Error('Dispatch may not be called while a dispatch is in progress')
		      }
		      this.__isDispatching = true
		    }
	
		    var prevState = this.state
	
		    try {
		      this.state = this.__handleAction(prevState, actionType, payload)
		    } catch (e) {
		      this.__isDispatching = false
		      throw e
		    }
	
	
		    if (this.__batchDepth > 0) {
		      this.__batchDispatchCount++
		    } else {
		      if (this.state !== prevState) {
		        try {
		          this.__notify()
		        } catch (e) {
		          this.__isDispatching = false
		          throw e
		        }
		      }
		      this.__isDispatching = false
		    }
		  }});
	
		  /**
		   * Allows batching of dispatches before notifying change observers
		   * @param {Function} fn
		   */
		  Object.defineProperty(Reactor.prototype,"batch",{writable:true,configurable:true,value:function(fn) {"use strict";
		    this.__batchStart()
		    fn()
		    this.__batchEnd()
		  }});
	
		  /**
		   * @deprecated
		   * @param {String} id
		   * @param {Store} store
		   */
		  Object.defineProperty(Reactor.prototype,"registerStore",{writable:true,configurable:true,value:function(id, store) {"use strict";
		    /* eslint-disable no-console */
		    console.warn('Deprecation warning: `registerStore` will no longer be supported in 1.1, use `registerStores` instead')
		    /* eslint-enable no-console */
		    var stores = {}
		    stores[id] = store
		    this.registerStores(stores)
		  }});
	
		  /**
		   * @param {Store[]} stores
		   */
		  Object.defineProperty(Reactor.prototype,"registerStores",{writable:true,configurable:true,value:function(stores) {"use strict";
		    each(stores, function(store, id)  {
		      if (this.__stores.get(id)) {
		        /* eslint-disable no-console */
		        console.warn('Store already defined for id = ' + id)
		        /* eslint-enable no-console */
		      }
	
		      var initialState = store.getInitialState()
	
		      if (this.debug && !isImmutableValue(initialState)) {
		        throw new Error('Store getInitialState() must return an immutable value, did you forget to call toImmutable')
		      }
	
		      this.__stores = this.__stores.set(id, store)
		      this.state = this.state.set(id, initialState)
		    }.bind(this))
	
		    this.__notify()
		  }});
	
		  /**
		   * Returns a plain object representing the application state
		   * @return {Object}
		   */
		  Object.defineProperty(Reactor.prototype,"serialize",{writable:true,configurable:true,value:function() {"use strict";
		    var serialized = {}
		    this.__stores.forEach(function(store, id)  {
		      var storeState = this.state.get(id)
		      var serializedState = store.serialize(storeState)
		      if (serializedState !== undefined) {
		        serialized[id] = serializedState
		      }
		    }.bind(this))
		    return serialized
		  }});
	
		  /**
		   * @param {Object} state
		   */
		  Object.defineProperty(Reactor.prototype,"loadState",{writable:true,configurable:true,value:function(state) {"use strict";
		    var stateToLoad = toImmutable({}).withMutations(function(stateToLoad)  {
		      each(state, function(serializedStoreState, storeId)  {
		        var store = this.__stores.get(storeId)
		        if (store) {
		          var storeState = store.deserialize(serializedStoreState)
		          if (storeState !== undefined) {
		            stateToLoad.set(storeId, storeState)
		          }
		        }
		      }.bind(this))
		    }.bind(this))
	
		    this.state = this.state.merge(stateToLoad)
		    this.__notify()
		  }});
	
		  /**
		   * Resets the state of a reactor and returns back to initial state
		   */
		  Object.defineProperty(Reactor.prototype,"reset",{writable:true,configurable:true,value:function() {"use strict";
		    var debug = this.debug
		    var prevState = this.state
	
		    this.state = Immutable.Map().withMutations(function(state)  {
		      this.__stores.forEach(function(store, id)  {
		        var storeState = prevState.get(id)
		        var resetStoreState = store.handleReset(storeState)
		        if (debug && resetStoreState === undefined) {
		          throw new Error('Store handleReset() must return a value, did you forget a return statement')
		        }
		        if (debug && !isImmutableValue(resetStoreState)) {
		          throw new Error('Store reset state must be an immutable value, did you forget to call toImmutable')
		        }
		        state.set(id, resetStoreState)
		      })
		    }.bind(this))
	
		    this.__evaluator.reset()
		    this.__changeObserver.reset(this.state)
		  }});
	
		  /**
		   * Notifies all change observers with the current state
		   * @private
		   */
		  Object.defineProperty(Reactor.prototype,"__notify",{writable:true,configurable:true,value:function() {"use strict";
		    this.__changeObserver.notifyObservers(this.state)
		  }});
	
		  /**
		   * Reduces the current state to the new state given actionType / message
		   * @param {string} actionType
		   * @param {object|undefined} payload
		   * @return {Immutable.Map}
		   */
		  Object.defineProperty(Reactor.prototype,"__handleAction",{writable:true,configurable:true,value:function(state, actionType, payload) {"use strict";
		    return state.withMutations(function(state)  {
		      if (this.debug) {
		        logging.dispatchStart(actionType, payload)
		      }
	
		      // let each store handle the message
		      this.__stores.forEach(function(store, id)  {
		        var currState = state.get(id)
		        var newState
	
		        try {
		          newState = store.handle(currState, actionType, payload)
		        } catch(e) {
		          // ensure console.group is properly closed
		          logging.dispatchError(e.message)
		          throw e
		        }
	
		        if (this.debug && newState === undefined) {
		          var errorMsg = 'Store handler must return a value, did you forget a return statement'
		          logging.dispatchError(errorMsg)
		          throw new Error(errorMsg)
		        }
	
		        state.set(id, newState)
	
		        if (this.debug) {
		          logging.storeHandled(id, currState, newState)
		        }
		      }.bind(this))
	
		      if (this.debug) {
		        logging.dispatchEnd(state)
		      }
		    }.bind(this))
		  }});
	
		  Object.defineProperty(Reactor.prototype,"__batchStart",{writable:true,configurable:true,value:function() {"use strict";
		    this.__batchDepth++
		  }});
	
		  Object.defineProperty(Reactor.prototype,"__batchEnd",{writable:true,configurable:true,value:function() {"use strict";
		    this.__batchDepth--
	
		    if (this.__batchDepth <= 0) {
		      if (this.__batchDispatchCount > 0) {
		        // set to true to catch if dispatch called from observer
		        this.__isDispatching = true
		        try {
		          this.__notify()
		        } catch (e) {
		          this.__isDispatching = false
		          throw e
		        }
		        this.__isDispatching = false
		      }
		      this.__batchDispatchCount = 0
		    }
		  }});
	
	
		module.exports = Reactor
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
		/* eslint-disable no-console */
		/**
		 * Wraps a Reactor.react invocation in a console.group
		*/
		exports.dispatchStart = function(type, payload) {
		  if (console.group) {
		    console.groupCollapsed('Dispatch: %s', type)
		    console.group('payload')
		    console.debug(payload)
		    console.groupEnd()
		  }
		}
	
		exports.dispatchError = function(error) {
		  if (console.group) {
		    console.debug('Dispatch error: ' + error)
		    console.groupEnd()
		  }
		}
	
		exports.storeHandled = function(id, before, after) {
		  if (console.group) {
		    if (before !== after) {
		      console.debug('Store ' + id + ' handled action')
		    }
		  }
		}
	
		exports.dispatchEnd = function(state) {
		  if (console.group) {
		    console.debug('Dispatch done, new state: ', state.toJS())
		    console.groupEnd()
		  }
		}
		/* eslint-enable no-console */
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Immutable = __webpack_require__(2)
		var hashCode = __webpack_require__(7)
		var isEqual = __webpack_require__(8)
	
		/**
		 * ChangeObserver is an object that contains a set of subscriptions
		 * to changes for keyPaths on a reactor
		 *
		 * Packaging the handlers together allows for easier cleanup
		 */
	
		  /**
		   * @param {Immutable.Map} initialState
		   * @param {Evaluator} evaluator
		   */
		  function ChangeObserver(initialState, evaluator) {"use strict";
		    this.__prevState = initialState
		    this.__evaluator = evaluator
		    this.__prevValues = Immutable.Map()
		    this.__observers = []
		  }
	
		  /**
		   * @param {Immutable.Map} newState
		   */
		  Object.defineProperty(ChangeObserver.prototype,"notifyObservers",{writable:true,configurable:true,value:function(newState) {"use strict";
		    if (this.__observers.length > 0) {
		      var currentValues = Immutable.Map()
	
		      this.__observers.forEach(function(entry)  {
		        var getter = entry.getter
		        var code = hashCode(getter)
		        var prevState = this.__prevState
		        var prevValue
	
		        if (this.__prevValues.has(code)) {
		          prevValue = this.__prevValues.get(code)
		        } else {
		          prevValue = this.__evaluator.evaluate(prevState, getter)
		          this.__prevValues = this.__prevValues.set(code, prevValue)
		        }
	
		        var currValue = this.__evaluator.evaluate(newState, getter)
	
		        if (!isEqual(prevValue, currValue)) {
		          entry.handler.call(null, currValue)
		          currentValues = currentValues.set(code, currValue)
		        }
		      }.bind(this))
	
		      this.__prevValues = currentValues
		    }
		    this.__prevState = newState
		  }});
	
		  /**
		   * Specify a getter and a change handler function
		   * Handler function is called whenever the value of the getter changes
		   * @param {Getter} getter
		   * @param {function} handler
		   * @return {function} unwatch function
		   */
		  Object.defineProperty(ChangeObserver.prototype,"onChange",{writable:true,configurable:true,value:function(getter, handler) {"use strict";
		    // TODO: make observers a map of <Getter> => { handlers }
		    var entry = {
		      getter: getter,
		      handler: handler,
		    }
		    this.__observers.push(entry)
		    // return unwatch function
		    return function()  {
		      // TODO: untrack from change emitter
		      var ind = this.__observers.indexOf(entry)
		      if (ind > -1) {
		        this.__observers.splice(ind, 1)
		      }
		    }.bind(this)
		  }});
	
		  /**
		   * Resets and clears all observers and reinitializes back to the supplied
		   * previous state
		   * @param {Immutable.Map} prevState
		   *
		   */
		  Object.defineProperty(ChangeObserver.prototype,"reset",{writable:true,configurable:true,value:function(prevState) {"use strict";
		    this.__prevState = prevState
		    this.__prevValues = Immutable.Map()
		    this.__observers = []
		  }});
	
	
		module.exports = ChangeObserver
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Immutable = __webpack_require__(2)
	
		/**
		 * Takes a getter and returns the hash code value
		 *
		 * If cache argument is true it will freeze the getter
		 * and cache the hashed value
		 *
		 * @param {Getter} getter
		 * @param {boolean} dontCache
		 * @return {number}
		 */
		module.exports = function(getter, dontCache) {
		  if (getter.hasOwnProperty('__hashCode')) {
		    return getter.__hashCode
		  }
	
		  var hashCode = Immutable.fromJS(getter).hashCode()
	
		  if (!dontCache) {
		    Object.defineProperty(getter, '__hashCode', {
		      enumerable: false,
		      configurable: false,
		      writable: false,
		      value: hashCode,
		    })
	
		    Object.freeze(getter)
		  }
	
		  return hashCode
		}
	
	
	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Immutable = __webpack_require__(2)
		/**
		 * Is equal by value check
		 */
		module.exports = function(a, b) {
		  return Immutable.is(a, b)
		}
	
	
	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isFunction = __webpack_require__(3).isFunction
		var isArray = __webpack_require__(3).isArray
		var isKeyPath = __webpack_require__(10).isKeyPath
	
		/**
		 * Getter helper functions
		 * A getter is an array with the form:
		 * [<KeyPath>, ...<KeyPath>, <function>]
		 */
		var identity = function(x)  {return x;}
	
		/**
		 * Checks if something is a getter literal, ex: ['dep1', 'dep2', function(dep1, dep2) {...}]
		 * @param {*} toTest
		 * @return {boolean}
		 */
		function isGetter(toTest) {
		  return (isArray(toTest) && isFunction(toTest[toTest.length - 1]))
		}
	
		/**
		 * Returns the compute function from a getter
		 * @param {Getter} getter
		 * @return {function}
		 */
		function getComputeFn(getter) {
		  return getter[getter.length - 1]
		}
	
		/**
		 * Returns an array of deps from a getter
		 * @param {Getter} getter
		 * @return {function}
		 */
		function getDeps(getter) {
		  return getter.slice(0, getter.length - 1)
		}
	
		/**
		 * @param {KeyPath}
		 * @return {Getter}
		 */
		function fromKeyPath(keyPath) {
		  if (!isKeyPath(keyPath)) {
		    throw new Error('Cannot create Getter from KeyPath: ' + keyPath)
		  }
	
		  return [keyPath, identity]
		}
	
	
		module.exports = {
		  isGetter: isGetter,
		  getComputeFn: getComputeFn,
		  getDeps: getDeps,
		  fromKeyPath: fromKeyPath,
		}
	
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
		var isArray = __webpack_require__(3).isArray
		var isFunction = __webpack_require__(3).isFunction
	
		/**
		 * Checks if something is simply a keyPath and not a getter
		 * @param {*} toTest
		 * @return {boolean}
		 */
		exports.isKeyPath = function(toTest) {
		  return (
		    isArray(toTest) &&
		    !isFunction(toTest[toTest.length - 1])
		  )
		}
	
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Immutable = __webpack_require__(2)
		var toImmutable = __webpack_require__(1).toImmutable
		var hashCode = __webpack_require__(7)
		var isEqual = __webpack_require__(8)
		var getComputeFn = __webpack_require__(9).getComputeFn
		var getDeps = __webpack_require__(9).getDeps
		var isKeyPath = __webpack_require__(10).isKeyPath
		var isGetter = __webpack_require__(9).isGetter
	
		// Keep track of whether we are currently executing a Getter's computeFn
		var __applyingComputeFn = false
	
	
		  function Evaluator() {"use strict";
		    /**
		     * {
		     *   <hashCode>: {
		     *     stateHashCode: number,
		     *     args: Immutable.List,
		     *     value: any,
		     *   }
		     * }
		     */
		    this.__cachedGetters = Immutable.Map({})
		  }
	
		  /**
		   * Takes either a KeyPath or Getter and evaluates
		   *
		   * KeyPath form:
		   * ['foo', 'bar'] => state.getIn(['foo', 'bar'])
		   *
		   * Getter form:
		   * [<KeyPath>, <KeyPath>, ..., <function>]
		   *
		   * @param {Immutable.Map} state
		   * @param {string|array} getter
		   * @return {any}
		   */
		  Object.defineProperty(Evaluator.prototype,"evaluate",{writable:true,configurable:true,value:function(state, keyPathOrGetter) {"use strict";
		    if (isKeyPath(keyPathOrGetter)) {
		      // if its a keyPath simply return
		      return state.getIn(keyPathOrGetter)
		    } else if (!isGetter(keyPathOrGetter)) {
		      throw new Error('evaluate must be passed a keyPath or Getter')
		    }
	
		    // Must be a Getter
		    var code = hashCode(keyPathOrGetter)
	
		    // if the value is cached for this dispatch cycle, return the cached value
		    if (this.__isCached(state, keyPathOrGetter)) {
		      // Cache hit
		      return this.__cachedGetters.getIn([code, 'value'])
	
		    }
	
		    // evaluate dependencies
		    var args = getDeps(keyPathOrGetter).map(function(dep)  {return this.evaluate(state, dep);}.bind(this))
	
		    if (this.__hasStaleValue(state, keyPathOrGetter)) {
		      // getter deps could still be unchanged since we only looked at the unwrapped (keypath, bottom level) deps
		      var prevArgs = this.__cachedGetters.getIn([code, 'args'])
	
		      // since Getter is a pure functions if the args are the same its a cache hit
		      if (isEqual(prevArgs, toImmutable(args))) {
		        var prevValue = this.__cachedGetters.getIn([code, 'value'])
		        this.__cacheValue(state, keyPathOrGetter, prevArgs, prevValue)
		        return prevValue
		      }
		    }
	
		    // This indicates that we have called evaluate within the body of a computeFn.
		    // Throw an error as this will lead to inconsistent caching
		    if (__applyingComputeFn === true) {
		      __applyingComputeFn = false
		      throw new Error('Evaluate may not be called within a Getters computeFn')
		    }
	
		    var evaluatedValue
		    __applyingComputeFn = true
		    try {
		      evaluatedValue = getComputeFn(keyPathOrGetter).apply(null, args)
		      __applyingComputeFn = false
		    } catch (e) {
		      __applyingComputeFn = false
		      throw e
		    }
	
		    this.__cacheValue(state, keyPathOrGetter, args, evaluatedValue)
	
		    return evaluatedValue
		  }});
	
		  /**
		   * @param {Immutable.Map} state
		   * @param {Getter} getter
		   */
		  Object.defineProperty(Evaluator.prototype,"__hasStaleValue",{writable:true,configurable:true,value:function(state, getter) {"use strict";
		    var code = hashCode(getter)
		    var cache = this.__cachedGetters
		    return (
		      cache.has(code) &&
		      cache.getIn([code, 'stateHashCode']) !== state.hashCode()
		    )
		  }});
	
		  /**
		   * Caches the value of a getter given state, getter, args, value
		   * @param {Immutable.Map} state
		   * @param {Getter} getter
		   * @param {Array} args
		   * @param {any} value
		   */
		  Object.defineProperty(Evaluator.prototype,"__cacheValue",{writable:true,configurable:true,value:function(state, getter, args, value) {"use strict";
		    var code = hashCode(getter)
		    this.__cachedGetters = this.__cachedGetters.set(code, Immutable.Map({
		      value: value,
		      args: toImmutable(args),
		      stateHashCode: state.hashCode(),
		    }))
		  }});
	
		  /**
		   * Returns boolean whether the supplied getter is cached for a given state
		   * @param {Immutable.Map} state
		   * @param {Getter} getter
		   * @return {boolean}
		   */
		  Object.defineProperty(Evaluator.prototype,"__isCached",{writable:true,configurable:true,value:function(state, getter) {"use strict";
		    var code = hashCode(getter)
		    return (
		      this.__cachedGetters.hasIn([code, 'value']) &&
		      this.__cachedGetters.getIn([code, 'stateHashCode']) === state.hashCode()
		    )
		  }});
	
		  /**
		   * Removes all caching about a getter
		   * @param {Getter}
		   */
		  Object.defineProperty(Evaluator.prototype,"untrack",{writable:true,configurable:true,value:function(getter) {"use strict";
		    // TODO: untrack all dependencies
		  }});
	
		  Object.defineProperty(Evaluator.prototype,"reset",{writable:true,configurable:true,value:function() {"use strict";
		    this.__cachedGetters = Immutable.Map({})
		  }});
	
	
		module.exports = Evaluator
	
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
		var each = __webpack_require__(3).each
		/**
		 * @param {Reactor} reactor
		 */
		module.exports = function(reactor) {
		  return {
		    getInitialState: function() {
		      return getState(reactor, this.getDataBindings())
		    },
	
		    componentDidMount: function() {
		      var component = this
		      component.__unwatchFns = []
		      each(this.getDataBindings(), function(getter, key) {
		        var unwatchFn = reactor.observe(getter, function(val) {
		          var newState = {}
		          newState[key] = val
		          component.setState(newState)
		        })
	
		        component.__unwatchFns.push(unwatchFn)
		      })
		    },
	
		    componentWillUnmount: function() {
		      while (this.__unwatchFns.length) {
		        this.__unwatchFns.shift()()
		      }
		    },
		  }
		}
	
		/**
		 * Returns a mapping of the getDataBinding keys to
		 * the reactor values
		 */
		function getState(reactor, data) {
		  var state = {}
		  each(data, function(value, key) {
		    state[key] = reactor.evaluate(value)
		  })
		  return state
		}
	
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
		var Map = __webpack_require__(2).Map
		var extend = __webpack_require__(3).extend
		var toJS = __webpack_require__(1).toJS
		var toImmutable = __webpack_require__(1).toImmutable
	
		/**
		 * Stores define how a certain domain of the application should respond to actions
		 * taken on the whole system.  They manage their own section of the entire app state
		 * and have no knowledge about the other parts of the application state.
		 */
	
		  function Store(config) {"use strict";
		    if (!(this instanceof Store)) {
		      return new Store(config)
		    }
	
		    this.__handlers = Map({})
	
		    if (config) {
		      // allow `MyStore extends Store` syntax without throwing error
		      extend(this, config)
		    }
	
		    this.initialize()
		  }
	
		  /**
		   * This method is overridden by extending classes to setup message handlers
		   * via `this.on` and to set up the initial state
		   *
		   * Anything returned from this function will be coerced into an ImmutableJS value
		   * and set as the initial state for the part of the ReactorCore
		   */
		  Object.defineProperty(Store.prototype,"initialize",{writable:true,configurable:true,value:function() {"use strict";
		    // extending classes implement to setup action handlers
		  }});
	
		  /**
		   * Overridable method to get the initial state for this type of store
		   */
		  Object.defineProperty(Store.prototype,"getInitialState",{writable:true,configurable:true,value:function() {"use strict";
		    return Map()
		  }});
	
		  /**
		   * Takes a current reactor state, action type and payload
		   * does the reaction and returns the new state
		   */
		  Object.defineProperty(Store.prototype,"handle",{writable:true,configurable:true,value:function(state, type, payload) {"use strict";
		    var handler = this.__handlers.get(type)
	
		    if (typeof handler === 'function') {
		      return handler.call(this, state, payload, type)
		    }
	
		    return state
		  }});
	
		  /**
		   * Pure function taking the current state of store and returning
		   * the new state after a NuclearJS reactor has been reset
		   *
		   * Overridable
		   */
		  Object.defineProperty(Store.prototype,"handleReset",{writable:true,configurable:true,value:function(state) {"use strict";
		    return this.getInitialState()
		  }});
	
		  /**
		   * Binds an action type => handler
		   */
		  Object.defineProperty(Store.prototype,"on",{writable:true,configurable:true,value:function(actionType, handler) {"use strict";
		    this.__handlers = this.__handlers.set(actionType, handler)
		  }});
	
		  /**
		   * Serializes store state to plain JSON serializable JavaScript
		   * Overridable
		   * @param {*}
		   * @return {*}
		   */
		  Object.defineProperty(Store.prototype,"serialize",{writable:true,configurable:true,value:function(state) {"use strict";
		    return toJS(state)
		  }});
	
		  /**
		   * Deserializes plain JavaScript to store state
		   * Overridable
		   * @param {*}
		   * @return {*}
		   */
		  Object.defineProperty(Store.prototype,"deserialize",{writable:true,configurable:true,value:function(state) {"use strict";
		    return toImmutable(state)
		  }});
	
	
		function isStore(toTest) {
		  return (toTest instanceof Store)
		}
	
		module.exports = Store
	
		module.exports.isStore = isStore
	
	
	/***/ }
	/******/ ])
	});
	;

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _dispatcher = __webpack_require__(167);
	
	var _dispatcher2 = _interopRequireDefault(_dispatcher);
	
	var _constants = __webpack_require__(170);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	exports["default"] = {
	  incCounter: function incCounter() {
	    _dispatcher2["default"].dispatch(_constants2["default"].INC_COUNTER);
	  },
	  decCounter: function decCounter() {
	    _dispatcher2["default"].dispatch(_constants2["default"].DEC_COUNTER);
	  }
	};
	module.exports = exports["default"];

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _reactLibKeyMirror = __webpack_require__(8);
	
	var _reactLibKeyMirror2 = _interopRequireDefault(_reactLibKeyMirror);
	
	exports['default'] = (0, _reactLibKeyMirror2['default'])({
	  INC_COUNTER: null,
	  DEC_COUNTER: null
	});
	module.exports = exports['default'];

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	var _nuclearJs = __webpack_require__(168);
	
	var _actionsConstants = __webpack_require__(170);
	
	var _actionsConstants2 = _interopRequireDefault(_actionsConstants);
	
	exports["default"] = (0, _nuclearJs.Store)({
	  getInitialState: function getInitialState() {
	    return (0, _nuclearJs.toImmutable)({
	      counter: 0
	    });
	  },
	  initialize: function initialize() {
	    this.on(_actionsConstants2["default"].INC_COUNTER, function (state) {
	      return state.set('counter', state.get('counter') + 1);
	    });
	    this.on(_actionsConstants2["default"].DEC_COUNTER, function (state) {
	      return state.set('counter', state.get('counter') - 1);
	    });
	  }
	});
	module.exports = exports["default"];

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var config = __webpack_require__(173);
	var webpack = __webpack_require__(174);
	config.output.filename = "index.min.js";
	delete config.devtool;
	config.plugins.push(new webpack.optimize.UglifyJsPlugin());
	config.plugins.push(new webpack.optimize.DedupePlugin());
	
	module.exports = config;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	var webpack = __webpack_require__(174);
	module.exports = {
	  entry: "./index.jsx",
	  output: {
	    path: './',
	    filename: "index.js"
	  },
	  module: {
	    loaders: [
	      { test: /\.(jsx|es6)$/, loaders:['babel'], exclude: /node_modules/ },
	      { test: /\.json$/, loader: 'json' },
	      { test: /\.css$/, exclude: /\.useable\.css$/, loader: "style!css" },
	      { test: /\.less$/, loader: "style!css!less" }
	    ]
	  },
	  resolve: {
	    extensions: ['', '.js', '.es6', '.jsx']
	  },
	  devtool: 'source-map',
	  plugins: [
	    new webpack.ProvidePlugin({
	      //fetch: 'imports?this=>global!exports?global.fetch!whatwg-fetch'
	    })
	  ]
	};

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Compiler = __webpack_require__(175);
	var WebEnvironmentPlugin = __webpack_require__(273);
	var WebpackOptionsApply = __webpack_require__(274);
	var WebpackOptionsDefaulter = __webpack_require__(549);
	
	function webpack(options, callback) {
		new WebpackOptionsDefaulter().process(options);
	
		var compiler = new Compiler();
		compiler.options = options;
		compiler.options = new WebpackOptionsApply().process(options, compiler);
		new WebEnvironmentPlugin(options.inputFileSystem, options.outputFileSystem).apply(compiler);
		if(callback) {
			compiler.run(callback);
		}
		return compiler;
	}
	module.exports = webpack;
	
	webpack.WebpackOptionsDefaulter = WebpackOptionsDefaulter;
	webpack.WebpackOptionsApply = WebpackOptionsApply;
	webpack.Compiler = Compiler;
	webpack.WebEnvironmentPlugin = WebEnvironmentPlugin;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(180);
	var Tapable = __webpack_require__(181);
	
	var Compilation = __webpack_require__(182);
	var Parser = __webpack_require__(249);
	var Resolver = __webpack_require__(252);
	
	var NormalModuleFactory = __webpack_require__(256);
	var ContextModuleFactory = __webpack_require__(269);
	
	function Watching(compiler, watchOptions, handler) {
		this.startTime = null;
		this.invalid = false;
		this.error = null;
		this.stats = null;
		this.handler = handler;
		if(typeof watchOptions === "number") {
			this.watchOptions = {
				aggregateTimeout: watchOptions
			};
		} else if(watchOptions && typeof watchOptions === "object") {
			this.watchOptions = Object.create(watchOptions);
		} else {
			this.watchOptions = {};
		}
		this.watchOptions.aggregateTimeout = this.watchOptions.aggregateTimeout || 200;
		this.compiler = compiler;
		this.running = true;
		this.compiler.readRecords(function(err) {
			if(err) return this._done(err);
	
			this._go();
		}.bind(this));
	}
	
	Watching.prototype._go = function() {
		this.startTime = new Date().getTime();
		this.running = true;
		this.invalid = false;
		this.compiler.applyPluginsAsync("watch-run", this, function(err) {
			if(err) return this._done(err);
			this.compiler.compile(function(err, compilation) {
				if(err) return this._done(err);
				if(this.invalid) return this._done();
	
				if(this.compiler.applyPluginsBailResult("should-emit", compilation) === false) {
					return this._done(null, compilation);
				}
	
				this.compiler.emitAssets(compilation, function(err) {
					if(err) return this._done(err);
					if(this.invalid) return this._done();
	
					this.compiler.emitRecords(function(err) {
						if(err) return this._done(err);
	
						return this._done(null, compilation);
					}.bind(this));
				}.bind(this));
			}.bind(this));
		}.bind(this));
	};
	
	Watching.prototype._done = function(err, compilation) {
		this.running = false;
		if(this.invalid) return this._go();
		this.error = err || null;
		this.stats = compilation ? compilation.getStats() : null;
		if(this.stats) {
			this.stats.startTime = this.startTime;
			this.stats.endTime = new Date().getTime();
		}
		if(this.stats)
			this.compiler.applyPlugins("done", this.stats);
		else
			this.compiler.applyPlugins("failed", this.error);
		this.handler(this.error, this.stats);
		if(!this.error)
			this.watch(compilation.fileDependencies, compilation.contextDependencies, compilation.missingDependencies);
	};
	
	Watching.prototype.watch = function(files, dirs, missing) {
		this.watcher = this.compiler.watchFileSystem.watch(files, dirs, missing, this.startTime, this.watchOptions, function(err, filesModified, contextModified, missingModified, fileTimestamps, contextTimestamps) {
			this.watcher = null;
			if(err) return this.handler(err);
	
			this.compiler.fileTimestamps = fileTimestamps;
			this.compiler.contextTimestamps = contextTimestamps;
			this.invalidate();
		}.bind(this), function() {
			this.compiler.applyPlugins("invalid");
		}.bind(this));
	};
	
	Watching.prototype.invalidate = function() {
		if(this.watcher) {
			this.watcher.pause();
			this.watcher = null;
		}
		if(this.running) {
			this.invalid = true;
			return false;
		} else {
			this._go();
		}
	};
	
	Watching.prototype.close = function(callback) {
		if(callback === undefined) callback = function() {};
	
		if(this.watcher) {
			this.watcher.close();
			this.watcher = null;
		}
		if(this.running) {
			this.invalid = true;
			this._done = function() {
				callback();
			};
		} else {
			callback();
		}
	};
	
	function Compiler() {
		Tapable.call(this);
	
		this.outputPath = "";
		this.outputFileSystem = null;
		this.inputFileSystem = null;
	
		this.recordsInputPath = null;
		this.recordsOutputPath = null;
		this.records = {};
	
		this.fileTimestamps = {};
		this.contextTimestamps = {};
	
		this.resolvers = {
			normal: new Resolver(null),
			loader: new Resolver(null),
			context: new Resolver(null)
		};
		this.parser = new Parser();
	
		this.options = {};
	}
	module.exports = Compiler;
	
	Compiler.prototype = Object.create(Tapable.prototype);
	Compiler.prototype.constructor = Compiler;
	
	Compiler.Watching = Watching;
	Compiler.prototype.watch = function(watchOptions, handler) {
		this.fileTimestamps = {};
		this.contextTimestamps = {};
		var watching = new Watching(this, watchOptions, handler);
		return watching;
	};
	
	Compiler.prototype.run = function(callback) {
		var startTime = new Date().getTime();
		this.applyPluginsAsync("run", this, function(err) {
			if(err) return callback(err);
	
			this.readRecords(function(err) {
				if(err) return callback(err);
	
				this.compile(function(err, compilation) {
					if(err) return callback(err);
	
					if(this.applyPluginsBailResult("should-emit", compilation) === false) {
						var stats = compilation.getStats();
						stats.startTime = startTime;
						stats.endTime = new Date().getTime();
						this.applyPlugins("done", stats);
						return callback(null, stats);
					}
	
					this.emitAssets(compilation, function(err) {
						if(err) return callback(err);
	
						this.emitRecords(function(err) {
							if(err) return callback(err);
	
							var stats = compilation.getStats();
							stats.startTime = startTime;
							stats.endTime = new Date().getTime();
							this.applyPlugins("done", stats);
							return callback(null, stats);
						}.bind(this));
					}.bind(this));
				}.bind(this));
			}.bind(this));
		}.bind(this));
	};
	
	Compiler.prototype.runAsChild = function(callback) {
		this.compile(function(err, compilation) {
			if(err) return callback(err);
	
			this.parentCompilation.children.push(compilation);
			Object.keys(compilation.assets).forEach(function(name) {
				this.parentCompilation.assets[name] = compilation.assets[name];
			}.bind(this));
	
			var entries = compilation.chunks.filter(function(chunk) {
				return chunk.entry;
			});
			return callback(null, entries, compilation);
		}.bind(this));
	};
	
	Compiler.prototype.purgeInputFileSystem = function() {
		if(this.inputFileSystem && this.inputFileSystem.purge)
			this.inputFileSystem.purge();
	};
	
	Compiler.prototype.emitAssets = function(compilation, callback) {
		var outputPath;
	
		this.applyPluginsAsync("emit", compilation, function(err) {
			if(err) return callback(err);
			outputPath = compilation.getPath(this.outputPath);
			this.outputFileSystem.mkdirp(outputPath, emitFiles.bind(this));
		}.bind(this));
	
		function emitFiles(err) {
			if(err) return callback(err);
	
			__webpack_require__(183).forEach(Object.keys(compilation.assets), function(file, callback) {
	
				var targetFile = file;
				var queryStringIdx = targetFile.indexOf("?");
				if(queryStringIdx >= 0) {
					targetFile = targetFile.substr(0, queryStringIdx);
				}
	
				if(targetFile.match(/\/|\\/)) {
					var dir = path.dirname(targetFile);
					this.outputFileSystem.mkdirp(this.outputFileSystem.join(outputPath, dir), writeOut.bind(this));
				} else writeOut.call(this);
	
				function writeOut(err) {
					if(err) return callback(err);
					var targetPath = this.outputFileSystem.join(outputPath, targetFile);
					var source = compilation.assets[file];
					if(source.existsAt === targetPath) {
						source.emitted = false;
						return callback();
					}
					var content = source.source();
					if(!Buffer.isBuffer(content))
						content = new Buffer(content, "utf-8");
					source.existsAt = targetPath;
					source.emitted = true;
					this.outputFileSystem.writeFile(targetPath, content, callback);
				}
	
			}.bind(this), function(err) {
				if(err) return callback(err);
	
				afterEmit.call(this);
			}.bind(this));
		}
	
		function afterEmit() {
			this.applyPluginsAsync("after-emit", compilation, function(err) {
				if(err) return callback(err);
	
				return callback();
			});
		}
	
	};
	
	Compiler.prototype.emitRecords = function emitRecords(callback) {
		if(!this.recordsOutputPath) return callback();
		var idx1 = this.recordsOutputPath.lastIndexOf("/");
		var idx2 = this.recordsOutputPath.lastIndexOf("\\");
		var recordsOutputPathDirectory = null;
		if(idx1 > idx2) recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1);
		if(idx1 < idx2) recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2);
		if(!recordsOutputPathDirectory) return writeFile.call(this);
		this.outputFileSystem.mkdirp(recordsOutputPathDirectory, function(err) {
			if(err) return callback(err);
			writeFile.call(this);
		}.bind(this));
	
		function writeFile() {
			this.outputFileSystem.writeFile(this.recordsOutputPath, JSON.stringify(this.records, undefined, 2), callback);
		}
	};
	
	Compiler.prototype.readRecords = function readRecords(callback) {
		if(!this.recordsInputPath) {
			this.records = {};
			return callback();
		}
		this.inputFileSystem.stat(this.recordsInputPath, function(err) {
			// It doesn't exist
			// We can ignore this.
			if(err) return callback();
	
			this.inputFileSystem.readFile(this.recordsInputPath, function(err, content) {
				if(err) return callback(err);
	
				try {
					this.records = JSON.parse(content);
				} catch(e) {
					e.message = "Cannot parse records: " + e.message;
					return callback(e);
				}
	
				return callback();
			}.bind(this));
		}.bind(this));
	};
	
	Compiler.prototype.createChildCompiler = function(compilation, compilerName, outputOptions) {
		var childCompiler = new Compiler();
		for(var name in this._plugins) {
			if(["make", "compile", "emit", "after-emit", "invalid", "done", "this-compilation"].indexOf(name) < 0)
				childCompiler._plugins[name] = this._plugins[name].slice();
		}
		childCompiler.name = compilerName;
		childCompiler.outputPath = this.outputPath;
		childCompiler.inputFileSystem = this.inputFileSystem;
		childCompiler.outputFileSystem = null;
		childCompiler.resolvers = this.resolvers;
		childCompiler.parser = this.parser;
		childCompiler.fileTimestamps = this.fileTimestamps;
		childCompiler.contextTimestamps = this.contextTimestamps;
		if(!this.records[compilerName]) this.records[compilerName] = [];
		this.records[compilerName].push(childCompiler.records = {});
		childCompiler.options = Object.create(this.options);
		childCompiler.options.output = Object.create(childCompiler.options.output);
		for(name in outputOptions) {
			childCompiler.options.output[name] = outputOptions[name];
		}
		childCompiler.parentCompilation = compilation;
		return childCompiler;
	};
	
	Compiler.prototype.isChild = function() {
		return !!this.parentCompilation;
	};
	
	Compiler.prototype.createCompilation = function() {
		return new Compilation(this);
	};
	
	Compiler.prototype.newCompilation = function(params) {
		var compilation = this.createCompilation();
		compilation.fileTimestamps = this.fileTimestamps;
		compilation.contextTimestamps = this.contextTimestamps;
		compilation.name = this.name;
		compilation.records = this.records;
		this.applyPlugins("this-compilation", compilation, params);
		this.applyPlugins("compilation", compilation, params);
		return compilation;
	};
	
	Compiler.prototype.createNormalModuleFactory = function() {
		var normalModuleFactory = new NormalModuleFactory(this.options.context, this.resolvers, this.parser, this.options.module || {});
		this.applyPlugins("normal-module-factory", normalModuleFactory);
		return normalModuleFactory;
	};
	
	Compiler.prototype.createContextModuleFactory = function() {
		var contextModuleFactory = new ContextModuleFactory(this.resolvers, this.inputFileSystem);
		this.applyPlugins("context-module-factory", contextModuleFactory);
		return contextModuleFactory;
	};
	
	Compiler.prototype.newCompilationParams = function() {
		var params = {
			normalModuleFactory: this.createNormalModuleFactory(),
			contextModuleFactory: this.createContextModuleFactory()
		};
		return params;
	};
	
	Compiler.prototype.compile = function(callback) {
		var params = this.newCompilationParams();
		this.applyPlugins("compile", params);
	
		var compilation = this.newCompilation(params);
	
		this.applyPluginsParallel("make", compilation, function(err) {
			if(err) return callback(err);
	
			compilation.seal(function(err) {
				if(err) return callback(err);
	
				this.applyPluginsAsync("after-compile", compilation, function(err) {
					if(err) return callback(err);
	
					return callback(null, compilation);
				});
			}.bind(this));
		}.bind(this));
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176).Buffer))

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	
	var base64 = __webpack_require__(177)
	var ieee754 = __webpack_require__(178)
	var isArray = __webpack_require__(179)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = (function () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	})()
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  this.length = 0
	  this.parent = undefined
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	// pre-set for values that may exist in the future
	Buffer.prototype.length = undefined
	Buffer.prototype.parent = undefined
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}
	
	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = value
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = value
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = value
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var BP = Buffer.prototype
	
	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true
	
	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set
	
	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set
	
	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer
	
	  return arr
	}
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176).Buffer))

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	
	;(function (exports) {
		'use strict';
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)
	
		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}
	
		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr
	
			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
	
			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
	
			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length
	
			var L = 0
	
			function push (v) {
				arr[L++] = v
			}
	
			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}
	
			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}
	
			return arr
		}
	
		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length
	
			function encode (num) {
				return lookup.charAt(num)
			}
	
			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}
	
			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}
	
			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}
	
			return output
		}
	
		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 178 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 179 */
/***/ function(module, exports) {

	
	/**
	 * isArray
	 */
	
	var isArray = Array.isArray;
	
	/**
	 * toString
	 */
	
	var str = Object.prototype.toString;
	
	/**
	 * Whether or not the given `val`
	 * is an array.
	 *
	 * example:
	 *
	 *        isArray([]);
	 *        // > true
	 *        isArray(arguments);
	 *        // > false
	 *        isArray('');
	 *        // > false
	 *
	 * @param {mixed} val
	 * @return {bool}
	 */
	
	module.exports = isArray || function (val) {
	  return !! val && '[object Array]' == str.call(val);
	};


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }
	
	  return parts;
	}
	
	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};
	
	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;
	
	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();
	
	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }
	
	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }
	
	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)
	
	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');
	
	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};
	
	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';
	
	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');
	
	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }
	
	  return (isAbsolute ? '/' : '') + path;
	};
	
	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};
	
	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};
	
	
	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);
	
	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }
	
	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }
	
	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }
	
	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));
	
	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }
	
	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }
	
	  outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
	  return outputParts.join('/');
	};
	
	exports.sep = '/';
	exports.delimiter = ':';
	
	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];
	
	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }
	
	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }
	
	  return root + dir;
	};
	
	
	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};
	
	
	exports.extname = function(path) {
	  return splitPath(path)[3];
	};
	
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}
	
	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 181 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function Tapable() {
		this._plugins = {};
	}
	module.exports = Tapable;
	
	function copyProperties(from, to) {
		for(var key in from)
			to[key] = from[key];
		return to;
	}
	
	Tapable.mixin = function mixinTapable(pt) {
		copyProperties(Tapable.prototype, pt);
	}
	
	Tapable.prototype.applyPlugins = function applyPlugins(name) {
		if(!this._plugins[name]) return;
		var args = Array.prototype.slice.call(arguments, 1);
		var plugins = this._plugins[name];
		var old = this._currentPluginApply;
		for(this._currentPluginApply = 0; this._currentPluginApply < plugins.length; this._currentPluginApply++)
			plugins[this._currentPluginApply].apply(this, args);
		this._currentPluginApply = old;
	};
	
	Tapable.prototype.applyPluginsWaterfall = function applyPlugins(name, init) {
		if(!this._plugins[name]) return init;
		var args = Array.prototype.slice.call(arguments, 2);
		var plugins = this._plugins[name];
		var current = init;
		var old = this._currentPluginApply;
		for(this._currentPluginApply = 0; this._currentPluginApply < plugins.length; this._currentPluginApply++)
			current = plugins[this._currentPluginApply].apply(this, [current].concat(args));
		this._currentPluginApply = old;
		return current;
	};
	
	Tapable.prototype.applyPluginsBailResult = function applyPluginsBailResult(name) {
		if(!this._plugins[name]) return;
		var args = Array.prototype.slice.call(arguments, 1);
		var plugins = this._plugins[name];
		var old = this._currentPluginApply
		for(this._currentPluginApply = 0; this._currentPluginApply < plugins.length; this._currentPluginApply++) {
			var result = plugins[this._currentPluginApply].apply(this, args);
			if(typeof result !== "undefined") {
				this._currentPluginApply = old;
				return result;
			}
		}
		this._currentPluginApply = old;
	};
	
	Tapable.prototype.applyPluginsAsyncSeries = Tapable.prototype.applyPluginsAsync = function applyPluginsAsync(name) {
		var args = Array.prototype.slice.call(arguments, 1);
		var callback = args.pop();
		if(!this._plugins[name] || this._plugins[name].length == 0) return callback();
		var plugins = this._plugins[name];
		var i = 0;
		args.push(copyProperties(callback, function next(err) {
			if(err) return callback(err);
			i++;
			if(i >= plugins.length) {
				return callback();
			}
			plugins[i].apply(this, args);
		}.bind(this)));
		plugins[0].apply(this, args);
	};
	
	Tapable.prototype.applyPluginsAsyncWaterfall = function applyPluginsAsyncWaterfall(name, init, callback) {
		if(!this._plugins[name] || this._plugins[name].length == 0) return callback(null, init);
		var plugins = this._plugins[name];
		var i = 0;
		var next = copyProperties(callback, function(err, value) {
			if(err) return callback(err);
			i++;
			if(i >= plugins.length) {
				return callback(null, value);
			}
			plugins[i].call(this, value, next);
		}.bind(this));
		plugins[0].call(this, init, next);
	};
	
	Tapable.prototype.applyPluginsParallel = function applyPluginsParallel(name) {
		var args = Array.prototype.slice.call(arguments, 1);
		var callback = args.pop();
		if(!this._plugins[name] || this._plugins[name].length == 0) return callback();
		var plugins = this._plugins[name];
		var remaining = plugins.length;
		args.push(copyProperties(callback, function(err) {
			if(remaining < 0) return; // ignore
			if(err) {
				remaining = -1;
				return callback(err);
			}
			remaining--;
			if(remaining == 0) {
				return callback();
			}
		}));
		for(var i = 0; i < plugins.length; i++) {
			plugins[i].apply(this, args);
			if(remaining < 0) return;
		}
	};
	
	Tapable.prototype.applyPluginsParallelBailResult = function applyPluginsParallelBailResult(name) {
		var args = Array.prototype.slice.call(arguments, 1);
		var callback = args[args.length-1];
		if(!this._plugins[name] || this._plugins[name].length == 0) return callback();
		var plugins = this._plugins[name];
		var currentPos = plugins.length;
		var currentError, currentResult;
		var done = [];
		for(var i = 0; i < plugins.length; i++) {
			args[args.length-1] = (function(i) {
				return copyProperties(callback, function(err, result) {
					if(i >= currentPos) return; // ignore
					done.push(i);
					if(err || result) {
						currentPos = i + 1;
						done = done.filter(function(item) {
							return item <= i;
						});
						currentError = err;
						currentResult = result;
					}
					if(done.length == currentPos) {
						callback(currentError, currentResult);
						currentPos = 0;
					}
				});
			}(i));
			plugins[i].apply(this, args);
		}
	};
	
	
	Tapable.prototype.restartApplyPlugins = function restartApplyPlugins() {
		if(typeof this._currentPluginApply !== "number")
			throw new Error("Tapable.prototype.restartApplyPlugins can only be used inside of any sync plugins application");
		this._currentPluginApply = -1;
	};
	
	
	Tapable.prototype.plugin = function plugin(name, fn) {
		if(Array.isArray(name)) {
			name.forEach(function(name) {
				this.plugin(name, fn);
			}, this);
			return;
		}
		if(!this._plugins[name]) this._plugins[name] = [fn];
		else this._plugins[name].push(fn);
	};
	
	Tapable.prototype.apply = function apply() {
		for(var i = 0; i < arguments.length; i++) {
			arguments[i].apply(this);
		}
	};


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var async = __webpack_require__(183);
	
	var Tapable = __webpack_require__(181);
	var EntryModuleNotFoundError = __webpack_require__(185);
	var ModuleNotFoundError = __webpack_require__(186);
	var CriticalDependenciesWarning = __webpack_require__(187);
	var Module = __webpack_require__(188);
	var ArrayMap = __webpack_require__(216);
	var Chunk = __webpack_require__(217);
	var Stats = __webpack_require__(218);
	var MainTemplate = __webpack_require__(220);
	var ChunkTemplate = __webpack_require__(225);
	var HotUpdateChunkTemplate = __webpack_require__(226);
	var ModuleTemplate = __webpack_require__(227);
	var Dependency = __webpack_require__(228);
	var ChunkRenderError = __webpack_require__(229);
	var CachedSource = __webpack_require__(230);
	
	function Compilation(compiler) {
		Tapable.call(this);
		this.compiler = compiler;
		this.resolvers = compiler.resolvers;
		this.inputFileSystem = compiler.inputFileSystem;
	
		var options = this.options = compiler.options;
		this.outputOptions = options && options.output;
		this.bail = options && options.bail;
		this.profile = options && options.profile;
	
		this.mainTemplate = new MainTemplate(this.outputOptions);
		this.chunkTemplate = new ChunkTemplate(this.outputOptions, this.mainTemplate);
		this.hotUpdateChunkTemplate = new HotUpdateChunkTemplate(this.outputOptions);
		this.moduleTemplate = new ModuleTemplate(this.outputOptions);
	
		this.entries = [];
		this.preparedChunks = [];
		this.chunks = [];
		this.namedChunks = {};
		this.modules = [];
		this._modules = {};
		this.cache = null;
		this.records = null;
		this.nextFreeModuleId = 1;
		this.nextFreeChunkId = 0;
		this.nextFreeModuleIndex = 0;
		this.nextFreeModuleIndex2 = 0;
		this.additionalChunkAssets = [];
		this.assets = {};
		this.errors = [];
		this.warnings = [];
		this.children = [];
		this.dependencyFactories = new ArrayMap();
		this.dependencyTemplates = new ArrayMap();
	}
	module.exports = Compilation;
	
	Compilation.prototype = Object.create(Tapable.prototype);
	Compilation.prototype.constructor = Compilation;
	
	Compilation.prototype.templatesPlugin = function(name, fn) {
		this.mainTemplate.plugin(name, fn);
		this.chunkTemplate.plugin(name, fn);
	};
	
	Compilation.prototype.addModule = function(module, cacheGroup) {
		cacheGroup = cacheGroup || "m";
		var identifier = module.identifier();
		if(this._modules[identifier]) {
			return false;
		}
		if(this.cache && this.cache[cacheGroup + identifier]) {
			var cacheModule = this.cache[cacheGroup + identifier];
	
			var rebuild = true;
			if(!cacheModule.error && cacheModule.cacheable && this.fileTimestamps && this.contextTimestamps) {
				rebuild = cacheModule.needRebuild(this.fileTimestamps, this.contextTimestamps);
			}
	
			if(!rebuild) {
				cacheModule.disconnect();
				this._modules[identifier] = cacheModule;
				this.modules.push(cacheModule);
				cacheModule.errors.forEach(function(err) {
					this.errors.push(err);
				}, this);
				cacheModule.warnings.forEach(function(err) {
					this.warnings.push(err);
				}, this);
				return cacheModule;
			} else {
				module.lastId = cacheModule.id;
			}
		}
		this._modules[identifier] = module;
		if(this.cache) {
			this.cache[cacheGroup + identifier] = module;
		}
		this.modules.push(module);
		return true;
	};
	
	Compilation.prototype.getModule = function(module) {
		var identifier = module.identifier();
		return this._modules[identifier];
	};
	
	Compilation.prototype.findModule = function(identifier) {
		return this._modules[identifier];
	};
	
	Compilation.prototype.buildModule = function(module, thisCallback) {
		this.applyPlugins("build-module", module);
		if(module.building) return module.building.push(thisCallback);
		var building = module.building = [thisCallback];
	
		function callback(err) {
			module.building = undefined;
			building.forEach(function(cb) {
				cb(err);
			});
		}
		module.build(this.options, this, this.resolvers.normal, this.inputFileSystem, function(err) {
			module.errors.forEach(function(err) {
				this.errors.push(err);
			}, this);
			module.warnings.forEach(function(err) {
				this.warnings.push(err);
			}, this);
			module.dependencies.sort(Dependency.compare);
			if(err) {
				module.error = err;
				this.applyPlugins("failed-module", module);
				return callback(err);
			}
			this.applyPlugins("succeed-module", module);
			return callback();
		}.bind(this));
	};
	
	Compilation.prototype.processModuleDependencies = function(module, callback) {
		var dependencies = [];
	
		function addDependency(dep) {
			for(var i = 0; i < dependencies.length; i++) {
				if(dep.isEqualResource(dependencies[i][0])) {
					return dependencies[i].push(dep);
				}
			}
			dependencies.push([dep]);
		}
	
		function addDependenciesBlock(block) {
			if(block.dependencies) {
				block.dependencies.forEach(addDependency);
			}
			if(block.blocks) {
				block.blocks.forEach(addDependenciesBlock);
			}
			if(block.variables) {
				block.variables.forEach(function(v) {
					v.dependencies.forEach(addDependency);
				});
			}
		}
		addDependenciesBlock(module);
		this.addModuleDependencies(module, dependencies, this.bail, null, true, callback);
	};
	
	Compilation.prototype.addModuleDependencies = function(module, dependencies, bail, cacheGroup, recursive, callback) {
		var start = this.profile && +new Date();
	
		var factories = [];
		for(var i = 0; i < dependencies.length; i++) {
			var factory = this.dependencyFactories.get(dependencies[i][0].Class);
			if(!factory) {
				return callback(new Error("No module factory available for dependency type: " + dependencies[i][0].Class.name));
			}
			factories[i] = [factory, dependencies[i]];
		}
		async.forEach(factories, function(item, callback) {
			var dependencies = item[1];
			var criticalDependencies = dependencies.filter(function(d) {
				return !!d.critical;
			});
			if(criticalDependencies.length > 0) {
				this.warnings.push(new CriticalDependenciesWarning(module, criticalDependencies));
			}
	
			var errorAndCallback = function errorAndCallback(err) {
				err.dependencies = dependencies;
				err.origin = module;
				module.dependenciesErrors.push(err);
				this.errors.push(err);
				if(bail) {
					callback(err);
				} else {
					callback();
				}
			}.bind(this);
			var warningAndCallback = function warningAndCallback(err) {
				err.dependencies = dependencies;
				err.origin = module;
				module.dependenciesWarnings.push(err);
				this.warnings.push(err);
				callback();
			}.bind(this);
	
			var factory = item[0];
			factory.create(module.context, dependencies[0], function(err, dependantModule) {
				function isOptional() {
					return dependencies.filter(function(d) {
						return !d.optional;
					}).length === 0;
				}
	
				function errorOrWarningAndCallback(err) {
					if(isOptional()) {
						return warningAndCallback(err);
					} else {
						return errorAndCallback(err);
					}
				}
				if(err) {
					return errorOrWarningAndCallback(new ModuleNotFoundError(module, err));
				}
				if(!dependantModule) {
					return process.nextTick(callback);
				}
				if(this.profile) {
					if(!dependantModule.profile) {
						dependantModule.profile = {};
					}
					var afterFactory = +new Date();
					dependantModule.profile.factory = afterFactory - start;
				}
	
				dependantModule.issuer = module.identifier();
				var newModule = this.addModule(dependantModule, cacheGroup);
	
				if(!newModule) { // from cache
					dependantModule = this.getModule(dependantModule);
	
					if(dependantModule.optional) {
						dependantModule.optional = isOptional();
					}
	
					if(dependantModule.id === 0) {
						return errorOrWarningAndCallback(
							new ModuleNotFoundError(module, new Error("a dependency to an entry point is not allowed"))
						);
					}
	
					dependencies.forEach(function(dep) {
						dep.module = dependantModule;
						dependantModule.addReason(module, dep);
					});
	
					if(this.profile) {
						if(!module.profile) {
							module.profile = {};
						}
						var time = +new Date() - start;
						if(!module.profile.dependencies || time > module.profile.dependencies) {
							module.profile.dependencies = time;
						}
					}
	
					return process.nextTick(callback);
				}
	
				if(newModule instanceof Module) {
					if(this.profile) {
						newModule.profile = dependantModule.profile;
					}
	
					newModule.optional = isOptional();
					newModule.issuer = dependantModule.issuer;
					dependantModule = newModule;
	
					dependencies.forEach(function(dep) {
						dep.module = dependantModule;
						dependantModule.addReason(module, dep);
					});
	
					if(this.profile) {
						var afterBuilding = +new Date();
						module.profile.building = afterBuilding - afterFactory;
					}
	
					if(recursive) {
						return process.nextTick(this.processModuleDependencies.bind(this, dependantModule, callback));
					} else {
						return process.nextTick(callback);
					}
				}
	
				dependantModule.optional = isOptional();
	
				dependencies.forEach(function(dep) {
					dep.module = dependantModule;
					dependantModule.addReason(module, dep);
				});
	
				this.buildModule(dependantModule, function(err) {
					if(err) {
						return errorOrWarningAndCallback(err);
					}
	
					if(this.profile) {
						var afterBuilding = +new Date();
						dependantModule.profile.building = afterBuilding - afterFactory;
					}
	
					if(recursive) {
						this.processModuleDependencies(dependantModule, callback);
					} else {
						return callback();
					}
				}.bind(this));
	
			}.bind(this));
		}.bind(this), function(err) {
			if(err) {
				return callback(err);
			}
	
			return callback();
		});
	};
	
	Compilation.prototype._addModuleChain = function process(context, dependency, onModule, callback) {
		var start = this.profile && +new Date();
	
		var errorAndCallback = this.bail ? function errorAndCallback(err) {
			callback(err);
		} : function errorAndCallback(err) {
			err.dependencies = [dependency];
			this.errors.push(err);
			callback();
		}.bind(this);
	
		if(typeof dependency !== "object" || dependency === null || !dependency.Class) {
			throw new Error("Parameter 'dependency' must be a Dependency");
		}
	
		var moduleFactory = this.dependencyFactories.get(dependency.Class);
		if(!moduleFactory) {
			throw new Error("No dependency factory available for this dependency type: " + dependency.Class.name);
		}
	
		moduleFactory.create(context, dependency, function(err, module) {
			if(err) {
				return errorAndCallback(new EntryModuleNotFoundError(err));
			}
	
			if(this.profile) {
				if(!module.profile) {
					module.profile = {};
				}
				var afterFactory = +new Date();
				module.profile.factory = afterFactory - start;
			}
	
			var result = this.addModule(module);
			if(!result) {
				module = this.getModule(module);
	
				onModule(module);
	
				if(this.profile) {
					var afterBuilding = +new Date();
					module.profile.building = afterBuilding - afterFactory;
				}
	
				return callback(null, module);
			}
	
			if(result instanceof Module) {
				if(this.profile) {
					result.profile = module.profile;
				}
	
				module = result;
	
				onModule(module);
	
				moduleReady.call(this);
				return;
			}
	
			onModule(module);
	
			this.buildModule(module, function(err) {
				if(err) {
					return errorAndCallback(err);
				}
	
				if(this.profile) {
					var afterBuilding = +new Date();
					module.profile.building = afterBuilding - afterFactory;
				}
	
				moduleReady.call(this);
			}.bind(this));
	
			function moduleReady() {
				this.processModuleDependencies(module, function(err) {
					if(err) {
						return callback(err);
					}
	
					return callback(null, module);
				});
			}
		}.bind(this));
	};
	
	Compilation.prototype.addEntry = function process(context, entry, name, callback) {
		this._addModuleChain(context, entry, function(module) {
	
			entry.module = module;
			this.entries.push(module);
			module.issuer = null;
			module.id = 0;
	
		}.bind(this), function(err, module) {
			if(err) {
				return callback(err);
			}
	
			if(module) {
				if(module.reasons.length > 0) {
					return callback(new Error("module cannot be added as entry point, because it's already in the bundle"));
				}
				this.preparedChunks.push({
					name: name,
					module: module
				});
			}
			return callback();
		}.bind(this));
	};
	
	Compilation.prototype.prefetch = function process(context, dependency, callback) {
		this._addModuleChain(context, dependency, function(module) {
	
			module.prefetched = true;
			module.issuer = null;
	
		}, callback);
	};
	
	Compilation.prototype.rebuildModule = function(module, thisCallback) {
		if(module.variables.length || module.blocks.length)
			throw new Error("Cannot rebuild a complex module with variables or blocks");
		if(module.rebuilding) {
			return module.rebuilding.push(thisCallback);
		}
		var rebuilding = module.rebuilding = [thisCallback];
	
		function callback(err) {
			module.rebuilding = undefined;
			rebuilding.forEach(function(cb) {
				cb(err);
			});
		}
		var deps = module.dependencies.slice();
		this.buildModule(module, function(err) {
			if(err) return callback(err);
	
			this.processModuleDependencies(module, function(err) {
				if(err) return callback(err);
				deps.forEach(function(d) {
					if(d.module && d.module.removeReason(module, d)) {
						module.chunks.forEach(function(chunk) {
							if(!d.module.hasReasonForChunk(chunk)) {
								if(d.module.removeChunk(chunk)) {
									this.removeChunkFromDependencies(d.module, chunk);
								}
							}
						}, this);
					}
				}, this);
				callback();
			}.bind(this));
	
		}.bind(this));
	};
	
	Compilation.prototype.seal = function seal(callback) {
		this.applyPlugins("seal");
		this.preparedChunks.sort(function(a, b) {
			if(a.name < b.name) return -1;
			if(a.name > b.name) return 1;
			return 0;
		});
		this.preparedChunks.forEach(function(preparedChunk) {
			var module = preparedChunk.module;
			var chunk = this.addChunk(preparedChunk.name, module);
			chunk.initial = chunk.entry = true;
			chunk.addModule(module);
			module.addChunk(chunk);
			if(typeof module.index !== "number") {
				module.index = this.nextFreeModuleIndex++;
			}
			this.processDependenciesBlockForChunk(module, chunk);
			if(typeof module.index2 !== "number") {
				module.index2 = this.nextFreeModuleIndex2++;
			}
		}, this);
		this.sortModules(this.modules);
		this.applyPlugins("optimize");
	
		this.applyPlugins("optimize-modules", this.modules);
		this.applyPlugins("after-optimize-modules", this.modules);
	
		this.applyPlugins("optimize-chunks", this.chunks);
		this.applyPlugins("after-optimize-chunks", this.chunks);
	
		this.applyPluginsAsync("optimize-tree", this.chunks, this.modules, function(err) {
			if(err) {
				return callback(err);
			}
	
			this.applyPlugins("after-optimize-tree", this.chunks, this.modules);
	
			var shouldRecord = this.applyPluginsBailResult("should-record") !== false;
	
			this.applyPlugins("revive-modules", this.modules, this.records);
			this.applyPlugins("optimize-module-order", this.modules);
			this.applyPlugins("before-module-ids", this.modules);
			this.applyModuleIds();
			this.applyPlugins("optimize-module-ids", this.modules);
			this.applyPlugins("after-optimize-module-ids", this.modules);
			if(shouldRecord)
				this.applyPlugins("record-modules", this.modules, this.records);
	
			this.applyPlugins("revive-chunks", this.chunks, this.records);
			this.applyPlugins("optimize-chunk-order", this.chunks);
			this.applyPlugins("before-chunk-ids", this.chunks);
			this.applyChunkIds();
			this.applyPlugins("optimize-chunk-ids", this.chunks);
			this.applyPlugins("after-optimize-chunk-ids", this.chunks);
			if(shouldRecord)
				this.applyPlugins("record-chunks", this.chunks, this.records);
	
			this.sortItems();
			this.applyPlugins("before-hash");
			this.createHash();
			this.applyPlugins("after-hash");
			this.applyPlugins("before-chunk-assets");
			this.createChunkAssets();
			this.applyPlugins("additional-chunk-assets", this.chunks);
			this.summarizeDependencies();
			if(shouldRecord)
				this.applyPlugins("record", this, this.records);
	
			this.applyPluginsAsync("additional-assets", function(err) {
				if(err) {
					return callback(err);
				}
				this.applyPluginsAsync("optimize-chunk-assets", this.chunks, function(err) {
					if(err) {
						return callback(err);
					}
					this.applyPlugins("after-optimize-chunk-assets", this.chunks);
					this.applyPluginsAsync("optimize-assets", this.assets, function(err) {
						if(err) {
							return callback(err);
						}
						this.applyPlugins("after-optimize-assets", this.assets);
						return callback();
					}.bind(this));
				}.bind(this));
			}.bind(this));
		}.bind(this));
	};
	
	Compilation.prototype.sortModules = function sortModules(modules) {
		modules.sort(function(a, b) {
			if(a.index < b.index) return -1;
			if(a.index > b.index) return 1;
			return 0;
		});
	};
	
	Compilation.prototype.addChunk = function addChunk(name, module, loc) {
		var chunk;
		if(name) {
			if(Object.prototype.hasOwnProperty.call(this.namedChunks, name)) {
				chunk = this.namedChunks[name];
				if(module) {
					chunk.addOrigin(module, loc);
				}
				return chunk;
			}
		}
		chunk = new Chunk(name, module, loc);
		this.chunks.push(chunk);
		if(name) {
			this.namedChunks[name] = chunk;
		}
		return chunk;
	};
	
	Compilation.prototype.processDependenciesBlockForChunk = function processDependenciesBlockForChunk(block, chunk) {
		if(block.variables) {
			block.variables.forEach(function(v) {
				v.dependencies.forEach(iteratorDependency, this);
			}, this);
		}
		if(block.dependencies) {
			block.dependencies.forEach(iteratorDependency, this);
		}
		if(block.blocks) {
			block.blocks.forEach(function(b) {
				var c;
				if(!b.chunks) {
					c = this.addChunk(b.chunkName, b.module, b.loc);
					b.chunks = [c];
					c.addBlock(b);
				} else {
					c = b.chunks[0];
				}
				chunk.addChunk(c);
				c.addParent(chunk);
				this.processDependenciesBlockForChunk(b, c);
			}, this);
		}
	
		function iteratorDependency(d) {
			if(!d.module) {
				return;
			}
			if(typeof d.module.index !== "number") {
				d.module.index = this.nextFreeModuleIndex++;
			}
			if(d.weak) {
				return;
			}
			if(d.module.error) {
				d.module = null;
				return;
			}
			if(chunk.addModule(d.module)) {
				d.module.addChunk(chunk);
				this.processDependenciesBlockForChunk(d.module, chunk);
			}
			if(typeof d.module.index2 !== "number") {
				d.module.index2 = this.nextFreeModuleIndex2++;
			}
		}
	};
	
	Compilation.prototype.removeChunkFromDependencies = function removeChunkFromDependencies(block, chunk) {
		block.blocks.forEach(function(b) {
			b.chunks.forEach(function(c) {
				chunk.removeChunk(c);
				c.removeParent(chunk);
				this.removeChunkFromDependencies(b, c);
			}, this);
		}, this);
	
		function iteratorDependency(d) {
			if(!d.module) {
				return;
			}
			if(!d.module.hasReasonForChunk(chunk)) {
				if(d.module.removeChunk(chunk)) {
					this.removeChunkFromDependencies(d.module, chunk);
				}
			}
		}
		block.dependencies.forEach(iteratorDependency, this);
		block.variables.forEach(function(v) {
			v.dependencies.forEach(iteratorDependency, this);
		}, this);
	
	};
	
	Compilation.prototype.applyModuleIds = function applyModuleIds() {
		this.modules.forEach(function(module) {
			if(module.id === null) {
				module.id = this.nextFreeModuleId++;
			}
		}, this);
	};
	
	Compilation.prototype.applyChunkIds = function applyChunkIds() {
		this.chunks.forEach(function(chunk) {
			if(chunk.id === null) {
				chunk.id = this.nextFreeChunkId++;
			}
			if(!chunk.ids) {
				chunk.ids = [chunk.id];
			}
		}, this);
	};
	
	Compilation.prototype.sortItems = function sortItems() {
		function byId(a, b) {
			return a.id - b.id;
		}
		this.chunks.sort(byId);
		this.modules.sort(byId);
		this.modules.forEach(function(module) {
			module.chunks.sort(byId);
			module.reasons.sort(function(a, b) {
				return byId(a.module, b.module);
			});
		});
		this.chunks.forEach(function(chunk) {
			chunk.modules.sort(byId);
		});
	};
	
	Compilation.prototype.summarizeDependencies = function summarizeDependencies() {
		function filterDups(array) {
			var newArray = [];
			for(var i = 0; i < array.length; i++) {
				if(i === 0 || array[i - 1] !== array[i])
					newArray.push(array[i]);
			}
			return newArray;
		}
		this.fileDependencies = [];
		this.contextDependencies = [];
		this.missingDependencies = [];
		this.children.forEach(function(child) {
			this.fileDependencies = this.fileDependencies.concat(child.fileDependencies);
			this.contextDependencies = this.contextDependencies.concat(child.contextDependencies);
			this.missingDependencies = this.missingDependencies.concat(child.missingDependencies);
		}.bind(this));
		this.modules.forEach(function(module) {
			if(module.fileDependencies) {
				module.fileDependencies.forEach(function(item) {
					this.fileDependencies.push(item);
				}, this);
			}
			if(module.contextDependencies) {
				module.contextDependencies.forEach(function(item) {
					this.contextDependencies.push(item);
				}, this);
			}
		}, this);
		this.errors.forEach(function(error) {
			if(Array.isArray(error.missing)) {
				error.missing.forEach(function(item) {
					this.missingDependencies.push(item);
				}, this);
			}
		}, this);
		this.fileDependencies.sort();
		this.fileDependencies = filterDups(this.fileDependencies);
		this.contextDependencies.sort();
		this.contextDependencies = filterDups(this.contextDependencies);
		this.missingDependencies.sort();
		this.missingDependencies = filterDups(this.missingDependencies);
	};
	
	Compilation.prototype.createHash = function createHash() {
		var outputOptions = this.outputOptions;
		var hashFunction = outputOptions.hashFunction;
		var hashDigest = outputOptions.hashDigest;
		var hashDigestLength = outputOptions.hashDigestLength;
		var hash = __webpack_require__(231).createHash(hashFunction);
		this.mainTemplate.updateHash(hash);
		this.chunkTemplate.updateHash(hash);
		this.moduleTemplate.updateHash(hash);
		var i, chunk;
		var chunks = this.chunks.slice();
		chunks.sort(function(a, b) {
			if(a.entry && !b.entry) return 1;
			if(!a.entry && b.entry) return -1;
			return 0;
		});
		for(i = 0; i < chunks.length; i++) {
			chunk = chunks[i];
			var chunkHash = __webpack_require__(231).createHash(hashFunction);
			chunk.updateHash(chunkHash);
			if(chunk.entry) {
				this.mainTemplate.updateHashForChunk(chunkHash, chunk);
			} else {
				this.chunkTemplate.updateHashForChunk(chunkHash);
			}
			this.applyPlugins("chunk-hash", chunk, chunkHash);
			chunk.hash = chunkHash.digest(hashDigest);
			hash.update(chunk.hash);
			chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
		}
		this.fullHash = hash.digest(hashDigest);
		this.hash = this.fullHash.substr(0, hashDigestLength);
	};
	
	Compilation.prototype.modifyHash = function modifyHash(update) {
		var outputOptions = this.outputOptions;
		var hashFunction = outputOptions.hashFunction;
		var hashDigest = outputOptions.hashDigest;
		var hashDigestLength = outputOptions.hashDigestLength;
		var hash = __webpack_require__(231).createHash(hashFunction);
		hash.update(this.fullHash);
		hash.update(update);
		this.fullHash = hash.digest(hashDigest);
		this.hash = this.fullHash.substr(0, hashDigestLength);
	};
	
	Compilation.prototype.createChunkAssets = function createChunkAssets() {
		var outputOptions = this.outputOptions;
		var filename = outputOptions.filename || "bundle.js";
		var chunkFilename = outputOptions.chunkFilename || "[id]." + filename;
		var namedChunkFilename = outputOptions.namedChunkFilename || null;
		for(var i = 0; i < this.modules.length; i++) {
			var module = this.modules[i];
			if(module.assets) {
				Object.keys(module.assets).forEach(function(name) {
					var file = this.getPath(name);
					this.assets[file] = module.assets[name];
					this.applyPlugins("module-asset", module, file);
				}, this);
			}
		}
		for(i = 0; i < this.chunks.length; i++) {
			var chunk = this.chunks[i];
			chunk.files = [];
			var chunkHash = chunk.hash;
			var source;
			var file;
			var filenameTemplate = chunk.filenameTemplate ? chunk.filenameTemplate :
				chunk.initial ? filename :
				chunkFilename;
			try {
				var useChunkHash = !chunk.entry || (this.mainTemplate.useChunkHash && this.mainTemplate.useChunkHash(chunk));
				var usedHash = useChunkHash ? chunkHash : this.fullHash;
				if(this.cache && this.cache["c" + chunk.id] && this.cache["c" + chunk.id].hash === usedHash) {
					source = this.cache["c" + chunk.id].source;
				} else {
					if(chunk.entry) {
						source = this.mainTemplate.render(this.hash, chunk, this.moduleTemplate, this.dependencyTemplates);
					} else {
						source = this.chunkTemplate.render(chunk, this.moduleTemplate, this.dependencyTemplates);
					}
					if(this.cache) {
						this.cache["c" + chunk.id] = {
							hash: usedHash,
							source: source = (source instanceof CachedSource ? source : new CachedSource(source))
						};
					}
				}
				this.assets[
					file = this.getPath(filenameTemplate, {
						noChunkHash: !useChunkHash,
						chunk: chunk
					})
				] = source;
				chunk.files.push(file);
				this.applyPlugins("chunk-asset", chunk, file);
				file = undefined;
				if(chunk.id !== 0 && namedChunkFilename && chunk.name) {
					this.assets[
						file = this.getPath(namedChunkFilename, {
							noChunkHash: !useChunkHash,
							chunk: chunk
						})
					] = source;
					chunk.files.push(file);
					this.applyPlugins("chunk-asset", chunk, file);
				}
			} catch(err) {
				this.errors.push(new ChunkRenderError(chunk, file || filenameTemplate, err));
			}
		}
	};
	
	Compilation.prototype.getPath = function(filename, data) {
		data = data || {};
		data.hash = data.hash || this.hash;
		return this.mainTemplate.applyPluginsWaterfall("asset-path", filename, data);
	};
	
	Compilation.prototype.getStats = function() {
		return new Stats(this);
	};
	
	Compilation.prototype.createChildCompiler = function(name, outputOptions) {
		return this.compiler.createChildCompiler(this, name, outputOptions);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate, process) {/*!
	 * async
	 * https://github.com/caolan/async
	 *
	 * Copyright 2010-2014 Caolan McMahon
	 * Released under the MIT license
	 */
	(function () {
	
	    var async = {};
	    function noop() {}
	    function identity(v) {
	        return v;
	    }
	    function toBool(v) {
	        return !!v;
	    }
	    function notId(v) {
	        return !v;
	    }
	
	    // global on the server, window in the browser
	    var previous_async;
	
	    // Establish the root object, `window` (`self`) in the browser, `global`
	    // on the server, or `this` in some virtual machines. We use `self`
	    // instead of `window` for `WebWorker` support.
	    var root = typeof self === 'object' && self.self === self && self ||
	            typeof global === 'object' && global.global === global && global ||
	            this;
	
	    if (root != null) {
	        previous_async = root.async;
	    }
	
	    async.noConflict = function () {
	        root.async = previous_async;
	        return async;
	    };
	
	    function only_once(fn) {
	        return function() {
	            if (fn === null) throw new Error("Callback was already called.");
	            fn.apply(this, arguments);
	            fn = null;
	        };
	    }
	
	    function _once(fn) {
	        return function() {
	            if (fn === null) return;
	            fn.apply(this, arguments);
	            fn = null;
	        };
	    }
	
	    //// cross-browser compatiblity functions ////
	
	    var _toString = Object.prototype.toString;
	
	    var _isArray = Array.isArray || function (obj) {
	        return _toString.call(obj) === '[object Array]';
	    };
	
	    // Ported from underscore.js isObject
	    var _isObject = function(obj) {
	        var type = typeof obj;
	        return type === 'function' || type === 'object' && !!obj;
	    };
	
	    function _isArrayLike(arr) {
	        return _isArray(arr) || (
	            // has a positive integer length property
	            typeof arr.length === "number" &&
	            arr.length >= 0 &&
	            arr.length % 1 === 0
	        );
	    }
	
	    function _each(coll, iterator) {
	        return _isArrayLike(coll) ?
	            _arrayEach(coll, iterator) :
	            _forEachOf(coll, iterator);
	    }
	
	    function _arrayEach(arr, iterator) {
	        var index = -1,
	            length = arr.length;
	
	        while (++index < length) {
	            iterator(arr[index], index, arr);
	        }
	    }
	
	    function _map(arr, iterator) {
	        var index = -1,
	            length = arr.length,
	            result = Array(length);
	
	        while (++index < length) {
	            result[index] = iterator(arr[index], index, arr);
	        }
	        return result;
	    }
	
	    function _range(count) {
	        return _map(Array(count), function (v, i) { return i; });
	    }
	
	    function _reduce(arr, iterator, memo) {
	        _arrayEach(arr, function (x, i, a) {
	            memo = iterator(memo, x, i, a);
	        });
	        return memo;
	    }
	
	    function _forEachOf(object, iterator) {
	        _arrayEach(_keys(object), function (key) {
	            iterator(object[key], key);
	        });
	    }
	
	    function _indexOf(arr, item) {
	        for (var i = 0; i < arr.length; i++) {
	            if (arr[i] === item) return i;
	        }
	        return -1;
	    }
	
	    var _keys = Object.keys || function (obj) {
	        var keys = [];
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    };
	
	    function _keyIterator(coll) {
	        var i = -1;
	        var len;
	        var keys;
	        if (_isArrayLike(coll)) {
	            len = coll.length;
	            return function next() {
	                i++;
	                return i < len ? i : null;
	            };
	        } else {
	            keys = _keys(coll);
	            len = keys.length;
	            return function next() {
	                i++;
	                return i < len ? keys[i] : null;
	            };
	        }
	    }
	
	    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
	    // This accumulates the arguments passed into an array, after a given index.
	    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).
	    function _restParam(func, startIndex) {
	        startIndex = startIndex == null ? func.length - 1 : +startIndex;
	        return function() {
	            var length = Math.max(arguments.length - startIndex, 0);
	            var rest = Array(length);
	            for (var index = 0; index < length; index++) {
	                rest[index] = arguments[index + startIndex];
	            }
	            switch (startIndex) {
	                case 0: return func.call(this, rest);
	                case 1: return func.call(this, arguments[0], rest);
	            }
	            // Currently unused but handle cases outside of the switch statement:
	            // var args = Array(startIndex + 1);
	            // for (index = 0; index < startIndex; index++) {
	            //     args[index] = arguments[index];
	            // }
	            // args[startIndex] = rest;
	            // return func.apply(this, args);
	        };
	    }
	
	    function _withoutIndex(iterator) {
	        return function (value, index, callback) {
	            return iterator(value, callback);
	        };
	    }
	
	    //// exported async module functions ////
	
	    //// nextTick implementation with browser-compatible fallback ////
	
	    // capture the global reference to guard against fakeTimer mocks
	    var _setImmediate = typeof setImmediate === 'function' && setImmediate;
	
	    var _delay = _setImmediate ? function(fn) {
	        // not a direct alias for IE10 compatibility
	        _setImmediate(fn);
	    } : function(fn) {
	        setTimeout(fn, 0);
	    };
	
	    if (typeof process === 'object' && typeof process.nextTick === 'function') {
	        async.nextTick = process.nextTick;
	    } else {
	        async.nextTick = _delay;
	    }
	    async.setImmediate = _setImmediate ? _delay : async.nextTick;
	
	
	    async.forEach =
	    async.each = function (arr, iterator, callback) {
	        return async.eachOf(arr, _withoutIndex(iterator), callback);
	    };
	
	    async.forEachSeries =
	    async.eachSeries = function (arr, iterator, callback) {
	        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
	    };
	
	
	    async.forEachLimit =
	    async.eachLimit = function (arr, limit, iterator, callback) {
	        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
	    };
	
	    async.forEachOf =
	    async.eachOf = function (object, iterator, callback) {
	        callback = _once(callback || noop);
	        object = object || [];
	        var size = _isArrayLike(object) ? object.length : _keys(object).length;
	        var completed = 0;
	        if (!size) {
	            return callback(null);
	        }
	        _each(object, function (value, key) {
	            iterator(object[key], key, only_once(done));
	        });
	        function done(err) {
	            if (err) {
	                callback(err);
	            }
	            else {
	                completed += 1;
	                if (completed >= size) {
	                    callback(null);
	                }
	            }
	        }
	    };
	
	    async.forEachOfSeries =
	    async.eachOfSeries = function (obj, iterator, callback) {
	        callback = _once(callback || noop);
	        obj = obj || [];
	        var nextKey = _keyIterator(obj);
	        var key = nextKey();
	        function iterate() {
	            var sync = true;
	            if (key === null) {
	                return callback(null);
	            }
	            iterator(obj[key], key, only_once(function (err) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    key = nextKey();
	                    if (key === null) {
	                        return callback(null);
	                    } else {
	                        if (sync) {
	                            async.nextTick(iterate);
	                        } else {
	                            iterate();
	                        }
	                    }
	                }
	            }));
	            sync = false;
	        }
	        iterate();
	    };
	
	
	
	    async.forEachOfLimit =
	    async.eachOfLimit = function (obj, limit, iterator, callback) {
	        _eachOfLimit(limit)(obj, iterator, callback);
	    };
	
	    function _eachOfLimit(limit) {
	
	        return function (obj, iterator, callback) {
	            callback = _once(callback || noop);
	            obj = obj || [];
	            var nextKey = _keyIterator(obj);
	            if (limit <= 0) {
	                return callback(null);
	            }
	            var done = false;
	            var running = 0;
	            var errored = false;
	
	            (function replenish () {
	                if (done && running <= 0) {
	                    return callback(null);
	                }
	
	                while (running < limit && !errored) {
	                    var key = nextKey();
	                    if (key === null) {
	                        done = true;
	                        if (running <= 0) {
	                            callback(null);
	                        }
	                        return;
	                    }
	                    running += 1;
	                    iterator(obj[key], key, only_once(function (err) {
	                        running -= 1;
	                        if (err) {
	                            callback(err);
	                            errored = true;
	                        }
	                        else {
	                            replenish();
	                        }
	                    }));
	                }
	            })();
	        };
	    }
	
	
	    function doParallel(fn) {
	        return function (obj, iterator, callback) {
	            return fn(async.eachOf, obj, iterator, callback);
	        };
	    }
	    function doParallelLimit(fn) {
	        return function (obj, limit, iterator, callback) {
	            return fn(_eachOfLimit(limit), obj, iterator, callback);
	        };
	    }
	    function doSeries(fn) {
	        return function (obj, iterator, callback) {
	            return fn(async.eachOfSeries, obj, iterator, callback);
	        };
	    }
	
	    function _asyncMap(eachfn, arr, iterator, callback) {
	        callback = _once(callback || noop);
	        var results = [];
	        eachfn(arr, function (value, index, callback) {
	            iterator(value, function (err, v) {
	                results[index] = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, results);
	        });
	    }
	
	    async.map = doParallel(_asyncMap);
	    async.mapSeries = doSeries(_asyncMap);
	    async.mapLimit = doParallelLimit(_asyncMap);
	
	    // reduce only has a series version, as doing reduce in parallel won't
	    // work in many situations.
	    async.inject =
	    async.foldl =
	    async.reduce = function (arr, memo, iterator, callback) {
	        async.eachOfSeries(arr, function (x, i, callback) {
	            iterator(memo, x, function (err, v) {
	                memo = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err || null, memo);
	        });
	    };
	
	    async.foldr =
	    async.reduceRight = function (arr, memo, iterator, callback) {
	        var reversed = _map(arr, identity).reverse();
	        async.reduce(reversed, memo, iterator, callback);
	    };
	
	    function _filter(eachfn, arr, iterator, callback) {
	        var results = [];
	        eachfn(arr, function (x, index, callback) {
	            iterator(x, function (v) {
	                if (v) {
	                    results.push({index: index, value: x});
	                }
	                callback();
	            });
	        }, function () {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    }
	
	    async.select =
	    async.filter = doParallel(_filter);
	
	    async.selectLimit =
	    async.filterLimit = doParallelLimit(_filter);
	
	    async.selectSeries =
	    async.filterSeries = doSeries(_filter);
	
	    function _reject(eachfn, arr, iterator, callback) {
	        _filter(eachfn, arr, function(value, cb) {
	            iterator(value, function(v) {
	                cb(!v);
	            });
	        }, callback);
	    }
	    async.reject = doParallel(_reject);
	    async.rejectLimit = doParallelLimit(_reject);
	    async.rejectSeries = doSeries(_reject);
	
	    function _createTester(eachfn, check, getResult) {
	        return function(arr, limit, iterator, cb) {
	            function done() {
	                if (cb) cb(getResult(false, void 0));
	            }
	            function iteratee(x, _, callback) {
	                if (!cb) return callback();
	                iterator(x, function (v) {
	                    if (cb && check(v)) {
	                        cb(getResult(true, x));
	                        cb = iterator = false;
	                    }
	                    callback();
	                });
	            }
	            if (arguments.length > 3) {
	                eachfn(arr, limit, iteratee, done);
	            } else {
	                cb = iterator;
	                iterator = limit;
	                eachfn(arr, iteratee, done);
	            }
	        };
	    }
	
	    async.any =
	    async.some = _createTester(async.eachOf, toBool, identity);
	
	    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);
	
	    async.all =
	    async.every = _createTester(async.eachOf, notId, notId);
	
	    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);
	
	    function _findGetResult(v, x) {
	        return x;
	    }
	    async.detect = _createTester(async.eachOf, identity, _findGetResult);
	    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
	    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);
	
	    async.sortBy = function (arr, iterator, callback) {
	        async.map(arr, function (x, callback) {
	            iterator(x, function (err, criteria) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    callback(null, {value: x, criteria: criteria});
	                }
	            });
	        }, function (err, results) {
	            if (err) {
	                return callback(err);
	            }
	            else {
	                callback(null, _map(results.sort(comparator), function (x) {
	                    return x.value;
	                }));
	            }
	
	        });
	
	        function comparator(left, right) {
	            var a = left.criteria, b = right.criteria;
	            return a < b ? -1 : a > b ? 1 : 0;
	        }
	    };
	
	    async.auto = function (tasks, callback) {
	        callback = _once(callback || noop);
	        var keys = _keys(tasks);
	        var remainingTasks = keys.length;
	        if (!remainingTasks) {
	            return callback(null);
	        }
	
	        var results = {};
	
	        var listeners = [];
	        function addListener(fn) {
	            listeners.unshift(fn);
	        }
	        function removeListener(fn) {
	            var idx = _indexOf(listeners, fn);
	            if (idx >= 0) listeners.splice(idx, 1);
	        }
	        function taskComplete() {
	            remainingTasks--;
	            _arrayEach(listeners.slice(0), function (fn) {
	                fn();
	            });
	        }
	
	        addListener(function () {
	            if (!remainingTasks) {
	                callback(null, results);
	            }
	        });
	
	        _arrayEach(keys, function (k) {
	            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
	            var taskCallback = _restParam(function(err, args) {
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                if (err) {
	                    var safeResults = {};
	                    _forEachOf(results, function(val, rkey) {
	                        safeResults[rkey] = val;
	                    });
	                    safeResults[k] = args;
	                    callback(err, safeResults);
	                }
	                else {
	                    results[k] = args;
	                    async.setImmediate(taskComplete);
	                }
	            });
	            var requires = task.slice(0, task.length - 1);
	            // prevent dead-locks
	            var len = requires.length;
	            var dep;
	            while (len--) {
	                if (!(dep = tasks[requires[len]])) {
	                    throw new Error('Has inexistant dependency');
	                }
	                if (_isArray(dep) && _indexOf(dep, k) >= 0) {
	                    throw new Error('Has cyclic dependencies');
	                }
	            }
	            function ready() {
	                return _reduce(requires, function (a, x) {
	                    return (a && results.hasOwnProperty(x));
	                }, true) && !results.hasOwnProperty(k);
	            }
	            if (ready()) {
	                task[task.length - 1](taskCallback, results);
	            }
	            else {
	                addListener(listener);
	            }
	            function listener() {
	                if (ready()) {
	                    removeListener(listener);
	                    task[task.length - 1](taskCallback, results);
	                }
	            }
	        });
	    };
	
	
	
	    async.retry = function(times, task, callback) {
	        var DEFAULT_TIMES = 5;
	        var DEFAULT_INTERVAL = 0;
	
	        var attempts = [];
	
	        var opts = {
	            times: DEFAULT_TIMES,
	            interval: DEFAULT_INTERVAL
	        };
	
	        function parseTimes(acc, t){
	            if(typeof t === 'number'){
	                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
	            } else if(typeof t === 'object'){
	                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
	                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
	            } else {
	                throw new Error('Unsupported argument type for \'times\': ' + typeof t);
	            }
	        }
	
	        var length = arguments.length;
	        if (length < 1 || length > 3) {
	            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
	        } else if (length <= 2 && typeof times === 'function') {
	            callback = task;
	            task = times;
	        }
	        if (typeof times !== 'function') {
	            parseTimes(opts, times);
	        }
	        opts.callback = callback;
	        opts.task = task;
	
	        function wrappedTask(wrappedCallback, wrappedResults) {
	            function retryAttempt(task, finalAttempt) {
	                return function(seriesCallback) {
	                    task(function(err, result){
	                        seriesCallback(!err || finalAttempt, {err: err, result: result});
	                    }, wrappedResults);
	                };
	            }
	
	            function retryInterval(interval){
	                return function(seriesCallback){
	                    setTimeout(function(){
	                        seriesCallback(null);
	                    }, interval);
	                };
	            }
	
	            while (opts.times) {
	
	                var finalAttempt = !(opts.times-=1);
	                attempts.push(retryAttempt(opts.task, finalAttempt));
	                if(!finalAttempt && opts.interval > 0){
	                    attempts.push(retryInterval(opts.interval));
	                }
	            }
	
	            async.series(attempts, function(done, data){
	                data = data[data.length - 1];
	                (wrappedCallback || opts.callback)(data.err, data.result);
	            });
	        }
	
	        // If a callback is passed, run this as a controll flow
	        return opts.callback ? wrappedTask() : wrappedTask;
	    };
	
	    async.waterfall = function (tasks, callback) {
	        callback = _once(callback || noop);
	        if (!_isArray(tasks)) {
	            var err = new Error('First argument to waterfall must be an array of functions');
	            return callback(err);
	        }
	        if (!tasks.length) {
	            return callback();
	        }
	        function wrapIterator(iterator) {
	            return _restParam(function (err, args) {
	                if (err) {
	                    callback.apply(null, [err].concat(args));
	                }
	                else {
	                    var next = iterator.next();
	                    if (next) {
	                        args.push(wrapIterator(next));
	                    }
	                    else {
	                        args.push(callback);
	                    }
	                    ensureAsync(iterator).apply(null, args);
	                }
	            });
	        }
	        wrapIterator(async.iterator(tasks))();
	    };
	
	    function _parallel(eachfn, tasks, callback) {
	        callback = callback || noop;
	        var results = _isArrayLike(tasks) ? [] : {};
	
	        eachfn(tasks, function (task, key, callback) {
	            task(_restParam(function (err, args) {
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                results[key] = args;
	                callback(err);
	            }));
	        }, function (err) {
	            callback(err, results);
	        });
	    }
	
	    async.parallel = function (tasks, callback) {
	        _parallel(async.eachOf, tasks, callback);
	    };
	
	    async.parallelLimit = function(tasks, limit, callback) {
	        _parallel(_eachOfLimit(limit), tasks, callback);
	    };
	
	    async.series = function(tasks, callback) {
	        _parallel(async.eachOfSeries, tasks, callback);
	    };
	
	    async.iterator = function (tasks) {
	        function makeCallback(index) {
	            function fn() {
	                if (tasks.length) {
	                    tasks[index].apply(null, arguments);
	                }
	                return fn.next();
	            }
	            fn.next = function () {
	                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
	            };
	            return fn;
	        }
	        return makeCallback(0);
	    };
	
	    async.apply = _restParam(function (fn, args) {
	        return _restParam(function (callArgs) {
	            return fn.apply(
	                null, args.concat(callArgs)
	            );
	        });
	    });
	
	    function _concat(eachfn, arr, fn, callback) {
	        var result = [];
	        eachfn(arr, function (x, index, cb) {
	            fn(x, function (err, y) {
	                result = result.concat(y || []);
	                cb(err);
	            });
	        }, function (err) {
	            callback(err, result);
	        });
	    }
	    async.concat = doParallel(_concat);
	    async.concatSeries = doSeries(_concat);
	
	    async.whilst = function (test, iterator, callback) {
	        callback = callback || noop;
	        if (test()) {
	            var next = _restParam(function(err, args) {
	                if (err) {
	                    callback(err);
	                } else if (test.apply(this, args)) {
	                    iterator(next);
	                } else {
	                    callback(null);
	                }
	            });
	            iterator(next);
	        } else {
	            callback(null);
	        }
	    };
	
	    async.doWhilst = function (iterator, test, callback) {
	        var calls = 0;
	        return async.whilst(function() {
	            return ++calls <= 1 || test.apply(this, arguments);
	        }, iterator, callback);
	    };
	
	    async.until = function (test, iterator, callback) {
	        return async.whilst(function() {
	            return !test.apply(this, arguments);
	        }, iterator, callback);
	    };
	
	    async.doUntil = function (iterator, test, callback) {
	        return async.doWhilst(iterator, function() {
	            return !test.apply(this, arguments);
	        }, callback);
	    };
	
	    async.during = function (test, iterator, callback) {
	        callback = callback || noop;
	
	        var next = _restParam(function(err, args) {
	            if (err) {
	                callback(err);
	            } else {
	                args.push(check);
	                test.apply(this, args);
	            }
	        });
	
	        var check = function(err, truth) {
	            if (err) {
	                callback(err);
	            } else if (truth) {
	                iterator(next);
	            } else {
	                callback(null);
	            }
	        };
	
	        test(check);
	    };
	
	    async.doDuring = function (iterator, test, callback) {
	        var calls = 0;
	        async.during(function(next) {
	            if (calls++ < 1) {
	                next(null, true);
	            } else {
	                test.apply(this, arguments);
	            }
	        }, iterator, callback);
	    };
	
	    function _queue(worker, concurrency, payload) {
	        if (concurrency == null) {
	            concurrency = 1;
	        }
	        else if(concurrency === 0) {
	            throw new Error('Concurrency must not be zero');
	        }
	        function _insert(q, data, pos, callback) {
	            if (callback != null && typeof callback !== "function") {
	                throw new Error("task callback must be a function");
	            }
	            q.started = true;
	            if (!_isArray(data)) {
	                data = [data];
	            }
	            if(data.length === 0 && q.idle()) {
	                // call drain immediately if there are no tasks
	                return async.setImmediate(function() {
	                    q.drain();
	                });
	            }
	            _arrayEach(data, function(task) {
	                var item = {
	                    data: task,
	                    callback: callback || noop
	                };
	
	                if (pos) {
	                    q.tasks.unshift(item);
	                } else {
	                    q.tasks.push(item);
	                }
	
	                if (q.tasks.length === q.concurrency) {
	                    q.saturated();
	                }
	            });
	            async.setImmediate(q.process);
	        }
	        function _next(q, tasks) {
	            return function(){
	                workers -= 1;
	                var args = arguments;
	                _arrayEach(tasks, function (task) {
	                    task.callback.apply(task, args);
	                });
	                if (q.tasks.length + workers === 0) {
	                    q.drain();
	                }
	                q.process();
	            };
	        }
	
	        var workers = 0;
	        var q = {
	            tasks: [],
	            concurrency: concurrency,
	            payload: payload,
	            saturated: noop,
	            empty: noop,
	            drain: noop,
	            started: false,
	            paused: false,
	            push: function (data, callback) {
	                _insert(q, data, false, callback);
	            },
	            kill: function () {
	                q.drain = noop;
	                q.tasks = [];
	            },
	            unshift: function (data, callback) {
	                _insert(q, data, true, callback);
	            },
	            process: function () {
	                if (!q.paused && workers < q.concurrency && q.tasks.length) {
	                    while(workers < q.concurrency && q.tasks.length){
	                        var tasks = q.payload ?
	                            q.tasks.splice(0, q.payload) :
	                            q.tasks.splice(0, q.tasks.length);
	
	                        var data = _map(tasks, function (task) {
	                            return task.data;
	                        });
	
	                        if (q.tasks.length === 0) {
	                            q.empty();
	                        }
	                        workers += 1;
	                        var cb = only_once(_next(q, tasks));
	                        worker(data, cb);
	                    }
	                }
	            },
	            length: function () {
	                return q.tasks.length;
	            },
	            running: function () {
	                return workers;
	            },
	            idle: function() {
	                return q.tasks.length + workers === 0;
	            },
	            pause: function () {
	                q.paused = true;
	            },
	            resume: function () {
	                if (q.paused === false) { return; }
	                q.paused = false;
	                var resumeCount = Math.min(q.concurrency, q.tasks.length);
	                // Need to call q.process once per concurrent
	                // worker to preserve full concurrency after pause
	                for (var w = 1; w <= resumeCount; w++) {
	                    async.setImmediate(q.process);
	                }
	            }
	        };
	        return q;
	    }
	
	    async.queue = function (worker, concurrency) {
	        var q = _queue(function (items, cb) {
	            worker(items[0], cb);
	        }, concurrency, 1);
	
	        return q;
	    };
	
	    async.priorityQueue = function (worker, concurrency) {
	
	        function _compareTasks(a, b){
	            return a.priority - b.priority;
	        }
	
	        function _binarySearch(sequence, item, compare) {
	            var beg = -1,
	                end = sequence.length - 1;
	            while (beg < end) {
	                var mid = beg + ((end - beg + 1) >>> 1);
	                if (compare(item, sequence[mid]) >= 0) {
	                    beg = mid;
	                } else {
	                    end = mid - 1;
	                }
	            }
	            return beg;
	        }
	
	        function _insert(q, data, priority, callback) {
	            if (callback != null && typeof callback !== "function") {
	                throw new Error("task callback must be a function");
	            }
	            q.started = true;
	            if (!_isArray(data)) {
	                data = [data];
	            }
	            if(data.length === 0) {
	                // call drain immediately if there are no tasks
	                return async.setImmediate(function() {
	                    q.drain();
	                });
	            }
	            _arrayEach(data, function(task) {
	                var item = {
	                    data: task,
	                    priority: priority,
	                    callback: typeof callback === 'function' ? callback : noop
	                };
	
	                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
	
	                if (q.tasks.length === q.concurrency) {
	                    q.saturated();
	                }
	                async.setImmediate(q.process);
	            });
	        }
	
	        // Start with a normal queue
	        var q = async.queue(worker, concurrency);
	
	        // Override push to accept second parameter representing priority
	        q.push = function (data, priority, callback) {
	            _insert(q, data, priority, callback);
	        };
	
	        // Remove unshift function
	        delete q.unshift;
	
	        return q;
	    };
	
	    async.cargo = function (worker, payload) {
	        return _queue(worker, 1, payload);
	    };
	
	    function _console_fn(name) {
	        return _restParam(function (fn, args) {
	            fn.apply(null, args.concat([_restParam(function (err, args) {
	                if (typeof console === 'object') {
	                    if (err) {
	                        if (console.error) {
	                            console.error(err);
	                        }
	                    }
	                    else if (console[name]) {
	                        _arrayEach(args, function (x) {
	                            console[name](x);
	                        });
	                    }
	                }
	            })]));
	        });
	    }
	    async.log = _console_fn('log');
	    async.dir = _console_fn('dir');
	    /*async.info = _console_fn('info');
	    async.warn = _console_fn('warn');
	    async.error = _console_fn('error');*/
	
	    async.memoize = function (fn, hasher) {
	        var memo = {};
	        var queues = {};
	        hasher = hasher || identity;
	        var memoized = _restParam(function memoized(args) {
	            var callback = args.pop();
	            var key = hasher.apply(null, args);
	            if (key in memo) {
	                async.nextTick(function () {
	                    callback.apply(null, memo[key]);
	                });
	            }
	            else if (key in queues) {
	                queues[key].push(callback);
	            }
	            else {
	                queues[key] = [callback];
	                fn.apply(null, args.concat([_restParam(function (args) {
	                    memo[key] = args;
	                    var q = queues[key];
	                    delete queues[key];
	                    for (var i = 0, l = q.length; i < l; i++) {
	                        q[i].apply(null, args);
	                    }
	                })]));
	            }
	        });
	        memoized.memo = memo;
	        memoized.unmemoized = fn;
	        return memoized;
	    };
	
	    async.unmemoize = function (fn) {
	        return function () {
	            return (fn.unmemoized || fn).apply(null, arguments);
	        };
	    };
	
	    function _times(mapper) {
	        return function (count, iterator, callback) {
	            mapper(_range(count), iterator, callback);
	        };
	    }
	
	    async.times = _times(async.map);
	    async.timesSeries = _times(async.mapSeries);
	    async.timesLimit = function (count, limit, iterator, callback) {
	        return async.mapLimit(_range(count), limit, iterator, callback);
	    };
	
	    async.seq = function (/* functions... */) {
	        var fns = arguments;
	        return _restParam(function (args) {
	            var that = this;
	
	            var callback = args[args.length - 1];
	            if (typeof callback == 'function') {
	                args.pop();
	            } else {
	                callback = noop;
	            }
	
	            async.reduce(fns, args, function (newargs, fn, cb) {
	                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {
	                    cb(err, nextargs);
	                })]));
	            },
	            function (err, results) {
	                callback.apply(that, [err].concat(results));
	            });
	        });
	    };
	
	    async.compose = function (/* functions... */) {
	        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
	    };
	
	
	    function _applyEach(eachfn) {
	        return _restParam(function(fns, args) {
	            var go = _restParam(function(args) {
	                var that = this;
	                var callback = args.pop();
	                return eachfn(fns, function (fn, _, cb) {
	                    fn.apply(that, args.concat([cb]));
	                },
	                callback);
	            });
	            if (args.length) {
	                return go.apply(this, args);
	            }
	            else {
	                return go;
	            }
	        });
	    }
	
	    async.applyEach = _applyEach(async.eachOf);
	    async.applyEachSeries = _applyEach(async.eachOfSeries);
	
	
	    async.forever = function (fn, callback) {
	        var done = only_once(callback || noop);
	        var task = ensureAsync(fn);
	        function next(err) {
	            if (err) {
	                return done(err);
	            }
	            task(next);
	        }
	        next();
	    };
	
	    function ensureAsync(fn) {
	        return _restParam(function (args) {
	            var callback = args.pop();
	            args.push(function () {
	                var innerArgs = arguments;
	                if (sync) {
	                    async.setImmediate(function () {
	                        callback.apply(null, innerArgs);
	                    });
	                } else {
	                    callback.apply(null, innerArgs);
	                }
	            });
	            var sync = true;
	            fn.apply(this, args);
	            sync = false;
	        });
	    }
	
	    async.ensureAsync = ensureAsync;
	
	    async.constant = _restParam(function(values) {
	        var args = [null].concat(values);
	        return function (callback) {
	            return callback.apply(this, args);
	        };
	    });
	
	    async.wrapSync =
	    async.asyncify = function asyncify(func) {
	        return _restParam(function (args) {
	            var callback = args.pop();
	            var result;
	            try {
	                result = func.apply(this, args);
	            } catch (e) {
	                return callback(e);
	            }
	            // if result is Promise object
	            if (_isObject(result) && typeof result.then === "function") {
	                result.then(function(value) {
	                    callback(null, value);
	                })["catch"](function(err) {
	                    callback(err.message ? err : new Error(err));
	                });
	            } else {
	                callback(null, result);
	            }
	        });
	    };
	
	    // Node.js
	    if (typeof module === 'object' && module.exports) {
	        module.exports = async;
	    }
	    // AMD / RequireJS
	    else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return async;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    // included directly via <script> tag
	    else {
	        root.async = async;
	    }
	
	}());
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(184).setImmediate, __webpack_require__(5)))

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(5).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(184).setImmediate, __webpack_require__(184).clearImmediate))

/***/ },
/* 185 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function EntryModuleNotFoundError(err) {
		Error.call(this);
		Error.captureStackTrace(this, EntryModuleNotFoundError);
		this.name = "EntryModuleNotFoundError";
		this.message = "Entry module not found: " + err;
		this.details = err.details;
		this.error = err;
	}
	module.exports = EntryModuleNotFoundError;
	
	EntryModuleNotFoundError.prototype = Object.create(Error.prototype);


/***/ },
/* 186 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleNotFoundError(module, err) {
		Error.call(this);
		Error.captureStackTrace(this, ModuleNotFoundError);
		this.name = "ModuleNotFoundError";
		this.message = "Module not found: " + err;
		this.details = err.details;
		this.missing = err.missing;
		this.module = module;
		this.error = err;
	}
	module.exports = ModuleNotFoundError;
	
	ModuleNotFoundError.prototype = Object.create(Error.prototype);


/***/ },
/* 187 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function CriticalDependenciesWarning(module, dependencies) {
		Error.call(this);
		Error.captureStackTrace(this, CriticalDependenciesWarning);
		this.name = "CriticalDependenciesWarning";
		this.message = "Critical dependencies:";
		this.message += dependencies.filter(function(d) {
			return typeof d.critical === "string" || d.loc;
		}).map(function(dep) {
			var line = [];
			if(dep.loc) line.push(dep.loc.start.line + ":" + dep.loc.start.column + "-" +
				(dep.loc.start.line !== dep.loc.end.line ? dep.loc.end.line + ":" : "") + dep.loc.end.column);
			if(typeof dep.critical === "string") line.push(dep.critical);
			return "\n" + line.join(" ");
		}).join("");
		this.dependencies = dependencies;
		this.origin = this.module = module;
	}
	module.exports = CriticalDependenciesWarning;
	
	CriticalDependenciesWarning.prototype = Object.create(Error.prototype);


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var DependenciesBlock = __webpack_require__(189);
	var ModuleReason = __webpack_require__(214);
	
	var debugId = 1000;
	
	function Module() {
		DependenciesBlock.call(this);
		this.context = null;
		this.reasons = [];
		this.debugId = debugId++;
		this.lastId = -1;
		this.id = null;
		this.index = null;
		this.index2 = null;
		this.chunks = [];
		this.warnings = [];
		this.dependenciesWarnings = [];
		this.errors = [];
		this.dependenciesErrors = [];
	}
	module.exports = Module;
	
	Module.prototype = Object.create(DependenciesBlock.prototype);
	
	Module.prototype.disconnect = function() {
		this.reasons.length = 0;
		this.lastId = this.id;
		this.id = null;
		this.index = null;
		this.index2 = null;
		this.chunks.length = 0;
		DependenciesBlock.prototype.disconnect.call(this);
	};
	
	Module.prototype.addChunk = function(chunk) {
		var idx = this.chunks.indexOf(chunk);
		if(idx < 0)
			this.chunks.push(chunk);
	};
	
	Module.prototype._removeAndDo = __webpack_require__(215);
	
	Module.prototype.removeChunk = function(chunk) {
		return this._removeAndDo("chunks", chunk, "removeModule");
	};
	
	Module.prototype.addReason = function(module, dependency) {
		this.reasons.push(new ModuleReason(module, dependency));
	};
	
	Module.prototype.removeReason = function(module, dependency) {
		for(var i = 0; i < this.reasons.length; i++) {
			var r = this.reasons[i];
			if(r.module === module && r.dependency === dependency) {
				this.reasons.splice(i, 1);
				return true;
			}
		}
		return false;
	};
	
	Module.prototype.hasReasonForChunk = function(chunk) {
		for(var i = 0; i < this.reasons.length; i++) {
			var r = this.reasons[i];
			if(r.chunks) {
				if(r.chunks.indexOf(chunk) >= 0)
					return true;
			} else if(r.module.chunks.indexOf(chunk) >= 0)
				return true;
		}
		return false;
	};
	
	function addToSet(set, items) {
		items.forEach(function(item) {
			if(set.indexOf(item) < 0)
				set.push(item);
		});
	}
	
	Module.prototype.rewriteChunkInReasons = function(oldChunk, newChunks) {
		this.reasons.forEach(function(r) {
			if(!r.chunks) {
				if(r.module.chunks.indexOf(oldChunk) < 0)
					return;
				r.chunks = r.module.chunks;
			}
			r.chunks = r.chunks.reduce(function(arr, c) {
				addToSet(arr, c !== oldChunk ? [c] : newChunks);
				return arr;
			}, []);
		});
	};
	
	Module.prototype.toString = function() {
		return "Module[" + (this.id || this.debugId) + "]";
	};
	
	Module.prototype.needRebuild = function( /* fileTimestamps, contextTimestamps */ ) {
		return true;
	};
	
	Module.prototype.updateHash = function(hash) {
		hash.update(this.id + "");
		DependenciesBlock.prototype.updateHash.call(this, hash);
	};
	
	Module.prototype.identifier = null;
	Module.prototype.readableIdentifier = null;
	Module.prototype.build = null;
	Module.prototype.source = null;
	Module.prototype.size = null;


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var DependenciesBlockVariable = __webpack_require__(190);
	
	function DependenciesBlock() {
		this.dependencies = [];
		this.blocks = [];
		this.variables = [];
	}
	module.exports = DependenciesBlock;
	
	DependenciesBlock.prototype.addBlock = function(block) {
		this.blocks.push(block);
		block.parent = this;
	};
	
	DependenciesBlock.prototype.addVariable = function(name, expression, dependencies) {
		for(var i = 0; i < this.variables.length; i++) {
			var v = this.variables[i];
			if(v.name === name && v.expression === expression) return;
		}
		this.variables.push(new DependenciesBlockVariable(name, expression, dependencies));
	};
	
	DependenciesBlock.prototype.addDependency = function(dependency) {
		this.dependencies.push(dependency);
	};
	
	DependenciesBlock.prototype.updateHash = function(hash) {
		this.dependencies.forEach(function(d) {
			d.updateHash(hash);
		});
		this.blocks.forEach(function(b) {
			b.updateHash(hash);
		});
		this.variables.forEach(function(v) {
			v.updateHash(hash);
		});
	};
	
	DependenciesBlock.prototype.disconnect = function() {
		function disconnect(i) {
			i.disconnect();
		}
		this.dependencies.forEach(disconnect);
		this.blocks.forEach(disconnect);
		this.variables.forEach(disconnect);
	};
	
	DependenciesBlock.prototype.hasDependencies = function() {
		return this.dependencies.length > 0 ||
			this.blocks.concat(this.variables).some(function(item) {
				return item.hasDependencies();
			});
	};


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ReplaceSource = __webpack_require__(191);
	var RawSource = __webpack_require__(213);
	
	function DependenciesBlockVariable(name, expression, dependencies) {
		this.name = name;
		this.expression = expression;
		this.dependencies = dependencies || [];
	}
	module.exports = DependenciesBlockVariable;
	
	DependenciesBlockVariable.prototype.updateHash = function(hash) {
		hash.update(this.name);
		hash.update(this.expression);
		this.dependencies.forEach(function(d) {
			d.updateHash(hash);
		});
	};
	
	DependenciesBlockVariable.prototype.expressionSource = function(dependencyTemplates, outputOptions, requestShortener) {
		var source = new ReplaceSource(new RawSource(this.expression));
		this.dependencies.forEach(function(dep) {
			var template = dependencyTemplates.get(dep.Class);
			if(!template) throw new Error("No template for dependency: " + dep.Class.name);
			template.apply(dep, source, outputOptions, requestShortener, dependencyTemplates);
		});
		return source;
	};
	
	DependenciesBlockVariable.prototype.disconnect = function() {
		this.dependencies.forEach(function(d) {
			d.disconnect();
		});
	};
	
	DependenciesBlockVariable.prototype.hasDependencies = function() {
		return this.dependencies.length > 0;
	};


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Source = __webpack_require__(192);
	var SourceNode = __webpack_require__(193).SourceNode;
	var SourceListMap = __webpack_require__(204).SourceListMap;
	var fromStringWithSourceMap = __webpack_require__(204).fromStringWithSourceMap;
	var SourceMapConsumer = __webpack_require__(193).SourceMapConsumer;
	
	function ReplaceSource(source, name) {
		Source.call(this);
		this._source = source;
		this._name = name;
		this.replacements = [];
	}
	module.exports = ReplaceSource;
	
	ReplaceSource.prototype = Object.create(Source.prototype);
	ReplaceSource.prototype.constructor = ReplaceSource;
	
	ReplaceSource.prototype.replace = function(start, end, newValue) {
		this.replacements.push([start, end, newValue]);
	};
	
	ReplaceSource.prototype.insert = function(pos, newValue) {
		this.replacements.push([pos, pos-1, newValue]);
	};
	
	ReplaceSource.prototype.source = function(options) {
		return this._replaceString(this._source.source());
	};
	
	ReplaceSource.prototype._replaceString = function(str) {
		this.replacements.sort(function(a, b) {
			return b[1] - a[1];
		});
		var result = [str];
		this.replacements.forEach(function(repl) {
			var remSource = result.pop();
			var splitted1 = this._splitString(remSource, Math.floor(repl[1]+1));
			var splitted2 = this._splitString(splitted1[0], Math.floor(repl[0]));
			result.push(splitted1[1], repl[2], splitted2[0]);
		}, this);
		result = result.reverse();
		return result.join("");
	};
	
	__webpack_require__(212)(ReplaceSource.prototype);
	
	ReplaceSource.prototype.node = function(options) {
		this.replacements.sort(function(a, b) {
			return b[1] - a[1];
		});
		var result = [this._source.node(options)];
		this.replacements.forEach(function(repl) {
			var remSource = result.pop();
			var splitted1 = this._splitSourceNode(remSource, Math.floor(repl[1]+1));
			if(Array.isArray(splitted1)) {
				var splitted2 = this._splitSourceNode(splitted1[0], Math.floor(repl[0]));
				if(Array.isArray(splitted2)) {
					result.push(splitted1[1], this._replacementToSourceNode(splitted2[1], repl[2]), splitted2[0]);
				} else {
					result.push(splitted1[1], this._replacementToSourceNode(splitted1[1], repl[2]), splitted1[0]);
				}
			} else {
				var splitted2 = this._splitSourceNode(remSource, Math.floor(repl[0]));
				if(Array.isArray(splitted2)) {
					result.push(this._replacementToSourceNode(splitted2[1], repl[2]), splitted2[0]);
				} else {
					result.push(repl[2], remSource);
				}
			}
		}, this);
		result = result.reverse();
		return new SourceNode(null, null, null, result);
	};
	
	ReplaceSource.prototype.listMap = function(options) {
		var map = this._source.listMap(options);
		if(map.children.length !== 1) {
			var code = map.toString();
			code = this._replaceString(code).split("\n");
			var currentIndex = 0;
			map.mapGeneratedCode(function(str) {
				var idx = -1;
				var count = -1;
				do {
					count++;
					idx = str.indexOf("\n", idx + 1);
				} while(idx >= 0);
				if(!count) return "";
				var result = code.slice(currentIndex, currentIndex + count).join("\n") + "\n";
				currentIndex += count;
				return result;
			});
			map.add(code.slice(currentIndex).join("\n"));
		} else {
			map.mapGeneratedCode(this._replaceString.bind(this));
		}
		return map;
	};
	
	ReplaceSource.prototype._replacementToSourceNode = function(oldNode, newString) {
		var map = oldNode.toStringWithSourceMap({ file: "?" }).map;
		var original = new SourceMapConsumer(map.toJSON()).originalPositionFor({ line: 1, column: 0 });
		if(original) {
			return new SourceNode(original.line, original.column, original.source, newString);
		} else {
			return newString;
		}
	};
	
	ReplaceSource.prototype._splitSourceNode = function(node, position) {
		if(typeof node === "string") {
			if(node.length <= position) return position - node.length;
			return [node.substr(0, position), node.substr(position)];
		} else {
			for(var i = 0; i < node.children.length; i++) {
				position = this._splitSourceNode(node.children[i], position);
				if(Array.isArray(position)) {
					var leftNode = new SourceNode(
						node.line,
						node.column,
						node.source,
						node.children.slice(0, i).concat([position[0]]),
						node.name
					);
					var rightNode = new SourceNode(
						node.line,
						node.column,
						node.source,
						[position[1]].concat(node.children.slice(i+1)),
						node.name
					);
					leftNode.sourceContents = node.sourceContents;
					return [leftNode, rightNode];
				}
			}
			return position;
		}
	};
	
	ReplaceSource.prototype._splitString = function(str, position) {
		return [str.substr(0, position), str.substr(position)];
	};


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(193).SourceNode;
	var SourceMapConsumer = __webpack_require__(193).SourceMapConsumer;
	
	function Source() {}
	
	module.exports = Source;
	
	Source.prototype.source = null;
	
	Source.prototype.size = function() {
		return this.source().length;
	};
	
	Source.prototype.map = function(options) {
		return null;
	};
	
	Source.prototype.sourceAndMap = function(options) {
		return {
			source: this.source(),
			map: this.map()
		};
	};
	
	Source.prototype.node = null;
	
	Source.prototype.listNode = null;
	
	Source.prototype.updateHash = function(hash) {
		var source = this.source();
		hash.update(source || "");
	};


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	exports.SourceMapGenerator = __webpack_require__(194).SourceMapGenerator;
	exports.SourceMapConsumer = __webpack_require__(200).SourceMapConsumer;
	exports.SourceNode = __webpack_require__(203).SourceNode;


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var base64VLQ = __webpack_require__(195);
	  var util = __webpack_require__(197);
	  var ArraySet = __webpack_require__(198).ArraySet;
	  var MappingList = __webpack_require__(199).MappingList;
	
	  /**
	   * An instance of the SourceMapGenerator represents a source map which is
	   * being built incrementally. You may pass an object with the following
	   * properties:
	   *
	   *   - file: The filename of the generated source.
	   *   - sourceRoot: A root for all relative URLs in this source map.
	   */
	  function SourceMapGenerator(aArgs) {
	    if (!aArgs) {
	      aArgs = {};
	    }
	    this._file = util.getArg(aArgs, 'file', null);
	    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	    this._mappings = new MappingList();
	    this._sourcesContents = null;
	  }
	
	  SourceMapGenerator.prototype._version = 3;
	
	  /**
	   * Creates a new SourceMapGenerator based on a SourceMapConsumer
	   *
	   * @param aSourceMapConsumer The SourceMap.
	   */
	  SourceMapGenerator.fromSourceMap =
	    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	      var sourceRoot = aSourceMapConsumer.sourceRoot;
	      var generator = new SourceMapGenerator({
	        file: aSourceMapConsumer.file,
	        sourceRoot: sourceRoot
	      });
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        var newMapping = {
	          generated: {
	            line: mapping.generatedLine,
	            column: mapping.generatedColumn
	          }
	        };
	
	        if (mapping.source != null) {
	          newMapping.source = mapping.source;
	          if (sourceRoot != null) {
	            newMapping.source = util.relative(sourceRoot, newMapping.source);
	          }
	
	          newMapping.original = {
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          };
	
	          if (mapping.name != null) {
	            newMapping.name = mapping.name;
	          }
	        }
	
	        generator.addMapping(newMapping);
	      });
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          generator.setSourceContent(sourceFile, content);
	        }
	      });
	      return generator;
	    };
	
	  /**
	   * Add a single mapping from original source line and column to the generated
	   * source's line and column for this source map being created. The mapping
	   * object should have the following properties:
	   *
	   *   - generated: An object with the generated line and column positions.
	   *   - original: An object with the original line and column positions.
	   *   - source: The original source file (relative to the sourceRoot).
	   *   - name: An optional original token name for this mapping.
	   */
	  SourceMapGenerator.prototype.addMapping =
	    function SourceMapGenerator_addMapping(aArgs) {
	      var generated = util.getArg(aArgs, 'generated');
	      var original = util.getArg(aArgs, 'original', null);
	      var source = util.getArg(aArgs, 'source', null);
	      var name = util.getArg(aArgs, 'name', null);
	
	      if (!this._skipValidation) {
	        this._validateMapping(generated, original, source, name);
	      }
	
	      if (source != null && !this._sources.has(source)) {
	        this._sources.add(source);
	      }
	
	      if (name != null && !this._names.has(name)) {
	        this._names.add(name);
	      }
	
	      this._mappings.add({
	        generatedLine: generated.line,
	        generatedColumn: generated.column,
	        originalLine: original != null && original.line,
	        originalColumn: original != null && original.column,
	        source: source,
	        name: name
	      });
	    };
	
	  /**
	   * Set the source content for a source file.
	   */
	  SourceMapGenerator.prototype.setSourceContent =
	    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	      var source = aSourceFile;
	      if (this._sourceRoot != null) {
	        source = util.relative(this._sourceRoot, source);
	      }
	
	      if (aSourceContent != null) {
	        // Add the source content to the _sourcesContents map.
	        // Create a new _sourcesContents map if the property is null.
	        if (!this._sourcesContents) {
	          this._sourcesContents = {};
	        }
	        this._sourcesContents[util.toSetString(source)] = aSourceContent;
	      } else if (this._sourcesContents) {
	        // Remove the source file from the _sourcesContents map.
	        // If the _sourcesContents map is empty, set the property to null.
	        delete this._sourcesContents[util.toSetString(source)];
	        if (Object.keys(this._sourcesContents).length === 0) {
	          this._sourcesContents = null;
	        }
	      }
	    };
	
	  /**
	   * Applies the mappings of a sub-source-map for a specific source file to the
	   * source map being generated. Each mapping to the supplied source file is
	   * rewritten using the supplied source map. Note: The resolution for the
	   * resulting mappings is the minimium of this map and the supplied map.
	   *
	   * @param aSourceMapConsumer The source map to be applied.
	   * @param aSourceFile Optional. The filename of the source file.
	   *        If omitted, SourceMapConsumer's file property will be used.
	   * @param aSourceMapPath Optional. The dirname of the path to the source map
	   *        to be applied. If relative, it is relative to the SourceMapConsumer.
	   *        This parameter is needed when the two source maps aren't in the same
	   *        directory, and the source map to be applied contains relative source
	   *        paths. If so, those relative source paths need to be rewritten
	   *        relative to the SourceMapGenerator.
	   */
	  SourceMapGenerator.prototype.applySourceMap =
	    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	      var sourceFile = aSourceFile;
	      // If aSourceFile is omitted, we will use the file property of the SourceMap
	      if (aSourceFile == null) {
	        if (aSourceMapConsumer.file == null) {
	          throw new Error(
	            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	            'or the source map\'s "file" property. Both were omitted.'
	          );
	        }
	        sourceFile = aSourceMapConsumer.file;
	      }
	      var sourceRoot = this._sourceRoot;
	      // Make "sourceFile" relative if an absolute Url is passed.
	      if (sourceRoot != null) {
	        sourceFile = util.relative(sourceRoot, sourceFile);
	      }
	      // Applying the SourceMap can add and remove items from the sources and
	      // the names array.
	      var newSources = new ArraySet();
	      var newNames = new ArraySet();
	
	      // Find mappings for the "sourceFile"
	      this._mappings.unsortedForEach(function (mapping) {
	        if (mapping.source === sourceFile && mapping.originalLine != null) {
	          // Check if it can be mapped by the source map, then update the mapping.
	          var original = aSourceMapConsumer.originalPositionFor({
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          });
	          if (original.source != null) {
	            // Copy mapping
	            mapping.source = original.source;
	            if (aSourceMapPath != null) {
	              mapping.source = util.join(aSourceMapPath, mapping.source)
	            }
	            if (sourceRoot != null) {
	              mapping.source = util.relative(sourceRoot, mapping.source);
	            }
	            mapping.originalLine = original.line;
	            mapping.originalColumn = original.column;
	            if (original.name != null) {
	              mapping.name = original.name;
	            }
	          }
	        }
	
	        var source = mapping.source;
	        if (source != null && !newSources.has(source)) {
	          newSources.add(source);
	        }
	
	        var name = mapping.name;
	        if (name != null && !newNames.has(name)) {
	          newNames.add(name);
	        }
	
	      }, this);
	      this._sources = newSources;
	      this._names = newNames;
	
	      // Copy sourcesContents of applied map.
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          if (aSourceMapPath != null) {
	            sourceFile = util.join(aSourceMapPath, sourceFile);
	          }
	          if (sourceRoot != null) {
	            sourceFile = util.relative(sourceRoot, sourceFile);
	          }
	          this.setSourceContent(sourceFile, content);
	        }
	      }, this);
	    };
	
	  /**
	   * A mapping can have one of the three levels of data:
	   *
	   *   1. Just the generated position.
	   *   2. The Generated position, original position, and original source.
	   *   3. Generated and original position, original source, as well as a name
	   *      token.
	   *
	   * To maintain consistency, we validate that any new mapping being added falls
	   * in to one of these categories.
	   */
	  SourceMapGenerator.prototype._validateMapping =
	    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                                aName) {
	      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	          && aGenerated.line > 0 && aGenerated.column >= 0
	          && !aOriginal && !aSource && !aName) {
	        // Case 1.
	        return;
	      }
	      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	               && aGenerated.line > 0 && aGenerated.column >= 0
	               && aOriginal.line > 0 && aOriginal.column >= 0
	               && aSource) {
	        // Cases 2 and 3.
	        return;
	      }
	      else {
	        throw new Error('Invalid mapping: ' + JSON.stringify({
	          generated: aGenerated,
	          source: aSource,
	          original: aOriginal,
	          name: aName
	        }));
	      }
	    };
	
	  /**
	   * Serialize the accumulated mappings in to the stream of base 64 VLQs
	   * specified by the source map format.
	   */
	  SourceMapGenerator.prototype._serializeMappings =
	    function SourceMapGenerator_serializeMappings() {
	      var previousGeneratedColumn = 0;
	      var previousGeneratedLine = 1;
	      var previousOriginalColumn = 0;
	      var previousOriginalLine = 0;
	      var previousName = 0;
	      var previousSource = 0;
	      var result = '';
	      var mapping;
	
	      var mappings = this._mappings.toArray();
	      for (var i = 0, len = mappings.length; i < len; i++) {
	        mapping = mappings[i];
	
	        if (mapping.generatedLine !== previousGeneratedLine) {
	          previousGeneratedColumn = 0;
	          while (mapping.generatedLine !== previousGeneratedLine) {
	            result += ';';
	            previousGeneratedLine++;
	          }
	        }
	        else {
	          if (i > 0) {
	            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	              continue;
	            }
	            result += ',';
	          }
	        }
	
	        result += base64VLQ.encode(mapping.generatedColumn
	                                   - previousGeneratedColumn);
	        previousGeneratedColumn = mapping.generatedColumn;
	
	        if (mapping.source != null) {
	          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
	                                     - previousSource);
	          previousSource = this._sources.indexOf(mapping.source);
	
	          // lines are stored 0-based in SourceMap spec version 3
	          result += base64VLQ.encode(mapping.originalLine - 1
	                                     - previousOriginalLine);
	          previousOriginalLine = mapping.originalLine - 1;
	
	          result += base64VLQ.encode(mapping.originalColumn
	                                     - previousOriginalColumn);
	          previousOriginalColumn = mapping.originalColumn;
	
	          if (mapping.name != null) {
	            result += base64VLQ.encode(this._names.indexOf(mapping.name)
	                                       - previousName);
	            previousName = this._names.indexOf(mapping.name);
	          }
	        }
	      }
	
	      return result;
	    };
	
	  SourceMapGenerator.prototype._generateSourcesContent =
	    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	      return aSources.map(function (source) {
	        if (!this._sourcesContents) {
	          return null;
	        }
	        if (aSourceRoot != null) {
	          source = util.relative(aSourceRoot, source);
	        }
	        var key = util.toSetString(source);
	        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
	                                                    key)
	          ? this._sourcesContents[key]
	          : null;
	      }, this);
	    };
	
	  /**
	   * Externalize the source map.
	   */
	  SourceMapGenerator.prototype.toJSON =
	    function SourceMapGenerator_toJSON() {
	      var map = {
	        version: this._version,
	        sources: this._sources.toArray(),
	        names: this._names.toArray(),
	        mappings: this._serializeMappings()
	      };
	      if (this._file != null) {
	        map.file = this._file;
	      }
	      if (this._sourceRoot != null) {
	        map.sourceRoot = this._sourceRoot;
	      }
	      if (this._sourcesContents) {
	        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	      }
	
	      return map;
	    };
	
	  /**
	   * Render the source map being generated to a string.
	   */
	  SourceMapGenerator.prototype.toString =
	    function SourceMapGenerator_toString() {
	      return JSON.stringify(this.toJSON());
	    };
	
	  exports.SourceMapGenerator = SourceMapGenerator;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var base64 = __webpack_require__(196);
	
	  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
	  // length quantities we use in the source map spec, the first bit is the sign,
	  // the next four bits are the actual value, and the 6th bit is the
	  // continuation bit. The continuation bit tells us whether there are more
	  // digits in this value following this digit.
	  //
	  //   Continuation
	  //   |    Sign
	  //   |    |
	  //   V    V
	  //   101011
	
	  var VLQ_BASE_SHIFT = 5;
	
	  // binary: 100000
	  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	
	  // binary: 011111
	  var VLQ_BASE_MASK = VLQ_BASE - 1;
	
	  // binary: 100000
	  var VLQ_CONTINUATION_BIT = VLQ_BASE;
	
	  /**
	   * Converts from a two-complement value to a value where the sign bit is
	   * placed in the least significant bit.  For example, as decimals:
	   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	   */
	  function toVLQSigned(aValue) {
	    return aValue < 0
	      ? ((-aValue) << 1) + 1
	      : (aValue << 1) + 0;
	  }
	
	  /**
	   * Converts to a two-complement value from a value where the sign bit is
	   * placed in the least significant bit.  For example, as decimals:
	   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	   */
	  function fromVLQSigned(aValue) {
	    var isNegative = (aValue & 1) === 1;
	    var shifted = aValue >> 1;
	    return isNegative
	      ? -shifted
	      : shifted;
	  }
	
	  /**
	   * Returns the base 64 VLQ encoded value.
	   */
	  exports.encode = function base64VLQ_encode(aValue) {
	    var encoded = "";
	    var digit;
	
	    var vlq = toVLQSigned(aValue);
	
	    do {
	      digit = vlq & VLQ_BASE_MASK;
	      vlq >>>= VLQ_BASE_SHIFT;
	      if (vlq > 0) {
	        // There are still more digits in this value, so we must make sure the
	        // continuation bit is marked.
	        digit |= VLQ_CONTINUATION_BIT;
	      }
	      encoded += base64.encode(digit);
	    } while (vlq > 0);
	
	    return encoded;
	  };
	
	  /**
	   * Decodes the next base 64 VLQ value from the given string and returns the
	   * value and the rest of the string via the out parameter.
	   */
	  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	    var strLen = aStr.length;
	    var result = 0;
	    var shift = 0;
	    var continuation, digit;
	
	    do {
	      if (aIndex >= strLen) {
	        throw new Error("Expected more digits in base 64 VLQ value.");
	      }
	
	      digit = base64.decode(aStr.charCodeAt(aIndex++));
	      if (digit === -1) {
	        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	      }
	
	      continuation = !!(digit & VLQ_CONTINUATION_BIT);
	      digit &= VLQ_BASE_MASK;
	      result = result + (digit << shift);
	      shift += VLQ_BASE_SHIFT;
	    } while (continuation);
	
	    aOutParam.value = fromVLQSigned(result);
	    aOutParam.rest = aIndex;
	  };
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
	
	  /**
	   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	   */
	  exports.encode = function (number) {
	    if (0 <= number && number < intToCharMap.length) {
	      return intToCharMap[number];
	    }
	    throw new TypeError("Must be between 0 and 63: " + aNumber);
	  };
	
	  /**
	   * Decode a single base 64 character code digit to an integer. Returns -1 on
	   * failure.
	   */
	  exports.decode = function (charCode) {
	    var bigA = 65;     // 'A'
	    var bigZ = 90;     // 'Z'
	
	    var littleA = 97;  // 'a'
	    var littleZ = 122; // 'z'
	
	    var zero = 48;     // '0'
	    var nine = 57;     // '9'
	
	    var plus = 43;     // '+'
	    var slash = 47;    // '/'
	
	    var littleOffset = 26;
	    var numberOffset = 52;
	
	    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	    if (bigA <= charCode && charCode <= bigZ) {
	      return (charCode - bigA);
	    }
	
	    // 26 - 51: abcdefghijklmnopqrstuvwxyz
	    if (littleA <= charCode && charCode <= littleZ) {
	      return (charCode - littleA + littleOffset);
	    }
	
	    // 52 - 61: 0123456789
	    if (zero <= charCode && charCode <= nine) {
	      return (charCode - zero + numberOffset);
	    }
	
	    // 62: +
	    if (charCode == plus) {
	      return 62;
	    }
	
	    // 63: /
	    if (charCode == slash) {
	      return 63;
	    }
	
	    // Invalid base64 digit.
	    return -1;
	  };
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  /**
	   * This is a helper function for getting values from parameter/options
	   * objects.
	   *
	   * @param args The object we are extracting values from
	   * @param name The name of the property we are getting.
	   * @param defaultValue An optional value to return if the property is missing
	   * from the object. If this is not specified and the property is missing, an
	   * error will be thrown.
	   */
	  function getArg(aArgs, aName, aDefaultValue) {
	    if (aName in aArgs) {
	      return aArgs[aName];
	    } else if (arguments.length === 3) {
	      return aDefaultValue;
	    } else {
	      throw new Error('"' + aName + '" is a required argument.');
	    }
	  }
	  exports.getArg = getArg;
	
	  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	  var dataUrlRegexp = /^data:.+\,.+$/;
	
	  function urlParse(aUrl) {
	    var match = aUrl.match(urlRegexp);
	    if (!match) {
	      return null;
	    }
	    return {
	      scheme: match[1],
	      auth: match[2],
	      host: match[3],
	      port: match[4],
	      path: match[5]
	    };
	  }
	  exports.urlParse = urlParse;
	
	  function urlGenerate(aParsedUrl) {
	    var url = '';
	    if (aParsedUrl.scheme) {
	      url += aParsedUrl.scheme + ':';
	    }
	    url += '//';
	    if (aParsedUrl.auth) {
	      url += aParsedUrl.auth + '@';
	    }
	    if (aParsedUrl.host) {
	      url += aParsedUrl.host;
	    }
	    if (aParsedUrl.port) {
	      url += ":" + aParsedUrl.port
	    }
	    if (aParsedUrl.path) {
	      url += aParsedUrl.path;
	    }
	    return url;
	  }
	  exports.urlGenerate = urlGenerate;
	
	  /**
	   * Normalizes a path, or the path portion of a URL:
	   *
	   * - Replaces consequtive slashes with one slash.
	   * - Removes unnecessary '.' parts.
	   * - Removes unnecessary '<dir>/..' parts.
	   *
	   * Based on code in the Node.js 'path' core module.
	   *
	   * @param aPath The path or url to normalize.
	   */
	  function normalize(aPath) {
	    var path = aPath;
	    var url = urlParse(aPath);
	    if (url) {
	      if (!url.path) {
	        return aPath;
	      }
	      path = url.path;
	    }
	    var isAbsolute = (path.charAt(0) === '/');
	
	    var parts = path.split(/\/+/);
	    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	      part = parts[i];
	      if (part === '.') {
	        parts.splice(i, 1);
	      } else if (part === '..') {
	        up++;
	      } else if (up > 0) {
	        if (part === '') {
	          // The first part is blank if the path is absolute. Trying to go
	          // above the root is a no-op. Therefore we can remove all '..' parts
	          // directly after the root.
	          parts.splice(i + 1, up);
	          up = 0;
	        } else {
	          parts.splice(i, 2);
	          up--;
	        }
	      }
	    }
	    path = parts.join('/');
	
	    if (path === '') {
	      path = isAbsolute ? '/' : '.';
	    }
	
	    if (url) {
	      url.path = path;
	      return urlGenerate(url);
	    }
	    return path;
	  }
	  exports.normalize = normalize;
	
	  /**
	   * Joins two paths/URLs.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be joined with the root.
	   *
	   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	   *   first.
	   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	   *   is updated with the result and aRoot is returned. Otherwise the result
	   *   is returned.
	   *   - If aPath is absolute, the result is aPath.
	   *   - Otherwise the two paths are joined with a slash.
	   * - Joining for example 'http://' and 'www.example.com' is also supported.
	   */
	  function join(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }
	    if (aPath === "") {
	      aPath = ".";
	    }
	    var aPathUrl = urlParse(aPath);
	    var aRootUrl = urlParse(aRoot);
	    if (aRootUrl) {
	      aRoot = aRootUrl.path || '/';
	    }
	
	    // `join(foo, '//www.example.org')`
	    if (aPathUrl && !aPathUrl.scheme) {
	      if (aRootUrl) {
	        aPathUrl.scheme = aRootUrl.scheme;
	      }
	      return urlGenerate(aPathUrl);
	    }
	
	    if (aPathUrl || aPath.match(dataUrlRegexp)) {
	      return aPath;
	    }
	
	    // `join('http://', 'www.example.com')`
	    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	      aRootUrl.host = aPath;
	      return urlGenerate(aRootUrl);
	    }
	
	    var joined = aPath.charAt(0) === '/'
	      ? aPath
	      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
	
	    if (aRootUrl) {
	      aRootUrl.path = joined;
	      return urlGenerate(aRootUrl);
	    }
	    return joined;
	  }
	  exports.join = join;
	
	  /**
	   * Make a path relative to a URL or another path.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be made relative to aRoot.
	   */
	  function relative(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }
	
	    aRoot = aRoot.replace(/\/$/, '');
	
	    // It is possible for the path to be above the root. In this case, simply
	    // checking whether the root is a prefix of the path won't work. Instead, we
	    // need to remove components from the root one by one, until either we find
	    // a prefix that fits, or we run out of components to remove.
	    var level = 0;
	    while (aPath.indexOf(aRoot + '/') !== 0) {
	      var index = aRoot.lastIndexOf("/");
	      if (index < 0) {
	        return aPath;
	      }
	
	      // If the only part of the root that is left is the scheme (i.e. http://,
	      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	      // have exhausted all components, so the path is not relative to the root.
	      aRoot = aRoot.slice(0, index);
	      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	        return aPath;
	      }
	
	      ++level;
	    }
	
	    // Make sure we add a "../" for each component we removed from the root.
	    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	  }
	  exports.relative = relative;
	
	  /**
	   * Because behavior goes wacky when you set `__proto__` on objects, we
	   * have to prefix all the strings in our set with an arbitrary character.
	   *
	   * See https://github.com/mozilla/source-map/pull/31 and
	   * https://github.com/mozilla/source-map/issues/30
	   *
	   * @param String aStr
	   */
	  function toSetString(aStr) {
	    return '$' + aStr;
	  }
	  exports.toSetString = toSetString;
	
	  function fromSetString(aStr) {
	    return aStr.substr(1);
	  }
	  exports.fromSetString = fromSetString;
	
	  /**
	   * Comparator between two mappings where the original positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same original source/line/column, but different generated
	   * line and column the same. Useful when searching for a mapping with a
	   * stubbed out mapping.
	   */
	  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	    var cmp = mappingA.source - mappingB.source;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0 || onlyCompareOriginal) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return mappingA.name - mappingB.name;
	  };
	  exports.compareByOriginalPositions = compareByOriginalPositions;
	
	  /**
	   * Comparator between two mappings with deflated source and name indices where
	   * the generated positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same generated line and column, but different
	   * source/name/original line and column the same. Useful when searching for a
	   * mapping with a stubbed out mapping.
	   */
	  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0 || onlyCompareGenerated) {
	      return cmp;
	    }
	
	    cmp = mappingA.source - mappingB.source;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return mappingA.name - mappingB.name;
	  };
	  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	
	  function strcmp(aStr1, aStr2) {
	    if (aStr1 === aStr2) {
	      return 0;
	    }
	
	    if (aStr1 > aStr2) {
	      return 1;
	    }
	
	    return -1;
	  }
	
	  /**
	   * Comparator between two mappings with inflated source and name strings where
	   * the generated positions are compared.
	   */
	  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = strcmp(mappingA.source, mappingB.source);
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return strcmp(mappingA.name, mappingB.name);
	  };
	  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var util = __webpack_require__(197);
	
	  /**
	   * A data structure which is a combination of an array and a set. Adding a new
	   * member is O(1), testing for membership is O(1), and finding the index of an
	   * element is O(1). Removing elements from the set is not supported. Only
	   * strings are supported for membership.
	   */
	  function ArraySet() {
	    this._array = [];
	    this._set = {};
	  }
	
	  /**
	   * Static method for creating ArraySet instances from an existing array.
	   */
	  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	    var set = new ArraySet();
	    for (var i = 0, len = aArray.length; i < len; i++) {
	      set.add(aArray[i], aAllowDuplicates);
	    }
	    return set;
	  };
	
	  /**
	   * Return how many unique items are in this ArraySet. If duplicates have been
	   * added, than those do not count towards the size.
	   *
	   * @returns Number
	   */
	  ArraySet.prototype.size = function ArraySet_size() {
	    return Object.getOwnPropertyNames(this._set).length;
	  };
	
	  /**
	   * Add the given string to this set.
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	    var isDuplicate = this.has(aStr);
	    var idx = this._array.length;
	    if (!isDuplicate || aAllowDuplicates) {
	      this._array.push(aStr);
	    }
	    if (!isDuplicate) {
	      this._set[util.toSetString(aStr)] = idx;
	    }
	  };
	
	  /**
	   * Is the given string a member of this set?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.has = function ArraySet_has(aStr) {
	    return Object.prototype.hasOwnProperty.call(this._set,
	                                                util.toSetString(aStr));
	  };
	
	  /**
	   * What is the index of the given string in the array?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	    if (this.has(aStr)) {
	      return this._set[util.toSetString(aStr)];
	    }
	    throw new Error('"' + aStr + '" is not in the set.');
	  };
	
	  /**
	   * What is the element at the given index?
	   *
	   * @param Number aIdx
	   */
	  ArraySet.prototype.at = function ArraySet_at(aIdx) {
	    if (aIdx >= 0 && aIdx < this._array.length) {
	      return this._array[aIdx];
	    }
	    throw new Error('No element indexed by ' + aIdx);
	  };
	
	  /**
	   * Returns the array representation of this set (which has the proper indices
	   * indicated by indexOf). Note that this is a copy of the internal array used
	   * for storing the members so that no one can mess with internal state.
	   */
	  ArraySet.prototype.toArray = function ArraySet_toArray() {
	    return this._array.slice();
	  };
	
	  exports.ArraySet = ArraySet;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var util = __webpack_require__(197);
	
	  /**
	   * Determine whether mappingB is after mappingA with respect to generated
	   * position.
	   */
	  function generatedPositionAfter(mappingA, mappingB) {
	    // Optimized for most common case
	    var lineA = mappingA.generatedLine;
	    var lineB = mappingB.generatedLine;
	    var columnA = mappingA.generatedColumn;
	    var columnB = mappingB.generatedColumn;
	    return lineB > lineA || lineB == lineA && columnB >= columnA ||
	           util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	  }
	
	  /**
	   * A data structure to provide a sorted view of accumulated mappings in a
	   * performance conscious manner. It trades a neglibable overhead in general
	   * case for a large speedup in case of mappings being added in order.
	   */
	  function MappingList() {
	    this._array = [];
	    this._sorted = true;
	    // Serves as infimum
	    this._last = {generatedLine: -1, generatedColumn: 0};
	  }
	
	  /**
	   * Iterate through internal items. This method takes the same arguments that
	   * `Array.prototype.forEach` takes.
	   *
	   * NOTE: The order of the mappings is NOT guaranteed.
	   */
	  MappingList.prototype.unsortedForEach =
	    function MappingList_forEach(aCallback, aThisArg) {
	      this._array.forEach(aCallback, aThisArg);
	    };
	
	  /**
	   * Add the given source mapping.
	   *
	   * @param Object aMapping
	   */
	  MappingList.prototype.add = function MappingList_add(aMapping) {
	    var mapping;
	    if (generatedPositionAfter(this._last, aMapping)) {
	      this._last = aMapping;
	      this._array.push(aMapping);
	    } else {
	      this._sorted = false;
	      this._array.push(aMapping);
	    }
	  };
	
	  /**
	   * Returns the flat, sorted array of mappings. The mappings are sorted by
	   * generated position.
	   *
	   * WARNING: This method returns internal data without copying, for
	   * performance. The return value must NOT be mutated, and should be treated as
	   * an immutable borrow. If you want to take ownership, you must make your own
	   * copy.
	   */
	  MappingList.prototype.toArray = function MappingList_toArray() {
	    if (!this._sorted) {
	      this._array.sort(util.compareByGeneratedPositionsInflated);
	      this._sorted = true;
	    }
	    return this._array;
	  };
	
	  exports.MappingList = MappingList;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var util = __webpack_require__(197);
	  var binarySearch = __webpack_require__(201);
	  var ArraySet = __webpack_require__(198).ArraySet;
	  var base64VLQ = __webpack_require__(195);
	  var quickSort = __webpack_require__(202).quickSort;
	
	  function SourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    return sourceMap.sections != null
	      ? new IndexedSourceMapConsumer(sourceMap)
	      : new BasicSourceMapConsumer(sourceMap);
	  }
	
	  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
	    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	  }
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  SourceMapConsumer.prototype._version = 3;
	
	  // `__generatedMappings` and `__originalMappings` are arrays that hold the
	  // parsed mapping coordinates from the source map's "mappings" attribute. They
	  // are lazily instantiated, accessed via the `_generatedMappings` and
	  // `_originalMappings` getters respectively, and we only parse the mappings
	  // and create these arrays once queried for a source location. We jump through
	  // these hoops because there can be many thousands of mappings, and parsing
	  // them is expensive, so we only want to do it if we must.
	  //
	  // Each object in the arrays is of the form:
	  //
	  //     {
	  //       generatedLine: The line number in the generated code,
	  //       generatedColumn: The column number in the generated code,
	  //       source: The path to the original source file that generated this
	  //               chunk of code,
	  //       originalLine: The line number in the original source that
	  //                     corresponds to this chunk of generated code,
	  //       originalColumn: The column number in the original source that
	  //                       corresponds to this chunk of generated code,
	  //       name: The name of the original symbol which generated this chunk of
	  //             code.
	  //     }
	  //
	  // All properties except for `generatedLine` and `generatedColumn` can be
	  // `null`.
	  //
	  // `_generatedMappings` is ordered by the generated positions.
	  //
	  // `_originalMappings` is ordered by the original positions.
	
	  SourceMapConsumer.prototype.__generatedMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	    get: function () {
	      if (!this.__generatedMappings) {
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	
	      return this.__generatedMappings;
	    }
	  });
	
	  SourceMapConsumer.prototype.__originalMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	    get: function () {
	      if (!this.__originalMappings) {
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	
	      return this.__originalMappings;
	    }
	  });
	
	  SourceMapConsumer.prototype._charIsMappingSeparator =
	    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	      var c = aStr.charAt(index);
	      return c === ";" || c === ",";
	    };
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  SourceMapConsumer.prototype._parseMappings =
	    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      throw new Error("Subclasses must implement _parseMappings");
	    };
	
	  SourceMapConsumer.GENERATED_ORDER = 1;
	  SourceMapConsumer.ORIGINAL_ORDER = 2;
	
	  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
	
	  /**
	   * Iterate over each mapping between an original source/line/column and a
	   * generated line/column in this source map.
	   *
	   * @param Function aCallback
	   *        The function that is called with each mapping.
	   * @param Object aContext
	   *        Optional. If specified, this object will be the value of `this` every
	   *        time that `aCallback` is called.
	   * @param aOrder
	   *        Either `SourceMapConsumer.GENERATED_ORDER` or
	   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	   *        iterate over the mappings sorted by the generated file's line/column
	   *        order or the original's source/line/column order, respectively. Defaults to
	   *        `SourceMapConsumer.GENERATED_ORDER`.
	   */
	  SourceMapConsumer.prototype.eachMapping =
	    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	      var context = aContext || null;
	      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
	
	      var mappings;
	      switch (order) {
	      case SourceMapConsumer.GENERATED_ORDER:
	        mappings = this._generatedMappings;
	        break;
	      case SourceMapConsumer.ORIGINAL_ORDER:
	        mappings = this._originalMappings;
	        break;
	      default:
	        throw new Error("Unknown order of iteration.");
	      }
	
	      var sourceRoot = this.sourceRoot;
	      mappings.map(function (mapping) {
	        var source = mapping.source === null ? null : this._sources.at(mapping.source);
	        if (source != null && sourceRoot != null) {
	          source = util.join(sourceRoot, source);
	        }
	        return {
	          source: source,
	          generatedLine: mapping.generatedLine,
	          generatedColumn: mapping.generatedColumn,
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: mapping.name === null ? null : this._names.at(mapping.name)
	        };
	      }, this).forEach(aCallback, context);
	    };
	
	  /**
	   * Returns all generated line and column information for the original source,
	   * line, and column provided. If no column is provided, returns all mappings
	   * corresponding to a either the line we are searching for or the next
	   * closest line that has any mappings. Otherwise, returns all mappings
	   * corresponding to the given line and either the column we are searching for
	   * or the next closest column that has any offsets.
	   *
	   * The only argument is an object with the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: Optional. the column number in the original source.
	   *
	   * and an array of objects is returned, each with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  SourceMapConsumer.prototype.allGeneratedPositionsFor =
	    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	      var line = util.getArg(aArgs, 'line');
	
	      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	      // returns the index of the closest mapping less than the needle. By
	      // setting needle.originalColumn to 0, we thus find the last mapping for
	      // the given line, provided such a mapping exists.
	      var needle = {
	        source: util.getArg(aArgs, 'source'),
	        originalLine: line,
	        originalColumn: util.getArg(aArgs, 'column', 0)
	      };
	
	      if (this.sourceRoot != null) {
	        needle.source = util.relative(this.sourceRoot, needle.source);
	      }
	      if (!this._sources.has(needle.source)) {
	        return [];
	      }
	      needle.source = this._sources.indexOf(needle.source);
	
	      var mappings = [];
	
	      var index = this._findMapping(needle,
	                                    this._originalMappings,
	                                    "originalLine",
	                                    "originalColumn",
	                                    util.compareByOriginalPositions,
	                                    binarySearch.LEAST_UPPER_BOUND);
	      if (index >= 0) {
	        var mapping = this._originalMappings[index];
	
	        if (aArgs.column === undefined) {
	          var originalLine = mapping.originalLine;
	
	          // Iterate until either we run out of mappings, or we run into
	          // a mapping for a different line than the one we found. Since
	          // mappings are sorted, this is guaranteed to find all mappings for
	          // the line we found.
	          while (mapping && mapping.originalLine === originalLine) {
	            mappings.push({
	              line: util.getArg(mapping, 'generatedLine', null),
	              column: util.getArg(mapping, 'generatedColumn', null),
	              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	            });
	
	            mapping = this._originalMappings[++index];
	          }
	        } else {
	          var originalColumn = mapping.originalColumn;
	
	          // Iterate until either we run out of mappings, or we run into
	          // a mapping for a different line than the one we were searching for.
	          // Since mappings are sorted, this is guaranteed to find all mappings for
	          // the line we are searching for.
	          while (mapping &&
	                 mapping.originalLine === line &&
	                 mapping.originalColumn == originalColumn) {
	            mappings.push({
	              line: util.getArg(mapping, 'generatedLine', null),
	              column: util.getArg(mapping, 'generatedColumn', null),
	              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	            });
	
	            mapping = this._originalMappings[++index];
	          }
	        }
	      }
	
	      return mappings;
	    };
	
	  exports.SourceMapConsumer = SourceMapConsumer;
	
	  /**
	   * A BasicSourceMapConsumer instance represents a parsed source map which we can
	   * query for information about the original file positions by giving it a file
	   * position in the generated source.
	   *
	   * The only parameter is the raw source map (either as a JSON string, or
	   * already parsed to an object). According to the spec, source maps have the
	   * following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - sources: An array of URLs to the original source files.
	   *   - names: An array of identifiers which can be referrenced by individual mappings.
	   *   - sourceRoot: Optional. The URL root from which all sources are relative.
	   *   - sourcesContent: Optional. An array of contents of the original source files.
	   *   - mappings: A string of base64 VLQs which contain the actual mappings.
	   *   - file: Optional. The generated file this source map is associated with.
	   *
	   * Here is an example source map, taken from the source map spec[0]:
	   *
	   *     {
	   *       version : 3,
	   *       file: "out.js",
	   *       sourceRoot : "",
	   *       sources: ["foo.js", "bar.js"],
	   *       names: ["src", "maps", "are", "fun"],
	   *       mappings: "AA,AB;;ABCDE;"
	   *     }
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	   */
	  function BasicSourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    var version = util.getArg(sourceMap, 'version');
	    var sources = util.getArg(sourceMap, 'sources');
	    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	    // requires the array) to play nice here.
	    var names = util.getArg(sourceMap, 'names', []);
	    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	    var mappings = util.getArg(sourceMap, 'mappings');
	    var file = util.getArg(sourceMap, 'file', null);
	
	    // Once again, Sass deviates from the spec and supplies the version as a
	    // string rather than a number, so we use loose equality checking here.
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    sources = sources.map(util.normalize);
	
	    // Pass `true` below to allow duplicate names and sources. While source maps
	    // are intended to be compressed and deduplicated, the TypeScript compiler
	    // sometimes generates source maps with duplicates in them. See Github issue
	    // #72 and bugzil.la/889492.
	    this._names = ArraySet.fromArray(names, true);
	    this._sources = ArraySet.fromArray(sources, true);
	
	    this.sourceRoot = sourceRoot;
	    this.sourcesContent = sourcesContent;
	    this._mappings = mappings;
	    this.file = file;
	  }
	
	  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
	
	  /**
	   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	   *
	   * @param SourceMapGenerator aSourceMap
	   *        The source map that will be consumed.
	   * @returns BasicSourceMapConsumer
	   */
	  BasicSourceMapConsumer.fromSourceMap =
	    function SourceMapConsumer_fromSourceMap(aSourceMap) {
	      var smc = Object.create(BasicSourceMapConsumer.prototype);
	
	      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	      smc.sourceRoot = aSourceMap._sourceRoot;
	      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                              smc.sourceRoot);
	      smc.file = aSourceMap._file;
	
	      // Because we are modifying the entries (by converting string sources and
	      // names to indices into the sources and names ArraySets), we have to make
	      // a copy of the entry or else bad things happen. Shared mutable state
	      // strikes again! See github issue #191.
	
	      var generatedMappings = aSourceMap._mappings.toArray().slice();
	      var destGeneratedMappings = smc.__generatedMappings = [];
	      var destOriginalMappings = smc.__originalMappings = [];
	
	      for (var i = 0, length = generatedMappings.length; i < length; i++) {
	        var srcMapping = generatedMappings[i];
	        var destMapping = new Mapping;
	        destMapping.generatedLine = srcMapping.generatedLine;
	        destMapping.generatedColumn = srcMapping.generatedColumn;
	
	        if (srcMapping.source) {
	          destMapping.source = sources.indexOf(srcMapping.source);
	          destMapping.originalLine = srcMapping.originalLine;
	          destMapping.originalColumn = srcMapping.originalColumn;
	
	          if (srcMapping.name) {
	            destMapping.name = names.indexOf(srcMapping.name);
	          }
	
	          destOriginalMappings.push(destMapping);
	        }
	
	        destGeneratedMappings.push(destMapping);
	      }
	
	      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
	
	      return smc;
	    };
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  BasicSourceMapConsumer.prototype._version = 3;
	
	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      return this._sources.toArray().map(function (s) {
	        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
	      }, this);
	    }
	  });
	
	  /**
	   * Provide the JIT with a nice shape / hidden class.
	   */
	  function Mapping() {
	    this.generatedLine = 0;
	    this.generatedColumn = 0;
	    this.source = null;
	    this.originalLine = null;
	    this.originalColumn = null;
	    this.name = null;
	  }
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  BasicSourceMapConsumer.prototype._parseMappings =
	    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      var generatedLine = 1;
	      var previousGeneratedColumn = 0;
	      var previousOriginalLine = 0;
	      var previousOriginalColumn = 0;
	      var previousSource = 0;
	      var previousName = 0;
	      var length = aStr.length;
	      var index = 0;
	      var cachedSegments = {};
	      var temp = {};
	      var originalMappings = [];
	      var generatedMappings = [];
	      var mapping, str, segment, end, value;
	
	      while (index < length) {
	        if (aStr.charAt(index) === ';') {
	          generatedLine++;
	          index++;
	          previousGeneratedColumn = 0;
	        }
	        else if (aStr.charAt(index) === ',') {
	          index++;
	        }
	        else {
	          mapping = new Mapping();
	          mapping.generatedLine = generatedLine;
	
	          // Because each offset is encoded relative to the previous one,
	          // many segments often have the same encoding. We can exploit this
	          // fact by caching the parsed variable length fields of each segment,
	          // allowing us to avoid a second parse if we encounter the same
	          // segment again.
	          for (end = index; end < length; end++) {
	            if (this._charIsMappingSeparator(aStr, end)) {
	              break;
	            }
	          }
	          str = aStr.slice(index, end);
	
	          segment = cachedSegments[str];
	          if (segment) {
	            index += str.length;
	          } else {
	            segment = [];
	            while (index < end) {
	              base64VLQ.decode(aStr, index, temp);
	              value = temp.value;
	              index = temp.rest;
	              segment.push(value);
	            }
	
	            if (segment.length === 2) {
	              throw new Error('Found a source, but no line and column');
	            }
	
	            if (segment.length === 3) {
	              throw new Error('Found a source and line, but no column');
	            }
	
	            cachedSegments[str] = segment;
	          }
	
	          // Generated column.
	          mapping.generatedColumn = previousGeneratedColumn + segment[0];
	          previousGeneratedColumn = mapping.generatedColumn;
	
	          if (segment.length > 1) {
	            // Original source.
	            mapping.source = previousSource + segment[1];
	            previousSource += segment[1];
	
	            // Original line.
	            mapping.originalLine = previousOriginalLine + segment[2];
	            previousOriginalLine = mapping.originalLine;
	            // Lines are stored 0-based
	            mapping.originalLine += 1;
	
	            // Original column.
	            mapping.originalColumn = previousOriginalColumn + segment[3];
	            previousOriginalColumn = mapping.originalColumn;
	
	            if (segment.length > 4) {
	              // Original name.
	              mapping.name = previousName + segment[4];
	              previousName += segment[4];
	            }
	          }
	
	          generatedMappings.push(mapping);
	          if (typeof mapping.originalLine === 'number') {
	            originalMappings.push(mapping);
	          }
	        }
	      }
	
	      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	      this.__generatedMappings = generatedMappings;
	
	      quickSort(originalMappings, util.compareByOriginalPositions);
	      this.__originalMappings = originalMappings;
	    };
	
	  /**
	   * Find the mapping that best matches the hypothetical "needle" mapping that
	   * we are searching for in the given "haystack" of mappings.
	   */
	  BasicSourceMapConsumer.prototype._findMapping =
	    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                           aColumnName, aComparator, aBias) {
	      // To return the position we are searching for, we must first find the
	      // mapping for the given position and then return the opposite position it
	      // points to. Because the mappings are sorted, we can use binary search to
	      // find the best mapping.
	
	      if (aNeedle[aLineName] <= 0) {
	        throw new TypeError('Line must be greater than or equal to 1, got '
	                            + aNeedle[aLineName]);
	      }
	      if (aNeedle[aColumnName] < 0) {
	        throw new TypeError('Column must be greater than or equal to 0, got '
	                            + aNeedle[aColumnName]);
	      }
	
	      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	    };
	
	  /**
	   * Compute the last column for each generated mapping. The last column is
	   * inclusive.
	   */
	  BasicSourceMapConsumer.prototype.computeColumnSpans =
	    function SourceMapConsumer_computeColumnSpans() {
	      for (var index = 0; index < this._generatedMappings.length; ++index) {
	        var mapping = this._generatedMappings[index];
	
	        // Mappings do not contain a field for the last generated columnt. We
	        // can come up with an optimistic estimate, however, by assuming that
	        // mappings are contiguous (i.e. given two consecutive mappings, the
	        // first mapping ends where the second one starts).
	        if (index + 1 < this._generatedMappings.length) {
	          var nextMapping = this._generatedMappings[index + 1];
	
	          if (mapping.generatedLine === nextMapping.generatedLine) {
	            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	            continue;
	          }
	        }
	
	        // The last mapping for each line spans the entire line.
	        mapping.lastGeneratedColumn = Infinity;
	      }
	    };
	
	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.
	   *   - column: The column number in the generated source.
	   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.
	   *   - column: The column number in the original source, or null.
	   *   - name: The original identifier, or null.
	   */
	  BasicSourceMapConsumer.prototype.originalPositionFor =
	    function SourceMapConsumer_originalPositionFor(aArgs) {
	      var needle = {
	        generatedLine: util.getArg(aArgs, 'line'),
	        generatedColumn: util.getArg(aArgs, 'column')
	      };
	
	      var index = this._findMapping(
	        needle,
	        this._generatedMappings,
	        "generatedLine",
	        "generatedColumn",
	        util.compareByGeneratedPositionsDeflated,
	        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	      );
	
	      if (index >= 0) {
	        var mapping = this._generatedMappings[index];
	
	        if (mapping.generatedLine === needle.generatedLine) {
	          var source = util.getArg(mapping, 'source', null);
	          if (source !== null) {
	            source = this._sources.at(source);
	            if (this.sourceRoot != null) {
	              source = util.join(this.sourceRoot, source);
	            }
	          }
	          var name = util.getArg(mapping, 'name', null);
	          if (name !== null) {
	            name = this._names.at(name);
	          }
	          return {
	            source: source,
	            line: util.getArg(mapping, 'originalLine', null),
	            column: util.getArg(mapping, 'originalColumn', null),
	            name: name
	          };
	        }
	      }
	
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    };
	
	  /**
	   * Return true if we have the source content for every source in the source
	   * map, false otherwise.
	   */
	  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	    function BasicSourceMapConsumer_hasContentsOfAllSources() {
	      if (!this.sourcesContent) {
	        return false;
	      }
	      return this.sourcesContent.length >= this._sources.size() &&
	        !this.sourcesContent.some(function (sc) { return sc == null; });
	    };
	
	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * availible.
	   */
	  BasicSourceMapConsumer.prototype.sourceContentFor =
	    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	      if (!this.sourcesContent) {
	        return null;
	      }
	
	      if (this.sourceRoot != null) {
	        aSource = util.relative(this.sourceRoot, aSource);
	      }
	
	      if (this._sources.has(aSource)) {
	        return this.sourcesContent[this._sources.indexOf(aSource)];
	      }
	
	      var url;
	      if (this.sourceRoot != null
	          && (url = util.urlParse(this.sourceRoot))) {
	        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	        // many users. We can help them out when they expect file:// URIs to
	        // behave like it would if they were running a local HTTP server. See
	        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	        if (url.scheme == "file"
	            && this._sources.has(fileUriAbsPath)) {
	          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	        }
	
	        if ((!url.path || url.path == "/")
	            && this._sources.has("/" + aSource)) {
	          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	        }
	      }
	
	      // This function is used recursively from
	      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	      // don't want to throw if we can't find the source - we just want to
	      // return null, so we provide a flag to exit gracefully.
	      if (nullOnMissing) {
	        return null;
	      }
	      else {
	        throw new Error('"' + aSource + '" is not in the SourceMap.');
	      }
	    };
	
	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: The column number in the original source.
	   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  BasicSourceMapConsumer.prototype.generatedPositionFor =
	    function SourceMapConsumer_generatedPositionFor(aArgs) {
	      var source = util.getArg(aArgs, 'source');
	      if (this.sourceRoot != null) {
	        source = util.relative(this.sourceRoot, source);
	      }
	      if (!this._sources.has(source)) {
	        return {
	          line: null,
	          column: null,
	          lastColumn: null
	        };
	      }
	      source = this._sources.indexOf(source);
	
	      var needle = {
	        source: source,
	        originalLine: util.getArg(aArgs, 'line'),
	        originalColumn: util.getArg(aArgs, 'column')
	      };
	
	      var index = this._findMapping(
	        needle,
	        this._originalMappings,
	        "originalLine",
	        "originalColumn",
	        util.compareByOriginalPositions,
	        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	      );
	
	      if (index >= 0) {
	        var mapping = this._originalMappings[index];
	
	        if (mapping.source === needle.source) {
	          return {
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          };
	        }
	      }
	
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    };
	
	  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	
	  /**
	   * An IndexedSourceMapConsumer instance represents a parsed source map which
	   * we can query for information. It differs from BasicSourceMapConsumer in
	   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	   * input.
	   *
	   * The only parameter is a raw source map (either as a JSON string, or already
	   * parsed to an object). According to the spec for indexed source maps, they
	   * have the following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - file: Optional. The generated file this source map is associated with.
	   *   - sections: A list of section definitions.
	   *
	   * Each value under the "sections" field has two fields:
	   *   - offset: The offset into the original specified at which this section
	   *       begins to apply, defined as an object with a "line" and "column"
	   *       field.
	   *   - map: A source map definition. This source map could also be indexed,
	   *       but doesn't have to be.
	   *
	   * Instead of the "map" field, it's also possible to have a "url" field
	   * specifying a URL to retrieve a source map from, but that's currently
	   * unsupported.
	   *
	   * Here's an example source map, taken from the source map spec[0], but
	   * modified to omit a section which uses the "url" field.
	   *
	   *  {
	   *    version : 3,
	   *    file: "app.js",
	   *    sections: [{
	   *      offset: {line:100, column:10},
	   *      map: {
	   *        version : 3,
	   *        file: "section.js",
	   *        sources: ["foo.js", "bar.js"],
	   *        names: ["src", "maps", "are", "fun"],
	   *        mappings: "AAAA,E;;ABCDE;"
	   *      }
	   *    }],
	   *  }
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	   */
	  function IndexedSourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    var version = util.getArg(sourceMap, 'version');
	    var sections = util.getArg(sourceMap, 'sections');
	
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	
	    var lastOffset = {
	      line: -1,
	      column: 0
	    };
	    this._sections = sections.map(function (s) {
	      if (s.url) {
	        // The url field will require support for asynchronicity.
	        // See https://github.com/mozilla/source-map/issues/16
	        throw new Error('Support for url field in sections not implemented.');
	      }
	      var offset = util.getArg(s, 'offset');
	      var offsetLine = util.getArg(offset, 'line');
	      var offsetColumn = util.getArg(offset, 'column');
	
	      if (offsetLine < lastOffset.line ||
	          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	        throw new Error('Section offsets must be ordered and non-overlapping.');
	      }
	      lastOffset = offset;
	
	      return {
	        generatedOffset: {
	          // The offset fields are 0-based, but we use 1-based indices when
	          // encoding/decoding from VLQ.
	          generatedLine: offsetLine + 1,
	          generatedColumn: offsetColumn + 1
	        },
	        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
	      }
	    });
	  }
	
	  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  IndexedSourceMapConsumer.prototype._version = 3;
	
	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      var sources = [];
	      for (var i = 0; i < this._sections.length; i++) {
	        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	          sources.push(this._sections[i].consumer.sources[j]);
	        }
	      };
	      return sources;
	    }
	  });
	
	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.
	   *   - column: The column number in the generated source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.
	   *   - column: The column number in the original source, or null.
	   *   - name: The original identifier, or null.
	   */
	  IndexedSourceMapConsumer.prototype.originalPositionFor =
	    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	      var needle = {
	        generatedLine: util.getArg(aArgs, 'line'),
	        generatedColumn: util.getArg(aArgs, 'column')
	      };
	
	      // Find the section containing the generated position we're trying to map
	      // to an original position.
	      var sectionIndex = binarySearch.search(needle, this._sections,
	        function(needle, section) {
	          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	          if (cmp) {
	            return cmp;
	          }
	
	          return (needle.generatedColumn -
	                  section.generatedOffset.generatedColumn);
	        });
	      var section = this._sections[sectionIndex];
	
	      if (!section) {
	        return {
	          source: null,
	          line: null,
	          column: null,
	          name: null
	        };
	      }
	
	      return section.consumer.originalPositionFor({
	        line: needle.generatedLine -
	          (section.generatedOffset.generatedLine - 1),
	        column: needle.generatedColumn -
	          (section.generatedOffset.generatedLine === needle.generatedLine
	           ? section.generatedOffset.generatedColumn - 1
	           : 0),
	        bias: aArgs.bias
	      });
	    };
	
	  /**
	   * Return true if we have the source content for every source in the source
	   * map, false otherwise.
	   */
	  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	      return this._sections.every(function (s) {
	        return s.consumer.hasContentsOfAllSources();
	      });
	    };
	
	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * available.
	   */
	  IndexedSourceMapConsumer.prototype.sourceContentFor =
	    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	
	        var content = section.consumer.sourceContentFor(aSource, true);
	        if (content) {
	          return content;
	        }
	      }
	      if (nullOnMissing) {
	        return null;
	      }
	      else {
	        throw new Error('"' + aSource + '" is not in the SourceMap.');
	      }
	    };
	
	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: The column number in the original source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  IndexedSourceMapConsumer.prototype.generatedPositionFor =
	    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	
	        // Only consider this section if the requested source is in the list of
	        // sources of the consumer.
	        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
	          continue;
	        }
	        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	        if (generatedPosition) {
	          var ret = {
	            line: generatedPosition.line +
	              (section.generatedOffset.generatedLine - 1),
	            column: generatedPosition.column +
	              (section.generatedOffset.generatedLine === generatedPosition.line
	               ? section.generatedOffset.generatedColumn - 1
	               : 0)
	          };
	          return ret;
	        }
	      }
	
	      return {
	        line: null,
	        column: null
	      };
	    };
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  IndexedSourceMapConsumer.prototype._parseMappings =
	    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      this.__generatedMappings = [];
	      this.__originalMappings = [];
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	        var sectionMappings = section.consumer._generatedMappings;
	        for (var j = 0; j < sectionMappings.length; j++) {
	          var mapping = sectionMappings[i];
	
	          var source = section.consumer._sources.at(mapping.source);
	          if (section.consumer.sourceRoot !== null) {
	            source = util.join(section.consumer.sourceRoot, source);
	          }
	          this._sources.add(source);
	          source = this._sources.indexOf(source);
	
	          var name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	
	          // The mappings coming from the consumer for the section have
	          // generated positions relative to the start of the section, so we
	          // need to offset them to be relative to the start of the concatenated
	          // generated file.
	          var adjustedMapping = {
	            source: source,
	            generatedLine: mapping.generatedLine +
	              (section.generatedOffset.generatedLine - 1),
	            generatedColumn: mapping.column +
	              (section.generatedOffset.generatedLine === mapping.generatedLine)
	              ? section.generatedOffset.generatedColumn - 1
	              : 0,
	            originalLine: mapping.originalLine,
	            originalColumn: mapping.originalColumn,
	            name: name
	          };
	
	          this.__generatedMappings.push(adjustedMapping);
	          if (typeof adjustedMapping.originalLine === 'number') {
	            this.__originalMappings.push(adjustedMapping);
	          }
	        };
	      };
	
	      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	      quickSort(this.__originalMappings, util.compareByOriginalPositions);
	    };
	
	  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  exports.GREATEST_LOWER_BOUND = 1;
	  exports.LEAST_UPPER_BOUND = 2;
	
	  /**
	   * Recursive implementation of binary search.
	   *
	   * @param aLow Indices here and lower do not contain the needle.
	   * @param aHigh Indices here and higher do not contain the needle.
	   * @param aNeedle The element being searched for.
	   * @param aHaystack The non-empty array being searched.
	   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   */
	  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	    // This function terminates when one of the following is true:
	    //
	    //   1. We find the exact element we are looking for.
	    //
	    //   2. We did not find the exact element, but we can return the index of
	    //      the next-closest element.
	    //
	    //   3. We did not find the exact element, and there is no next-closest
	    //      element than the one we are searching for, so we return -1.
	    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	    var cmp = aCompare(aNeedle, aHaystack[mid], true);
	    if (cmp === 0) {
	      // Found the element we are looking for.
	      return mid;
	    }
	    else if (cmp > 0) {
	      // Our needle is greater than aHaystack[mid].
	      if (aHigh - mid > 1) {
	        // The element is in the upper half.
	        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	      }
	
	      // The exact needle element was not found in this haystack. Determine if
	      // we are in termination case (3) or (2) and return the appropriate thing.
	      if (aBias == exports.LEAST_UPPER_BOUND) {
	        return aHigh < aHaystack.length ? aHigh : -1;
	      } else {
	        return mid;
	      }
	    }
	    else {
	      // Our needle is less than aHaystack[mid].
	      if (mid - aLow > 1) {
	        // The element is in the lower half.
	        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	      }
	
	      // we are in termination case (3) or (2) and return the appropriate thing.
	      if (aBias == exports.LEAST_UPPER_BOUND) {
	        return mid;
	      } else {
	        return aLow < 0 ? -1 : aLow;
	      }
	    }
	  }
	
	  /**
	   * This is an implementation of binary search which will always try and return
	   * the index of the closest element if there is no exact hit. This is because
	   * mappings between original and generated line/col pairs are single points,
	   * and there is an implicit region between each of them, so a miss just means
	   * that you aren't on the very start of a region.
	   *
	   * @param aNeedle The element you are looking for.
	   * @param aHaystack The array that is being searched.
	   * @param aCompare A function which takes the needle and an element in the
	   *     array and returns -1, 0, or 1 depending on whether the needle is less
	   *     than, equal to, or greater than the element, respectively.
	   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	   */
	  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	    if (aHaystack.length === 0) {
	      return -1;
	    }
	
	    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	    if (index < 0) {
	      return -1;
	    }
	
	    // We have found either the exact element, or the next-closest element than
	    // the one we are searching for. However, there may be more than one such
	    // element. Make sure we always return the smallest of these.
	    while (index - 1 >= 0) {
	      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	        break;
	      }
	      --index;
	    }
	
	    return index;
	  };
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  // It turns out that some (most?) JavaScript engines don't self-host
	  // `Array.prototype.sort`. This makes sense because C++ will likely remain
	  // faster than JS when doing raw CPU-intensive sorting. However, when using a
	  // custom comparator function, calling back and forth between the VM's C++ and
	  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
	  // worse generated code for the comparator function than would be optimal. In
	  // fact, when sorting with a comparator, these costs outweigh the benefits of
	  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	  // a ~3500ms mean speed-up in `bench/bench.html`.
	
	  /**
	   * Swap the elements indexed by `x` and `y` in the array `ary`.
	   *
	   * @param {Array} ary
	   *        The array.
	   * @param {Number} x
	   *        The index of the first item.
	   * @param {Number} y
	   *        The index of the second item.
	   */
	  function swap(ary, x, y) {
	    var temp = ary[x];
	    ary[x] = ary[y];
	    ary[y] = temp;
	  }
	
	  /**
	   * Returns a random integer within the range `low .. high` inclusive.
	   *
	   * @param {Number} low
	   *        The lower bound on the range.
	   * @param {Number} high
	   *        The upper bound on the range.
	   */
	  function randomIntInRange(low, high) {
	    return Math.round(low + (Math.random() * (high - low)));
	  }
	
	  /**
	   * The Quick Sort algorithm.
	   *
	   * @param {Array} ary
	   *        An array to sort.
	   * @param {function} comparator
	   *        Function to use to compare two items.
	   * @param {Number} p
	   *        Start index of the array
	   * @param {Number} r
	   *        End index of the array
	   */
	  function doQuickSort(ary, comparator, p, r) {
	    // If our lower bound is less than our upper bound, we (1) partition the
	    // array into two pieces and (2) recurse on each half. If it is not, this is
	    // the empty array and our base case.
	
	    if (p < r) {
	      // (1) Partitioning.
	      //
	      // The partitioning chooses a pivot between `p` and `r` and moves all
	      // elements that are less than or equal to the pivot to the before it, and
	      // all the elements that are greater than it after it. The effect is that
	      // once partition is done, the pivot is in the exact place it will be when
	      // the array is put in sorted order, and it will not need to be moved
	      // again. This runs in O(n) time.
	
	      // Always choose a random pivot so that an input array which is reverse
	      // sorted does not cause O(n^2) running time.
	      var pivotIndex = randomIntInRange(p, r);
	      var i = p - 1;
	
	      swap(ary, pivotIndex, r);
	      var pivot = ary[r];
	
	      // Immediately after `j` is incremented in this loop, the following hold
	      // true:
	      //
	      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	      //
	      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	      for (var j = p; j < r; j++) {
	        if (comparator(ary[j], pivot) <= 0) {
	          i += 1;
	          swap(ary, i, j);
	        }
	      }
	
	      swap(ary, i + 1, j);
	      var q = i + 1;
	
	      // (2) Recurse on each half.
	
	      doQuickSort(ary, comparator, p, q - 1);
	      doQuickSort(ary, comparator, q + 1, r);
	    }
	  }
	
	  /**
	   * Sort the given array in-place with the given comparator function.
	   *
	   * @param {Array} ary
	   *        An array to sort.
	   * @param {function} comparator
	   *        Function to use to compare two items.
	   */
	  exports.quickSort = function (ary, comparator) {
	    doQuickSort(ary, comparator, 0, ary.length - 1);
	  };
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var SourceMapGenerator = __webpack_require__(194).SourceMapGenerator;
	  var util = __webpack_require__(197);
	
	  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	  // operating systems these days (capturing the result).
	  var REGEX_NEWLINE = /(\r?\n)/;
	
	  // Newline character code for charCodeAt() comparisons
	  var NEWLINE_CODE = 10;
	
	  // Private symbol for identifying `SourceNode`s when multiple versions of
	  // the source-map library are loaded. This MUST NOT CHANGE across
	  // versions!
	  var isSourceNode = "$$$isSourceNode$$$";
	
	  /**
	   * SourceNodes provide a way to abstract over interpolating/concatenating
	   * snippets of generated JavaScript source code while maintaining the line and
	   * column information associated with the original source code.
	   *
	   * @param aLine The original line number.
	   * @param aColumn The original column number.
	   * @param aSource The original source's filename.
	   * @param aChunks Optional. An array of strings which are snippets of
	   *        generated JS, or other SourceNodes.
	   * @param aName The original identifier.
	   */
	  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	    this.children = [];
	    this.sourceContents = {};
	    this.line = aLine == null ? null : aLine;
	    this.column = aColumn == null ? null : aColumn;
	    this.source = aSource == null ? null : aSource;
	    this.name = aName == null ? null : aName;
	    this[isSourceNode] = true;
	    if (aChunks != null) this.add(aChunks);
	  }
	
	  /**
	   * Creates a SourceNode from generated code and a SourceMapConsumer.
	   *
	   * @param aGeneratedCode The generated code
	   * @param aSourceMapConsumer The SourceMap for the generated code
	   * @param aRelativePath Optional. The path that relative sources in the
	   *        SourceMapConsumer should be relative to.
	   */
	  SourceNode.fromStringWithSourceMap =
	    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	      // The SourceNode we want to fill with the generated code
	      // and the SourceMap
	      var node = new SourceNode();
	
	      // All even indices of this array are one line of the generated code,
	      // while all odd indices are the newlines between two adjacent lines
	      // (since `REGEX_NEWLINE` captures its match).
	      // Processed fragments are removed from this array, by calling `shiftNextLine`.
	      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	      var shiftNextLine = function() {
	        var lineContents = remainingLines.shift();
	        // The last line of a file might not have a newline.
	        var newLine = remainingLines.shift() || "";
	        return lineContents + newLine;
	      };
	
	      // We need to remember the position of "remainingLines"
	      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
	
	      // The generate SourceNodes we need a code range.
	      // To extract it current and last mapping is used.
	      // Here we store the last mapping.
	      var lastMapping = null;
	
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        if (lastMapping !== null) {
	          // We add the code from "lastMapping" to "mapping":
	          // First check if there is a new line in between.
	          if (lastGeneratedLine < mapping.generatedLine) {
	            var code = "";
	            // Associate first line with "lastMapping"
	            addMappingWithCode(lastMapping, shiftNextLine());
	            lastGeneratedLine++;
	            lastGeneratedColumn = 0;
	            // The remaining code is added without mapping
	          } else {
	            // There is no new line in between.
	            // Associate the code between "lastGeneratedColumn" and
	            // "mapping.generatedColumn" with "lastMapping"
	            var nextLine = remainingLines[0];
	            var code = nextLine.substr(0, mapping.generatedColumn -
	                                          lastGeneratedColumn);
	            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
	                                                lastGeneratedColumn);
	            lastGeneratedColumn = mapping.generatedColumn;
	            addMappingWithCode(lastMapping, code);
	            // No more remaining code, continue
	            lastMapping = mapping;
	            return;
	          }
	        }
	        // We add the generated code until the first mapping
	        // to the SourceNode without any mapping.
	        // Each line is added as separate string.
	        while (lastGeneratedLine < mapping.generatedLine) {
	          node.add(shiftNextLine());
	          lastGeneratedLine++;
	        }
	        if (lastGeneratedColumn < mapping.generatedColumn) {
	          var nextLine = remainingLines[0];
	          node.add(nextLine.substr(0, mapping.generatedColumn));
	          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	        }
	        lastMapping = mapping;
	      }, this);
	      // We have processed all mappings.
	      if (remainingLines.length > 0) {
	        if (lastMapping) {
	          // Associate the remaining code in the current line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	        }
	        // and add the remaining lines without any mapping
	        node.add(remainingLines.join(""));
	      }
	
	      // Copy sourcesContent into SourceNode
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          if (aRelativePath != null) {
	            sourceFile = util.join(aRelativePath, sourceFile);
	          }
	          node.setSourceContent(sourceFile, content);
	        }
	      });
	
	      return node;
	
	      function addMappingWithCode(mapping, code) {
	        if (mapping === null || mapping.source === undefined) {
	          node.add(code);
	        } else {
	          var source = aRelativePath
	            ? util.join(aRelativePath, mapping.source)
	            : mapping.source;
	          node.add(new SourceNode(mapping.originalLine,
	                                  mapping.originalColumn,
	                                  source,
	                                  code,
	                                  mapping.name));
	        }
	      }
	    };
	
	  /**
	   * Add a chunk of generated JS to this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.add = function SourceNode_add(aChunk) {
	    if (Array.isArray(aChunk)) {
	      aChunk.forEach(function (chunk) {
	        this.add(chunk);
	      }, this);
	    }
	    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	      if (aChunk) {
	        this.children.push(aChunk);
	      }
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };
	
	  /**
	   * Add a chunk of generated JS to the beginning of this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	    if (Array.isArray(aChunk)) {
	      for (var i = aChunk.length-1; i >= 0; i--) {
	        this.prepend(aChunk[i]);
	      }
	    }
	    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	      this.children.unshift(aChunk);
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };
	
	  /**
	   * Walk over the tree of JS snippets in this node and its children. The
	   * walking function is called once for each snippet of JS and is passed that
	   * snippet and the its original associated source's line/column location.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	    var chunk;
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      chunk = this.children[i];
	      if (chunk[isSourceNode]) {
	        chunk.walk(aFn);
	      }
	      else {
	        if (chunk !== '') {
	          aFn(chunk, { source: this.source,
	                       line: this.line,
	                       column: this.column,
	                       name: this.name });
	        }
	      }
	    }
	  };
	
	  /**
	   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	   * each of `this.children`.
	   *
	   * @param aSep The separator.
	   */
	  SourceNode.prototype.join = function SourceNode_join(aSep) {
	    var newChildren;
	    var i;
	    var len = this.children.length;
	    if (len > 0) {
	      newChildren = [];
	      for (i = 0; i < len-1; i++) {
	        newChildren.push(this.children[i]);
	        newChildren.push(aSep);
	      }
	      newChildren.push(this.children[i]);
	      this.children = newChildren;
	    }
	    return this;
	  };
	
	  /**
	   * Call String.prototype.replace on the very right-most source snippet. Useful
	   * for trimming whitespace from the end of a source node, etc.
	   *
	   * @param aPattern The pattern to replace.
	   * @param aReplacement The thing to replace the pattern with.
	   */
	  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	    var lastChild = this.children[this.children.length - 1];
	    if (lastChild[isSourceNode]) {
	      lastChild.replaceRight(aPattern, aReplacement);
	    }
	    else if (typeof lastChild === 'string') {
	      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	    }
	    else {
	      this.children.push(''.replace(aPattern, aReplacement));
	    }
	    return this;
	  };
	
	  /**
	   * Set the source content for a source file. This will be added to the SourceMapGenerator
	   * in the sourcesContent field.
	   *
	   * @param aSourceFile The filename of the source file
	   * @param aSourceContent The content of the source file
	   */
	  SourceNode.prototype.setSourceContent =
	    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	    };
	
	  /**
	   * Walk over the tree of SourceNodes. The walking function is called for each
	   * source file content and is passed the filename and source content.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walkSourceContents =
	    function SourceNode_walkSourceContents(aFn) {
	      for (var i = 0, len = this.children.length; i < len; i++) {
	        if (this.children[i][isSourceNode]) {
	          this.children[i].walkSourceContents(aFn);
	        }
	      }
	
	      var sources = Object.keys(this.sourceContents);
	      for (var i = 0, len = sources.length; i < len; i++) {
	        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	      }
	    };
	
	  /**
	   * Return the string representation of this source node. Walks over the tree
	   * and concatenates all the various snippets together to one string.
	   */
	  SourceNode.prototype.toString = function SourceNode_toString() {
	    var str = "";
	    this.walk(function (chunk) {
	      str += chunk;
	    });
	    return str;
	  };
	
	  /**
	   * Returns the string representation of this source node along with a source
	   * map.
	   */
	  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	    var generated = {
	      code: "",
	      line: 1,
	      column: 0
	    };
	    var map = new SourceMapGenerator(aArgs);
	    var sourceMappingActive = false;
	    var lastOriginalSource = null;
	    var lastOriginalLine = null;
	    var lastOriginalColumn = null;
	    var lastOriginalName = null;
	    this.walk(function (chunk, original) {
	      generated.code += chunk;
	      if (original.source !== null
	          && original.line !== null
	          && original.column !== null) {
	        if(lastOriginalSource !== original.source
	           || lastOriginalLine !== original.line
	           || lastOriginalColumn !== original.column
	           || lastOriginalName !== original.name) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	        lastOriginalSource = original.source;
	        lastOriginalLine = original.line;
	        lastOriginalColumn = original.column;
	        lastOriginalName = original.name;
	        sourceMappingActive = true;
	      } else if (sourceMappingActive) {
	        map.addMapping({
	          generated: {
	            line: generated.line,
	            column: generated.column
	          }
	        });
	        lastOriginalSource = null;
	        sourceMappingActive = false;
	      }
	      for (var idx = 0, length = chunk.length; idx < length; idx++) {
	        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	          generated.line++;
	          generated.column = 0;
	          // Mappings end at eol
	          if (idx + 1 === length) {
	            lastOriginalSource = null;
	            sourceMappingActive = false;
	          } else if (sourceMappingActive) {
	            map.addMapping({
	              source: original.source,
	              original: {
	                line: original.line,
	                column: original.column
	              },
	              generated: {
	                line: generated.line,
	                column: generated.column
	              },
	              name: original.name
	            });
	          }
	        } else {
	          generated.column++;
	        }
	      }
	    });
	    this.walkSourceContents(function (sourceFile, sourceContent) {
	      map.setSourceContent(sourceFile, sourceContent);
	    });
	
	    return { code: generated.code, map: map };
	  };
	
	  exports.SourceNode = SourceNode;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	exports.SourceListMap = __webpack_require__(205);
	exports.SourceNode = __webpack_require__(208);
	exports.CodeNode = __webpack_require__(206);
	exports.MappingsContext = __webpack_require__(210);
	exports.fromStringWithSourceMap = __webpack_require__(211);


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var CodeNode = __webpack_require__(206);
	var SourceNode = __webpack_require__(208);
	var MappingsContext = __webpack_require__(210);
	
	function SourceListMap(generatedCode, source, originalSource) {
		if(Array.isArray(generatedCode)) {
			this.children = generatedCode;
		} else {
			this.children = [];
			if(generatedCode || source)
				this.add(generatedCode, source, originalSource);
		}
	}
	module.exports = SourceListMap;
	
	SourceListMap.prototype.add = function(generatedCode, source, originalSource) {
		if(typeof generatedCode === "string") {
			if(source) {
				this.children.push(new SourceNode(generatedCode, source, originalSource));
			} else if(this.children.length > 0 && this.children[this.children.length - 1].addGeneratedCode) {
				this.children[this.children.length - 1].addGeneratedCode(generatedCode);
			} else {
				this.children.push(new CodeNode(generatedCode));
			}
		} else if(generatedCode.getMappings && generatedCode.getGeneratedCode) {
			this.children.push(generatedCode);
		} else if(generatedCode.children) {
			generatedCode.children.forEach(function(sln) {
				this.children.push(sln);
			}, this);
		} else {
			throw new Error("Invalid arguments to SourceListMap.prototype.add: Expected string, Node or SourceListMap");
		}
	};
	
	SourceListMap.prototype.preprend = function(source) {
		if(typeof generatedCode === "string") {
			if(source) {
				this.children.unshift(new SourceNode(generatedCode, source, originalSource));
			} else if(this.children.length > 0 && this.children[this.children.length - 1].preprendGeneratedCode) {
				this.children[this.children.length - 1].preprendGeneratedCode(generatedCode);
			} else {
				this.children.unshift(new CodeNode(generatedCode));
			}
		} else if(generatedCode.getMappings && generatedCode.getGeneratedCode) {
			this.children.unshift(generatedCode);
		} else if(generatedCode.children) {
			generatedCode.children.slice().reverse().forEach(function(sln) {
				this.children.unshift(sln);
			}, this);
		} else {
			throw new Error("Invalid arguments to SourceListMap.prototype.prerend: Expected string, Node or SourceListMap");
		}
	};
	
	SourceListMap.prototype.mapGeneratedCode = function(fn) {
		this.children.forEach(function(sln) {
			sln.mapGeneratedCode(fn);
		});
	};
	
	SourceListMap.prototype.toString = function() {
		return this.children.map(function(sln) {
			return sln.getGeneratedCode();
		}).join("");
	};
	
	SourceListMap.prototype.toStringWithSourceMap = function(options) {
		var mappingsContext = new MappingsContext();
		var source = this.children.map(function(sln) {
			return sln.generatedCode;
		}).join("");
		var mappings = this.children.map(function(sln) {
			return sln.getMappings(mappingsContext);
		}).join("");
		return {
			source: source,
			map: {
				version: 3,
				file: options && options.file,
				sources: mappingsContext.sources,
				sourcesContent: mappingsContext.hasSourceContent ? mappingsContext.sourcesContent : undefined,
				mappings: mappings
			}
		};
	}


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var getNumberOfLines = __webpack_require__(207).getNumberOfLines;
	
	function CodeNode(generatedCode) {
		this.generatedCode = generatedCode;
	}
	module.exports = CodeNode;
	
	CodeNode.prototype.clone = function() {
		return new CodeNode(this.generatedCode);
	}
	
	CodeNode.prototype.getGeneratedCode = function() {
		return this.generatedCode;
	};
	
	CodeNode.prototype.getMappings = function(mappingsContext) {
		var lines = getNumberOfLines(this.generatedCode);
		return Array(lines+1).join(";");
	};
	
	CodeNode.prototype.addGeneratedCode = function(generatedCode) {
		this.generatedCode += generatedCode;
	};
	
	CodeNode.prototype.mapGeneratedCode = function(fn) {
		this.generatedCode = fn(this.generatedCode);
	};


/***/ },
/* 207 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	exports.getNumberOfLines = function getNumberOfLines(str) {
		var nr = -1;
		var idx = -1;
		do {
			nr++
			idx = str.indexOf("\n", idx + 1);
		} while(idx >= 0);
		return nr;
	};


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var base64VLQ = __webpack_require__(209);
	var getNumberOfLines = __webpack_require__(207).getNumberOfLines;
	
	function SourceNode(generatedCode, source, originalSource, startingLine) {
		this.generatedCode = generatedCode;
		this.originalSource = originalSource;
		this.source = source;
		this.startingLine = startingLine || 1;
	}
	module.exports = SourceNode;
	
	SourceNode.prototype.clone = function() {
		return new SourceNode(this.generatedCode, this.source, this.originalSource, this.startingLine);
	}
	
	var LINE_MAPPING = "AACA;";
	var LAST_LINE_MAPPING = "AACA";
	
	SourceNode.prototype.getGeneratedCode = function() {
		return this.generatedCode;
	};
	
	SourceNode.prototype.getMappings = function(mappingsContext) {
		var lines = getNumberOfLines(this.generatedCode);
		var sourceIdx = mappingsContext.ensureSource(this.source, this.originalSource);
		var mappings = "A"; // generated column 0
		mappings += base64VLQ.encode(sourceIdx - mappingsContext.currentSource); // source index
		mappings += base64VLQ.encode(this.startingLine - mappingsContext.currentOriginalLine); // original line index
		mappings += "A"; // original column 0
		if(lines !== 0)
			mappings += ";"
		mappingsContext.currentSource = sourceIdx;
		mappingsContext.currentOriginalLine = (lines || 1) + this.startingLine - 1;
		mappings += Array(lines).join(LINE_MAPPING);
		if(lines !== 0 && this.generatedCode[this.generatedCode.length - 1] !== "\n") {
			mappings += LAST_LINE_MAPPING;
			mappingsContext.currentOriginalLine++;
		}
		return mappings;
	};
	
	SourceNode.prototype.mapGeneratedCode = function(fn) {
		this.generatedCode = fn(this.generatedCode);
	};


/***/ },
/* 209 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	
	/*eslint no-bitwise:0,quotes:0,global-strict:0*/
	
	var charToIntMap = {};
	var intToCharMap = {};
	
	'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	  .split('')
	  .forEach(function (ch, index) {
	    charToIntMap[ch] = index;
	    intToCharMap[index] = ch;
	  });
	
	var base64 = {};
	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	base64.encode = function base64_encode(aNumber) {
	  if (aNumber in intToCharMap) {
	    return intToCharMap[aNumber];
	  }
	  throw new TypeError("Must be between 0 and 63: " + aNumber);
	};
	
	/**
	 * Decode a single base 64 digit to an integer.
	 */
	base64.decode = function base64_decode(aChar) {
	  if (aChar in charToIntMap) {
	    return charToIntMap[aChar];
	  }
	  throw new TypeError("Not a valid base 64 digit: " + aChar);
	};
	
	
	
	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011
	
	var VLQ_BASE_SHIFT = 5;
	
	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	
	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;
	
	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;
	
	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}
	
	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}
	
	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	exports.encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;
	
	  var vlq = toVLQSigned(aValue);
	
	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);
	
	  return encoded;
	};
	
	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	exports.decode = function base64VLQ_decode(aStr, aOutParam) {
	  var i = 0;
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;
	
	  do {
	    if (i >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }
	    digit = base64.decode(aStr.charAt(i++));
	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);
	
	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aStr.slice(i);
	};


/***/ },
/* 210 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function MappingsContext() {
		this.sources = [];
		this.sourcesContent = [];
		this.hasSourceContent = false;
		this.currentOriginalLine = 1;
		this.currentSource = 0;
	}
	module.exports = MappingsContext;
	
	MappingsContext.prototype.ensureSource = function(source, originalSource) {
		var idx = this.sources.indexOf(source);
		if(idx >= 0)
			return idx;
		idx = this.sources.length;
		this.sources.push(source);
		this.sourcesContent.push(originalSource);
		if(typeof originalSource === "string")
			this.hasSourceContent = true;
		return idx;
	};


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var base64VLQ = __webpack_require__(209);
	var SourceNode = __webpack_require__(208);
	var CodeNode = __webpack_require__(206);
	var SourceListMap = __webpack_require__(205);
	
	module.exports = function fromStringWithSourceMap(code, map) {
		var sources = map.sources;
		var sourcesContent = map.sourcesContent;
		var mappings = map.mappings.split(";");
		var lines = code.split("\n");
		var nodes = [];
		var currentNode = null;
		var currentLine = 1;
		var currentSourceIdx = 0;
		var currentSourceNodeLine;
		mappings.forEach(function(mapping, idx) {
			var line = lines[idx];
			if(idx !== lines.length - 1) line += "\n";
			if(!mapping)
				return addCode(line);
			mapping = { value: 0, rest: mapping };
			var lineAdded = false;
			while(mapping.rest)
				lineAdded = processMapping(mapping, line, lineAdded) || lineAdded;
			if(!lineAdded)
				addCode(line);
		});
		if(mappings.length < lines.length) {
			var idx = mappings.length;
			while(!lines[idx].trim() && idx < lines.length-1) {
				addCode(lines[idx] + "\n");
				idx++;
			}
			addCode(lines.slice(idx).join("\n"));
		}
		return new SourceListMap(nodes);
		function processMapping(mapping, line, ignore) {
			if(mapping.rest && mapping.rest[0] !== ",") {
				base64VLQ.decode(mapping.rest, mapping);
			}
			if(!mapping.rest)
				return false;
			if(mapping.rest[0] === ",") {
				mapping.rest = mapping.rest.substr(1);
				return false;
			}
	
			base64VLQ.decode(mapping.rest, mapping);
			var sourceIdx = mapping.value + currentSourceIdx;
			currentSourceIdx = sourceIdx;
	
			if(mapping.rest && mapping.rest[0] !== ",") {
				base64VLQ.decode(mapping.rest, mapping);
				var linePosition = mapping.value + currentLine;
				currentLine = linePosition;
			} else {
				var linePosition = currentLine;
			}
	
			if(mapping.rest && mapping.rest[0] === ",") {
				mapping.rest = mapping.rest.substr(1);
			}
	
			if(!ignore) {
				addSource(line, sources ? sources[sourceIdx] : null, sourcesContent ? sourcesContent[sourceIdx] : null, linePosition)
				return true;
			}
		}
		function addCode(generatedCode) {
			if(currentNode && currentNode instanceof CodeNode) {
				currentNode.addGeneratedCode(generatedCode);
			} else if(currentNode && currentNode instanceof SourceNode && !generatedCode.trim()) {
				currentNode.generatedCode += generatedCode;
				currentSourceNodeLine++;
			} else {
				currentNode = new CodeNode(generatedCode);
				nodes.push(currentNode);
			}
		}
		function addSource(generatedCode, source, originalSource, linePosition) {
			if(currentNode && currentNode instanceof SourceNode &&
				currentNode.source === source &&
				currentSourceNodeLine === linePosition
			) {
				currentNode.generatedCode += generatedCode;
				currentSourceNodeLine++;
			} else {
				currentNode = new SourceNode(generatedCode, source, originalSource, linePosition);
				currentSourceNodeLine = linePosition + 1;
				nodes.push(currentNode);
			}
		}
	};


/***/ },
/* 212 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function mixinSourceAndMap(proto) {
		proto.map = function(options) {
			options = options || {};
			if(options.columns === false) {
				return this.listMap(options).toStringWithSourceMap().map;
			}
	
			return this.node(options).toStringWithSourceMap({file:"x"}).map.toJSON();
		};
	
		proto.sourceAndMap = function(options) {
			options = options || {};
			if(options.columns === false) {
				//console.log(this.listMap(options).debugInfo());
				return this.listMap(options).toStringWithSourceMap();
			}
	
			var res = this.node(options).toStringWithSourceMap({file:"x"});
			return {
				source: res.code,
				map: res.map.toJSON()
			};
		};
	}


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Source = __webpack_require__(192);
	var SourceNode = __webpack_require__(193).SourceNode;
	var SourceListMap = __webpack_require__(204).SourceListMap;
	
	function RawSource(value) {
		Source.call(this);
		this._value = value;
	}
	module.exports = RawSource;
	
	RawSource.prototype = Object.create(Source.prototype);
	RawSource.prototype.constructor = RawSource;
	
	RawSource.prototype.source = function() {
		return this._value;
	};
	
	RawSource.prototype.map = function(options) {
		return null;
	};
	
	RawSource.prototype.node = function(options) {
		return new SourceNode(null, null, null, this._value);
	};
	
	RawSource.prototype.listMap = function(options) {
		return new SourceListMap(this._value);
	};
	
	RawSource.prototype.updateHash = function(hash) {
		hash.update(this._value);
	};


/***/ },
/* 214 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleReason(module, dependency) {
		this.module = module;
		this.dependency = dependency;
	}
	module.exports = ModuleReason;


/***/ },
/* 215 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function removeAndDo(collection, thing, action) {
		var idx = this[collection].indexOf(thing);
		if(idx >= 0) {
			this[collection].splice(idx, 1);
			thing[action](this);
			return true;
		}
		return false;
	};


/***/ },
/* 216 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ArrayMap() {
		this.keys = [];
		this.values = [];
	}
	module.exports = ArrayMap;
	
	ArrayMap.prototype.get = function(key) {
		for(var i = 0; i < this.keys.length; i++) {
			if(this.keys[i] === key) {
				return this.values[i];
			}
		}
		return;
	};
	
	ArrayMap.prototype.set = function(key, value) {
		for(var i = 0; i < this.keys.length; i++) {
			if(this.keys[i] === key) {
				this.values[i] = value;
				return this;
			}
		}
		this.keys.push(key);
		this.values.push(value);
		return this;
	};
	
	ArrayMap.prototype.remove = function(key) {
		for(var i = 0; i < this.keys.length; i++) {
			if(this.keys[i] === key) {
				this.keys.splice(i, 1);
				this.values.splice(i, 1);
				return true;
			}
		}
		return false;
	};
	
	ArrayMap.prototype.clone = function() {
		var newMap = new ArrayMap();
		for(var i = 0; i < this.keys.length; i++) {
			newMap.keys.push(this.keys[i]);
			newMap.values.push(this.values[i]);
		}
		return newMap;
	};


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function Chunk(name, module, loc) {
		this.id = null;
		this.ids = null;
		this.name = name;
		this.modules = [];
		this.chunks = [];
		this.parents = [];
		this.blocks = [];
		this.origins = [];
		this.files = [];
		this.rendered = false;
		this.entry = false;
		this.initial = false;
		if(module) {
			this.origins.push({
				module: module,
				loc: loc,
				name: name
			});
		}
	}
	module.exports = Chunk;
	
	Chunk.prototype.addModule = function(module) {
		if(this.modules.indexOf(module) >= 0) {
			return false;
		}
		this.modules.push(module);
		return true;
	};
	
	Chunk.prototype._removeAndDo = __webpack_require__(215);
	
	Chunk.prototype.removeModule = function(module) {
		this._removeAndDo("modules", module, "removeChunk");
	};
	
	Chunk.prototype.removeChunk = function(chunk) {
		this._removeAndDo("chunks", chunk, "removeParent");
	};
	
	Chunk.prototype.removeParent = function(chunk) {
		this._removeAndDo("parents", chunk, "removeChunk");
	};
	
	function createAdder(collection) {
		return function(chunk) {
			if(chunk === this) {
				return false;
			}
			if(this[collection].indexOf(chunk) >= 0) {
				return false;
			}
			this[collection].push(chunk);
			return true;
		};
	}
	
	Chunk.prototype.addChunk = createAdder("chunks");
	
	Chunk.prototype.addParent = createAdder("parents");
	
	Chunk.prototype.addBlock = function(block) {
		if(this.blocks.indexOf(block) >= 0) {
			return false;
		}
		this.blocks.push(block);
		return true;
	};
	
	Chunk.prototype.addOrigin = function(module, loc) {
		this.origins.push({
			module: module,
			loc: loc,
			name: this.name
		});
	};
	
	Chunk.prototype.remove = function(reason) {
		this.modules.slice().forEach(function(m) {
			m.removeChunk(this);
		}, this);
		this.parents.forEach(function(c) {
			var idx = c.chunks.indexOf(this);
			if(idx >= 0) {
				c.chunks.splice(idx, 1);
			}
			this.chunks.forEach(function(cc) {
				cc.addParent(c);
			});
		}, this);
		this.chunks.forEach(function(c) {
			var idx = c.parents.indexOf(this);
			if(idx >= 0) {
				c.parents.splice(idx, 1);
			}
			this.parents.forEach(function(cc) {
				cc.addChunk(c);
			});
		}, this);
		this.blocks.forEach(function(b) {
			var idx = b.chunks.indexOf(this);
			if(idx >= 0) {
				b.chunks.splice(idx, 1);
				if(b.chunks.length === 0) {
					b.chunks = null;
					b.chunkReason = reason;
				}
			}
		}, this);
	};
	
	Chunk.prototype.integrate = function(other, reason) {
		if(!this.canBeIntegrated(other)) {
			return false;
		}
	
		var otherModules = other.modules.slice();
		otherModules.forEach(function(m) {
			m.removeChunk(other);
			m.addChunk(this);
			this.addModule(m);
			m.rewriteChunkInReasons(other, [this]);
		}, this);
		other.modules.length = 0;
	
		function moveChunks(chunks, kind, onChunk) {
			chunks.forEach(function(c) {
				var idx = c[kind].indexOf(other);
				if(idx >= 0) {
					c[kind].splice(idx, 1);
				}
				onChunk(c);
			});
		}
		moveChunks(other.parents, "chunks", function(c) {
			if(c !== this && this.addParent(c)) {
				c.addChunk(this);
			}
		}.bind(this));
		other.parents.length = 0;
		moveChunks(other.chunks, "parents", function(c) {
			if(c !== this && this.addChunk(c)) {
				c.addParent(this);
			}
		}.bind(this));
		other.chunks.length = 0;
		other.blocks.forEach(function(b) {
			b.chunks = (b.chunks || [this]).map(function(c) {
				return c === other ? this : c;
			}, this);
			b.chunkReason = reason;
			this.addBlock(b);
		}, this);
		other.blocks.length = 0;
		other.origins.forEach(function(origin) {
			if(!origin.reasons) {
				origin.reasons = [reason];
			} else if(origin.reasons[0] !== reason) {
				origin.reasons.unshift(reason);
			}
			this.origins.push(origin);
		}, this);
		return true;
	};
	
	Chunk.prototype.isEmpty = function() {
		return this.modules.length === 0;
	};
	
	Chunk.prototype.updateHash = function(hash) {
		hash.update(this.id + " ");
		hash.update(this.ids ? this.ids.join(",") : "");
		hash.update(this.name + "");
		this.modules.forEach(function(m) {
			m.updateHash(hash);
		});
	};
	
	Chunk.prototype.size = function(options) {
		var CHUNK_OVERHEAD = options.chunkOverhead || 10000;
		var ENTRY_CHUNK_MULTIPLICATOR = options.entryChunkMultiplicator || 10;
	
		var modulesSize = this.modules.reduce(function(a, b) {
			return a + b.size();
		}, 0);
		return modulesSize * (this.initial ? ENTRY_CHUNK_MULTIPLICATOR : 1) + CHUNK_OVERHEAD;
	};
	
	Chunk.prototype.canBeIntegrated = function(other) {
		if(other.initial) {
			return false;
		}
		if(this.initial) {
			if(other.parents.length !== 1 || other.parents[0] !== this) {
				return false;
			}
		}
		return true;
	};
	
	Chunk.prototype.integratedSize = function(other, options) {
		// Chunk if it's possible to integrate this chunk
		if(!this.canBeIntegrated(other)) {
			return false;
		}
	
		var CHUNK_OVERHEAD = options.chunkOverhead || 10000;
		var ENTRY_CHUNK_MULTIPLICATOR = options.entryChunkMultiplicator || 10;
	
		var mergedModules = this.modules.slice();
		other.modules.forEach(function(m) {
			if(this.modules.indexOf(m) < 0) {
				mergedModules.push(m);
			}
		}, this);
	
		var modulesSize = mergedModules.map(function(m) {
			return m.size();
		}).reduce(function(a, b) {
			return a + b;
		}, 0);
		return modulesSize * (this.initial || other.initial ? ENTRY_CHUNK_MULTIPLICATOR : 1) + CHUNK_OVERHEAD;
	};
	
	Chunk.prototype.getChunkMaps = function(includeEntries, realHash) {
		var chunksProcessed = [];
		var chunkHashMap = {};
		var chunkNameMap = {};
		(function addChunk(c) {
			if(chunksProcessed.indexOf(c) >= 0) return;
			chunksProcessed.push(c);
			if(!c.entry || includeEntries) {
				chunkHashMap[c.id] = realHash ? c.hash : c.renderedHash;
				if(c.name)
					chunkNameMap[c.id] = c.name;
			}
			c.chunks.forEach(addChunk);
		}(this));
		return {
			hash: chunkHashMap,
			name: chunkNameMap
		};
	};
	
	Chunk.prototype.toString = function() {
		return "Chunk[" + this.modules.join() + "]";
	};


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RequestShortener = __webpack_require__(219);
	
	function Stats(compilation) {
		this.compilation = compilation;
		this.hash = compilation.hash;
	}
	module.exports = Stats;
	
	Stats.prototype.hasWarnings = function() {
		return this.compilation.warnings.length > 0;
	};
	
	Stats.prototype.hasErrors = function() {
		return this.compilation.errors.length > 0;
	};
	
	Stats.prototype.toJson = function toJson(options, forToString) {
		if(typeof options === "boolean" || typeof options === "string") {
			options = Stats.presetToOptions(options);
		} else if(!options) {
			options = {};
		}
	
		function d(v, def) {
			return v === undefined ? def : v;
		}
		var compilation = this.compilation;
		var requestShortener = new RequestShortener(d(options.context, process.cwd()));
		var showHash = d(options.hash, true);
		var showVersion = d(options.version, true);
		var showTimings = d(options.timings, true);
		var showAssets = d(options.assets, true);
		var showChunks = d(options.chunks, true);
		var showChunkModules = d(options.chunkModules, !!forToString);
		var showChunkOrigins = d(options.chunkOrigins, !forToString);
		var showModules = d(options.modules, !forToString);
		var showCachedModules = d(options.cached, true);
		var showCachedAssets = d(options.cachedAssets, true);
		var showReasons = d(options.reasons, !forToString);
		var showChildren = d(options.children, true);
		var showSource = d(options.source, !forToString);
		var showErrors = d(options.errors, true);
		var showErrorDetails = d(options.errorDetails, !forToString);
		var showWarnings = d(options.warnings, true);
		var showPublicPath = d(options.publicPath, !forToString);
		var excludeModules = [].concat(d(options.exclude, [])).map(function(str) {
			if(typeof str !== "string") return str;
			return new RegExp("[\\\\/]" + str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&") + "([\\\\/]|$|!|\\?)");
		});
		var sortModules = d(options.modulesSort, "id");
		var sortChunks = d(options.chunksSort, "id");
		var sortAssets = d(options.assetsSort, "");
	
		function moduleFilter(module) {
			if(!showCachedModules && !module.built) {
				return false;
			}
			if(excludeModules.length === 0)
				return true;
			var ident = module.identifier();
			return !excludeModules.some(function(regExp) {
				return regExp.test(ident);
			});
		}
	
		function sortByField(field) {
			if(!field) return function() {
				return 0;
			};
			if(field[0] === "!") {
				field = field.substr(1);
				return function(a, b) {
					if(a[field] === b[field]) return 0;
					return a[field] < b[field] ? 1 : -1;
				};
			}
			return function(a, b) {
				if(a[field] === b[field]) return 0;
				return a[field] < b[field] ? -1 : 1;
			};
		}
	
		function formatError(e) {
			var text = "";
			if(typeof e === "string")
				e = {
					message: e
				};
			if(e.chunk) {
				text += "chunk " + (e.chunk.name || e.chunk.id) +
					(e.chunk.entry ? " [entry]" : e.chunk.initial ? " [initial]" : "") + "\n";
			}
			if(e.file) {
				text += e.file + "\n";
			}
			if(e.module && e.module.readableIdentifier && typeof e.module.readableIdentifier === "function") {
				text += e.module.readableIdentifier(requestShortener) + "\n";
			}
			text += e.message;
			if(showErrorDetails && e.details) text += "\n" + e.details;
			if(showErrorDetails && e.missing) text += e.missing.map(function(item) {
				return "\n[" + item + "]";
			}).join("");
			if(e.dependencies && e.origin) {
				text += "\n @ " + e.origin.readableIdentifier(requestShortener);
				e.dependencies.forEach(function(dep) {
					if(!dep.loc) return;
					if(typeof dep.loc === "string") return;
					if(!dep.loc.start) return;
					if(!dep.loc.end) return;
					text += " " + dep.loc.start.line + ":" + dep.loc.start.column + "-" +
						(dep.loc.start.line !== dep.loc.end.line ? dep.loc.end.line + ":" : "") + dep.loc.end.column;
				});
			}
			return text;
		}
	
		var obj = {
			errors: compilation.errors.map(formatError),
			warnings: compilation.warnings.map(formatError)
		};
	
		//We just hint other renderers since actually omitting
		//errors/warnings from the JSON would be kind of weird.
		Object.defineProperty(obj, "_showWarnings", {
			value: showWarnings,
			enumerable: false
		});
		Object.defineProperty(obj, "_showErrors", {
			value: showErrors,
			enumerable: false
		});
	
		if(showVersion) {
			obj.version = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../package.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).version;
		}
	
		if(showHash) obj.hash = this.hash;
		if(showTimings && this.startTime && this.endTime) {
			obj.time = this.endTime - this.startTime;
		}
		if(showPublicPath) {
			obj.publicPath = this.compilation.mainTemplate.getPublicPath({
				hash: this.compilation.hash
			});
		}
		if(showAssets) {
			var assetsByFile = {};
			obj.assetsByChunkName = {};
			obj.assets = Object.keys(compilation.assets).map(function(asset) {
				var obj = {
					name: asset,
					size: compilation.assets[asset].size(),
					chunks: [],
					chunkNames: [],
					emitted: compilation.assets[asset].emitted
				};
				assetsByFile[asset] = obj;
				return obj;
			}).filter(function(asset) {
				return showCachedAssets || asset.emitted;
			});
			compilation.chunks.forEach(function(chunk) {
				chunk.files.forEach(function(asset) {
					if(assetsByFile[asset]) {
						chunk.ids.forEach(function(id) {
							assetsByFile[asset].chunks.push(id);
						});
						if(chunk.name) {
							assetsByFile[asset].chunkNames.push(chunk.name);
							if(obj.assetsByChunkName[chunk.name])
								obj.assetsByChunkName[chunk.name] = [].concat(obj.assetsByChunkName[chunk.name]).concat([asset]);
							else
								obj.assetsByChunkName[chunk.name] = asset;
						}
					}
				});
			});
			obj.assets.sort(sortByField(sortAssets));
		}
	
		function fnModule(module) {
			var obj = {
				id: module.id,
				identifier: module.identifier(),
				name: module.readableIdentifier(requestShortener),
				index: module.index,
				index2: module.index2,
				size: module.size(),
				cacheable: !!module.cacheable,
				built: !!module.built,
				optional: !!module.optional,
				prefetched: !!module.prefetched,
				chunks: module.chunks.map(function(chunk) {
					return chunk.id;
				}),
				assets: Object.keys(module.assets || {}),
				issuer: module.issuer,
				profile: module.profile,
				failed: !!module.error,
				errors: module.errors && module.dependenciesErrors && (module.errors.length + module.dependenciesErrors.length),
				warnings: module.errors && module.dependenciesErrors && (module.warnings.length + module.dependenciesWarnings.length)
			};
			if(showReasons) {
				obj.reasons = module.reasons.filter(function(reason) {
					return reason.dependency && reason.module;
				}).map(function(reason) {
					var obj = {
						moduleId: reason.module.id,
						moduleIdentifier: reason.module.identifier(),
						module: reason.module.readableIdentifier(requestShortener),
						moduleName: reason.module.readableIdentifier(requestShortener),
						type: reason.dependency.type,
						userRequest: reason.dependency.userRequest
					};
					var dep = reason.dependency;
					if(dep.templateModules) obj.templateModules = dep.templateModules.map(function(module) {
						return module.id;
					});
					if(typeof dep.loc === "object") obj.loc = dep.loc.start.line + ":" + dep.loc.start.column + "-" +
						(dep.loc.start.line !== dep.loc.end.line ? dep.loc.end.line + ":" : "") + dep.loc.end.column;
					return obj;
				}).sort(function(a, b) {
					return a.moduleId - b.moduleId;
				});
			}
			if(showSource && module._source) {
				obj.source = module._source.source();
			}
			return obj;
		}
		if(showChunks) {
			obj.chunks = compilation.chunks.map(function(chunk) {
				var obj = {
					id: chunk.id,
					rendered: chunk.rendered,
					initial: !!chunk.initial,
					entry: !!chunk.entry,
					extraAsync: !!chunk.extraAsync,
					size: chunk.modules.reduce(function(size, module) {
						return size + module.size();
					}, 0),
					names: chunk.name ? [chunk.name] : [],
					files: chunk.files.slice(),
					hash: chunk.renderedHash,
					parents: chunk.parents.map(function(c) {
						return c.id;
					})
				};
				if(showChunkModules) {
					obj.modules = chunk.modules.filter(moduleFilter).map(fnModule);
					obj.filteredModules = chunk.modules.length - obj.modules.length;
					obj.modules.sort(sortByField(sortModules));
				}
				if(showChunkOrigins) {
					obj.origins = chunk.origins.map(function(origin) {
						return {
							moduleId: origin.module ? origin.module.id : undefined,
							module: origin.module ? origin.module.identifier() : "",
							moduleIdentifier: origin.module ? origin.module.identifier() : "",
							moduleName: origin.module ? origin.module.readableIdentifier(requestShortener) : "",
							loc: typeof origin.loc === "object" ? obj.loc = origin.loc.start.line + ":" + origin.loc.start.column + "-" +
								(origin.loc.start.line !== origin.loc.end.line ? origin.loc.end.line + ":" : "") + origin.loc.end.column : "",
							name: origin.name,
							reasons: origin.reasons || []
						};
					});
				}
				return obj;
			});
			obj.chunks.sort(sortByField(sortChunks));
		}
		if(showModules) {
			obj.modules = compilation.modules.filter(moduleFilter).map(fnModule);
			obj.filteredModules = compilation.modules.length - obj.modules.length;
			obj.modules.sort(sortByField(sortModules));
		}
		if(showChildren) {
			obj.children = compilation.children.map(function(child) {
				var obj = new Stats(child).toJson(options, forToString);
				delete obj.hash;
				delete obj.version;
				obj.name = child.name;
				return obj;
			});
		}
		return obj;
	};
	
	Stats.prototype.toString = function toString(options) {
		if(typeof options === "boolean" || typeof options === "string") {
			options = Stats.presetToOptions(options);
		} else if(!options) options = {};
	
		function d(v, def) {
			return v === undefined ? def : v;
		}
		var useColors = d(options.colors, false);
	
		var obj = this.toJson(options, true);
	
		return Stats.jsonToString(obj, useColors);
	};
	
	Stats.jsonToString = function jsonToString(obj, useColors) {
		var buf = [];
	
		function normal(str) {
			buf.push(str);
		}
	
		function bold(str) {
			if(useColors) buf.push("\u001b[1m");
			buf.push(str);
			if(useColors) buf.push("\u001b[22m");
		}
	
		function yellow(str) {
			if(useColors) buf.push("\u001b[1m\u001b[33m");
			buf.push(str);
			if(useColors) buf.push("\u001b[39m\u001b[22m");
		}
	
		function red(str) {
			if(useColors) buf.push("\u001b[1m\u001b[31m");
			buf.push(str);
			if(useColors) buf.push("\u001b[39m\u001b[22m");
		}
	
		function green(str) {
			if(useColors) buf.push("\u001b[1m\u001b[32m");
			buf.push(str);
			if(useColors) buf.push("\u001b[39m\u001b[22m");
		}
	
		function cyan(str) {
			if(useColors) buf.push("\u001b[1m\u001b[36m");
			buf.push(str);
			if(useColors) buf.push("\u001b[39m\u001b[22m");
		}
	
		function magenta(str) {
			if(useColors) buf.push("\u001b[1m\u001b[35m");
			buf.push(str);
			if(useColors) buf.push("\u001b[39m\u001b[22m");
		}
	
		function coloredTime(time) {
			var times = [800, 400, 200, 100];
			if(obj.time) {
				times = [obj.time / 2, obj.time / 4, obj.time / 8, obj.time / 16];
			}
			if(time < times[3])
				normal(time + "ms");
			else if(time < times[2])
				bold(time + "ms");
			else if(time < times[1])
				green(time + "ms");
			else if(time < times[0])
				yellow(time + "ms");
			else
				red(time + "ms");
		}
	
		function newline() {
			buf.push("\n");
		}
	
		function table(array, formats, align, splitter) {
			var rows = array.length;
			var cols = array[0].length;
			var colSizes = new Array(cols);
			for(var col = 0; col < cols; col++)
				colSizes[col] = 3;
			for(var row = 0; row < rows; row++) {
				for(var col = 0; col < cols; col++) {
					var value = array[row][col] + "";
					if(value.length > colSizes[col]) {
						colSizes[col] = value.length;
					}
				}
			}
			for(var row = 0; row < rows; row++) {
				for(var col = 0; col < cols; col++) {
					var format = row === 0 ? bold : formats[col];
					var value = array[row][col] + "";
					var l = value.length;
					if(align[col] === "l")
						format(value);
					for(; l < colSizes[col] && col !== cols - 1; l++)
						normal(" ");
					if(align[col] === "r")
						format(value);
					if(col + 1 < cols)
						normal(splitter || "  ");
				}
				newline();
			}
		}
	
		function formatSize(size) {
			if(size <= 0) return "0 bytes";
	
			var abbreviations = ["bytes", "kB", "MB", "GB"];
			var index = Math.floor(Math.log(size) / Math.log(1000));
	
			return +(size / Math.pow(1000, index))
				.toPrecision(3) + " " + abbreviations[index];
		}
	
		if(obj.hash) {
			normal("Hash: ");
			bold(obj.hash);
			newline();
		}
		if(obj.version) {
			normal("Version: webpack ");
			bold(obj.version);
			newline();
		}
		if(typeof obj.time === "number") {
			normal("Time: ");
			bold(obj.time);
			normal("ms");
			newline();
		}
		if(obj.publicPath) {
			normal("PublicPath: ");
			bold(obj.publicPath);
			newline();
		}
		if(obj.assets && obj.assets.length > 0) {
			var t = [
				["Asset", "Size", "Chunks", "", "Chunk Names"]
			];
			obj.assets.forEach(function(asset) {
				t.push([
					asset.name,
					formatSize(asset.size),
					asset.chunks.join(", "),
					asset.emitted ? "[emitted]" : "",
					asset.chunkNames.join(", ")
				]);
			});
			table(t, [green, normal, bold, green, normal], "rrrll");
		}
		var modulesByIdentifier = {};
		if(obj.modules) {
			obj.modules.forEach(function(module) {
				modulesByIdentifier["$" + module.identifier] = module;
			});
		} else if(obj.chunks) {
			obj.chunks.forEach(function(chunk) {
				if(chunk.modules) {
					chunk.modules.forEach(function(module) {
						modulesByIdentifier["$" + module.identifier] = module;
					});
				}
			});
		}
	
		function processProfile(module) {
			if(module.profile) {
				normal("      ");
				var sum = 0,
					allowSum = true;
				var path = [];
				var current = module;
				while(current.issuer) {
					if(!modulesByIdentifier["$" + current.issuer]) {
						normal(" ... ->");
						allowSum = false;
						break;
					}
					path.unshift(current = modulesByIdentifier["$" + current.issuer]);
				}
				path.forEach(function(module) {
					normal(" [");
					normal(module.id);
					normal("] ");
					if(module.profile) {
						var time = (module.profile.factory || 0) + (module.profile.building || 0);
						coloredTime(time);
						sum += time;
						normal(" ");
					}
					normal("->");
				});
				Object.keys(module.profile).forEach(function(key) {
					normal(" " + key + ":");
					var time = module.profile[key];
					coloredTime(time);
					sum += time;
				});
				if(allowSum) {
					normal(" = ");
					coloredTime(sum);
				}
				newline();
			}
		}
	
		function processModuleAttributes(module) {
			normal(" ");
			normal(formatSize(module.size));
			if(module.chunks) {
				module.chunks.forEach(function(chunk) {
					normal(" {");
					yellow(chunk);
					normal("}");
				});
			}
			if(!module.cacheable) {
				red(" [not cacheable]");
			}
			if(module.optional) {
				yellow(" [optional]");
			}
			if(module.built) {
				green(" [built]");
			}
			if(module.prefetched) {
				magenta(" [prefetched]");
			}
			if(module.failed)
				red(" [failed]");
			if(module.warnings)
				yellow(" [" + module.warnings + " warning" + (module.warnings === 1 ? "" : "s") + "]");
			if(module.errors)
				red(" [" + module.errors + " error" + (module.errors === 1 ? "" : "s") + "]");
		}
		if(obj.chunks) {
			obj.chunks.forEach(function(chunk) {
				normal("chunk ");
				if(chunk.id < 1000) normal(" ");
				if(chunk.id < 100) normal(" ");
				if(chunk.id < 10) normal(" ");
				normal("{");
				yellow(chunk.id);
				normal("} ");
				green(chunk.files.join(", "));
				if(chunk.names && chunk.names.length > 0) {
					normal(" (");
					normal(chunk.names.join(", "));
					normal(")");
				}
				normal(" ");
				normal(formatSize(chunk.size));
				chunk.parents.forEach(function(id) {
					normal(" {");
					yellow(id);
					normal("}");
				});
				if(chunk.rendered) {
					green(" [rendered]");
				}
				newline();
				if(chunk.origins) {
					chunk.origins.forEach(function(origin) {
						normal("    > ");
						if(origin.reasons && origin.reasons.length) {
							yellow(origin.reasons.join(" "));
							normal(" ");
						}
						if(origin.name) {
							normal(origin.name);
							normal(" ");
						}
						if(origin.module) {
							normal("[");
							normal(origin.moduleId);
							normal("] ");
							var module = modulesByIdentifier["$" + origin.module];
							if(module) {
								bold(module.name);
								normal(" ");
							}
							if(origin.loc) {
								normal(origin.loc);
							}
						}
						newline();
					});
				}
				if(chunk.modules) {
					chunk.modules.forEach(function(module) {
						normal(" ");
						if(module.id < 1000) normal(" ");
						if(module.id < 100) normal(" ");
						if(module.id < 10) normal(" ");
						normal("[");
						normal(module.id);
						normal("] ");
						bold(module.name);
						processModuleAttributes(module);
						newline();
						if(module.reasons) {
							module.reasons.forEach(function(reason) {
								normal("        ");
								normal(reason.type);
								normal(" ");
								cyan(reason.userRequest);
								if(reason.templateModules) cyan(reason.templateModules.join(" "));
								normal(" [");
								normal(reason.moduleId);
								normal("] ");
								magenta(reason.module);
								if(reason.loc) {
									normal(" ");
									normal(reason.loc);
								}
								newline();
							});
						}
						processProfile(module);
					});
					if(chunk.filteredModules > 0) {
						normal("     + " + chunk.filteredModules + " hidden modules");
						newline();
					}
				}
			});
		}
		if(obj.modules) {
			obj.modules.forEach(function(module) {
				if(module.id < 1000) normal(" ");
				if(module.id < 100) normal(" ");
				if(module.id < 10) normal(" ");
				normal("[");
				normal(module.id);
				normal("] ");
				bold(module.name || module.identifier);
				processModuleAttributes(module);
				newline();
				if(module.reasons) {
					module.reasons.forEach(function(reason) {
						normal("       ");
						normal(reason.type);
						normal(" ");
						cyan(reason.userRequest);
						if(reason.templateModules) cyan(reason.templateModules.join(" "));
						normal(" [");
						normal(reason.moduleId);
						normal("] ");
						magenta(reason.module);
						if(reason.loc) {
							normal(" ");
							normal(reason.loc);
						}
						newline();
					});
				}
				processProfile(module);
			});
			if(obj.filteredModules > 0) {
				normal("    + " + obj.filteredModules + " hidden modules");
				newline();
			}
		}
		if(obj._showWarnings && obj.warnings) {
			obj.warnings.forEach(function(warning) {
				newline();
				yellow("WARNING in " + warning);
				newline();
			});
		}
		if(obj._showErrors && obj.errors) {
			obj.errors.forEach(function(error) {
				newline();
				red("ERROR in " + error);
				newline();
			});
		}
		if(obj.children) {
			obj.children.forEach(function(child) {
				if(child.name) {
					normal("Child ");
					bold(child.name);
					normal(":");
				} else {
					normal("Child");
				}
				newline();
				buf.push("    ");
				buf.push(Stats.jsonToString(child, useColors).replace(/\n/g, "\n    "));
				newline();
			});
		}
	
		while(buf[buf.length - 1] === "\n") buf.pop();
		return buf.join("");
	};
	
	Stats.presetToOptions = function(name) {
		//Accepted values: none, errors-only, minimal, normal, verbose
		//Any other falsy value will behave as 'none', truthy values as 'normal'
		var pn = (typeof name === "string") && name.toLowerCase() || name;
		if(pn === "none" || !pn) {
			return {
				hash: false,
				version: false,
				timings: false,
				assets: false,
				chunks: false,
				modules: false,
				reasons: false,
				children: false,
				source: false,
				errors: false,
				errorDetails: false,
				warnings: false,
				publicPath: false
			};
		} else {
			return {
				assets: pn === "verbose",
				version: pn === "verbose",
				timings: pn !== "errors-only" && pn !== "minimal",
				hash: pn !== "errors-only" && pn !== "minimal",
				chunks: pn !== "errors-only",
				chunkModules: pn === "verbose",
				//warnings: pn !== "errors-only",
				errorDetails: pn !== "errors-only" && pn !== "minimal",
				reasons: pn === "verbose",
				colors: true
			};
		}
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(180);
	
	function RequestShortener(directory) {
		var parentDirectory = path.dirname(directory);
		if(/[\/\\]$/.test(directory)) directory = directory.substr(0, directory.length - 1);
		if(directory) {
			var currentDirectoryRegExp = directory.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
			currentDirectoryRegExp = new RegExp("^" + currentDirectoryRegExp + "|(!)" + currentDirectoryRegExp, "g");
	
			this.currentDirectoryRegExp = currentDirectoryRegExp;
		}
	
		if(/[\/\\]$/.test(parentDirectory)) parentDirectory = parentDirectory.substr(0, parentDirectory.length - 1);
		if(parentDirectory && parentDirectory !== directory) {
			var parentDirectoryRegExp = parentDirectory.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
			parentDirectoryRegExp = new RegExp("^" + parentDirectoryRegExp + "|(!)" + parentDirectoryRegExp, "g");
	
			this.parentDirectoryRegExp = parentDirectoryRegExp;
		}
	
		if(__dirname.length >= 2) {
			var buildins = path.join(__dirname, "..");
			var buildinsAsModule = currentDirectoryRegExp && currentDirectoryRegExp.test(buildins);
			var buildinsRegExp = buildins.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
			buildinsRegExp = new RegExp("^" + buildinsRegExp + "|(!)" + buildinsRegExp, "g");
	
			this.buildinsAsModule = buildinsAsModule;
			this.buildinsRegExp = buildinsRegExp;
		}
	
		this.nodeModulesRegExp = /\/node_modules\//g;
		this.indexJsRegExp = /\/index.js(!|\?|\(query\))/g;
	}
	module.exports = RequestShortener;
	
	RequestShortener.prototype.shorten = function(request) {
		if(!request)
			return request;
		if(this.buildinsAsModule && this.buildinsRegExp)
			request = request.replace(this.buildinsRegExp, "!(webpack)");
		if(this.currentDirectoryRegExp)
			request = request.replace(this.currentDirectoryRegExp, "!.");
		if(this.parentDirectoryRegExp)
			request = request.replace(this.parentDirectoryRegExp, "!..");
		if(!this.buildinsAsModule && this.buildinsRegExp)
			request = request.replace(this.buildinsRegExp, "!(webpack)");
		request = request.replace(/\\/g, "/");
		request = request.replace(this.nodeModulesRegExp, "/~/");
		request = request.replace(this.indexJsRegExp, "$1");
		return request.replace(/^!|!$/, "");
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(221);
	var OriginalSource = __webpack_require__(222);
	var PrefixSource = __webpack_require__(223);
	var Template = __webpack_require__(224);
	
	function MainTemplate(outputOptions) {
		Template.call(this, outputOptions);
		this.plugin("startup", function(source, chunk, hash) {
			var buf = [];
			if(chunk.modules.some(function(m) {
					return m.id === 0;
				})) {
				buf.push("");
				buf.push("// Load entry module and return exports");
				buf.push("return " + this.renderRequireFunctionForModule(hash, chunk, "0") + "(0);");
			}
			return this.asString(buf);
		});
		this.plugin("render", function(bootstrapSource, chunk, hash, moduleTemplate, dependencyTemplates) {
			var source = new ConcatSource();
			source.add("/******/ (function(modules) { // webpackBootstrap\n");
			source.add(new PrefixSource("/******/", bootstrapSource));
			source.add("/******/ })\n");
			source.add("/************************************************************************/\n");
			source.add("/******/ (");
			var modules = this.renderChunkModules(chunk, moduleTemplate, dependencyTemplates, "/******/ ");
			source.add(this.applyPluginsWaterfall("modules", modules, chunk, hash, moduleTemplate, dependencyTemplates));
			source.add(")");
			return source;
		});
		this.plugin("local-vars", function(source /*, chunk, hash*/ ) {
			return this.asString([
				source,
				"// The module cache",
				"var installedModules = {};"
			]);
		});
		this.plugin("require", function(source, chunk, hash) {
			return this.asString([
				source,
				"// Check if module is in cache",
				"if(installedModules[moduleId])",
				this.indent("return installedModules[moduleId].exports;"),
				"",
				"// Create a new module (and put it into the cache)",
				"var module = installedModules[moduleId] = {",
				this.indent(this.applyPluginsWaterfall("module-obj", "", chunk, hash, "moduleId")),
				"};",
				"",
				"// Execute the module function",
				"modules[moduleId].call(module.exports, module, module.exports, " + this.renderRequireFunctionForModule(hash, chunk, "moduleId") + ");",
				"",
				"// Flag the module as loaded",
				"module.loaded = true;",
				"",
				"// Return the exports of the module",
				"return module.exports;"
			]);
		});
		this.plugin("module-obj", function( /*source, chunk, hash, varModuleId*/ ) {
			return this.asString([
				"exports: {},",
				"id: moduleId,",
				"loaded: false"
			]);
		});
		this.plugin("require-extensions", function(source, chunk, hash) {
			var buf = [];
			if(chunk.chunks.length > 0) {
				buf.push("// This file contains only the entry chunk.");
				buf.push("// The chunk loading function for additional chunks");
				buf.push(this.requireFn + ".e = function requireEnsure(chunkId, callback) {");
				buf.push(this.indent(this.applyPluginsWaterfall("require-ensure", "throw new Error('Not chunk loading available');", chunk, hash, "chunkId")));
				buf.push("};");
			}
			buf.push("");
			buf.push("// expose the modules object (__webpack_modules__)");
			buf.push(this.requireFn + ".m = modules;");
	
			buf.push("");
			buf.push("// expose the module cache");
			buf.push(this.requireFn + ".c = installedModules;");
	
			var publicPath = this.getPublicPath({
				hash: hash
			});
			buf.push("");
			buf.push("// __webpack_public_path__");
			buf.push(this.requireFn + ".p = " + JSON.stringify(publicPath) + ";");
			return this.asString(buf);
		});
	}
	module.exports = MainTemplate;
	
	MainTemplate.prototype = Object.create(Template.prototype);
	MainTemplate.prototype.requireFn = "__webpack_require__";
	MainTemplate.prototype.render = function(hash, chunk, moduleTemplate, dependencyTemplates) {
		var buf = [];
		buf.push(this.applyPluginsWaterfall("bootstrap", "", chunk, hash, moduleTemplate, dependencyTemplates));
		buf.push(this.applyPluginsWaterfall("local-vars", "", chunk, hash));
		buf.push("");
		buf.push("// The require function");
		buf.push("function " + this.requireFn + "(moduleId) {");
		buf.push(this.indent(this.applyPluginsWaterfall("require", "", chunk, hash)));
		buf.push("}");
		buf.push("");
		buf.push(this.asString(this.applyPluginsWaterfall("require-extensions", "", chunk, hash)));
		buf.push(this.asString(this.applyPluginsWaterfall("startup", "", chunk, hash)));
		var source = this.applyPluginsWaterfall("render", new OriginalSource(this.prefix(buf, " \t") + "\n", "webpack/bootstrap " + hash), chunk, hash, moduleTemplate, dependencyTemplates);
		if(chunk.modules.some(function(module) {
				return module.id === 0;
			})) {
			source = this.applyPluginsWaterfall("render-with-entry", source, chunk, hash);
		}
		if(!source) throw new Error("Compiler error: MainTemplate plugin 'render' should return something");
		chunk.rendered = true;
		return new ConcatSource(source, ";");
	};
	
	MainTemplate.prototype.renderRequireFunctionForModule = function(hash, chunk, varModuleId) {
		return this.applyPluginsWaterfall("module-require", this.requireFn, chunk, hash, varModuleId);
	};
	
	MainTemplate.prototype.renderAddModule = function(hash, chunk, varModuleId, varModule) {
		return this.applyPluginsWaterfall("add-module", "modules[" + varModuleId + "] = " + varModule + ";", chunk, hash, varModuleId, varModule);
	};
	
	MainTemplate.prototype.renderCurrentHashCode = function(hash, length) {
		length = length || Infinity;
		return this.applyPluginsWaterfall("current-hash", JSON.stringify(hash.substr(0, length)), length);
	};
	
	MainTemplate.prototype.entryPointInChildren = function(chunk) {
		function checkChildren(chunk, alreadyCheckedChunks) {
			return chunk.chunks.some(function(child) {
				if(alreadyCheckedChunks.indexOf(child) >= 0) return;
				alreadyCheckedChunks.push(child);
				return child.modules.some(function(module) {
					return module.id === 0;
				}) || checkChildren(child, alreadyCheckedChunks);
			});
		}
		return checkChildren(chunk, []);
	};
	
	MainTemplate.prototype.getPublicPath = function(options) {
		return this.applyPluginsWaterfall("asset-path", this.outputOptions.publicPath || "", options);
	};
	
	MainTemplate.prototype.updateHash = function(hash) {
		hash.update("maintemplate");
		hash.update("3");
		hash.update(this.outputOptions.publicPath + "");
		this.applyPlugins("hash", hash);
	};
	
	MainTemplate.prototype.updateHashForChunk = function(hash, chunk) {
		this.updateHash(hash);
		this.applyPlugins("hash-for-chunk", hash, chunk);
	};
	
	MainTemplate.prototype.useChunkHash = function(chunk) {
		var paths = this.applyPluginsWaterfall("global-hash-paths", []);
		return !this.applyPluginsBailResult("global-hash", chunk, paths);
	};


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(193).SourceNode;
	var SourceListMap = __webpack_require__(204).SourceListMap;
	var Source = __webpack_require__(192);
	
	function ConcatSource() {
		Source.call(this);
		this.children = Array.prototype.slice.call(arguments);
	}
	module.exports = ConcatSource;
	
	ConcatSource.prototype = Object.create(Source.prototype);
	ConcatSource.prototype.constructor = ConcatSource;
	
	ConcatSource.prototype.add = function(item) {
		this.children.push(item);
	};
	
	ConcatSource.prototype.source = function() {
		return this.children.map(function(item) {
			return typeof item === "string" ? item : item.source();
		}).join("");
	};
	
	ConcatSource.prototype.size = function() {
		return this.children.map(function(item) {
			return typeof item === "string" ? item.length : item.size();
		}).reduce(function(sum, s) { return sum + s; }, 0);
	};
	
	__webpack_require__(212)(ConcatSource.prototype);
	
	ConcatSource.prototype.node = function(options) {
		var node = new SourceNode(null, null, null, this.children.map(function(item) {
			return typeof item === "string" ? item : item.node(options);
		}));
		return node;
	};
	
	ConcatSource.prototype.listMap = function(options) {
		var map = new SourceListMap();
		this.children.forEach(function(item) {
			if(typeof item === "string")
				map.add(item);
			else
				map.add(item.listMap(options));
		});
		return map;
	};
	
	ConcatSource.prototype.updateHash = function(hash) {
		this.children.forEach(function(item) {
			item.updateHash(hash);
		});
	};


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(193).SourceNode;
	var SourceMapConsumer = __webpack_require__(193).SourceMapConsumer;
	var SourceListMap = __webpack_require__(204).SourceListMap;
	var Source = __webpack_require__(192);
	
	function isSplitter(c) {
		switch(c) {
		case 10: // \n
		case 13: // \r
		case 59: // ;
		case 123: // {
		case 125: // }
		return true;
		}
		return false;
	}
	function _splitCode(code) {
		var result = [];
		var i = 0, j = 0;
		for(; i < code.length; i++) {
			if(isSplitter(code.charCodeAt(i))) {
				while(isSplitter(code.charCodeAt(++i)));
				result.push(code.substring(j, i));
				j = i;
			}
		}
		if(j < code.length)
			result.push(code.substr(j));
		return result;
	}
	
	function OriginalSource(value, name) {
		Source.call(this);
		this._value = value;
		this._name = name;
	}
	
	module.exports = OriginalSource;
	
	OriginalSource.prototype = Object.create(Source.prototype);
	OriginalSource.prototype.constructor = OriginalSource;
	
	OriginalSource.prototype.source = function() {
		return this._value;
	};
	
	__webpack_require__(212)(OriginalSource.prototype);
	
	OriginalSource.prototype.node = function(options) {
		options = options || {};
		var sourceMap = this._sourceMap;
		var value = this._value;
		var name = this._name;
		var lines = value.split("\n");
		var node = new SourceNode(null, null, null,
			lines.map(function(line, idx) {
				var pos = 0;
				if(options.columns === false) {
					return new SourceNode(idx+1, 0, name,
						(line + (idx != lines.length-1 ? "\n" : ""))
					);
				}
				return new SourceNode(null, null, null,
					_splitCode(line + (idx != lines.length-1 ? "\n" : "")).map(function(item) {
						if(/^\s*$/.test(item)) return item;
						var res = new SourceNode(idx+1, pos, name, item);
						pos += item.length;
						return res;
					})
				);
			})
		);
		node.setSourceContent(name, value);
		return node;
	};
	
	OriginalSource.prototype.listMap = function(options) {
		return new SourceListMap(this._value, this._name, this._value)
	};
	
	OriginalSource.prototype.updateHash = function(hash) {
		hash.update(this._value);
	};


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Source = __webpack_require__(192);
	var SourceNode = __webpack_require__(193).SourceNode;
	
	function PrefixSource(prefix, source) {
		Source.call(this);
		this._source = source;
		this._prefix = prefix;
	}
	module.exports = PrefixSource;
	
	PrefixSource.prototype = Object.create(Source.prototype);
	PrefixSource.prototype.constructor = PrefixSource;
	
	PrefixSource.prototype.source = function() {
		var node = typeof this._source === "string" ? this._source : this._source.source();
		var prefix = this._prefix;
		return prefix + node.replace(/\n(.)/g, "\n" + prefix + "$1");
	};
	
	__webpack_require__(212)(PrefixSource.prototype);
	
	PrefixSource.prototype.node = function(options) {
		var node = this._source.node(options);
		var append = [this._prefix];
		return new SourceNode(null, null, null, [
			cloneAndPrefix(node, this._prefix, append)
		]);
	};
	
	PrefixSource.prototype.listMap = function(options) {
		var prefix = this._prefix;
		var map = this._source.listMap(options);
		map.mapGeneratedCode(function(code) {
			return prefix + code.replace(/\n(.)/g, "\n" + prefix + "$1");
		});
		return map;
	};
	
	PrefixSource.prototype.updateHash = function(hash) {
		if(typeof this._source === "string")
			hash.update(this._source);
		else
			this._source.updateHash(hash);
		if(typeof this._prefix === "string")
			hash.update(this._prefix);
		else
			this._prefix.updateHash(hash);
	};
	
	function cloneAndPrefix(node, prefix, append) {
		if(typeof node === "string") {
			var result = node.replace(/\n(.)/g, "\n" + prefix + "$1");
			if(append.length > 0) result = append.pop() + result;
			if(/\n$/.test(node)) append.push(prefix);
			return result;
		} else {
			var newNode = new SourceNode(
				node.line,
				node.column,
				node.source,
				node.children.map(function(node) {
					return cloneAndPrefix(node, prefix, append);
				}),
				node.name
			);
			newNode.sourceContents = node.sourceContents;
			return newNode;
		}
	};


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Tapable = __webpack_require__(181);
	var ConcatSource = __webpack_require__(221);
	
	function Template(outputOptions) {
		Tapable.call(this);
		this.outputOptions = outputOptions || {};
	}
	module.exports = Template;
	
	Template.getFunctionContent = function(fn) {
		return fn.toString().replace(/^function\s?\(\)\s?\{\n?|\n?\}$/g, "").replace(/^\t/mg, "");
	};
	
	Template.toIdentifier = function(str) {
		if(typeof str !== "string") return "";
		return str.replace(/^[^a-zA-Z$_]/, "_").replace(/[^a-zA-Z0-9$_]/g, "_");
	};
	
	Template.prototype = Object.create(Tapable.prototype);
	Template.prototype.constructor = Template;
	
	Template.prototype.indent = function indent(str) {
		if(Array.isArray(str)) {
			return str.map(indent).join("\n");
		} else {
			str = str.trimRight();
			if(!str) return "";
			var ind = (str[0] === "\n" ? "" : "\t");
			return ind + str.replace(/\n([^\n])/g, "\n\t$1");
		}
	};
	
	Template.prototype.prefix = function(str, prefix) {
		if(Array.isArray(str)) {
			str = str.join("\n");
		}
		str = str.trim();
		if(!str) return "";
		var ind = (str[0] === "\n" ? "" : prefix);
		return ind + str.replace(/\n([^\n])/g, "\n" + prefix + "$1");
	};
	
	Template.prototype.asString = function(str) {
		if(Array.isArray(str)) {
			return str.join("\n");
		}
		return str;
	};
	
	Template.prototype.getModulesArrayBounds = function(modules) {
		if(modules.some(function(module) {
				return typeof module.id !== "number";
			}))
			return false;
		var maxId = -Infinity;
		var minId = Infinity;
		modules.forEach(function(module) {
			if(maxId < module.id) maxId = module.id;
			if(minId > module.id) minId = module.id;
		});
		if(minId < 16 + ("" + minId).length) {
			// add minId x ',' instead of 'Array(minId).concat(...)'
			minId = 0;
		}
		var objectOverhead = modules.map(function(module) {
			var idLength = (module.id + "").length;
			return idLength + 2;
		}).reduce(function(a, b) {
			return a + b;
		}, -1);
		var arrayOverhead = minId === 0 ? maxId : 16 + ("" + minId).length + maxId;
		return arrayOverhead < objectOverhead ? [minId, maxId] : false;
	};
	
	Template.prototype.renderChunkModules = function(chunk, moduleTemplate, dependencyTemplates, prefix) {
		if(!prefix) prefix = "";
		var source = new ConcatSource();
		if(chunk.modules.length === 0) {
			source.add("[]");
			return source;
		}
		var bounds = this.getModulesArrayBounds(chunk.modules);
		if(bounds) {
			// Render a spare array
			var minId = bounds[0];
			var maxId = bounds[1];
			if(minId !== 0) source.add("Array(" + minId + ").concat(");
			source.add("[\n");
			var modules = {};
			chunk.modules.forEach(function(module) {
				modules[module.id] = module;
			});
			for(var idx = minId; idx <= maxId; idx++) {
				var module = modules[idx];
				if(idx !== minId) source.add(",\n");
				source.add("/* " + idx + " */");
				if(module) {
					source.add("\n");
					source.add(moduleTemplate.render(module, dependencyTemplates, chunk));
				}
			}
			source.add("\n" + prefix + "]");
			if(minId !== 0) source.add(")");
		} else {
			// Render an object
			source.add("{\n");
			chunk.modules.forEach(function(module, idx) {
				if(idx !== 0) source.add(",\n");
				source.add("\n/***/ " + JSON.stringify(module.id) + ":\n");
				source.add(moduleTemplate.render(module, dependencyTemplates, chunk));
			});
			source.add("\n\n" + prefix + "}");
		}
		return source;
	};


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(221);
	var Template = __webpack_require__(224);
	
	function ChunkTemplate(outputOptions) {
		Template.call(this, outputOptions);
	}
	
	module.exports = ChunkTemplate;
	
	ChunkTemplate.prototype = Object.create(Template.prototype);
	ChunkTemplate.prototype.render = function(chunk, moduleTemplate, dependencyTemplates) {
		var modules = this.renderChunkModules(chunk, moduleTemplate, dependencyTemplates);
		var core = this.applyPluginsWaterfall("modules", modules, chunk, moduleTemplate, dependencyTemplates);
		var source = this.applyPluginsWaterfall("render", core, chunk, moduleTemplate, dependencyTemplates);
		if(chunk.modules.some(function(module) {
				return module.id === 0;
			})) {
			source = this.applyPluginsWaterfall("render-with-entry", source, chunk);
		}
		chunk.rendered = true;
		return new ConcatSource(source, ";");
	};
	
	ChunkTemplate.prototype.updateHash = function(hash) {
		hash.update("ChunkTemplate");
		hash.update("2");
		this.applyPlugins("hash", hash);
	};
	
	ChunkTemplate.prototype.updateHashForChunk = function(hash, chunk) {
		this.updateHash(hash);
		this.applyPlugins("hash-for-chunk", hash, chunk);
	};


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Template = __webpack_require__(224);
	
	function HotUpdateChunkTemplate(outputOptions) {
		Template.call(this, outputOptions);
	}
	
	module.exports = HotUpdateChunkTemplate;
	
	HotUpdateChunkTemplate.prototype = Object.create(Template.prototype);
	HotUpdateChunkTemplate.prototype.render = function(id, modules, hash, moduleTemplate, dependencyTemplates) {
		var modulesSource = this.renderChunkModules({
			id: id,
			modules: modules
		}, moduleTemplate, dependencyTemplates);
		var core = this.applyPluginsWaterfall("modules", modulesSource, modules, moduleTemplate, dependencyTemplates);
		var source = this.applyPluginsWaterfall("render", core, modules, hash, id, moduleTemplate, dependencyTemplates);
		return source;
	};
	
	HotUpdateChunkTemplate.prototype.updateHash = function(hash) {
		hash.update("HotUpdateChunkTemplate");
		hash.update("1");
		this.applyPlugins("hash", hash);
	};


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Template = __webpack_require__(224);
	
	function ModuleTemplate(outputOptions) {
		Template.call(this, outputOptions);
	}
	module.exports = ModuleTemplate;
	
	ModuleTemplate.prototype = Object.create(Template.prototype);
	ModuleTemplate.prototype.render = function(module, dependencyTemplates, chunk) {
		var moduleSource = module.source(dependencyTemplates, this.outputOptions, this.requestShortener);
		moduleSource = this.applyPluginsWaterfall("module", moduleSource, module, chunk, dependencyTemplates);
		moduleSource = this.applyPluginsWaterfall("render", moduleSource, module, chunk, dependencyTemplates);
		return this.applyPluginsWaterfall("package", moduleSource, module, chunk, dependencyTemplates);
	};
	
	ModuleTemplate.prototype.updateHash = function(hash) {
		hash.update("1");
		this.applyPlugins("hash", hash);
	};


/***/ },
/* 228 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function Dependency() {
		this.module = null;
		this.Class = Dependency;
	}
	module.exports = Dependency;
	
	Dependency.prototype.isEqualResource = function( /* other */ ) {
		return false;
	};
	
	Dependency.prototype.updateHash = function(hash) {
		hash.update((this.module && this.module.id) + "");
	};
	
	Dependency.prototype.disconnect = function() {
		this.module = null;
	};
	
	Dependency.compare = function(a, b) {
		return Dependency.compareLocations(a.loc, b.loc);
	};
	
	Dependency.compareLocations = function(a, b) {
		if(typeof a === "string") {
			if(typeof b === "string") {
				if(a < b) return -1;
				if(a > b) return 1;
				return 0;
			} else if(typeof b === "object") {
				return 1;
			} else {
				return 0;
			}
		} else if(typeof a === "object") {
			if(typeof b === "string") {
				return -1;
			} else if(typeof b === "object") {
				if(a.start) a = a.start;
				if(b.start) b = b.start;
				if(a.line < b.line) return -1;
				if(a.line > b.line) return 1;
				if(a.column < b.column) return -1;
				if(a.column > b.column) return 1;
				if(a.index < b.index) return -1;
				if(a.index > b.index) return 1;
				return 0;
			} else {
				return 0;
			}
		}
	};


/***/ },
/* 229 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ChunkRenderError(chunk, file, error) {
		Error.call(this);
		Error.captureStackTrace(this, ChunkRenderError);
		this.name = "ChunkRenderError";
		this.error = error;
		this.message = error.message;
		this.details = error.stack;
		this.file = file;
		this.chunk = chunk;
	}
	module.exports = ChunkRenderError;
	
	ChunkRenderError.prototype = Object.create(Error.prototype);


/***/ },
/* 230 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function CachedSource(source) {
		this._source = source;
		this._cachedSource = undefined;
		this._cachedSize = undefined;
		this._cachedMaps = {};
	}
	module.exports = CachedSource;
	
	CachedSource.prototype.source = function() {
		if(typeof this._cachedSource !== "undefined") return this._cachedSource;
		return this._cachedSource = this._source.source();
	};
	
	CachedSource.prototype.size = function() {
		if(typeof this._cachedSize !== "undefined") return this._cachedSize;
		if(typeof this._cachedSource !== "undefined")
			return this._cachedSize = this._cachedSource.length;
		return this._cachedSize = this._source.size();
	};
	
	CachedSource.prototype.sourceAndMap = function(options) {
		var key = JSON.stringify(options);
		if(typeof this._cachedSource !== "undefined" && key in this._cachedMaps)
			return { source: this._cachedSource, map: this._cachedMaps[key] };
		else if(typeof this._cachedSource !== "undefined") {
			return { source: this._cachedSource, map: this._cachedMaps[key] = this._source.map(options) };
		} else if(key in this._cachedMaps) {
			return { source: this._cachedSource = this._source.source(), map: this._cachedMaps[key] };
		}
		var result = this._source.sourceAndMap(options);
		this._cachedSource = result.source;
		this._cachedMaps[key] = result.map;
		return { source: this._cachedSource, map: this._cachedMaps[key] };
	};
	
	CachedSource.prototype.node = function(options) {
		return this._source.node(options);
	};
	
	CachedSource.prototype.listMap = function(options) {
		return this._source.listMap(options);
	}
	
	CachedSource.prototype.map = function(options) {
		if(!options) options = {};
		var key = JSON.stringify(options);
		if(key in this._cachedMaps)
			return this._cachedMaps[key];
		return this._cachedMaps[key] = this._source.map();
	};
	
	CachedSource.prototype.updateHash = function(hash) {
		this._source.updateHash(hash);
	};


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(232)
	
	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}
	
	exports.createHash = __webpack_require__(234)
	
	exports.createHmac = __webpack_require__(246)
	
	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}
	
	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}
	
	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}
	
	var p = __webpack_require__(247)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync
	
	
	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createCipher'
	, 'createCipheriv'
	, 'createDecipher'
	, 'createDecipheriv'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176).Buffer))

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(233)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	    
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(176).Buffer))

/***/ },
/* 233 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(235)
	
	var md5 = toConstructor(__webpack_require__(243))
	var rmd160 = toConstructor(__webpack_require__(245))
	
	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}
	
	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176).Buffer))

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}
	
	var Buffer = __webpack_require__(176).Buffer
	var Hash   = __webpack_require__(236)(Buffer)
	
	exports.sha1 = __webpack_require__(237)(Buffer, Hash)
	exports.sha256 = __webpack_require__(241)(Buffer, Hash)
	exports.sha512 = __webpack_require__(242)(Buffer, Hash)


/***/ },
/* 236 */
/***/ function(module, exports) {

	module.exports = function (Buffer) {
	
	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }
	
	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }
	
	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }
	
	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block
	
	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)
	
	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }
	
	      s += ch
	      f += ch
	
	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s
	
	    return this
	  }
	
	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8
	
	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80
	
	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)
	
	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }
	
	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)
	
	    var hash = this._update(this._block) || this._hash()
	
	    return enc ? hash.toString(enc) : hash
	  }
	
	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }
	
	  return Hash
	}


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */
	
	var inherits = __webpack_require__(238).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0
	
	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)
	
	  var POOL = []
	
	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()
	
	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)
	
	    this._h = null
	    this.init()
	  }
	
	  inherits(Sha1, Hash)
	
	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0
	
	    Hash.prototype.init.call(this)
	    return this
	  }
	
	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {
	
	    var a, b, c, d, e, _a, _b, _c, _d, _e
	
	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e
	
	    var w = this._w
	
	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)
	
	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )
	
	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }
	
	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }
	
	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }
	
	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }
	
	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }
	
	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }
	
	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }
	
	  return Sha1
	}


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(239);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(240);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5)))

/***/ },
/* 239 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 240 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */
	
	var inherits = __webpack_require__(238).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]
	
	  var W = new Array(64)
	
	  function Sha256() {
	    this.init()
	
	    this._w = W //new Array(64)
	
	    Hash.call(this, 16*4, 14*4)
	  }
	
	  inherits(Sha256, Hash)
	
	  Sha256.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }
	
	  function R (X, n) {
	    return (X >>> n);
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }
	
	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }
	
	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }
	
	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }
	
	  Sha256.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]
	
	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w
	
	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }
	
	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0
	
	  };
	
	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)
	
	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)
	
	    return H
	  }
	
	  return Sha256
	
	}


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(238).inherits
	
	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]
	
	  var W = new Array(160)
	
	  function Sha512() {
	    this.init()
	    this._w = W
	
	    Hash.call(this, 128, 112)
	  }
	
	  inherits(Sha512, Hash)
	
	  Sha512.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  Sha512.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0
	
	    for (var i = 0; i < 80; i++) {
	      var j = i * 2
	
	      var Wi, Wil
	
	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)
	
	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)
	
	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)
	
	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]
	
	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]
	
	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)
	
	        W[j] = Wi
	        W[j + 1] = Wil
	      }
	
	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)
	
	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)
	
	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]
	
	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)
	
	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)
	
	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)
	
	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }
	
	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0
	
	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }
	
	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)
	
	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }
	
	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)
	
	    return H
	  }
	
	  return Sha512
	
	}


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */
	
	var helpers = __webpack_require__(244);
	
	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;
	
	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;
	
	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;
	
	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);
	
	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);
	
	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);
	
	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);
	
	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);
	
	}
	
	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}
	
	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}
	
	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}
	
	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;
	
	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }
	
	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}
	
	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}
	
	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}
	
	module.exports = { hash: hash };
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176).Buffer))

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160
	
	
	
	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.
	
	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
	
	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];
	
	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
	
	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};
	
	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};
	
	var processBlock = function (H, M, offset) {
	
	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];
	
	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }
	
	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;
	
	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;
	
	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};
	
	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}
	
	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}
	
	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}
	
	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}
	
	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}
	
	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}
	
	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
	
	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');
	
	  var m = bytesToWords(message);
	
	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;
	
	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );
	
	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }
	
	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];
	
	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }
	
	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}
	
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176).Buffer))

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(234)
	
	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)
	
	module.exports = Hmac
	
	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg
	
	  var blocksize = (alg === 'sha512') ? 128 : 64
	
	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key
	
	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }
	
	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)
	
	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }
	
	  this._hash = createHash(alg).update(ipad)
	}
	
	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}
	
	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176).Buffer))

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(248)
	
	module.exports = function (crypto, exports) {
	  exports = exports || {}
	
	  var exported = pbkdf2Export(crypto)
	
	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync
	
	  return exports
	}


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }
	
	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')
	
	    setTimeout(function() {
	      var result
	
	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }
	
	      callback(undefined, result)
	    })
	  }
	
	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')
	
	    if (iterations < 0)
	      throw new TypeError('Bad iterations')
	
	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')
	
	    if (keylen < 0)
	      throw new TypeError('Bad key length')
	
	    digest = digest || 'sha1'
	
	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)
	
	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)
	
	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)
	
	      var U = crypto.createHmac(digest, password).update(block1).digest()
	
	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen
	
	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }
	
	      U.copy(T, 0, 0, hLen)
	
	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()
	
	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }
	
	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }
	
	    return DK
	  }
	
	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176).Buffer))

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var esprima = __webpack_require__(250);
	var Tapable = __webpack_require__(181);
	var BasicEvaluatedExpression = __webpack_require__(251);
	
	function Parser(options) {
		Tapable.call(this);
		this.options = options;
		this.initializeEvaluating();
	}
	module.exports = Parser;
	
	// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API
	
	Parser.prototype = Object.create(Tapable.prototype);
	Parser.prototype.constructor = Parser;
	
	Parser.prototype.initializeEvaluating = function() {
		function joinRanges(startRange, endRange) {
			if(!endRange) return startRange;
			if(!startRange) return endRange;
			return [startRange[0], endRange[1]];
		}
		this.plugin("evaluate Literal", function(expr) {
			switch(typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);
			}
			if(expr.value === null)
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			if(expr.value instanceof RegExp)
				return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);
		});
		this.plugin("evaluate LogicalExpression", function(expr) {
			if(expr.operator === "&&") {
				var left = this.evaluateExpression(expr.left);
				var leftAsBool = left && left.asBool();
				if(leftAsBool === false) return left.setRange(expr.range);
				if(leftAsBool !== true) return;
				var right = this.evaluateExpression(expr.right);
				return right.setRange(expr.range);
			} else if(expr.operator === "||") {
				var left = this.evaluateExpression(expr.left);
				var leftAsBool = left && left.asBool();
				if(leftAsBool === true) return left.setRange(expr.range);
				if(leftAsBool !== false) return;
				var right = this.evaluateExpression(expr.right);
				return right.setRange(expr.range);
			}
		});
		this.plugin("evaluate BinaryExpression", function(expr) {
			if(expr.operator === "+") {
				var left = this.evaluateExpression(expr.left);
				var right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				var res = new BasicEvaluatedExpression();
				if(left.isString()) {
					if(right.isString()) {
						res.setString(left.string + right.string);
					} else if(right.isNumber()) {
						res.setString(left.string + right.number);
					} else if(right.isWrapped() && right.prefix && right.prefix.isString()) {
						res.setWrapped(
							new BasicEvaluatedExpression()
							.setString(left.string + right.prefix.string)
							.setRange(joinRanges(left.range, right.prefix.range)),
							right.postfix);
					} else {
						res.setWrapped(left, null);
					}
				} else if(left.isNumber()) {
					if(right.isString()) {
						res.setString(left.number + right.string);
					} else if(right.isNumber()) {
						res.setNumber(left.number + right.number);
					}
				} else if(left.isWrapped()) {
					if(left.postfix && left.postfix.isString() && right.isString()) {
						res.setWrapped(left.prefix,
							new BasicEvaluatedExpression()
							.setString(left.postfix.string + right.string)
							.setRange(joinRanges(left.postfix.range, right.range))
						);
					} else if(left.postfix && left.postfix.isString() && right.isNumber()) {
						res.setWrapped(left.prefix,
							new BasicEvaluatedExpression()
							.setString(left.postfix.string + right.number)
							.setRange(joinRanges(left.postfix.range, right.range))
						);
					} else if(right.isString()) {
						res.setWrapped(left.prefix, right);
					} else if(right.isNumber()) {
						res.setWrapped(left.prefix,
							new BasicEvaluatedExpression()
							.setString(right.number + "")
							.setRange(right.range));
					} else {
						res.setWrapped(left.prefix, new BasicEvaluatedExpression());
					}
				} else {
					if(right.isString()) {
						res.setWrapped(null, right);
					}
				}
				res.setRange(expr.range);
				return res;
			} else if(expr.operator === "-") {
				var left = this.evaluateExpression(expr.left);
				var right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				if(!left.isNumber() || !right.isNumber()) return;
				var res = new BasicEvaluatedExpression();
				res.setNumber(left.number - right.number);
				res.setRange(expr.range);
				return res;
			} else if(expr.operator === "*") {
				var left = this.evaluateExpression(expr.left);
				var right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				if(!left.isNumber() || !right.isNumber()) return;
				var res = new BasicEvaluatedExpression();
				res.setNumber(left.number * right.number);
				res.setRange(expr.range);
				return res;
			} else if(expr.operator === "/") {
				var left = this.evaluateExpression(expr.left);
				var right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				if(!left.isNumber() || !right.isNumber()) return;
				var res = new BasicEvaluatedExpression();
				res.setNumber(left.number / right.number);
				res.setRange(expr.range);
				return res;
			} else if(expr.operator === "==" || expr.operator === "===") {
				var left = this.evaluateExpression(expr.left);
				var right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				var res = new BasicEvaluatedExpression();
				res.setRange(expr.range);
				if(left.isString() && right.isString()) {
					return res.setBoolean(left.string === right.string);
				} else if(left.isNumber() && right.isNumber()) {
					return res.setBoolean(left.number === right.number);
				} else if(left.isBoolean() && right.isBoolean()) {
					return res.setBoolean(left.bool === right.bool);
				}
			} else if(expr.operator === "!=" || expr.operator === "!==") {
				var left = this.evaluateExpression(expr.left);
				var right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				var res = new BasicEvaluatedExpression();
				res.setRange(expr.range);
				if(left.isString() && right.isString()) {
					return res.setBoolean(left.string !== right.string);
				} else if(left.isNumber() && right.isNumber()) {
					return res.setBoolean(left.number !== right.number);
				} else if(left.isBoolean() && right.isBoolean()) {
					return res.setBoolean(left.bool !== right.bool);
				}
			}
		});
		this.plugin("evaluate UnaryExpression", function(expr) {
			if(expr.operator === "typeof") {
				if(expr.argument.type === "Identifier") {
					var name = this.scope.renames["$" + expr.argument.name] || expr.argument.name;
					if(this.scope.definitions.indexOf(name) === -1) {
						var res = this.applyPluginsBailResult("evaluate typeof " + name, expr);
						if(res !== undefined) return res;
					}
				}
				if(expr.argument.type === "MemberExpression") {
					var expression = expr.argument;
					var exprName = [];
					while(expression.type === "MemberExpression" && !expression.computed) {
						exprName.unshift(this.scope.renames["$" + expression.property.name] || expression.property.name);
						expression = expression.object;
					}
					if(expression.type === "Identifier") {
						exprName.unshift(this.scope.renames["$" + expression.name] || expression.name);
						if(this.scope.definitions.indexOf(name) === -1) {
							exprName = exprName.join(".");
							var res = this.applyPluginsBailResult("evaluate typeof " + exprName, expr);
							if(res !== undefined) return res;
						}
					}
				}
				if(expr.argument.type === "FunctionExpression") {
					return new BasicEvaluatedExpression().setString("function").setRange(expr.range);
				}
				var arg = this.evaluateExpression(expr.argument);
				if(arg.isString() || arg.isWrapped()) return new BasicEvaluatedExpression().setString("string").setRange(expr.range);
				else if(arg.isNumber()) return new BasicEvaluatedExpression().setString("number").setRange(expr.range);
				else if(arg.isBoolean()) return new BasicEvaluatedExpression().setString("boolean").setRange(expr.range);
				else if(arg.isArray() || arg.isConstArray() || arg.isRegExp()) return new BasicEvaluatedExpression().setString("object").setRange(expr.range);
			} else if(expr.operator === "!") {
				var argument = this.evaluateExpression(expr.argument);
				if(!argument) return;
				if(argument.isBoolean()) {
					return new BasicEvaluatedExpression().setBoolean(!argument.bool).setRange(expr.range);
				} else if(argument.isString()) {
					return new BasicEvaluatedExpression().setBoolean(!argument.string).setRange(expr.range);
				} else if(argument.isNumber()) {
					return new BasicEvaluatedExpression().setBoolean(!argument.number).setRange(expr.range);
				}
			}
		});
		this.plugin("evaluate typeof undefined", function(expr) {
			return new BasicEvaluatedExpression().setString("undefined").setRange(expr.range);
		});
		this.plugin("evaluate Identifier", function(expr) {
			var name = this.scope.renames["$" + expr.name] || expr.name;
			if(this.scope.definitions.indexOf(expr.name) === -1) {
				var result = this.applyPluginsBailResult("evaluate Identifier " + name, expr);
				if(result) return result;
				return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);
			} else {
				return this.applyPluginsBailResult("evaluate defined Identifier " + name, expr);
			}
		});
		this.plugin("evaluate MemberExpression", function(expression) {
			var expr = expression;
			var exprName = [];
			while(expr.type === "MemberExpression" && !expr.computed) {
				exprName.unshift(expr.property.name);
				expr = expr.object;
			}
			if(expr.type === "Identifier") {
				var name = this.scope.renames["$" + expr.name] || expr.name;
				if(this.scope.definitions.indexOf(name) === -1) {
					exprName.unshift(name);
					exprName = exprName.join(".");
					if(this.scope.definitions.indexOf(expr.name) === -1) {
						var result = this.applyPluginsBailResult("evaluate Identifier " + exprName, expression);
						if(result) return result;
						return new BasicEvaluatedExpression().setIdentifier(exprName).setRange(expression.range);
					} else {
						return this.applyPluginsBailResult("evaluate defined Identifier " + exprName, expression);
					}
				}
			}
		});
		this.plugin("evaluate CallExpression", function(expr) {
			if(expr.callee.type !== "MemberExpression") return;
			if(expr.callee.computed) return;
			var param = this.evaluateExpression(expr.callee.object);
			if(!param) return;
			return this.applyPluginsBailResult("evaluate CallExpression ." + expr.callee.property.name, expr, param);
		});
		this.plugin("evaluate CallExpression .replace", function(expr, param) {
			if(!param.isString()) return;
			if(expr.arguments.length !== 2) return;
			var arg1 = this.evaluateExpression(expr.arguments[0]);
			var arg2 = this.evaluateExpression(expr.arguments[1]);
			if(!arg1.isString() && !arg1.isRegExp()) return;
			arg1 = arg1.regExp || arg1.string;
			if(!arg2.isString()) return;
			arg2 = arg2.string;
			return new BasicEvaluatedExpression().setString(param.string.replace(arg1, arg2)).setRange(expr.range);
		});
		["substr", "substring"].forEach(function(fn) {
			this.plugin("evaluate CallExpression ." + fn, function(expr, param) {
				if(!param.isString()) return;
				var result, str = param.string;
				switch(expr.arguments.length) {
					case 1:
						var arg1 = this.evaluateExpression(expr.arguments[0]);
						if(!arg1.isNumber()) return;
						result = str[fn](arg1.number);
						break;
					case 2:
						var arg1 = this.evaluateExpression(expr.arguments[0]);
						var arg2 = this.evaluateExpression(expr.arguments[1]);
						if(!arg1.isNumber()) return;
						if(!arg2.isNumber()) return;
						result = str[fn](arg1.number, arg2.number);
						break;
					default:
						return;
				}
				return new BasicEvaluatedExpression().setString(result).setRange(expr.range);
			});
		}, this);
		this.plugin("evaluate CallExpression .split", function(expr, param) {
			if(!param.isString()) return;
			if(expr.arguments.length !== 1) return;
			var result;
			var arg = this.evaluateExpression(expr.arguments[0]);
			if(arg.isString()) {
				result = param.string.split(arg.string);
			} else if(arg.isRegExp()) {
				result = param.string.split(arg.regExp);
			} else return;
			return new BasicEvaluatedExpression().setArray(result).setRange(expr.range);
		});
		this.plugin("evaluate ConditionalExpression", function(expr) {
			var condition = this.evaluateExpression(expr.test);
			var conditionValue = condition.asBool();
			if(conditionValue === undefined) {
				var consequent = this.evaluateExpression(expr.consequent);
				var alternate = this.evaluateExpression(expr.alternate);
				if(!consequent || !alternate) return;
				var res = new BasicEvaluatedExpression();
				if(consequent.isConditional())
					res.setOptions(consequent.options);
				else
					res.setOptions([consequent]);
				if(alternate.isConditional())
					res.addOptions(alternate.options);
				else
					res.addOptions([alternate]);
			} else {
				var res = this.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);
			}
			res.setRange(expr.range);
			return res;
		});
		this.plugin("evaluate ArrayExpression", function(expr) {
			var items = expr.elements.map(function(element) {
				return element !== null && this.evaluateExpression(element);
			}, this);
			if(items.filter(function(i) {
					return !i;
				}).length > 0) return;
			return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);
		});
	};
	
	Parser.prototype.getRenameIdentifier = function getRenameIdentifier(expr) {
		var result = this.evaluateExpression(expr);
		if(!result) return;
		if(result.isIdentifier()) return result.identifier;
		return;
	};
	
	Parser.prototype.walkStatements = function walkStatements(statements) {
		statements.forEach(function(statement) {
			this.walkStatement(statement);
		}, this);
	};
	
	Parser.prototype.walkStatement = function walkStatement(statement) {
		if(this.applyPluginsBailResult("statement", statement) !== undefined) return;
		if(this["walk" + statement.type])
			this["walk" + statement.type](statement);
	};
	
	// Real Statements
	Parser.prototype.walkBlockStatement = function walkBlockStatement(statement) {
		this.walkStatements(statement.body);
	};
	
	Parser.prototype.walkExpressionStatement = function walkExpressionStatement(statement) {
		this.walkExpression(statement.expression);
	};
	
	Parser.prototype.walkIfStatement = function walkIfStatement(statement) {
		var result = this.applyPluginsBailResult("statement if", statement);
		if(result === undefined) {
			this.walkExpression(statement.test);
			this.walkStatement(statement.consequent);
			if(statement.alternate)
				this.walkStatement(statement.alternate);
		} else {
			if(result)
				this.walkStatement(statement.consequent);
			else if(statement.alternate)
				this.walkStatement(statement.alternate);
		}
	};
	
	Parser.prototype.walkLabeledStatement = function walkLabeledStatement(statement) {
		var result = this.applyPluginsBailResult("label " + statement.label.name, statement);
		if(result !== true)
			this.walkStatement(statement.body);
	};
	
	Parser.prototype.walkWithStatement = function walkWithStatement(statement) {
		this.walkExpression(statement.object);
		this.walkStatement(statement.body);
	};
	
	Parser.prototype.walkSwitchStatement = function walkSwitchStatement(statement) {
		this.walkExpression(statement.discriminant);
		this.walkSwitchCases(statement.cases);
	};
	
	Parser.prototype.walkReturnStatement =
		Parser.prototype.walkThrowStatement = function walkArgumentStatement(statement) {
			if(statement.argument)
				this.walkExpression(statement.argument);
		};
	
	Parser.prototype.walkTryStatement = function walkTryStatement(statement) {
		if(this.scope.inTry) {
			this.walkStatement(statement.block);
		} else {
			this.scope.inTry = true;
			this.walkStatement(statement.block);
			this.scope.inTry = false;
		}
		this.walkCatchClauses(statement.handlers);
		if(statement.finalizer)
			this.walkStatement(statement.finalizer);
	};
	
	Parser.prototype.walkWhileStatement =
		Parser.prototype.walkDoWhileStatement = function walkLoopStatement(statement) {
			this.walkExpression(statement.test);
			this.walkStatement(statement.body);
		};
	
	Parser.prototype.walkForStatement = function walkForStatement(statement) {
		if(statement.init) {
			if(statement.init.type === "VariableDeclaration")
				this.walkStatement(statement.init);
			else
				this.walkExpression(statement.init);
		}
		if(statement.test)
			this.walkExpression(statement.test);
		if(statement.update)
			this.walkExpression(statement.update);
		this.walkStatement(statement.body);
	};
	
	Parser.prototype.walkForInStatement = function walkForInStatement(statement) {
		if(statement.left.type === "VariableDeclaration")
			this.walkStatement(statement.left);
		else
			this.walkExpression(statement.left);
		this.walkExpression(statement.right);
		this.walkStatement(statement.body);
	};
	
	// Declarations
	Parser.prototype.walkFunctionDeclaration = function walkFunctionDeclaration(statement) {
		this.scope.renames["$" + statement.id.name] = undefined;
		this.scope.definitions.push(statement.id.name);
		this.inScope(statement.params, function() {
			if(statement.body.type === "BlockStatement")
				this.walkStatement(statement.body);
			else
				this.walkExpression(statement.body);
		}.bind(this));
	};
	
	Parser.prototype.walkVariableDeclaration = function walkVariableDeclaration(statement) {
		if(statement.declarations)
			this.walkVariableDeclarators(statement.declarations);
	};
	
	Parser.prototype.walkSwitchCases = function walkSwitchCases(switchCases) {
		switchCases.forEach(function(switchCase) {
			if(switchCase.test)
				this.walkExpression(switchCase.test);
			this.walkStatements(switchCase.consequent);
		}, this);
	};
	
	Parser.prototype.walkCatchClauses = function walkCatchClauses(catchClauses) {
		catchClauses.forEach(function(catchClause) {
			if(catchClause.guard)
				this.walkExpression(catchClause.guard);
			this.inScope([catchClause.param], function() {
				this.walkStatement(catchClause.body);
			}.bind(this));
		}, this);
	};
	
	Parser.prototype.walkVariableDeclarators = function walkVariableDeclarators(declarators) {
		declarators.forEach(function(declarator) {
			switch(declarator.type) {
				case "VariableDeclarator":
					var renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);
					if(renameIdentifier && declarator.id.type === "Identifier" && this.applyPluginsBailResult("can-rename " + renameIdentifier, declarator.init)) {
						// renaming with "var a = b;"
						if(!this.applyPluginsBailResult("rename " + renameIdentifier, declarator.init)) {
							this.scope.renames["$" + declarator.id.name] = this.scope.renames["$" + renameIdentifier] || renameIdentifier;
							var idx = this.scope.definitions.indexOf(declarator.id.name);
							if(idx >= 0) this.scope.definitions.splice(idx, 1);
						}
					} else if(declarator.id.type === "Identifier" && !this.applyPluginsBailResult("var " + declarator.id.name, declarator)) {
						this.scope.renames["$" + declarator.id.name] = undefined;
						this.scope.definitions.push(declarator.id.name);
						if(declarator.init)
							this.walkExpression(declarator.init);
					} else {
						this.walkExpression(declarator.id);
						if(declarator.init)
							this.walkExpression(declarator.init);
					}
					break;
			}
		}, this);
	};
	
	Parser.prototype.walkExpressions = function walkExpressions(expressions) {
		expressions.forEach(function(expression) {
			if(expression)
				this.walkExpression(expression);
		}, this);
	};
	
	Parser.prototype.walkExpression = function walkExpression(expression) {
		if(this["walk" + expression.type])
			return this["walk" + expression.type](expression);
	};
	
	Parser.prototype.walkArrayExpression = function walkArrayExpression(expression) {
		if(expression.elements)
			this.walkExpressions(expression.elements);
	};
	
	Parser.prototype.walkObjectExpression = function walkObjectExpression(expression) {
		expression.properties.forEach(function(prop) {
			this.walkExpression(prop.value);
		}, this);
	};
	
	Parser.prototype.walkFunctionExpression = function walkFunctionExpression(expression) {
		this.inScope(expression.params, function() {
			if(expression.body.type === "BlockStatement")
				this.walkStatement(expression.body);
			else
				this.walkExpression(expression.body);
		}.bind(this));
	};
	
	Parser.prototype.walkSequenceExpression = function walkSequenceExpression(expression) {
		if(expression.expressions)
			this.walkExpressions(expression.expressions);
	};
	
	Parser.prototype.walkUpdateExpression = function walkUpdateExpression(expression) {
		this.walkExpression(expression.argument);
	};
	
	Parser.prototype.walkUnaryExpression = function walkUnaryExpression(expression) {
		if(expression.operator === "typeof") {
			var expr = expression.argument;
			var exprName = [];
			while(expr.type === "MemberExpression" && !expr.computed) {
				exprName.unshift(expr.property.name);
				expr = expr.object;
			}
			if(expr.type === "Identifier" && this.scope.definitions.indexOf(expr.name) === -1) {
				exprName.unshift(this.scope.renames["$" + expr.name] || expr.name);
				exprName = exprName.join(".");
				var result = this.applyPluginsBailResult("typeof " + exprName, expression);
				if(result === true)
					return;
			}
		}
		this.walkExpression(expression.argument);
	};
	
	Parser.prototype.walkBinaryExpression =
		Parser.prototype.walkLogicalExpression = function walkLeftRightExpression(expression) {
			this.walkExpression(expression.left);
			this.walkExpression(expression.right);
		};
	
	Parser.prototype.walkAssignmentExpression = function walkAssignmentExpression(expression) {
		var renameIdentifier = this.getRenameIdentifier(expression.right);
		if(expression.left.type === "Identifier" && renameIdentifier && this.applyPluginsBailResult("can-rename " + renameIdentifier, expression.right)) {
			// renaming "a = b;"
			if(!this.applyPluginsBailResult("rename " + renameIdentifier, expression.right)) {
				this.scope.renames["$" + expression.left.name] = renameIdentifier;
				var idx = this.scope.definitions.indexOf(expression.left.name);
				if(idx >= 0) this.scope.definitions.splice(idx, 1);
			}
		} else if(expression.left.type === "Identifier") {
			if(!this.applyPluginsBailResult("assigned " + expression.left.name, expression)) {
				this.walkExpression(expression.right);
			}
			this.scope.renames["$" + expression.left.name] = undefined;
			if(!this.applyPluginsBailResult("assign " + expression.left.name, expression)) {
				this.walkExpression(expression.left);
			}
		} else {
			this.walkExpression(expression.right);
			this.scope.renames["$" + expression.left.name] = undefined;
			this.walkExpression(expression.left);
		}
	};
	
	Parser.prototype.walkConditionalExpression = function walkConditionalExpression(expression) {
		var result = this.applyPluginsBailResult("expression ?:", expression);
		if(result === undefined) {
			this.walkExpression(expression.test);
			this.walkExpression(expression.consequent);
			if(expression.alternate)
				this.walkExpression(expression.alternate);
		} else {
			if(result)
				this.walkExpression(expression.consequent);
			else if(expression.alternate)
				this.walkExpression(expression.alternate);
		}
	};
	
	Parser.prototype.walkNewExpression = function walkNewExpression(expression) {
		this.walkExpression(expression.callee);
		if(expression.arguments)
			this.walkExpressions(expression.arguments);
	};
	
	Parser.prototype.walkCallExpression = function walkCallExpression(expression) {
		function walkIIFE(functionExpression, args) {
			var params = functionExpression.params;
			var args = args.map(function(arg) {
				var renameIdentifier = this.getRenameIdentifier(arg);
				if(renameIdentifier && this.applyPluginsBailResult("can-rename " + renameIdentifier, arg)) {
					if(!this.applyPluginsBailResult("rename " + renameIdentifier, arg))
						return renameIdentifier;
				}
				this.walkExpression(arg);
			}, this);
			this.inScope(params.filter(function(identifier, idx) {
				return !args[idx];
			}), function() {
				args.forEach(function(arg, idx) {
					if(!arg) return;
					if(!params[idx] || params[idx].type !== "Identifier") return;
					this.scope.renames["$" + params[idx].name] = arg;
				}, this);
				if(functionExpression.body.type === "BlockStatement")
					this.walkStatement(functionExpression.body);
				else
					this.walkExpression(functionExpression.body);
			}.bind(this));
		}
		if(expression.callee.type === "MemberExpression" && expression.callee.object.type === "FunctionExpression" && !expression.callee.computed && ["call", "bind"].indexOf(expression.callee.property.name) >= 0 && expression.arguments && expression.arguments.length > 1) {
			// (function(...) { }.call/bind(?, ...))
			walkIIFE.call(this, expression.callee.object, expression.arguments.slice(1));
			this.walkExpression(expression.arguments[0]);
		} else if(expression.callee.type === "FunctionExpression" && expression.arguments) {
			// (function(...) { }(...))
			walkIIFE.call(this, expression.callee, expression.arguments);
		} else {
	
			var callee = this.evaluateExpression(expression.callee);
			if(callee.isIdentifier()) {
				var result = this.applyPluginsBailResult("call " + callee.identifier, expression);
				if(result === true)
					return;
			}
	
			if(expression.callee)
				this.walkExpression(expression.callee);
			if(expression.arguments)
				this.walkExpressions(expression.arguments);
		}
	};
	
	Parser.prototype.walkMemberExpression = function walkMemberExpression(expression) {
		var expr = expression;
		var exprName = [];
		while(expr.type === "MemberExpression" && !expr.computed) {
			exprName.unshift(expr.property.name);
			expr = expr.object;
		}
		if(expr.type === "Identifier" && this.scope.definitions.indexOf(expr.name) === -1) {
			exprName.unshift(this.scope.renames["$" + expr.name] || expr.name);
			exprName = exprName.join(".");
			var result = this.applyPluginsBailResult("expression " + exprName, expression);
			if(result === true)
				return;
		}
		this.walkExpression(expression.object);
		if(expression.computed === true)
			this.walkExpression(expression.property);
	};
	
	Parser.prototype.walkIdentifier = function walkIdentifier(expression) {
		if(this.scope.definitions.indexOf(expression.name) === -1) {
			var result = this.applyPluginsBailResult("expression " + (this.scope.renames["$" + expression.name] || expression.name), expression);
			if(result === true)
				return;
		}
	};
	
	Parser.prototype.inScope = function inScope(params, fn) {
		var oldScope = this.scope;
		this.scope = {
			inTry: false,
			definitions: oldScope.definitions.slice(),
			renames: Object.create(oldScope.renames)
		};
		params.forEach(function(param) {
			if(typeof param !== "string") {
				if(param.type !== "Identifier")
					return;
				param = param.name;
			}
			this.scope.renames["$" + param] = undefined;
			this.scope.definitions.push(param);
		}, this);
		fn();
		this.scope = oldScope;
	};
	
	Parser.prototype.evaluateExpression = function evaluateExpression(expression) {
		var result = this.applyPluginsBailResult("evaluate " + expression.type, expression);
		if(result !== undefined)
			return result;
		return new BasicEvaluatedExpression().setRange(expression.range);
	};
	
	Parser.prototype.parseString = function parseString(expression) {
		switch(expression.type) {
			case "BinaryExpression":
				if(expression.operator === "+")
					return this.parseString(expression.left) + this.parseString(expression.right);
				break;
			case "Literal":
				return expression.value + "";
		}
		throw new Error(expression.type + " is not supported as parameter for require");
	};
	
	Parser.prototype.parseCalculatedString = function parseCalculatedString(expression) {
		switch(expression.type) {
			case "BinaryExpression":
				if(expression.operator === "+") {
					var left = this.parseCalculatedString(expression.left);
					var right = this.parseCalculatedString(expression.right);
					if(left.code) {
						return {
							range: left.range,
							value: left.value,
							code: true
						};
					} else if(right.code) {
						return {
							range: [left.range[0], right.range ? right.range[1] : left.range[1]],
							value: left.value + right.value,
							code: true
						};
					} else {
						return {
							range: [left.range[0], right.range[1]],
							value: left.value + right.value
						};
					}
				}
				break;
			case "ConditionalExpression":
				var consequent = this.parseCalculatedString(expression.consequent);
				var alternate = this.parseCalculatedString(expression.alternate);
				var items = [];
				if(consequent.conditional)
					Array.prototype.push.apply(items, consequent.conditional);
				else if(!consequent.code)
					items.push(consequent);
				else break;
				if(alternate.conditional)
					Array.prototype.push.apply(items, alternate.conditional);
				else if(!alternate.code)
					items.push(alternate);
				else break;
				return {
					value: "",
					code: true,
					conditional: items
				};
			case "Literal":
				return {
					range: expression.range,
					value: expression.value + ""
				};
		}
		return {
			value: "",
			code: true
		};
	};
	
	["parseString", "parseCalculatedString"].forEach(function(fn) {
		Parser.prototype[fn + "Array"] = function parseXXXArray(expression) {
			switch(expression.type) {
				case "ArrayExpression":
					var arr = [];
					if(expression.elements)
						expression.elements.forEach(function(expr) {
							arr.push(this[fn](expr));
						}, this);
					return arr;
			}
			return [this[fn](expression)];
		};
	});
	
	Parser.prototype.parse = function parse(source, initialState) {
		var ast = esprima.parse(source, {
			range: true,
			loc: true,
			raw: true
		});
		if(!ast || typeof ast !== "object")
			throw new Error("Source couldn't be parsed");
		var oldScope = this.scope;
		var oldState = this.state;
		this.scope = {
			inTry: false,
			definitions: [],
			renames: {}
		};
		var state = this.state = initialState || {};
		if(this.applyPluginsBailResult("program", ast) === undefined)
			this.walkStatements(ast.body);
		this.scope = oldScope;
		this.state = oldState;
		return state;
	};
	
	Parser.prototype.evaluate = function evaluate(source) {
		var ast = esprima.parse("(" + source + ")", {
			range: true,
			loc: true,
			raw: true
		});
		if(!ast || typeof ast !== "object" || ast.type !== "Program")
			throw new Error("evaluate: Source couldn't be parsed");
		if(ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement")
			throw new Error("evaluate: Source is not a expression");
		return this.evaluateExpression(ast.body[0].expression);
	};


/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.
	
	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:
	
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	
	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	(function (root, factory) {
	    'use strict';
	
	    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
	    // Rhino, and plain browser loading.
	
	    /* istanbul ignore next */
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== 'undefined') {
	        factory(exports);
	    } else {
	        factory((root.esprima = {}));
	    }
	}(this, function (exports) {
	    'use strict';
	
	    var Token,
	        TokenName,
	        FnExprTokens,
	        Syntax,
	        PlaceHolders,
	        Messages,
	        Regex,
	        source,
	        strict,
	        index,
	        lineNumber,
	        lineStart,
	        hasLineTerminator,
	        lastIndex,
	        lastLineNumber,
	        lastLineStart,
	        startIndex,
	        startLineNumber,
	        startLineStart,
	        scanning,
	        length,
	        lookahead,
	        state,
	        extra,
	        isBindingElement,
	        isAssignmentTarget,
	        firstCoverInitializedNameError;
	
	    Token = {
	        BooleanLiteral: 1,
	        EOF: 2,
	        Identifier: 3,
	        Keyword: 4,
	        NullLiteral: 5,
	        NumericLiteral: 6,
	        Punctuator: 7,
	        StringLiteral: 8,
	        RegularExpression: 9,
	        Template: 10
	    };
	
	    TokenName = {};
	    TokenName[Token.BooleanLiteral] = 'Boolean';
	    TokenName[Token.EOF] = '<end>';
	    TokenName[Token.Identifier] = 'Identifier';
	    TokenName[Token.Keyword] = 'Keyword';
	    TokenName[Token.NullLiteral] = 'Null';
	    TokenName[Token.NumericLiteral] = 'Numeric';
	    TokenName[Token.Punctuator] = 'Punctuator';
	    TokenName[Token.StringLiteral] = 'String';
	    TokenName[Token.RegularExpression] = 'RegularExpression';
	    TokenName[Token.Template] = 'Template';
	
	    // A function following one of those tokens is an expression.
	    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	                    'return', 'case', 'delete', 'throw', 'void',
	                    // assignment operators
	                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
	                    '&=', '|=', '^=', ',',
	                    // binary/unary operators
	                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	                    '<=', '<', '>', '!=', '!=='];
	
	    Syntax = {
	        AssignmentExpression: 'AssignmentExpression',
	        AssignmentPattern: 'AssignmentPattern',
	        ArrayExpression: 'ArrayExpression',
	        ArrayPattern: 'ArrayPattern',
	        ArrowFunctionExpression: 'ArrowFunctionExpression',
	        BlockStatement: 'BlockStatement',
	        BinaryExpression: 'BinaryExpression',
	        BreakStatement: 'BreakStatement',
	        CallExpression: 'CallExpression',
	        CatchClause: 'CatchClause',
	        ClassBody: 'ClassBody',
	        ClassDeclaration: 'ClassDeclaration',
	        ClassExpression: 'ClassExpression',
	        ConditionalExpression: 'ConditionalExpression',
	        ContinueStatement: 'ContinueStatement',
	        DoWhileStatement: 'DoWhileStatement',
	        DebuggerStatement: 'DebuggerStatement',
	        EmptyStatement: 'EmptyStatement',
	        ExportAllDeclaration: 'ExportAllDeclaration',
	        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	        ExportNamedDeclaration: 'ExportNamedDeclaration',
	        ExportSpecifier: 'ExportSpecifier',
	        ExpressionStatement: 'ExpressionStatement',
	        ForStatement: 'ForStatement',
	        ForOfStatement: 'ForOfStatement',
	        ForInStatement: 'ForInStatement',
	        FunctionDeclaration: 'FunctionDeclaration',
	        FunctionExpression: 'FunctionExpression',
	        Identifier: 'Identifier',
	        IfStatement: 'IfStatement',
	        ImportDeclaration: 'ImportDeclaration',
	        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	        ImportSpecifier: 'ImportSpecifier',
	        Literal: 'Literal',
	        LabeledStatement: 'LabeledStatement',
	        LogicalExpression: 'LogicalExpression',
	        MemberExpression: 'MemberExpression',
	        MetaProperty: 'MetaProperty',
	        MethodDefinition: 'MethodDefinition',
	        NewExpression: 'NewExpression',
	        ObjectExpression: 'ObjectExpression',
	        ObjectPattern: 'ObjectPattern',
	        Program: 'Program',
	        Property: 'Property',
	        RestElement: 'RestElement',
	        ReturnStatement: 'ReturnStatement',
	        SequenceExpression: 'SequenceExpression',
	        SpreadElement: 'SpreadElement',
	        Super: 'Super',
	        SwitchCase: 'SwitchCase',
	        SwitchStatement: 'SwitchStatement',
	        TaggedTemplateExpression: 'TaggedTemplateExpression',
	        TemplateElement: 'TemplateElement',
	        TemplateLiteral: 'TemplateLiteral',
	        ThisExpression: 'ThisExpression',
	        ThrowStatement: 'ThrowStatement',
	        TryStatement: 'TryStatement',
	        UnaryExpression: 'UnaryExpression',
	        UpdateExpression: 'UpdateExpression',
	        VariableDeclaration: 'VariableDeclaration',
	        VariableDeclarator: 'VariableDeclarator',
	        WhileStatement: 'WhileStatement',
	        WithStatement: 'WithStatement',
	        YieldExpression: 'YieldExpression'
	    };
	
	    PlaceHolders = {
	        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'
	    };
	
	    // Error messages should be identical to V8.
	    Messages = {
	        UnexpectedToken: 'Unexpected token %0',
	        UnexpectedNumber: 'Unexpected number',
	        UnexpectedString: 'Unexpected string',
	        UnexpectedIdentifier: 'Unexpected identifier',
	        UnexpectedReserved: 'Unexpected reserved word',
	        UnexpectedTemplate: 'Unexpected quasi %0',
	        UnexpectedEOS: 'Unexpected end of input',
	        NewlineAfterThrow: 'Illegal newline after throw',
	        InvalidRegExp: 'Invalid regular expression',
	        UnterminatedRegExp: 'Invalid regular expression: missing /',
	        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	        InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	        NoCatchOrFinally: 'Missing catch or finally after try',
	        UnknownLabel: 'Undefined label \'%0\'',
	        Redeclaration: '%0 \'%1\' has already been declared',
	        IllegalContinue: 'Illegal continue statement',
	        IllegalBreak: 'Illegal break statement',
	        IllegalReturn: 'Illegal return statement',
	        StrictModeWith: 'Strict mode code may not include a with statement',
	        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictReservedWord: 'Use of future reserved word in strict mode',
	        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	        DefaultRestParameter: 'Unexpected token =',
	        ObjectPatternAsRestParameter: 'Unexpected token {',
	        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	        ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	        DuplicateConstructor: 'A class may only have one constructor',
	        StaticPrototype: 'Classes may not have static property named prototype',
	        MissingFromClause: 'Unexpected token',
	        NoAsAfterImportNamespace: 'Unexpected token',
	        InvalidModuleSpecifier: 'Unexpected token',
	        IllegalImportDeclaration: 'Unexpected token',
	        IllegalExportDeclaration: 'Unexpected token',
	        DuplicateBinding: 'Duplicate binding %0'
	    };
	
	    // See also tools/generate-unicode-regex.js.
	    Regex = {
	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
	        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
	
	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
	        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	    };
	
	    // Ensure the condition is true, otherwise throw an error.
	    // This is only to have a better contract semantic, i.e. another safety net
	    // to catch a logic error. The condition shall be fulfilled in normal case.
	    // Do NOT use this to enforce a certain condition on any user input.
	
	    function assert(condition, message) {
	        /* istanbul ignore if */
	        if (!condition) {
	            throw new Error('ASSERT: ' + message);
	        }
	    }
	
	    function isDecimalDigit(ch) {
	        return (ch >= 0x30 && ch <= 0x39);   // 0..9
	    }
	
	    function isHexDigit(ch) {
	        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
	    }
	
	    function isOctalDigit(ch) {
	        return '01234567'.indexOf(ch) >= 0;
	    }
	
	    function octalToDecimal(ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);
	
	        if (index < length && isOctalDigit(source[index])) {
	            octal = true;
	            code = code * 8 + '01234567'.indexOf(source[index++]);
	
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 &&
	                    index < length &&
	                    isOctalDigit(source[index])) {
	                code = code * 8 + '01234567'.indexOf(source[index++]);
	            }
	        }
	
	        return {
	            code: code,
	            octal: octal
	        };
	    }
	
	    // ECMA-262 11.2 White Space
	
	    function isWhiteSpace(ch) {
	        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
	            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
	    }
	
	    // ECMA-262 11.3 Line Terminators
	
	    function isLineTerminator(ch) {
	        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
	    }
	
	    // ECMA-262 11.6 Identifier Names and Identifiers
	
	    function fromCodePoint(cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	            String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    }
	
	    function isIdentifierStart(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch)));
	    }
	
	    function isIdentifierPart(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch)));
	    }
	
	    // ECMA-262 11.6.2.2 Future Reserved Words
	
	    function isFutureReservedWord(id) {
	        switch (id) {
	        case 'enum':
	        case 'export':
	        case 'import':
	        case 'super':
	            return true;
	        default:
	            return false;
	        }
	    }
	
	    function isStrictModeReservedWord(id) {
	        switch (id) {
	        case 'implements':
	        case 'interface':
	        case 'package':
	        case 'private':
	        case 'protected':
	        case 'public':
	        case 'static':
	        case 'yield':
	        case 'let':
	            return true;
	        default:
	            return false;
	        }
	    }
	
	    function isRestrictedWord(id) {
	        return id === 'eval' || id === 'arguments';
	    }
	
	    // ECMA-262 11.6.2.1 Keywords
	
	    function isKeyword(id) {
	
	        // 'const' is specialized as Keyword in V8.
	        // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.
	        // Some others are from future reserved words.
	
	        switch (id.length) {
	        case 2:
	            return (id === 'if') || (id === 'in') || (id === 'do');
	        case 3:
	            return (id === 'var') || (id === 'for') || (id === 'new') ||
	                (id === 'try') || (id === 'let');
	        case 4:
	            return (id === 'this') || (id === 'else') || (id === 'case') ||
	                (id === 'void') || (id === 'with') || (id === 'enum');
	        case 5:
	            return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                (id === 'class') || (id === 'super');
	        case 6:
	            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                (id === 'switch') || (id === 'export') || (id === 'import');
	        case 7:
	            return (id === 'default') || (id === 'finally') || (id === 'extends');
	        case 8:
	            return (id === 'function') || (id === 'continue') || (id === 'debugger');
	        case 10:
	            return (id === 'instanceof');
	        default:
	            return false;
	        }
	    }
	
	    // ECMA-262 11.4 Comments
	
	    function addComment(type, value, start, end, loc) {
	        var comment;
	
	        assert(typeof start === 'number', 'Comment must have valid position');
	
	        state.lastCommentStart = start;
	
	        comment = {
	            type: type,
	            value: value
	        };
	        if (extra.range) {
	            comment.range = [start, end];
	        }
	        if (extra.loc) {
	            comment.loc = loc;
	        }
	        extra.comments.push(comment);
	        if (extra.attachComment) {
	            extra.leadingComments.push(comment);
	            extra.trailingComments.push(comment);
	        }
	    }
	
	    function skipSingleLineComment(offset) {
	        var start, loc, ch, comment;
	
	        start = index - offset;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart - offset
	            }
	        };
	
	        while (index < length) {
	            ch = source.charCodeAt(index);
	            ++index;
	            if (isLineTerminator(ch)) {
	                hasLineTerminator = true;
	                if (extra.comments) {
	                    comment = source.slice(start + offset, index - 1);
	                    loc.end = {
	                        line: lineNumber,
	                        column: index - lineStart - 1
	                    };
	                    addComment('Line', comment, start, index - 1, loc);
	                }
	                if (ch === 13 && source.charCodeAt(index) === 10) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                return;
	            }
	        }
	
	        if (extra.comments) {
	            comment = source.slice(start + offset, index);
	            loc.end = {
	                line: lineNumber,
	                column: index - lineStart
	            };
	            addComment('Line', comment, start, index, loc);
	        }
	    }
	
	    function skipMultiLineComment() {
	        var start, loc, ch, comment;
	
	        if (extra.comments) {
	            start = index - 2;
	            loc = {
	                start: {
	                    line: lineNumber,
	                    column: index - lineStart - 2
	                }
	            };
	        }
	
	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (isLineTerminator(ch)) {
	                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
	                    ++index;
	                }
	                hasLineTerminator = true;
	                ++lineNumber;
	                ++index;
	                lineStart = index;
	            } else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (source.charCodeAt(index + 1) === 0x2F) {
	                    ++index;
	                    ++index;
	                    if (extra.comments) {
	                        comment = source.slice(start + 2, index - 2);
	                        loc.end = {
	                            line: lineNumber,
	                            column: index - lineStart
	                        };
	                        addComment('Block', comment, start, index, loc);
	                    }
	                    return;
	                }
	                ++index;
	            } else {
	                ++index;
	            }
	        }
	
	        // Ran off the end of the file - the whole thing is a comment
	        if (extra.comments) {
	            loc.end = {
	                line: lineNumber,
	                column: index - lineStart
	            };
	            comment = source.slice(start + 2, index);
	            addComment('Block', comment, start, index, loc);
	        }
	        tolerateUnexpectedToken();
	    }
	
	    function skipComment() {
	        var ch, start;
	        hasLineTerminator = false;
	
	        start = (index === 0);
	        while (index < length) {
	            ch = source.charCodeAt(index);
	
	            if (isWhiteSpace(ch)) {
	                ++index;
	            } else if (isLineTerminator(ch)) {
	                hasLineTerminator = true;
	                ++index;
	                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                start = true;
	            } else if (ch === 0x2F) { // U+002F is '/'
	                ch = source.charCodeAt(index + 1);
	                if (ch === 0x2F) {
	                    ++index;
	                    ++index;
	                    skipSingleLineComment(2);
	                    start = true;
	                } else if (ch === 0x2A) {  // U+002A is '*'
	                    ++index;
	                    ++index;
	                    skipMultiLineComment();
	                } else {
	                    break;
	                }
	            } else if (start && ch === 0x2D) { // U+002D is '-'
	                // U+003E is '>'
	                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    index += 3;
	                    skipSingleLineComment(3);
	                } else {
	                    break;
	                }
	            } else if (ch === 0x3C) { // U+003C is '<'
	                if (source.slice(index + 1, index + 4) === '!--') {
	                    ++index; // `<`
	                    ++index; // `!`
	                    ++index; // `-`
	                    ++index; // `-`
	                    skipSingleLineComment(4);
	                } else {
	                    break;
	                }
	            } else {
	                break;
	            }
	        }
	    }
	
	    function scanHexEscape(prefix) {
	        var i, len, ch, code = 0;
	
	        len = (prefix === 'u') ? 4 : 2;
	        for (i = 0; i < len; ++i) {
	            if (index < length && isHexDigit(source[index])) {
	                ch = source[index++];
	                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	            } else {
	                return '';
	            }
	        }
	        return String.fromCharCode(code);
	    }
	
	    function scanUnicodeCodePointEscape() {
	        var ch, code;
	
	        ch = source[index];
	        code = 0;
	
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            throwUnexpectedToken();
	        }
	
	        while (index < length) {
	            ch = source[index++];
	            if (!isHexDigit(ch)) {
	                break;
	            }
	            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	        }
	
	        if (code > 0x10FFFF || ch !== '}') {
	            throwUnexpectedToken();
	        }
	
	        return fromCodePoint(code);
	    }
	
	    function codePointAt(i) {
	        var cp, first, second;
	
	        cp = source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            second = source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	
	        return cp;
	    }
	
	    function getComplexIdentifier() {
	        var cp, ch, id;
	
	        cp = codePointAt(index);
	        id = fromCodePoint(cp);
	        index += id.length;
	
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        if (cp === 0x5C) {
	            if (source.charCodeAt(index) !== 0x75) {
	                throwUnexpectedToken();
	            }
	            ++index;
	            if (source[index] === '{') {
	                ++index;
	                ch = scanUnicodeCodePointEscape();
	            } else {
	                ch = scanHexEscape('u');
	                cp = ch.charCodeAt(0);
	                if (!ch || ch === '\\' || !isIdentifierStart(cp)) {
	                    throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	
	        while (index < length) {
	            cp = codePointAt(index);
	            if (!isIdentifierPart(cp)) {
	                break;
	            }
	            ch = fromCodePoint(cp);
	            id += ch;
	            index += ch.length;
	
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (source.charCodeAt(index) !== 0x75) {
	                    throwUnexpectedToken();
	                }
	                ++index;
	                if (source[index] === '{') {
	                    ++index;
	                    ch = scanUnicodeCodePointEscape();
	                } else {
	                    ch = scanHexEscape('u');
	                    cp = ch.charCodeAt(0);
	                    if (!ch || ch === '\\' || !isIdentifierPart(cp)) {
	                        throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	
	        return id;
	    }
	
	    function getIdentifier() {
	        var start, ch;
	
	        start = index++;
	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                index = start;
	                return getComplexIdentifier();
	            } else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                index = start;
	                return getComplexIdentifier();
	            }
	            if (isIdentifierPart(ch)) {
	                ++index;
	            } else {
	                break;
	            }
	        }
	
	        return source.slice(start, index);
	    }
	
	    function scanIdentifier() {
	        var start, id, type;
	
	        start = index;
	
	        // Backslash (U+005C) starts an escaped character.
	        id = (source.charCodeAt(index) === 0x5C) ? getComplexIdentifier() : getIdentifier();
	
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = Token.Identifier;
	        } else if (isKeyword(id)) {
	            type = Token.Keyword;
	        } else if (id === 'null') {
	            type = Token.NullLiteral;
	        } else if (id === 'true' || id === 'false') {
	            type = Token.BooleanLiteral;
	        } else {
	            type = Token.Identifier;
	        }
	
	        return {
	            type: type,
	            value: id,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }
	
	
	    // ECMA-262 11.7 Punctuators
	
	    function scanPunctuator() {
	        var token, str;
	
	        token = {
	            type: Token.Punctuator,
	            value: '',
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: index,
	            end: index
	        };
	
	        // Check for most common single-character punctuators.
	        str = source[index];
	        switch (str) {
	
	        case '(':
	            if (extra.tokenize) {
	                extra.openParenToken = extra.tokens.length;
	            }
	            ++index;
	            break;
	
	        case '{':
	            if (extra.tokenize) {
	                extra.openCurlyToken = extra.tokens.length;
	            }
	            state.curlyStack.push('{');
	            ++index;
	            break;
	
	        case '.':
	            ++index;
	            if (source[index] === '.' && source[index + 1] === '.') {
	                // Spread operator: ...
	                index += 2;
	                str = '...';
	            }
	            break;
	
	        case '}':
	            ++index;
	            state.curlyStack.pop();
	            break;
	        case ')':
	        case ';':
	        case ',':
	        case '[':
	        case ']':
	        case ':':
	        case '?':
	        case '~':
	            ++index;
	            break;
	
	        default:
	            // 4-character punctuator.
	            str = source.substr(index, 4);
	            if (str === '>>>=') {
	                index += 4;
	            } else {
	
	                // 3-character punctuators.
	                str = str.substr(0, 3);
	                if (str === '===' || str === '!==' || str === '>>>' ||
	                    str === '<<=' || str === '>>=') {
	                    index += 3;
	                } else {
	
	                    // 2-character punctuators.
	                    str = str.substr(0, 2);
	                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                        str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                        str === '<=' || str === '>=' || str === '=>') {
	                        index += 2;
	                    } else {
	
	                        // 1-character punctuators.
	                        str = source[index];
	                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                            ++index;
	                        }
	                    }
	                }
	            }
	        }
	
	        if (index === token.start) {
	            throwUnexpectedToken();
	        }
	
	        token.end = index;
	        token.value = str;
	        return token;
	    }
	
	    // ECMA-262 11.8.3 Numeric Literals
	
	    function scanHexLiteral(start) {
	        var number = '';
	
	        while (index < length) {
	            if (!isHexDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }
	
	        if (number.length === 0) {
	            throwUnexpectedToken();
	        }
	
	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }
	
	        return {
	            type: Token.NumericLiteral,
	            value: parseInt('0x' + number, 16),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }
	
	    function scanBinaryLiteral(start) {
	        var ch, number;
	
	        number = '';
	
	        while (index < length) {
	            ch = source[index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            number += source[index++];
	        }
	
	        if (number.length === 0) {
	            // only 0b or 0B
	            throwUnexpectedToken();
	        }
	
	        if (index < length) {
	            ch = source.charCodeAt(index);
	            /* istanbul ignore else */
	            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
	                throwUnexpectedToken();
	            }
	        }
	
	        return {
	            type: Token.NumericLiteral,
	            value: parseInt(number, 2),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }
	
	    function scanOctalLiteral(prefix, start) {
	        var number, octal;
	
	        if (isOctalDigit(prefix)) {
	            octal = true;
	            number = '0' + source[index++];
	        } else {
	            octal = false;
	            ++index;
	            number = '';
	        }
	
	        while (index < length) {
	            if (!isOctalDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }
	
	        if (!octal && number.length === 0) {
	            // only 0o or 0O
	            throwUnexpectedToken();
	        }
	
	        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }
	
	        return {
	            type: Token.NumericLiteral,
	            value: parseInt(number, 8),
	            octal: octal,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }
	
	    function isImplicitOctalLiteral() {
	        var i, ch;
	
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (i = index + 1; i < length; ++i) {
	            ch = source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!isOctalDigit(ch)) {
	                return true;
	            }
	        }
	
	        return true;
	    }
	
	    function scanNumericLiteral() {
	        var number, start, ch;
	
	        ch = source[index];
	        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
	            'Numeric literal must start with a decimal digit or a decimal point');
	
	        start = index;
	        number = '';
	        if (ch !== '.') {
	            number = source[index++];
	            ch = source[index];
	
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (number === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++index;
	                    return scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++index;
	                    return scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return scanOctalLiteral(ch, start);
	                }
	
	                if (isOctalDigit(ch)) {
	                    if (isImplicitOctalLiteral()) {
	                        return scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	
	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }
	
	        if (ch === '.') {
	            number += source[index++];
	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }
	
	        if (ch === 'e' || ch === 'E') {
	            number += source[index++];
	
	            ch = source[index];
	            if (ch === '+' || ch === '-') {
	                number += source[index++];
	            }
	            if (isDecimalDigit(source.charCodeAt(index))) {
	                while (isDecimalDigit(source.charCodeAt(index))) {
	                    number += source[index++];
	                }
	            } else {
	                throwUnexpectedToken();
	            }
	        }
	
	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }
	
	        return {
	            type: Token.NumericLiteral,
	            value: parseFloat(number),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }
	
	    // ECMA-262 11.8.4 String Literals
	
	    function scanStringLiteral() {
	        var str = '', quote, start, ch, unescaped, octToDec, octal = false;
	
	        quote = source[index];
	        assert((quote === '\'' || quote === '"'),
	            'String literal must starts with a quote');
	
	        start = index;
	        ++index;
	
	        while (index < length) {
	            ch = source[index++];
	
	            if (ch === quote) {
	                quote = '';
	                break;
	            } else if (ch === '\\') {
	                ch = source[index++];
	                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'u':
	                    case 'x':
	                        if (source[index] === '{') {
	                            ++index;
	                            str += scanUnicodeCodePointEscape();
	                        } else {
	                            unescaped = scanHexEscape(ch);
	                            if (!unescaped) {
	                                throw throwUnexpectedToken();
	                            }
	                            str += unescaped;
	                        }
	                        break;
	                    case 'n':
	                        str += '\n';
	                        break;
	                    case 'r':
	                        str += '\r';
	                        break;
	                    case 't':
	                        str += '\t';
	                        break;
	                    case 'b':
	                        str += '\b';
	                        break;
	                    case 'f':
	                        str += '\f';
	                        break;
	                    case 'v':
	                        str += '\x0B';
	                        break;
	                    case '8':
	                    case '9':
	                        str += ch;
	                        tolerateUnexpectedToken();
	                        break;
	
	                    default:
	                        if (isOctalDigit(ch)) {
	                            octToDec = octalToDecimal(ch);
	
	                            octal = octToDec.octal || octal;
	                            str += String.fromCharCode(octToDec.code);
	                        } else {
	                            str += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    ++lineNumber;
	                    if (ch === '\r' && source[index] === '\n') {
	                        ++index;
	                    }
	                    lineStart = index;
	                }
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            } else {
	                str += ch;
	            }
	        }
	
	        if (quote !== '') {
	            throwUnexpectedToken();
	        }
	
	        return {
	            type: Token.StringLiteral,
	            value: str,
	            octal: octal,
	            lineNumber: startLineNumber,
	            lineStart: startLineStart,
	            start: start,
	            end: index
	        };
	    }
	
	    // ECMA-262 11.8.6 Template Literal Lexical Components
	
	    function scanTemplate() {
	        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;
	
	        terminated = false;
	        tail = false;
	        start = index;
	        head = (source[index] === '`');
	        rawOffset = 2;
	
	        ++index;
	
	        while (index < length) {
	            ch = source[index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            } else if (ch === '$') {
	                if (source[index] === '{') {
	                    state.curlyStack.push('${');
	                    ++index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            } else if (ch === '\\') {
	                ch = source[index++];
	                if (!isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'n':
	                        cooked += '\n';
	                        break;
	                    case 'r':
	                        cooked += '\r';
	                        break;
	                    case 't':
	                        cooked += '\t';
	                        break;
	                    case 'u':
	                    case 'x':
	                        if (source[index] === '{') {
	                            ++index;
	                            cooked += scanUnicodeCodePointEscape();
	                        } else {
	                            restore = index;
	                            unescaped = scanHexEscape(ch);
	                            if (unescaped) {
	                                cooked += unescaped;
	                            } else {
	                                index = restore;
	                                cooked += ch;
	                            }
	                        }
	                        break;
	                    case 'b':
	                        cooked += '\b';
	                        break;
	                    case 'f':
	                        cooked += '\f';
	                        break;
	                    case 'v':
	                        cooked += '\v';
	                        break;
	
	                    default:
	                        if (ch === '0') {
	                            if (isDecimalDigit(source.charCodeAt(index))) {
	                                // Illegal: \01 \02 and so on
	                                throwError(Messages.TemplateOctalLiteral);
	                            }
	                            cooked += '\0';
	                        } else if (isOctalDigit(ch)) {
	                            // Illegal: \1 \2
	                            throwError(Messages.TemplateOctalLiteral);
	                        } else {
	                            cooked += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    ++lineNumber;
	                    if (ch === '\r' && source[index] === '\n') {
	                        ++index;
	                    }
	                    lineStart = index;
	                }
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                ++lineNumber;
	                if (ch === '\r' && source[index] === '\n') {
	                    ++index;
	                }
	                lineStart = index;
	                cooked += '\n';
	            } else {
	                cooked += ch;
	            }
	        }
	
	        if (!terminated) {
	            throwUnexpectedToken();
	        }
	
	        if (!head) {
	            state.curlyStack.pop();
	        }
	
	        return {
	            type: Token.Template,
	            value: {
	                cooked: cooked,
	                raw: source.slice(start + 1, index - rawOffset)
	            },
	            head: head,
	            tail: tail,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }
	
	    // ECMA-262 11.8.5 Regular Expression Literals
	
	    function testRegExp(pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF',
	            tmp = pattern;
	
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                // Replace every Unicode escape sequence with the equivalent
	                // BMP character or a constant ASCII code point in the case of
	                // astral symbols. (See the above note on `astralSubstitute`
	                // for more information.)
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                    var codePoint = parseInt($1 || $2, 16);
	                    if (codePoint > 0x10FFFF) {
	                        throwUnexpectedToken(null, Messages.InvalidRegExp);
	                    }
	                    if (codePoint <= 0xFFFF) {
	                        return String.fromCharCode(codePoint);
	                    }
	                    return astralSubstitute;
	                })
	                // Replace each paired surrogate with a single ASCII symbol to
	                // avoid throwing on regular expressions that are only valid in
	                // combination with the "u" flag.
	                .replace(
	                    /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
	                    astralSubstitute
	                );
	        }
	
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        } catch (e) {
	            throwUnexpectedToken(null, Messages.InvalidRegExp);
	        }
	
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        } catch (exception) {
	            return null;
	        }
	    }
	
	    function scanRegExpBody() {
	        var ch, str, classMarker, terminated, body;
	
	        ch = source[index];
	        assert(ch === '/', 'Regular expression literal must start with a slash');
	        str = source[index++];
	
	        classMarker = false;
	        terminated = false;
	        while (index < length) {
	            ch = source[index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = source[index++];
	                // ECMA-262 7.8.5
	                if (isLineTerminator(ch.charCodeAt(0))) {
	                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	            } else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            } else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                } else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	
	        if (!terminated) {
	            throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	        }
	
	        // Exclude leading and trailing slash.
	        body = str.substr(1, str.length - 2);
	        return {
	            value: body,
	            literal: str
	        };
	    }
	
	    function scanRegExpFlags() {
	        var ch, str, flags, restore;
	
	        str = '';
	        flags = '';
	        while (index < length) {
	            ch = source[index];
	            if (!isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	
	            ++index;
	            if (ch === '\\' && index < length) {
	                ch = source[index];
	                if (ch === 'u') {
	                    ++index;
	                    restore = index;
	                    ch = scanHexEscape('u');
	                    if (ch) {
	                        flags += ch;
	                        for (str += '\\u'; restore < index; ++restore) {
	                            str += source[restore];
	                        }
	                    } else {
	                        index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    tolerateUnexpectedToken();
	                } else {
	                    str += '\\';
	                    tolerateUnexpectedToken();
	                }
	            } else {
	                flags += ch;
	                str += ch;
	            }
	        }
	
	        return {
	            value: flags,
	            literal: str
	        };
	    }
	
	    function scanRegExp() {
	        var start, body, flags, value;
	        scanning = true;
	
	        lookahead = null;
	        skipComment();
	        start = index;
	
	        body = scanRegExpBody();
	        flags = scanRegExpFlags();
	        value = testRegExp(body.value, flags.value);
	        scanning = false;
	        if (extra.tokenize) {
	            return {
	                type: Token.RegularExpression,
	                value: value,
	                regex: {
	                    pattern: body.value,
	                    flags: flags.value
	                },
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }
	
	        return {
	            literal: body.literal + flags.literal,
	            value: value,
	            regex: {
	                pattern: body.value,
	                flags: flags.value
	            },
	            start: start,
	            end: index
	        };
	    }
	
	    function collectRegex() {
	        var pos, loc, regex, token;
	
	        skipComment();
	
	        pos = index;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };
	
	        regex = scanRegExp();
	
	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };
	
	        /* istanbul ignore next */
	        if (!extra.tokenize) {
	            // Pop the previous token, which is likely '/' or '/='
	            if (extra.tokens.length > 0) {
	                token = extra.tokens[extra.tokens.length - 1];
	                if (token.range[0] === pos && token.type === 'Punctuator') {
	                    if (token.value === '/' || token.value === '/=') {
	                        extra.tokens.pop();
	                    }
	                }
	            }
	
	            extra.tokens.push({
	                type: 'RegularExpression',
	                value: regex.literal,
	                regex: regex.regex,
	                range: [pos, index],
	                loc: loc
	            });
	        }
	
	        return regex;
	    }
	
	    function isIdentifierName(token) {
	        return token.type === Token.Identifier ||
	            token.type === Token.Keyword ||
	            token.type === Token.BooleanLiteral ||
	            token.type === Token.NullLiteral;
	    }
	
	    function advanceSlash() {
	        var prevToken,
	            checkToken;
	        // Using the following algorithm:
	        // https://github.com/mozilla/sweet.js/wiki/design
	        prevToken = extra.tokens[extra.tokens.length - 1];
	        if (!prevToken) {
	            // Nothing before that: it cannot be a division.
	            return collectRegex();
	        }
	        if (prevToken.type === 'Punctuator') {
	            if (prevToken.value === ']') {
	                return scanPunctuator();
	            }
	            if (prevToken.value === ')') {
	                checkToken = extra.tokens[extra.openParenToken - 1];
	                if (checkToken &&
	                        checkToken.type === 'Keyword' &&
	                        (checkToken.value === 'if' ||
	                         checkToken.value === 'while' ||
	                         checkToken.value === 'for' ||
	                         checkToken.value === 'with')) {
	                    return collectRegex();
	                }
	                return scanPunctuator();
	            }
	            if (prevToken.value === '}') {
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                if (extra.tokens[extra.openCurlyToken - 3] &&
	                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
	                    // Anonymous function.
	                    checkToken = extra.tokens[extra.openCurlyToken - 4];
	                    if (!checkToken) {
	                        return scanPunctuator();
	                    }
	                } else if (extra.tokens[extra.openCurlyToken - 4] &&
	                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
	                    // Named function.
	                    checkToken = extra.tokens[extra.openCurlyToken - 5];
	                    if (!checkToken) {
	                        return collectRegex();
	                    }
	                } else {
	                    return scanPunctuator();
	                }
	                // checkToken determines whether the function is
	                // a declaration or an expression.
	                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
	                    // It is an expression.
	                    return scanPunctuator();
	                }
	                // It is a declaration.
	                return collectRegex();
	            }
	            return collectRegex();
	        }
	        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
	            return collectRegex();
	        }
	        return scanPunctuator();
	    }
	
	    function advance() {
	        var cp, token;
	
	        if (index >= length) {
	            return {
	                type: Token.EOF,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: index,
	                end: index
	            };
	        }
	
	        cp = source.charCodeAt(index);
	
	        if (isIdentifierStart(cp)) {
	            token = scanIdentifier();
	            if (strict && isStrictModeReservedWord(token.value)) {
	                token.type = Token.Keyword;
	            }
	            return token;
	        }
	
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return scanPunctuator();
	        }
	
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return scanStringLiteral();
	        }
	
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (isDecimalDigit(source.charCodeAt(index + 1))) {
	                return scanNumericLiteral();
	            }
	            return scanPunctuator();
	        }
	
	        if (isDecimalDigit(cp)) {
	            return scanNumericLiteral();
	        }
	
	        // Slash (/) U+002F can also start a regex.
	        if (extra.tokenize && cp === 0x2F) {
	            return advanceSlash();
	        }
	
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {
	            return scanTemplate();
	        }
	
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            cp = codePointAt(index);
	            if (isIdentifierStart(cp)) {
	                return scanIdentifier();
	            }
	        }
	
	        return scanPunctuator();
	    }
	
	    function collectToken() {
	        var loc, token, value, entry;
	
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };
	
	        token = advance();
	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };
	
	        if (token.type !== Token.EOF) {
	            value = source.slice(token.start, token.end);
	            entry = {
	                type: TokenName[token.type],
	                value: value,
	                range: [token.start, token.end],
	                loc: loc
	            };
	            if (token.regex) {
	                entry.regex = {
	                    pattern: token.regex.pattern,
	                    flags: token.regex.flags
	                };
	            }
	            extra.tokens.push(entry);
	        }
	
	        return token;
	    }
	
	    function lex() {
	        var token;
	        scanning = true;
	
	        lastIndex = index;
	        lastLineNumber = lineNumber;
	        lastLineStart = lineStart;
	
	        skipComment();
	
	        token = lookahead;
	
	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;
	
	        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
	        scanning = false;
	        return token;
	    }
	
	    function peek() {
	        scanning = true;
	
	        skipComment();
	
	        lastIndex = index;
	        lastLineNumber = lineNumber;
	        lastLineStart = lineStart;
	
	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;
	
	        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
	        scanning = false;
	    }
	
	    function Position() {
	        this.line = startLineNumber;
	        this.column = startIndex - startLineStart;
	    }
	
	    function SourceLocation() {
	        this.start = new Position();
	        this.end = null;
	    }
	
	    function WrappingSourceLocation(startToken) {
	        this.start = {
	            line: startToken.lineNumber,
	            column: startToken.start - startToken.lineStart
	        };
	        this.end = null;
	    }
	
	    function Node() {
	        if (extra.range) {
	            this.range = [startIndex, 0];
	        }
	        if (extra.loc) {
	            this.loc = new SourceLocation();
	        }
	    }
	
	    function WrappingNode(startToken) {
	        if (extra.range) {
	            this.range = [startToken.start, 0];
	        }
	        if (extra.loc) {
	            this.loc = new WrappingSourceLocation(startToken);
	        }
	    }
	
	    WrappingNode.prototype = Node.prototype = {
	
	        processComment: function () {
	            var lastChild,
	                leadingComments,
	                trailingComments,
	                bottomRight = extra.bottomRightStack,
	                i,
	                comment,
	                last = bottomRight[bottomRight.length - 1];
	
	            if (this.type === Syntax.Program) {
	                if (this.body.length > 0) {
	                    return;
	                }
	            }
	
	            if (extra.trailingComments.length > 0) {
	                trailingComments = [];
	                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
	                    comment = extra.trailingComments[i];
	                    if (comment.range[0] >= this.range[1]) {
	                        trailingComments.unshift(comment);
	                        extra.trailingComments.splice(i, 1);
	                    }
	                }
	                extra.trailingComments = [];
	            } else {
	                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
	                    trailingComments = last.trailingComments;
	                    delete last.trailingComments;
	                }
	            }
	
	            // Eating the stack.
	            while (last && last.range[0] >= this.range[0]) {
	                lastChild = bottomRight.pop();
	                last = bottomRight[bottomRight.length - 1];
	            }
	
	            if (lastChild) {
	                if (lastChild.leadingComments) {
	                    leadingComments = [];
	                    for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {
	                        comment = lastChild.leadingComments[i];
	                        if (comment.range[1] <= this.range[0]) {
	                            leadingComments.unshift(comment);
	                            lastChild.leadingComments.splice(i, 1);
	                        }
	                    }
	
	                    if (!lastChild.leadingComments.length) {
	                        lastChild.leadingComments = undefined;
	                    }
	                }
	            } else if (extra.leadingComments.length > 0) {
	                leadingComments = [];
	                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
	                    comment = extra.leadingComments[i];
	                    if (comment.range[1] <= this.range[0]) {
	                        leadingComments.unshift(comment);
	                        extra.leadingComments.splice(i, 1);
	                    }
	                }
	            }
	
	
	            if (leadingComments && leadingComments.length > 0) {
	                this.leadingComments = leadingComments;
	            }
	            if (trailingComments && trailingComments.length > 0) {
	                this.trailingComments = trailingComments;
	            }
	
	            bottomRight.push(this);
	        },
	
	        finish: function () {
	            if (extra.range) {
	                this.range[1] = lastIndex;
	            }
	            if (extra.loc) {
	                this.loc.end = {
	                    line: lastLineNumber,
	                    column: lastIndex - lastLineStart
	                };
	                if (extra.source) {
	                    this.loc.source = extra.source;
	                }
	            }
	
	            if (extra.attachComment) {
	                this.processComment();
	            }
	        },
	
	        finishArrayExpression: function (elements) {
	            this.type = Syntax.ArrayExpression;
	            this.elements = elements;
	            this.finish();
	            return this;
	        },
	
	        finishArrayPattern: function (elements) {
	            this.type = Syntax.ArrayPattern;
	            this.elements = elements;
	            this.finish();
	            return this;
	        },
	
	        finishArrowFunctionExpression: function (params, defaults, body, expression) {
	            this.type = Syntax.ArrowFunctionExpression;
	            this.id = null;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = false;
	            this.expression = expression;
	            this.finish();
	            return this;
	        },
	
	        finishAssignmentExpression: function (operator, left, right) {
	            this.type = Syntax.AssignmentExpression;
	            this.operator = operator;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },
	
	        finishAssignmentPattern: function (left, right) {
	            this.type = Syntax.AssignmentPattern;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },
	
	        finishBinaryExpression: function (operator, left, right) {
	            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
	            this.operator = operator;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },
	
	        finishBlockStatement: function (body) {
	            this.type = Syntax.BlockStatement;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishBreakStatement: function (label) {
	            this.type = Syntax.BreakStatement;
	            this.label = label;
	            this.finish();
	            return this;
	        },
	
	        finishCallExpression: function (callee, args) {
	            this.type = Syntax.CallExpression;
	            this.callee = callee;
	            this.arguments = args;
	            this.finish();
	            return this;
	        },
	
	        finishCatchClause: function (param, body) {
	            this.type = Syntax.CatchClause;
	            this.param = param;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishClassBody: function (body) {
	            this.type = Syntax.ClassBody;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishClassDeclaration: function (id, superClass, body) {
	            this.type = Syntax.ClassDeclaration;
	            this.id = id;
	            this.superClass = superClass;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishClassExpression: function (id, superClass, body) {
	            this.type = Syntax.ClassExpression;
	            this.id = id;
	            this.superClass = superClass;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishConditionalExpression: function (test, consequent, alternate) {
	            this.type = Syntax.ConditionalExpression;
	            this.test = test;
	            this.consequent = consequent;
	            this.alternate = alternate;
	            this.finish();
	            return this;
	        },
	
	        finishContinueStatement: function (label) {
	            this.type = Syntax.ContinueStatement;
	            this.label = label;
	            this.finish();
	            return this;
	        },
	
	        finishDebuggerStatement: function () {
	            this.type = Syntax.DebuggerStatement;
	            this.finish();
	            return this;
	        },
	
	        finishDoWhileStatement: function (body, test) {
	            this.type = Syntax.DoWhileStatement;
	            this.body = body;
	            this.test = test;
	            this.finish();
	            return this;
	        },
	
	        finishEmptyStatement: function () {
	            this.type = Syntax.EmptyStatement;
	            this.finish();
	            return this;
	        },
	
	        finishExpressionStatement: function (expression) {
	            this.type = Syntax.ExpressionStatement;
	            this.expression = expression;
	            this.finish();
	            return this;
	        },
	
	        finishForStatement: function (init, test, update, body) {
	            this.type = Syntax.ForStatement;
	            this.init = init;
	            this.test = test;
	            this.update = update;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishForOfStatement: function (left, right, body) {
	            this.type = Syntax.ForOfStatement;
	            this.left = left;
	            this.right = right;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishForInStatement: function (left, right, body) {
	            this.type = Syntax.ForInStatement;
	            this.left = left;
	            this.right = right;
	            this.body = body;
	            this.each = false;
	            this.finish();
	            return this;
	        },
	
	        finishFunctionDeclaration: function (id, params, defaults, body, generator) {
	            this.type = Syntax.FunctionDeclaration;
	            this.id = id;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = generator;
	            this.expression = false;
	            this.finish();
	            return this;
	        },
	
	        finishFunctionExpression: function (id, params, defaults, body, generator) {
	            this.type = Syntax.FunctionExpression;
	            this.id = id;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = generator;
	            this.expression = false;
	            this.finish();
	            return this;
	        },
	
	        finishIdentifier: function (name) {
	            this.type = Syntax.Identifier;
	            this.name = name;
	            this.finish();
	            return this;
	        },
	
	        finishIfStatement: function (test, consequent, alternate) {
	            this.type = Syntax.IfStatement;
	            this.test = test;
	            this.consequent = consequent;
	            this.alternate = alternate;
	            this.finish();
	            return this;
	        },
	
	        finishLabeledStatement: function (label, body) {
	            this.type = Syntax.LabeledStatement;
	            this.label = label;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishLiteral: function (token) {
	            this.type = Syntax.Literal;
	            this.value = token.value;
	            this.raw = source.slice(token.start, token.end);
	            if (token.regex) {
	                this.regex = token.regex;
	            }
	            this.finish();
	            return this;
	        },
	
	        finishMemberExpression: function (accessor, object, property) {
	            this.type = Syntax.MemberExpression;
	            this.computed = accessor === '[';
	            this.object = object;
	            this.property = property;
	            this.finish();
	            return this;
	        },
	
	        finishMetaProperty: function (meta, property) {
	            this.type = Syntax.MetaProperty;
	            this.meta = meta;
	            this.property = property;
	            this.finish();
	            return this;
	        },
	
	        finishNewExpression: function (callee, args) {
	            this.type = Syntax.NewExpression;
	            this.callee = callee;
	            this.arguments = args;
	            this.finish();
	            return this;
	        },
	
	        finishObjectExpression: function (properties) {
	            this.type = Syntax.ObjectExpression;
	            this.properties = properties;
	            this.finish();
	            return this;
	        },
	
	        finishObjectPattern: function (properties) {
	            this.type = Syntax.ObjectPattern;
	            this.properties = properties;
	            this.finish();
	            return this;
	        },
	
	        finishPostfixExpression: function (operator, argument) {
	            this.type = Syntax.UpdateExpression;
	            this.operator = operator;
	            this.argument = argument;
	            this.prefix = false;
	            this.finish();
	            return this;
	        },
	
	        finishProgram: function (body, sourceType) {
	            this.type = Syntax.Program;
	            this.body = body;
	            this.sourceType = sourceType;
	            this.finish();
	            return this;
	        },
	
	        finishProperty: function (kind, key, computed, value, method, shorthand) {
	            this.type = Syntax.Property;
	            this.key = key;
	            this.computed = computed;
	            this.value = value;
	            this.kind = kind;
	            this.method = method;
	            this.shorthand = shorthand;
	            this.finish();
	            return this;
	        },
	
	        finishRestElement: function (argument) {
	            this.type = Syntax.RestElement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },
	
	        finishReturnStatement: function (argument) {
	            this.type = Syntax.ReturnStatement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },
	
	        finishSequenceExpression: function (expressions) {
	            this.type = Syntax.SequenceExpression;
	            this.expressions = expressions;
	            this.finish();
	            return this;
	        },
	
	        finishSpreadElement: function (argument) {
	            this.type = Syntax.SpreadElement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },
	
	        finishSwitchCase: function (test, consequent) {
	            this.type = Syntax.SwitchCase;
	            this.test = test;
	            this.consequent = consequent;
	            this.finish();
	            return this;
	        },
	
	        finishSuper: function () {
	            this.type = Syntax.Super;
	            this.finish();
	            return this;
	        },
	
	        finishSwitchStatement: function (discriminant, cases) {
	            this.type = Syntax.SwitchStatement;
	            this.discriminant = discriminant;
	            this.cases = cases;
	            this.finish();
	            return this;
	        },
	
	        finishTaggedTemplateExpression: function (tag, quasi) {
	            this.type = Syntax.TaggedTemplateExpression;
	            this.tag = tag;
	            this.quasi = quasi;
	            this.finish();
	            return this;
	        },
	
	        finishTemplateElement: function (value, tail) {
	            this.type = Syntax.TemplateElement;
	            this.value = value;
	            this.tail = tail;
	            this.finish();
	            return this;
	        },
	
	        finishTemplateLiteral: function (quasis, expressions) {
	            this.type = Syntax.TemplateLiteral;
	            this.quasis = quasis;
	            this.expressions = expressions;
	            this.finish();
	            return this;
	        },
	
	        finishThisExpression: function () {
	            this.type = Syntax.ThisExpression;
	            this.finish();
	            return this;
	        },
	
	        finishThrowStatement: function (argument) {
	            this.type = Syntax.ThrowStatement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },
	
	        finishTryStatement: function (block, handler, finalizer) {
	            this.type = Syntax.TryStatement;
	            this.block = block;
	            this.guardedHandlers = [];
	            this.handlers = handler ? [handler] : [];
	            this.handler = handler;
	            this.finalizer = finalizer;
	            this.finish();
	            return this;
	        },
	
	        finishUnaryExpression: function (operator, argument) {
	            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
	            this.operator = operator;
	            this.argument = argument;
	            this.prefix = true;
	            this.finish();
	            return this;
	        },
	
	        finishVariableDeclaration: function (declarations) {
	            this.type = Syntax.VariableDeclaration;
	            this.declarations = declarations;
	            this.kind = 'var';
	            this.finish();
	            return this;
	        },
	
	        finishLexicalDeclaration: function (declarations, kind) {
	            this.type = Syntax.VariableDeclaration;
	            this.declarations = declarations;
	            this.kind = kind;
	            this.finish();
	            return this;
	        },
	
	        finishVariableDeclarator: function (id, init) {
	            this.type = Syntax.VariableDeclarator;
	            this.id = id;
	            this.init = init;
	            this.finish();
	            return this;
	        },
	
	        finishWhileStatement: function (test, body) {
	            this.type = Syntax.WhileStatement;
	            this.test = test;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishWithStatement: function (object, body) {
	            this.type = Syntax.WithStatement;
	            this.object = object;
	            this.body = body;
	            this.finish();
	            return this;
	        },
	
	        finishExportSpecifier: function (local, exported) {
	            this.type = Syntax.ExportSpecifier;
	            this.exported = exported || local;
	            this.local = local;
	            this.finish();
	            return this;
	        },
	
	        finishImportDefaultSpecifier: function (local) {
	            this.type = Syntax.ImportDefaultSpecifier;
	            this.local = local;
	            this.finish();
	            return this;
	        },
	
	        finishImportNamespaceSpecifier: function (local) {
	            this.type = Syntax.ImportNamespaceSpecifier;
	            this.local = local;
	            this.finish();
	            return this;
	        },
	
	        finishExportNamedDeclaration: function (declaration, specifiers, src) {
	            this.type = Syntax.ExportNamedDeclaration;
	            this.declaration = declaration;
	            this.specifiers = specifiers;
	            this.source = src;
	            this.finish();
	            return this;
	        },
	
	        finishExportDefaultDeclaration: function (declaration) {
	            this.type = Syntax.ExportDefaultDeclaration;
	            this.declaration = declaration;
	            this.finish();
	            return this;
	        },
	
	        finishExportAllDeclaration: function (src) {
	            this.type = Syntax.ExportAllDeclaration;
	            this.source = src;
	            this.finish();
	            return this;
	        },
	
	        finishImportSpecifier: function (local, imported) {
	            this.type = Syntax.ImportSpecifier;
	            this.local = local || imported;
	            this.imported = imported;
	            this.finish();
	            return this;
	        },
	
	        finishImportDeclaration: function (specifiers, src) {
	            this.type = Syntax.ImportDeclaration;
	            this.specifiers = specifiers;
	            this.source = src;
	            this.finish();
	            return this;
	        },
	
	        finishYieldExpression: function (argument, delegate) {
	            this.type = Syntax.YieldExpression;
	            this.argument = argument;
	            this.delegate = delegate;
	            this.finish();
	            return this;
	        }
	    };
	
	
	    function recordError(error) {
	        var e, existing;
	
	        for (e = 0; e < extra.errors.length; e++) {
	            existing = extra.errors[e];
	            // Prevent duplicated error.
	            /* istanbul ignore next */
	            if (existing.index === error.index && existing.message === error.message) {
	                return;
	            }
	        }
	
	        extra.errors.push(error);
	    }
	
	    function constructError(msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        } catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        } finally {
	            return error;
	        }
	    }
	
	    function createError(line, pos, description) {
	        var msg, column, error;
	
	        msg = 'Line ' + line + ': ' + description;
	        column = pos - (scanning ? lineStart : lastLineStart) + 1;
	        error = constructError(msg, column);
	        error.lineNumber = line;
	        error.description = description;
	        error.index = pos;
	        return error;
	    }
	
	    // Throw an exception
	
	    function throwError(messageFormat) {
	        var args, msg;
	
	        args = Array.prototype.slice.call(arguments, 1);
	        msg = messageFormat.replace(/%(\d)/g,
	            function (whole, idx) {
	                assert(idx < args.length, 'Message reference must be in range');
	                return args[idx];
	            }
	        );
	
	        throw createError(lastLineNumber, lastIndex, msg);
	    }
	
	    function tolerateError(messageFormat) {
	        var args, msg, error;
	
	        args = Array.prototype.slice.call(arguments, 1);
	        /* istanbul ignore next */
	        msg = messageFormat.replace(/%(\d)/g,
	            function (whole, idx) {
	                assert(idx < args.length, 'Message reference must be in range');
	                return args[idx];
	            }
	        );
	
	        error = createError(lineNumber, lastIndex, msg);
	        if (extra.errors) {
	            recordError(error);
	        } else {
	            throw error;
	        }
	    }
	
	    // Throw an exception because of the token.
	
	    function unexpectedTokenError(token, message) {
	        var value, msg = message || Messages.UnexpectedToken;
	
	        if (token) {
	            if (!message) {
	                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :
	                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
	                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
	                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
	                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :
	                    Messages.UnexpectedToken;
	
	                if (token.type === Token.Keyword) {
	                    if (isFutureReservedWord(token.value)) {
	                        msg = Messages.UnexpectedReserved;
	                    } else if (strict && isStrictModeReservedWord(token.value)) {
	                        msg = Messages.StrictReservedWord;
	                    }
	                }
	            }
	
	            value = (token.type === Token.Template) ? token.value.raw : token.value;
	        } else {
	            value = 'ILLEGAL';
	        }
	
	        msg = msg.replace('%0', value);
	
	        return (token && typeof token.lineNumber === 'number') ?
	            createError(token.lineNumber, token.start, msg) :
	            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
	    }
	
	    function throwUnexpectedToken(token, message) {
	        throw unexpectedTokenError(token, message);
	    }
	
	    function tolerateUnexpectedToken(token, message) {
	        var error = unexpectedTokenError(token, message);
	        if (extra.errors) {
	            recordError(error);
	        } else {
	            throw error;
	        }
	    }
	
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	
	    function expect(value) {
	        var token = lex();
	        if (token.type !== Token.Punctuator || token.value !== value) {
	            throwUnexpectedToken(token);
	        }
	    }
	
	    /**
	     * @name expectCommaSeparator
	     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
	     * to <code>expect(value)</code>
	     * @since 2.0
	     */
	    function expectCommaSeparator() {
	        var token;
	
	        if (extra.errors) {
	            token = lookahead;
	            if (token.type === Token.Punctuator && token.value === ',') {
	                lex();
	            } else if (token.type === Token.Punctuator && token.value === ';') {
	                lex();
	                tolerateUnexpectedToken(token);
	            } else {
	                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
	            }
	        } else {
	            expect(',');
	        }
	    }
	
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	
	    function expectKeyword(keyword) {
	        var token = lex();
	        if (token.type !== Token.Keyword || token.value !== keyword) {
	            throwUnexpectedToken(token);
	        }
	    }
	
	    // Return true if the next token matches the specified punctuator.
	
	    function match(value) {
	        return lookahead.type === Token.Punctuator && lookahead.value === value;
	    }
	
	    // Return true if the next token matches the specified keyword
	
	    function matchKeyword(keyword) {
	        return lookahead.type === Token.Keyword && lookahead.value === keyword;
	    }
	
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	
	    function matchContextualKeyword(keyword) {
	        return lookahead.type === Token.Identifier && lookahead.value === keyword;
	    }
	
	    // Return true if the next token is an assignment operator
	
	    function matchAssign() {
	        var op;
	
	        if (lookahead.type !== Token.Punctuator) {
	            return false;
	        }
	        op = lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    }
	
	    function consumeSemicolon() {
	        // Catch the very common case first: immediately a semicolon (U+003B).
	        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {
	            lex();
	            return;
	        }
	
	        if (hasLineTerminator) {
	            return;
	        }
	
	        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
	        lastIndex = startIndex;
	        lastLineNumber = startLineNumber;
	        lastLineStart = startLineStart;
	
	        if (lookahead.type !== Token.EOF && !match('}')) {
	            throwUnexpectedToken(lookahead);
	        }
	    }
	
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    function isolateCoverGrammar(parser) {
	        var oldIsBindingElement = isBindingElement,
	            oldIsAssignmentTarget = isAssignmentTarget,
	            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
	            result;
	        isBindingElement = true;
	        isAssignmentTarget = true;
	        firstCoverInitializedNameError = null;
	        result = parser();
	        if (firstCoverInitializedNameError !== null) {
	            throwUnexpectedToken(firstCoverInitializedNameError);
	        }
	        isBindingElement = oldIsBindingElement;
	        isAssignmentTarget = oldIsAssignmentTarget;
	        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
	        return result;
	    }
	
	    function inheritCoverGrammar(parser) {
	        var oldIsBindingElement = isBindingElement,
	            oldIsAssignmentTarget = isAssignmentTarget,
	            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
	            result;
	        isBindingElement = true;
	        isAssignmentTarget = true;
	        firstCoverInitializedNameError = null;
	        result = parser();
	        isBindingElement = isBindingElement && oldIsBindingElement;
	        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
	        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
	        return result;
	    }
	
	    // ECMA-262 13.3.3 Destructuring Binding Patterns
	
	    function parseArrayPattern(params, kind) {
	        var node = new Node(), elements = [], rest, restNode;
	        expect('[');
	
	        while (!match(']')) {
	            if (match(',')) {
	                lex();
	                elements.push(null);
	            } else {
	                if (match('...')) {
	                    restNode = new Node();
	                    lex();
	                    params.push(lookahead);
	                    rest = parseVariableIdentifier(params, kind);
	                    elements.push(restNode.finishRestElement(rest));
	                    break;
	                } else {
	                    elements.push(parsePatternWithDefault(params, kind));
	                }
	                if (!match(']')) {
	                    expect(',');
	                }
	            }
	
	        }
	
	        expect(']');
	
	        return node.finishArrayPattern(elements);
	    }
	
	    function parsePropertyPattern(params, kind) {
	        var node = new Node(), key, keyToken, computed = match('['), init;
	        if (lookahead.type === Token.Identifier) {
	            keyToken = lookahead;
	            key = parseVariableIdentifier();
	            if (match('=')) {
	                params.push(keyToken);
	                lex();
	                init = parseAssignmentExpression();
	
	                return node.finishProperty(
	                    'init', key, false,
	                    new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, false);
	            } else if (!match(':')) {
	                params.push(keyToken);
	                return node.finishProperty('init', key, false, key, false, true);
	            }
	        } else {
	            key = parseObjectPropertyKey(params, kind);
	        }
	        expect(':');
	        init = parsePatternWithDefault(params, kind);
	        return node.finishProperty('init', key, computed, init, false, false);
	    }
	
	    function parseObjectPattern(params, kind) {
	        var node = new Node(), properties = [];
	
	        expect('{');
	
	        while (!match('}')) {
	            properties.push(parsePropertyPattern(params, kind));
	            if (!match('}')) {
	                expect(',');
	            }
	        }
	
	        lex();
	
	        return node.finishObjectPattern(properties);
	    }
	
	    function parsePattern(params, kind) {
	        if (match('[')) {
	            return parseArrayPattern(params, kind);
	        } else if (match('{')) {
	            return parseObjectPattern(params, kind);
	        }
	        params.push(lookahead);
	        return parseVariableIdentifier(kind);
	    }
	
	    function parsePatternWithDefault(params, kind) {
	        var startToken = lookahead, pattern, previousAllowYield, right;
	        pattern = parsePattern(params, kind);
	        if (match('=')) {
	            lex();
	            previousAllowYield = state.allowYield;
	            state.allowYield = true;
	            right = isolateCoverGrammar(parseAssignmentExpression);
	            state.allowYield = previousAllowYield;
	            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);
	        }
	        return pattern;
	    }
	
	    // ECMA-262 12.2.5 Array Initializer
	
	    function parseArrayInitializer() {
	        var elements = [], node = new Node(), restSpread;
	
	        expect('[');
	
	        while (!match(']')) {
	            if (match(',')) {
	                lex();
	                elements.push(null);
	            } else if (match('...')) {
	                restSpread = new Node();
	                lex();
	                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));
	
	                if (!match(']')) {
	                    isAssignmentTarget = isBindingElement = false;
	                    expect(',');
	                }
	                elements.push(restSpread);
	            } else {
	                elements.push(inheritCoverGrammar(parseAssignmentExpression));
	
	                if (!match(']')) {
	                    expect(',');
	                }
	            }
	        }
	
	        lex();
	
	        return node.finishArrayExpression(elements);
	    }
	
	    // ECMA-262 12.2.6 Object Initializer
	
	    function parsePropertyFunction(node, paramInfo, isGenerator) {
	        var previousStrict, body;
	
	        isAssignmentTarget = isBindingElement = false;
	
	        previousStrict = strict;
	        body = isolateCoverGrammar(parseFunctionSourceElements);
	
	        if (strict && paramInfo.firstRestricted) {
	            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
	        }
	        if (strict && paramInfo.stricted) {
	            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
	        }
	
	        strict = previousStrict;
	        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);
	    }
	
	    function parsePropertyMethodFunction() {
	        var params, method, node = new Node(),
	            previousAllowYield = state.allowYield;
	
	        state.allowYield = false;
	        params = parseParams();
	        state.allowYield = previousAllowYield;
	
	        state.allowYield = false;
	        method = parsePropertyFunction(node, params, false);
	        state.allowYield = previousAllowYield;
	
	        return method;
	    }
	
	    function parseObjectPropertyKey() {
	        var token, node = new Node(), expr;
	
	        token = lex();
	
	        // Note: This function is called only from parseObjectProperty(), where
	        // EOF and Punctuator tokens are already filtered out.
	
	        switch (token.type) {
	        case Token.StringLiteral:
	        case Token.NumericLiteral:
	            if (strict && token.octal) {
	                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
	            }
	            return node.finishLiteral(token);
	        case Token.Identifier:
	        case Token.BooleanLiteral:
	        case Token.NullLiteral:
	        case Token.Keyword:
	            return node.finishIdentifier(token.value);
	        case Token.Punctuator:
	            if (token.value === '[') {
	                expr = isolateCoverGrammar(parseAssignmentExpression);
	                expect(']');
	                return expr;
	            }
	            break;
	        }
	        throwUnexpectedToken(token);
	    }
	
	    function lookaheadPropertyName() {
	        switch (lookahead.type) {
	        case Token.Identifier:
	        case Token.StringLiteral:
	        case Token.BooleanLiteral:
	        case Token.NullLiteral:
	        case Token.NumericLiteral:
	        case Token.Keyword:
	            return true;
	        case Token.Punctuator:
	            return lookahead.value === '[';
	        }
	        return false;
	    }
	
	    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
	    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.
	    // This can only be determined after we consumed up to the left parentheses.
	    //
	    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
	    // is responsible to visit other options.
	    function tryParseMethodDefinition(token, key, computed, node) {
	        var value, options, methodNode, params,
	            previousAllowYield = state.allowYield;
	
	        if (token.type === Token.Identifier) {
	            // check for `get` and `set`;
	
	            if (token.value === 'get' && lookaheadPropertyName()) {
	                computed = match('[');
	                key = parseObjectPropertyKey();
	                methodNode = new Node();
	                expect('(');
	                expect(')');
	
	                state.allowYield = false;
	                value = parsePropertyFunction(methodNode, {
	                    params: [],
	                    defaults: [],
	                    stricted: null,
	                    firstRestricted: null,
	                    message: null
	                }, false);
	                state.allowYield = previousAllowYield;
	
	                return node.finishProperty('get', key, computed, value, false, false);
	            } else if (token.value === 'set' && lookaheadPropertyName()) {
	                computed = match('[');
	                key = parseObjectPropertyKey();
	                methodNode = new Node();
	                expect('(');
	
	                options = {
	                    params: [],
	                    defaultCount: 0,
	                    defaults: [],
	                    firstRestricted: null,
	                    paramSet: {}
	                };
	                if (match(')')) {
	                    tolerateUnexpectedToken(lookahead);
	                } else {
	                    state.allowYield = false;
	                    parseParam(options);
	                    state.allowYield = previousAllowYield;
	                    if (options.defaultCount === 0) {
	                        options.defaults = [];
	                    }
	                }
	                expect(')');
	
	                state.allowYield = false;
	                value = parsePropertyFunction(methodNode, options, false);
	                state.allowYield = previousAllowYield;
	
	                return node.finishProperty('set', key, computed, value, false, false);
	            }
	        } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {
	            computed = match('[');
	            key = parseObjectPropertyKey();
	            methodNode = new Node();
	
	            state.allowYield = true;
	            params = parseParams();
	            state.allowYield = previousAllowYield;
	
	            state.allowYield = false;
	            value = parsePropertyFunction(methodNode, params, true);
	            state.allowYield = previousAllowYield;
	
	            return node.finishProperty('init', key, computed, value, true, false);
	        }
	
	        if (key && match('(')) {
	            value = parsePropertyMethodFunction();
	            return node.finishProperty('init', key, computed, value, true, false);
	        }
	
	        // Not a MethodDefinition.
	        return null;
	    }
	
	    function parseObjectProperty(hasProto) {
	        var token = lookahead, node = new Node(), computed, key, maybeMethod, proto, value;
	
	        computed = match('[');
	        if (match('*')) {
	            lex();
	        } else {
	            key = parseObjectPropertyKey();
	        }
	        maybeMethod = tryParseMethodDefinition(token, key, computed, node);
	        if (maybeMethod) {
	            return maybeMethod;
	        }
	
	        if (!key) {
	            throwUnexpectedToken(lookahead);
	        }
	
	        // Check for duplicated __proto__
	        if (!computed) {
	            proto = (key.type === Syntax.Identifier && key.name === '__proto__') ||
	                (key.type === Syntax.Literal && key.value === '__proto__');
	            if (hasProto.value && proto) {
	                tolerateError(Messages.DuplicateProtoProperty);
	            }
	            hasProto.value |= proto;
	        }
	
	        if (match(':')) {
	            lex();
	            value = inheritCoverGrammar(parseAssignmentExpression);
	            return node.finishProperty('init', key, computed, value, false, false);
	        }
	
	        if (token.type === Token.Identifier) {
	            if (match('=')) {
	                firstCoverInitializedNameError = lookahead;
	                lex();
	                value = isolateCoverGrammar(parseAssignmentExpression);
	                return node.finishProperty('init', key, computed,
	                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);
	            }
	            return node.finishProperty('init', key, computed, key, false, true);
	        }
	
	        throwUnexpectedToken(lookahead);
	    }
	
	    function parseObjectInitializer() {
	        var properties = [], hasProto = {value: false}, node = new Node();
	
	        expect('{');
	
	        while (!match('}')) {
	            properties.push(parseObjectProperty(hasProto));
	
	            if (!match('}')) {
	                expectCommaSeparator();
	            }
	        }
	
	        expect('}');
	
	        return node.finishObjectExpression(properties);
	    }
	
	    function reinterpretExpressionAsPattern(expr) {
	        var i;
	        switch (expr.type) {
	        case Syntax.Identifier:
	        case Syntax.MemberExpression:
	        case Syntax.RestElement:
	        case Syntax.AssignmentPattern:
	            break;
	        case Syntax.SpreadElement:
	            expr.type = Syntax.RestElement;
	            reinterpretExpressionAsPattern(expr.argument);
	            break;
	        case Syntax.ArrayExpression:
	            expr.type = Syntax.ArrayPattern;
	            for (i = 0; i < expr.elements.length; i++) {
	                if (expr.elements[i] !== null) {
	                    reinterpretExpressionAsPattern(expr.elements[i]);
	                }
	            }
	            break;
	        case Syntax.ObjectExpression:
	            expr.type = Syntax.ObjectPattern;
	            for (i = 0; i < expr.properties.length; i++) {
	                reinterpretExpressionAsPattern(expr.properties[i].value);
	            }
	            break;
	        case Syntax.AssignmentExpression:
	            expr.type = Syntax.AssignmentPattern;
	            reinterpretExpressionAsPattern(expr.left);
	            break;
	        default:
	            // Allow other node type for tolerant parsing.
	            break;
	        }
	    }
	
	    // ECMA-262 12.2.9 Template Literals
	
	    function parseTemplateElement(option) {
	        var node, token;
	
	        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
	            throwUnexpectedToken();
	        }
	
	        node = new Node();
	        token = lex();
	
	        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);
	    }
	
	    function parseTemplateLiteral() {
	        var quasi, quasis, expressions, node = new Node();
	
	        quasi = parseTemplateElement({ head: true });
	        quasis = [quasi];
	        expressions = [];
	
	        while (!quasi.tail) {
	            expressions.push(parseExpression());
	            quasi = parseTemplateElement({ head: false });
	            quasis.push(quasi);
	        }
	
	        return node.finishTemplateLiteral(quasis, expressions);
	    }
	
	    // ECMA-262 12.2.10 The Grouping Operator
	
	    function parseGroupExpression() {
	        var expr, expressions, startToken, i, params = [];
	
	        expect('(');
	
	        if (match(')')) {
	            lex();
	            if (!match('=>')) {
	                expect('=>');
	            }
	            return {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: [],
	                rawParams: []
	            };
	        }
	
	        startToken = lookahead;
	        if (match('...')) {
	            expr = parseRestElement(params);
	            expect(')');
	            if (!match('=>')) {
	                expect('=>');
	            }
	            return {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: [expr]
	            };
	        }
	
	        isBindingElement = true;
	        expr = inheritCoverGrammar(parseAssignmentExpression);
	
	        if (match(',')) {
	            isAssignmentTarget = false;
	            expressions = [expr];
	
	            while (startIndex < length) {
	                if (!match(',')) {
	                    break;
	                }
	                lex();
	
	                if (match('...')) {
	                    if (!isBindingElement) {
	                        throwUnexpectedToken(lookahead);
	                    }
	                    expressions.push(parseRestElement(params));
	                    expect(')');
	                    if (!match('=>')) {
	                        expect('=>');
	                    }
	                    isBindingElement = false;
	                    for (i = 0; i < expressions.length; i++) {
	                        reinterpretExpressionAsPattern(expressions[i]);
	                    }
	                    return {
	                        type: PlaceHolders.ArrowParameterPlaceHolder,
	                        params: expressions
	                    };
	                }
	
	                expressions.push(inheritCoverGrammar(parseAssignmentExpression));
	            }
	
	            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
	        }
	
	
	        expect(')');
	
	        if (match('=>')) {
	            if (expr.type === Syntax.Identifier && expr.name === 'yield') {
	                return {
	                    type: PlaceHolders.ArrowParameterPlaceHolder,
	                    params: [expr]
	                };
	            }
	
	            if (!isBindingElement) {
	                throwUnexpectedToken(lookahead);
	            }
	
	            if (expr.type === Syntax.SequenceExpression) {
	                for (i = 0; i < expr.expressions.length; i++) {
	                    reinterpretExpressionAsPattern(expr.expressions[i]);
	                }
	            } else {
	                reinterpretExpressionAsPattern(expr);
	            }
	
	            expr = {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
	            };
	        }
	        isBindingElement = false;
	        return expr;
	    }
	
	
	    // ECMA-262 12.2 Primary Expressions
	
	    function parsePrimaryExpression() {
	        var type, token, expr, node;
	
	        if (match('(')) {
	            isBindingElement = false;
	            return inheritCoverGrammar(parseGroupExpression);
	        }
	
	        if (match('[')) {
	            return inheritCoverGrammar(parseArrayInitializer);
	        }
	
	        if (match('{')) {
	            return inheritCoverGrammar(parseObjectInitializer);
	        }
	
	        type = lookahead.type;
	        node = new Node();
	
	        if (type === Token.Identifier) {
	            if (state.sourceType === 'module' && lookahead.value === 'await') {
	                tolerateUnexpectedToken(lookahead);
	            }
	            expr = node.finishIdentifier(lex().value);
	        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            if (strict && lookahead.octal) {
	                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
	            }
	            expr = node.finishLiteral(lex());
	        } else if (type === Token.Keyword) {
	            if (!strict && state.allowYield && matchKeyword('yield')) {
	                return parseNonComputedProperty();
	            }
	            isAssignmentTarget = isBindingElement = false;
	            if (matchKeyword('function')) {
	                return parseFunctionExpression();
	            }
	            if (matchKeyword('this')) {
	                lex();
	                return node.finishThisExpression();
	            }
	            if (matchKeyword('class')) {
	                return parseClassExpression();
	            }
	            throwUnexpectedToken(lex());
	        } else if (type === Token.BooleanLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            token = lex();
	            token.value = (token.value === 'true');
	            expr = node.finishLiteral(token);
	        } else if (type === Token.NullLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            token = lex();
	            token.value = null;
	            expr = node.finishLiteral(token);
	        } else if (match('/') || match('/=')) {
	            isAssignmentTarget = isBindingElement = false;
	            index = startIndex;
	
	            if (typeof extra.tokens !== 'undefined') {
	                token = collectRegex();
	            } else {
	                token = scanRegExp();
	            }
	            lex();
	            expr = node.finishLiteral(token);
	        } else if (type === Token.Template) {
	            expr = parseTemplateLiteral();
	        } else {
	            throwUnexpectedToken(lex());
	        }
	
	        return expr;
	    }
	
	    // ECMA-262 12.3 Left-Hand-Side Expressions
	
	    function parseArguments() {
	        var args = [], expr;
	
	        expect('(');
	
	        if (!match(')')) {
	            while (startIndex < length) {
	                if (match('...')) {
	                    expr = new Node();
	                    lex();
	                    expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));
	                } else {
	                    expr = isolateCoverGrammar(parseAssignmentExpression);
	                }
	                args.push(expr);
	                if (match(')')) {
	                    break;
	                }
	                expectCommaSeparator();
	            }
	        }
	
	        expect(')');
	
	        return args;
	    }
	
	    function parseNonComputedProperty() {
	        var token, node = new Node();
	
	        token = lex();
	
	        if (!isIdentifierName(token)) {
	            throwUnexpectedToken(token);
	        }
	
	        return node.finishIdentifier(token.value);
	    }
	
	    function parseNonComputedMember() {
	        expect('.');
	
	        return parseNonComputedProperty();
	    }
	
	    function parseComputedMember() {
	        var expr;
	
	        expect('[');
	
	        expr = isolateCoverGrammar(parseExpression);
	
	        expect(']');
	
	        return expr;
	    }
	
	    // ECMA-262 12.3.3 The new Operator
	
	    function parseNewExpression() {
	        var callee, args, node = new Node();
	
	        expectKeyword('new');
	
	        if (match('.')) {
	            lex();
	            if (lookahead.type === Token.Identifier && lookahead.value === 'target') {
	                if (state.inFunctionBody) {
	                    lex();
	                    return node.finishMetaProperty('new', 'target');
	                }
	            }
	            throwUnexpectedToken(lookahead);
	        }
	
	        callee = isolateCoverGrammar(parseLeftHandSideExpression);
	        args = match('(') ? parseArguments() : [];
	
	        isAssignmentTarget = isBindingElement = false;
	
	        return node.finishNewExpression(callee, args);
	    }
	
	    // ECMA-262 12.3.4 Function Calls
	
	    function parseLeftHandSideExpressionAllowCall() {
	        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;
	
	        startToken = lookahead;
	        state.allowIn = true;
	
	        if (matchKeyword('super') && state.inFunctionBody) {
	            expr = new Node();
	            lex();
	            expr = expr.finishSuper();
	            if (!match('(') && !match('.') && !match('[')) {
	                throwUnexpectedToken(lookahead);
	            }
	        } else {
	            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
	        }
	
	        for (;;) {
	            if (match('.')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseNonComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
	            } else if (match('(')) {
	                isBindingElement = false;
	                isAssignmentTarget = false;
	                args = parseArguments();
	                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
	            } else if (match('[')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
	            } else if (lookahead.type === Token.Template && lookahead.head) {
	                quasi = parseTemplateLiteral();
	                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
	            } else {
	                break;
	            }
	        }
	        state.allowIn = previousAllowIn;
	
	        return expr;
	    }
	
	    // ECMA-262 12.3 Left-Hand-Side Expressions
	
	    function parseLeftHandSideExpression() {
	        var quasi, expr, property, startToken;
	        assert(state.allowIn, 'callee of new expression always allow in keyword.');
	
	        startToken = lookahead;
	
	        if (matchKeyword('super') && state.inFunctionBody) {
	            expr = new Node();
	            lex();
	            expr = expr.finishSuper();
	            if (!match('[') && !match('.')) {
	                throwUnexpectedToken(lookahead);
	            }
	        } else {
	            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
	        }
	
	        for (;;) {
	            if (match('[')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
	            } else if (match('.')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseNonComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
	            } else if (lookahead.type === Token.Template && lookahead.head) {
	                quasi = parseTemplateLiteral();
	                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
	            } else {
	                break;
	            }
	        }
	        return expr;
	    }
	
	    // ECMA-262 12.4 Postfix Expressions
	
	    function parsePostfixExpression() {
	        var expr, token, startToken = lookahead;
	
	        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);
	
	        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {
	            if (match('++') || match('--')) {
	                // ECMA-262 11.3.1, 11.3.2
	                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                    tolerateError(Messages.StrictLHSPostfix);
	                }
	
	                if (!isAssignmentTarget) {
	                    tolerateError(Messages.InvalidLHSInAssignment);
	                }
	
	                isAssignmentTarget = isBindingElement = false;
	
	                token = lex();
	                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
	            }
	        }
	
	        return expr;
	    }
	
	    // ECMA-262 12.5 Unary Operators
	
	    function parseUnaryExpression() {
	        var token, expr, startToken;
	
	        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
	            expr = parsePostfixExpression();
	        } else if (match('++') || match('--')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            // ECMA-262 11.4.4, 11.4.5
	            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                tolerateError(Messages.StrictLHSPrefix);
	            }
	
	            if (!isAssignmentTarget) {
	                tolerateError(Messages.InvalidLHSInAssignment);
	            }
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            isAssignmentTarget = isBindingElement = false;
	        } else if (match('+') || match('-') || match('~') || match('!')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            isAssignmentTarget = isBindingElement = false;
	        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
	                tolerateError(Messages.StrictDelete);
	            }
	            isAssignmentTarget = isBindingElement = false;
	        } else {
	            expr = parsePostfixExpression();
	        }
	
	        return expr;
	    }
	
	    function binaryPrecedence(token, allowIn) {
	        var prec = 0;
	
	        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
	            return 0;
	        }
	
	        switch (token.value) {
	        case '||':
	            prec = 1;
	            break;
	
	        case '&&':
	            prec = 2;
	            break;
	
	        case '|':
	            prec = 3;
	            break;
	
	        case '^':
	            prec = 4;
	            break;
	
	        case '&':
	            prec = 5;
	            break;
	
	        case '==':
	        case '!=':
	        case '===':
	        case '!==':
	            prec = 6;
	            break;
	
	        case '<':
	        case '>':
	        case '<=':
	        case '>=':
	        case 'instanceof':
	            prec = 7;
	            break;
	
	        case 'in':
	            prec = allowIn ? 7 : 0;
	            break;
	
	        case '<<':
	        case '>>':
	        case '>>>':
	            prec = 8;
	            break;
	
	        case '+':
	        case '-':
	            prec = 9;
	            break;
	
	        case '*':
	        case '/':
	        case '%':
	            prec = 11;
	            break;
	
	        default:
	            break;
	        }
	
	        return prec;
	    }
	
	    // ECMA-262 12.6 Multiplicative Operators
	    // ECMA-262 12.7 Additive Operators
	    // ECMA-262 12.8 Bitwise Shift Operators
	    // ECMA-262 12.9 Relational Operators
	    // ECMA-262 12.10 Equality Operators
	    // ECMA-262 12.11 Binary Bitwise Operators
	    // ECMA-262 12.12 Binary Logical Operators
	
	    function parseBinaryExpression() {
	        var marker, markers, expr, token, prec, stack, right, operator, left, i;
	
	        marker = lookahead;
	        left = inheritCoverGrammar(parseUnaryExpression);
	
	        token = lookahead;
	        prec = binaryPrecedence(token, state.allowIn);
	        if (prec === 0) {
	            return left;
	        }
	        isAssignmentTarget = isBindingElement = false;
	        token.prec = prec;
	        lex();
	
	        markers = [marker, lookahead];
	        right = isolateCoverGrammar(parseUnaryExpression);
	
	        stack = [left, token, right];
	
	        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {
	
	            // Reduce: make a binary expression from the three topmost entries.
	            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
	                right = stack.pop();
	                operator = stack.pop().value;
	                left = stack.pop();
	                markers.pop();
	                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
	                stack.push(expr);
	            }
	
	            // Shift.
	            token = lex();
	            token.prec = prec;
	            stack.push(token);
	            markers.push(lookahead);
	            expr = isolateCoverGrammar(parseUnaryExpression);
	            stack.push(expr);
	        }
	
	        // Final reduce to clean-up the stack.
	        i = stack.length - 1;
	        expr = stack[i];
	        markers.pop();
	        while (i > 1) {
	            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
	            i -= 2;
	        }
	
	        return expr;
	    }
	
	
	    // ECMA-262 12.13 Conditional Operator
	
	    function parseConditionalExpression() {
	        var expr, previousAllowIn, consequent, alternate, startToken;
	
	        startToken = lookahead;
	
	        expr = inheritCoverGrammar(parseBinaryExpression);
	        if (match('?')) {
	            lex();
	            previousAllowIn = state.allowIn;
	            state.allowIn = true;
	            consequent = isolateCoverGrammar(parseAssignmentExpression);
	            state.allowIn = previousAllowIn;
	            expect(':');
	            alternate = isolateCoverGrammar(parseAssignmentExpression);
	
	            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
	            isAssignmentTarget = isBindingElement = false;
	        }
	
	        return expr;
	    }
	
	    // ECMA-262 14.2 Arrow Function Definitions
	
	    function parseConciseBody() {
	        if (match('{')) {
	            return parseFunctionSourceElements();
	        }
	        return isolateCoverGrammar(parseAssignmentExpression);
	    }
	
	    function checkPatternParam(options, param) {
	        var i;
	        switch (param.type) {
	        case Syntax.Identifier:
	            validateParam(options, param, param.name);
	            break;
	        case Syntax.RestElement:
	            checkPatternParam(options, param.argument);
	            break;
	        case Syntax.AssignmentPattern:
	            checkPatternParam(options, param.left);
	            break;
	        case Syntax.ArrayPattern:
	            for (i = 0; i < param.elements.length; i++) {
	                if (param.elements[i] !== null) {
	                    checkPatternParam(options, param.elements[i]);
	                }
	            }
	            break;
	        case Syntax.YieldExpression:
	            break;
	        default:
	            assert(param.type === Syntax.ObjectPattern, 'Invalid type');
	            for (i = 0; i < param.properties.length; i++) {
	                checkPatternParam(options, param.properties[i].value);
	            }
	            break;
	        }
	    }
	    function reinterpretAsCoverFormalsList(expr) {
	        var i, len, param, params, defaults, defaultCount, options, token;
	
	        defaults = [];
	        defaultCount = 0;
	        params = [expr];
	
	        switch (expr.type) {
	        case Syntax.Identifier:
	            break;
	        case PlaceHolders.ArrowParameterPlaceHolder:
	            params = expr.params;
	            break;
	        default:
	            return null;
	        }
	
	        options = {
	            paramSet: {}
	        };
	
	        for (i = 0, len = params.length; i < len; i += 1) {
	            param = params[i];
	            switch (param.type) {
	            case Syntax.AssignmentPattern:
	                params[i] = param.left;
	                if (param.right.type === Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        throwUnexpectedToken(lookahead);
	                    }
	                    param.right.type = Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	                defaults.push(param.right);
	                ++defaultCount;
	                checkPatternParam(options, param.left);
	                break;
	            default:
	                checkPatternParam(options, param);
	                params[i] = param;
	                defaults.push(null);
	                break;
	            }
	        }
	
	        if (strict || !state.allowYield) {
	            for (i = 0, len = params.length; i < len; i += 1) {
	                param = params[i];
	                if (param.type === Syntax.YieldExpression) {
	                    throwUnexpectedToken(lookahead);
	                }
	            }
	        }
	
	        if (options.message === Messages.StrictParamDupe) {
	            token = strict ? options.stricted : options.firstRestricted;
	            throwUnexpectedToken(token, options.message);
	        }
	
	        if (defaultCount === 0) {
	            defaults = [];
	        }
	
	        return {
	            params: params,
	            defaults: defaults,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    }
	
	    function parseArrowFunctionExpression(options, node) {
	        var previousStrict, previousAllowYield, body;
	
	        if (hasLineTerminator) {
	            tolerateUnexpectedToken(lookahead);
	        }
	        expect('=>');
	
	        previousStrict = strict;
	        previousAllowYield = state.allowYield;
	        state.allowYield = true;
	
	        body = parseConciseBody();
	
	        if (strict && options.firstRestricted) {
	            throwUnexpectedToken(options.firstRestricted, options.message);
	        }
	        if (strict && options.stricted) {
	            tolerateUnexpectedToken(options.stricted, options.message);
	        }
	
	        strict = previousStrict;
	        state.allowYield = previousAllowYield;
	
	        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
	    }
	
	    // ECMA-262 14.4 Yield expression
	
	    function parseYieldExpression() {
	        var argument, expr, delegate, previousAllowYield;
	
	        argument = null;
	        expr = new Node();
	
	        expectKeyword('yield');
	
	        if (!hasLineTerminator) {
	            previousAllowYield = state.allowYield;
	            state.allowYield = false;
	            delegate = match('*');
	            if (delegate) {
	                lex();
	                argument = parseAssignmentExpression();
	            } else {
	                if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {
	                    argument = parseAssignmentExpression();
	                }
	            }
	            state.allowYield = previousAllowYield;
	        }
	
	        return expr.finishYieldExpression(argument, delegate);
	    }
	
	    // ECMA-262 12.14 Assignment Operators
	
	    function parseAssignmentExpression() {
	        var token, expr, right, list, startToken;
	
	        startToken = lookahead;
	        token = lookahead;
	
	        if (!state.allowYield && matchKeyword('yield')) {
	            return parseYieldExpression();
	        }
	
	        expr = parseConditionalExpression();
	
	        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
	            isAssignmentTarget = isBindingElement = false;
	            list = reinterpretAsCoverFormalsList(expr);
	
	            if (list) {
	                firstCoverInitializedNameError = null;
	                return parseArrowFunctionExpression(list, new WrappingNode(startToken));
	            }
	
	            return expr;
	        }
	
	        if (matchAssign()) {
	            if (!isAssignmentTarget) {
	                tolerateError(Messages.InvalidLHSInAssignment);
	            }
	
	            // ECMA-262 12.1.1
	            if (strict && expr.type === Syntax.Identifier) {
	                if (isRestrictedWord(expr.name)) {
	                    tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
	                }
	                if (isStrictModeReservedWord(expr.name)) {
	                    tolerateUnexpectedToken(token, Messages.StrictReservedWord);
	                }
	            }
	
	            if (!match('=')) {
	                isAssignmentTarget = isBindingElement = false;
	            } else {
	                reinterpretExpressionAsPattern(expr);
	            }
	
	            token = lex();
	            right = isolateCoverGrammar(parseAssignmentExpression);
	            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
	            firstCoverInitializedNameError = null;
	        }
	
	        return expr;
	    }
	
	    // ECMA-262 12.15 Comma Operator
	
	    function parseExpression() {
	        var expr, startToken = lookahead, expressions;
	
	        expr = isolateCoverGrammar(parseAssignmentExpression);
	
	        if (match(',')) {
	            expressions = [expr];
	
	            while (startIndex < length) {
	                if (!match(',')) {
	                    break;
	                }
	                lex();
	                expressions.push(isolateCoverGrammar(parseAssignmentExpression));
	            }
	
	            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
	        }
	
	        return expr;
	    }
	
	    // ECMA-262 13.2 Block
	
	    function parseStatementListItem() {
	        if (lookahead.type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'export':
	                if (state.sourceType !== 'module') {
	                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
	                }
	                return parseExportDeclaration();
	            case 'import':
	                if (state.sourceType !== 'module') {
	                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
	                }
	                return parseImportDeclaration();
	            case 'const':
	            case 'let':
	                return parseLexicalDeclaration({inFor: false});
	            case 'function':
	                return parseFunctionDeclaration(new Node());
	            case 'class':
	                return parseClassDeclaration();
	            }
	        }
	
	        return parseStatement();
	    }
	
	    function parseStatementList() {
	        var list = [];
	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            list.push(parseStatementListItem());
	        }
	
	        return list;
	    }
	
	    function parseBlock() {
	        var block, node = new Node();
	
	        expect('{');
	
	        block = parseStatementList();
	
	        expect('}');
	
	        return node.finishBlockStatement(block);
	    }
	
	    // ECMA-262 13.3.2 Variable Statement
	
	    function parseVariableIdentifier(kind) {
	        var token, node = new Node();
	
	        token = lex();
	
	        if (token.type === Token.Keyword && token.value === 'yield') {
	            if (strict) {
	                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
	            } if (!state.allowYield) {
	                throwUnexpectedToken(token);
	            }
	        } else if (token.type !== Token.Identifier) {
	            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
	                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
	            } else {
	                if (strict || token.value !== 'let' || kind !== 'var') {
	                    throwUnexpectedToken(token);
	                }
	            }
	        } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {
	            tolerateUnexpectedToken(token);
	        }
	
	        return node.finishIdentifier(token.value);
	    }
	
	    function parseVariableDeclaration(options) {
	        var init = null, id, node = new Node(), params = [];
	
	        id = parsePattern(params, 'var');
	
	        // ECMA-262 12.2.1
	        if (strict && isRestrictedWord(id.name)) {
	            tolerateError(Messages.StrictVarName);
	        }
	
	        if (match('=')) {
	            lex();
	            init = isolateCoverGrammar(parseAssignmentExpression);
	        } else if (id.type !== Syntax.Identifier && !options.inFor) {
	            expect('=');
	        }
	
	        return node.finishVariableDeclarator(id, init);
	    }
	
	    function parseVariableDeclarationList(options) {
	        var list = [];
	
	        do {
	            list.push(parseVariableDeclaration({ inFor: options.inFor }));
	            if (!match(',')) {
	                break;
	            }
	            lex();
	        } while (startIndex < length);
	
	        return list;
	    }
	
	    function parseVariableStatement(node) {
	        var declarations;
	
	        expectKeyword('var');
	
	        declarations = parseVariableDeclarationList({ inFor: false });
	
	        consumeSemicolon();
	
	        return node.finishVariableDeclaration(declarations);
	    }
	
	    // ECMA-262 13.3.1 Let and Const Declarations
	
	    function parseLexicalBinding(kind, options) {
	        var init = null, id, node = new Node(), params = [];
	
	        id = parsePattern(params, kind);
	
	        // ECMA-262 12.2.1
	        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {
	            tolerateError(Messages.StrictVarName);
	        }
	
	        if (kind === 'const') {
	            if (!matchKeyword('in') && !matchContextualKeyword('of')) {
	                expect('=');
	                init = isolateCoverGrammar(parseAssignmentExpression);
	            }
	        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {
	            expect('=');
	            init = isolateCoverGrammar(parseAssignmentExpression);
	        }
	
	        return node.finishVariableDeclarator(id, init);
	    }
	
	    function parseBindingList(kind, options) {
	        var list = [];
	
	        do {
	            list.push(parseLexicalBinding(kind, options));
	            if (!match(',')) {
	                break;
	            }
	            lex();
	        } while (startIndex < length);
	
	        return list;
	    }
	
	    function parseLexicalDeclaration(options) {
	        var kind, declarations, node = new Node();
	
	        kind = lex().value;
	        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	
	        declarations = parseBindingList(kind, options);
	
	        consumeSemicolon();
	
	        return node.finishLexicalDeclaration(declarations, kind);
	    }
	
	    function parseRestElement(params) {
	        var param, node = new Node();
	
	        lex();
	
	        if (match('{')) {
	            throwError(Messages.ObjectPatternAsRestParameter);
	        }
	
	        params.push(lookahead);
	
	        param = parseVariableIdentifier();
	
	        if (match('=')) {
	            throwError(Messages.DefaultRestParameter);
	        }
	
	        if (!match(')')) {
	            throwError(Messages.ParameterAfterRestParameter);
	        }
	
	        return node.finishRestElement(param);
	    }
	
	    // ECMA-262 13.4 Empty Statement
	
	    function parseEmptyStatement(node) {
	        expect(';');
	        return node.finishEmptyStatement();
	    }
	
	    // ECMA-262 12.4 Expression Statement
	
	    function parseExpressionStatement(node) {
	        var expr = parseExpression();
	        consumeSemicolon();
	        return node.finishExpressionStatement(expr);
	    }
	
	    // ECMA-262 13.6 If statement
	
	    function parseIfStatement(node) {
	        var test, consequent, alternate;
	
	        expectKeyword('if');
	
	        expect('(');
	
	        test = parseExpression();
	
	        expect(')');
	
	        consequent = parseStatement();
	
	        if (matchKeyword('else')) {
	            lex();
	            alternate = parseStatement();
	        } else {
	            alternate = null;
	        }
	
	        return node.finishIfStatement(test, consequent, alternate);
	    }
	
	    // ECMA-262 13.7 Iteration Statements
	
	    function parseDoWhileStatement(node) {
	        var body, test, oldInIteration;
	
	        expectKeyword('do');
	
	        oldInIteration = state.inIteration;
	        state.inIteration = true;
	
	        body = parseStatement();
	
	        state.inIteration = oldInIteration;
	
	        expectKeyword('while');
	
	        expect('(');
	
	        test = parseExpression();
	
	        expect(')');
	
	        if (match(';')) {
	            lex();
	        }
	
	        return node.finishDoWhileStatement(body, test);
	    }
	
	    function parseWhileStatement(node) {
	        var test, body, oldInIteration;
	
	        expectKeyword('while');
	
	        expect('(');
	
	        test = parseExpression();
	
	        expect(')');
	
	        oldInIteration = state.inIteration;
	        state.inIteration = true;
	
	        body = parseStatement();
	
	        state.inIteration = oldInIteration;
	
	        return node.finishWhileStatement(test, body);
	    }
	
	    function parseForStatement(node) {
	        var init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations,
	            body, oldInIteration, previousAllowIn = state.allowIn;
	
	        init = test = update = null;
	        forIn = true;
	
	        expectKeyword('for');
	
	        expect('(');
	
	        if (match(';')) {
	            lex();
	        } else {
	            if (matchKeyword('var')) {
	                init = new Node();
	                lex();
	
	                state.allowIn = false;
	                declarations = parseVariableDeclarationList({ inFor: true });
	                state.allowIn = previousAllowIn;
	
	                if (declarations.length === 1 && matchKeyword('in')) {
	                    init = init.finishVariableDeclaration(declarations);
	                    lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
	                    init = init.finishVariableDeclaration(declarations);
	                    lex();
	                    left = init;
	                    right = parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                } else {
	                    init = init.finishVariableDeclaration(declarations);
	                    expect(';');
	                }
	            } else if (matchKeyword('const') || matchKeyword('let')) {
	                init = new Node();
	                kind = lex().value;
	
	                state.allowIn = false;
	                declarations = parseBindingList(kind, {inFor: true});
	                state.allowIn = previousAllowIn;
	
	                if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {
	                    init = init.finishLexicalDeclaration(declarations, kind);
	                    lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
	                    init = init.finishLexicalDeclaration(declarations, kind);
	                    lex();
	                    left = init;
	                    right = parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                } else {
	                    consumeSemicolon();
	                    init = init.finishLexicalDeclaration(declarations, kind);
	                }
	            } else {
	                initStartToken = lookahead;
	                state.allowIn = false;
	                init = inheritCoverGrammar(parseAssignmentExpression);
	                state.allowIn = previousAllowIn;
	
	                if (matchKeyword('in')) {
	                    if (!isAssignmentTarget) {
	                        tolerateError(Messages.InvalidLHSInForIn);
	                    }
	
	                    lex();
	                    reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else if (matchContextualKeyword('of')) {
	                    if (!isAssignmentTarget) {
	                        tolerateError(Messages.InvalidLHSInForLoop);
	                    }
	
	                    lex();
	                    reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                } else {
	                    if (match(',')) {
	                        initSeq = [init];
	                        while (match(',')) {
	                            lex();
	                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
	                        }
	                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);
	                    }
	                    expect(';');
	                }
	            }
	        }
	
	        if (typeof left === 'undefined') {
	
	            if (!match(';')) {
	                test = parseExpression();
	            }
	            expect(';');
	
	            if (!match(')')) {
	                update = parseExpression();
	            }
	        }
	
	        expect(')');
	
	        oldInIteration = state.inIteration;
	        state.inIteration = true;
	
	        body = isolateCoverGrammar(parseStatement);
	
	        state.inIteration = oldInIteration;
	
	        return (typeof left === 'undefined') ?
	                node.finishForStatement(init, test, update, body) :
	                forIn ? node.finishForInStatement(left, right, body) :
	                    node.finishForOfStatement(left, right, body);
	    }
	
	    // ECMA-262 13.8 The continue statement
	
	    function parseContinueStatement(node) {
	        var label = null, key;
	
	        expectKeyword('continue');
	
	        // Optimize the most common form: 'continue;'.
	        if (source.charCodeAt(startIndex) === 0x3B) {
	            lex();
	
	            if (!state.inIteration) {
	                throwError(Messages.IllegalContinue);
	            }
	
	            return node.finishContinueStatement(null);
	        }
	
	        if (hasLineTerminator) {
	            if (!state.inIteration) {
	                throwError(Messages.IllegalContinue);
	            }
	
	            return node.finishContinueStatement(null);
	        }
	
	        if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();
	
	            key = '$' + label.name;
	            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.UnknownLabel, label.name);
	            }
	        }
	
	        consumeSemicolon();
	
	        if (label === null && !state.inIteration) {
	            throwError(Messages.IllegalContinue);
	        }
	
	        return node.finishContinueStatement(label);
	    }
	
	    // ECMA-262 13.9 The break statement
	
	    function parseBreakStatement(node) {
	        var label = null, key;
	
	        expectKeyword('break');
	
	        // Catch the very common case first: immediately a semicolon (U+003B).
	        if (source.charCodeAt(lastIndex) === 0x3B) {
	            lex();
	
	            if (!(state.inIteration || state.inSwitch)) {
	                throwError(Messages.IllegalBreak);
	            }
	
	            return node.finishBreakStatement(null);
	        }
	
	        if (hasLineTerminator) {
	            if (!(state.inIteration || state.inSwitch)) {
	                throwError(Messages.IllegalBreak);
	            }
	
	            return node.finishBreakStatement(null);
	        }
	
	        if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();
	
	            key = '$' + label.name;
	            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.UnknownLabel, label.name);
	            }
	        }
	
	        consumeSemicolon();
	
	        if (label === null && !(state.inIteration || state.inSwitch)) {
	            throwError(Messages.IllegalBreak);
	        }
	
	        return node.finishBreakStatement(label);
	    }
	
	    // ECMA-262 13.10 The return statement
	
	    function parseReturnStatement(node) {
	        var argument = null;
	
	        expectKeyword('return');
	
	        if (!state.inFunctionBody) {
	            tolerateError(Messages.IllegalReturn);
	        }
	
	        // 'return' followed by a space and an identifier is very common.
	        if (source.charCodeAt(lastIndex) === 0x20) {
	            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
	                argument = parseExpression();
	                consumeSemicolon();
	                return node.finishReturnStatement(argument);
	            }
	        }
	
	        if (hasLineTerminator) {
	            // HACK
	            return node.finishReturnStatement(null);
	        }
	
	        if (!match(';')) {
	            if (!match('}') && lookahead.type !== Token.EOF) {
	                argument = parseExpression();
	            }
	        }
	
	        consumeSemicolon();
	
	        return node.finishReturnStatement(argument);
	    }
	
	    // ECMA-262 13.11 The with statement
	
	    function parseWithStatement(node) {
	        var object, body;
	
	        if (strict) {
	            tolerateError(Messages.StrictModeWith);
	        }
	
	        expectKeyword('with');
	
	        expect('(');
	
	        object = parseExpression();
	
	        expect(')');
	
	        body = parseStatement();
	
	        return node.finishWithStatement(object, body);
	    }
	
	    // ECMA-262 13.12 The switch statement
	
	    function parseSwitchCase() {
	        var test, consequent = [], statement, node = new Node();
	
	        if (matchKeyword('default')) {
	            lex();
	            test = null;
	        } else {
	            expectKeyword('case');
	            test = parseExpression();
	        }
	        expect(':');
	
	        while (startIndex < length) {
	            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
	                break;
	            }
	            statement = parseStatementListItem();
	            consequent.push(statement);
	        }
	
	        return node.finishSwitchCase(test, consequent);
	    }
	
	    function parseSwitchStatement(node) {
	        var discriminant, cases, clause, oldInSwitch, defaultFound;
	
	        expectKeyword('switch');
	
	        expect('(');
	
	        discriminant = parseExpression();
	
	        expect(')');
	
	        expect('{');
	
	        cases = [];
	
	        if (match('}')) {
	            lex();
	            return node.finishSwitchStatement(discriminant, cases);
	        }
	
	        oldInSwitch = state.inSwitch;
	        state.inSwitch = true;
	        defaultFound = false;
	
	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            clause = parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    throwError(Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	
	        state.inSwitch = oldInSwitch;
	
	        expect('}');
	
	        return node.finishSwitchStatement(discriminant, cases);
	    }
	
	    // ECMA-262 13.14 The throw statement
	
	    function parseThrowStatement(node) {
	        var argument;
	
	        expectKeyword('throw');
	
	        if (hasLineTerminator) {
	            throwError(Messages.NewlineAfterThrow);
	        }
	
	        argument = parseExpression();
	
	        consumeSemicolon();
	
	        return node.finishThrowStatement(argument);
	    }
	
	    // ECMA-262 13.15 The try statement
	
	    function parseCatchClause() {
	        var param, params = [], paramMap = {}, key, i, body, node = new Node();
	
	        expectKeyword('catch');
	
	        expect('(');
	        if (match(')')) {
	            throwUnexpectedToken(lookahead);
	        }
	
	        param = parsePattern(params);
	        for (i = 0; i < params.length; i++) {
	            key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                tolerateError(Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	
	        // ECMA-262 12.14.1
	        if (strict && isRestrictedWord(param.name)) {
	            tolerateError(Messages.StrictCatchVariable);
	        }
	
	        expect(')');
	        body = parseBlock();
	        return node.finishCatchClause(param, body);
	    }
	
	    function parseTryStatement(node) {
	        var block, handler = null, finalizer = null;
	
	        expectKeyword('try');
	
	        block = parseBlock();
	
	        if (matchKeyword('catch')) {
	            handler = parseCatchClause();
	        }
	
	        if (matchKeyword('finally')) {
	            lex();
	            finalizer = parseBlock();
	        }
	
	        if (!handler && !finalizer) {
	            throwError(Messages.NoCatchOrFinally);
	        }
	
	        return node.finishTryStatement(block, handler, finalizer);
	    }
	
	    // ECMA-262 13.16 The debugger statement
	
	    function parseDebuggerStatement(node) {
	        expectKeyword('debugger');
	
	        consumeSemicolon();
	
	        return node.finishDebuggerStatement();
	    }
	
	    // 13 Statements
	
	    function parseStatement() {
	        var type = lookahead.type,
	            expr,
	            labeledBody,
	            key,
	            node;
	
	        if (type === Token.EOF) {
	            throwUnexpectedToken(lookahead);
	        }
	
	        if (type === Token.Punctuator && lookahead.value === '{') {
	            return parseBlock();
	        }
	        isAssignmentTarget = isBindingElement = true;
	        node = new Node();
	
	        if (type === Token.Punctuator) {
	            switch (lookahead.value) {
	            case ';':
	                return parseEmptyStatement(node);
	            case '(':
	                return parseExpressionStatement(node);
	            default:
	                break;
	            }
	        } else if (type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'break':
	                return parseBreakStatement(node);
	            case 'continue':
	                return parseContinueStatement(node);
	            case 'debugger':
	                return parseDebuggerStatement(node);
	            case 'do':
	                return parseDoWhileStatement(node);
	            case 'for':
	                return parseForStatement(node);
	            case 'function':
	                return parseFunctionDeclaration(node);
	            case 'if':
	                return parseIfStatement(node);
	            case 'return':
	                return parseReturnStatement(node);
	            case 'switch':
	                return parseSwitchStatement(node);
	            case 'throw':
	                return parseThrowStatement(node);
	            case 'try':
	                return parseTryStatement(node);
	            case 'var':
	                return parseVariableStatement(node);
	            case 'while':
	                return parseWhileStatement(node);
	            case 'with':
	                return parseWithStatement(node);
	            default:
	                break;
	            }
	        }
	
	        expr = parseExpression();
	
	        // ECMA-262 12.12 Labelled Statements
	        if ((expr.type === Syntax.Identifier) && match(':')) {
	            lex();
	
	            key = '$' + expr.name;
	            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.Redeclaration, 'Label', expr.name);
	            }
	
	            state.labelSet[key] = true;
	            labeledBody = parseStatement();
	            delete state.labelSet[key];
	            return node.finishLabeledStatement(expr, labeledBody);
	        }
	
	        consumeSemicolon();
	
	        return node.finishExpressionStatement(expr);
	    }
	
	    // ECMA-262 14.1 Function Definition
	
	    function parseFunctionSourceElements() {
	        var statement, body = [], token, directive, firstRestricted,
	            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,
	            node = new Node();
	
	        expect('{');
	
	        while (startIndex < length) {
	            if (lookahead.type !== Token.StringLiteral) {
	                break;
	            }
	            token = lookahead;
	
	            statement = parseStatementListItem();
	            body.push(statement);
	            if (statement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.start + 1, token.end - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	
	        oldLabelSet = state.labelSet;
	        oldInIteration = state.inIteration;
	        oldInSwitch = state.inSwitch;
	        oldInFunctionBody = state.inFunctionBody;
	        oldParenthesisCount = state.parenthesizedCount;
	
	        state.labelSet = {};
	        state.inIteration = false;
	        state.inSwitch = false;
	        state.inFunctionBody = true;
	        state.parenthesizedCount = 0;
	
	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            body.push(parseStatementListItem());
	        }
	
	        expect('}');
	
	        state.labelSet = oldLabelSet;
	        state.inIteration = oldInIteration;
	        state.inSwitch = oldInSwitch;
	        state.inFunctionBody = oldInFunctionBody;
	        state.parenthesizedCount = oldParenthesisCount;
	
	        return node.finishBlockStatement(body);
	    }
	
	    function validateParam(options, param, name) {
	        var key = '$' + name;
	        if (strict) {
	            if (isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamDupe;
	            }
	        } else if (!options.firstRestricted) {
	            if (isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = Messages.StrictParamName;
	            } else if (isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = Messages.StrictReservedWord;
	            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamDupe;
	            }
	        }
	        options.paramSet[key] = true;
	    }
	
	    function parseParam(options) {
	        var token, param, params = [], i, def;
	
	        token = lookahead;
	        if (token.value === '...') {
	            param = parseRestElement(params);
	            validateParam(options, param.argument, param.argument.name);
	            options.params.push(param);
	            options.defaults.push(null);
	            return false;
	        }
	
	        param = parsePatternWithDefault(params);
	        for (i = 0; i < params.length; i++) {
	            validateParam(options, params[i], params[i].value);
	        }
	
	        if (param.type === Syntax.AssignmentPattern) {
	            def = param.right;
	            param = param.left;
	            ++options.defaultCount;
	        }
	
	        options.params.push(param);
	        options.defaults.push(def);
	
	        return !match(')');
	    }
	
	    function parseParams(firstRestricted) {
	        var options;
	
	        options = {
	            params: [],
	            defaultCount: 0,
	            defaults: [],
	            firstRestricted: firstRestricted
	        };
	
	        expect('(');
	
	        if (!match(')')) {
	            options.paramSet = {};
	            while (startIndex < length) {
	                if (!parseParam(options)) {
	                    break;
	                }
	                expect(',');
	            }
	        }
	
	        expect(')');
	
	        if (options.defaultCount === 0) {
	            options.defaults = [];
	        }
	
	        return {
	            params: options.params,
	            defaults: options.defaults,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    }
	
	    function parseFunctionDeclaration(node, identifierIsOptional) {
	        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict,
	            isGenerator, previousAllowYield;
	
	        previousAllowYield = state.allowYield;
	
	        expectKeyword('function');
	
	        isGenerator = match('*');
	        if (isGenerator) {
	            lex();
	        }
	
	        if (!identifierIsOptional || !match('(')) {
	            token = lookahead;
	            id = parseVariableIdentifier();
	            if (strict) {
	                if (isRestrictedWord(token.value)) {
	                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
	                }
	            } else {
	                if (isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictFunctionName;
	                } else if (isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                }
	            }
	        }
	
	        state.allowYield = !isGenerator;
	        tmp = parseParams(firstRestricted);
	        params = tmp.params;
	        defaults = tmp.defaults;
	        stricted = tmp.stricted;
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }
	
	
	        previousStrict = strict;
	        body = parseFunctionSourceElements();
	        if (strict && firstRestricted) {
	            throwUnexpectedToken(firstRestricted, message);
	        }
	        if (strict && stricted) {
	            tolerateUnexpectedToken(stricted, message);
	        }
	
	        strict = previousStrict;
	        state.allowYield = previousAllowYield;
	
	        return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);
	    }
	
	    function parseFunctionExpression() {
	        var token, id = null, stricted, firstRestricted, message, tmp,
	            params = [], defaults = [], body, previousStrict, node = new Node(),
	            isGenerator, previousAllowYield;
	
	        previousAllowYield = state.allowYield;
	
	        expectKeyword('function');
	
	        isGenerator = match('*');
	        if (isGenerator) {
	            lex();
	        }
	
	        state.allowYield = !isGenerator;
	        if (!match('(')) {
	            token = lookahead;
	            id = (!strict && !isGenerator && matchKeyword('yield')) ? parseNonComputedProperty() : parseVariableIdentifier();
	            if (strict) {
	                if (isRestrictedWord(token.value)) {
	                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
	                }
	            } else {
	                if (isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictFunctionName;
	                } else if (isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                }
	            }
	        }
	
	        tmp = parseParams(firstRestricted);
	        params = tmp.params;
	        defaults = tmp.defaults;
	        stricted = tmp.stricted;
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }
	
	        previousStrict = strict;
	        body = parseFunctionSourceElements();
	        if (strict && firstRestricted) {
	            throwUnexpectedToken(firstRestricted, message);
	        }
	        if (strict && stricted) {
	            tolerateUnexpectedToken(stricted, message);
	        }
	        strict = previousStrict;
	        state.allowYield = previousAllowYield;
	
	        return node.finishFunctionExpression(id, params, defaults, body, isGenerator);
	    }
	
	    // ECMA-262 14.5 Class Definitions
	
	    function parseClassBody() {
	        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;
	
	        classBody = new Node();
	
	        expect('{');
	        body = [];
	        while (!match('}')) {
	            if (match(';')) {
	                lex();
	            } else {
	                method = new Node();
	                token = lookahead;
	                isStatic = false;
	                computed = match('[');
	                if (match('*')) {
	                    lex();
	                } else {
	                    key = parseObjectPropertyKey();
	                    if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {
	                        token = lookahead;
	                        isStatic = true;
	                        computed = match('[');
	                        if (match('*')) {
	                            lex();
	                        } else {
	                            key = parseObjectPropertyKey();
	                        }
	                    }
	                }
	                method = tryParseMethodDefinition(token, key, computed, method);
	                if (method) {
	                    method['static'] = isStatic; // jscs:ignore requireDotNotation
	                    if (method.kind === 'init') {
	                        method.kind = 'method';
	                    }
	                    if (!isStatic) {
	                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {
	                            if (method.kind !== 'method' || !method.method || method.value.generator) {
	                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
	                            }
	                            if (hasConstructor) {
	                                throwUnexpectedToken(token, Messages.DuplicateConstructor);
	                            } else {
	                                hasConstructor = true;
	                            }
	                            method.kind = 'constructor';
	                        }
	                    } else {
	                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {
	                            throwUnexpectedToken(token, Messages.StaticPrototype);
	                        }
	                    }
	                    method.type = Syntax.MethodDefinition;
	                    delete method.method;
	                    delete method.shorthand;
	                    body.push(method);
	                } else {
	                    throwUnexpectedToken(lookahead);
	                }
	            }
	        }
	        lex();
	        return classBody.finishClassBody(body);
	    }
	
	    function parseClassDeclaration(identifierIsOptional) {
	        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
	        strict = true;
	
	        expectKeyword('class');
	
	        if (!identifierIsOptional || lookahead.type === Token.Identifier) {
	            id = parseVariableIdentifier();
	        }
	
	        if (matchKeyword('extends')) {
	            lex();
	            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
	        }
	        classBody = parseClassBody();
	        strict = previousStrict;
	
	        return classNode.finishClassDeclaration(id, superClass, classBody);
	    }
	
	    function parseClassExpression() {
	        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
	        strict = true;
	
	        expectKeyword('class');
	
	        if (lookahead.type === Token.Identifier) {
	            id = parseVariableIdentifier();
	        }
	
	        if (matchKeyword('extends')) {
	            lex();
	            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
	        }
	        classBody = parseClassBody();
	        strict = previousStrict;
	
	        return classNode.finishClassExpression(id, superClass, classBody);
	    }
	
	    // ECMA-262 15.2 Modules
	
	    function parseModuleSpecifier() {
	        var node = new Node();
	
	        if (lookahead.type !== Token.StringLiteral) {
	            throwError(Messages.InvalidModuleSpecifier);
	        }
	        return node.finishLiteral(lex());
	    }
	
	    // ECMA-262 15.2.3 Exports
	
	    function parseExportSpecifier() {
	        var exported, local, node = new Node(), def;
	        if (matchKeyword('default')) {
	            // export {default} from 'something';
	            def = new Node();
	            lex();
	            local = def.finishIdentifier('default');
	        } else {
	            local = parseVariableIdentifier();
	        }
	        if (matchContextualKeyword('as')) {
	            lex();
	            exported = parseNonComputedProperty();
	        }
	        return node.finishExportSpecifier(local, exported);
	    }
	
	    function parseExportNamedDeclaration(node) {
	        var declaration = null,
	            isExportFromIdentifier,
	            src = null, specifiers = [];
	
	        // non-default export
	        if (lookahead.type === Token.Keyword) {
	            // covers:
	            // export var f = 1;
	            switch (lookahead.value) {
	                case 'let':
	                case 'const':
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = parseStatementListItem();
	                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
	            }
	        }
	
	        expect('{');
	        while (!match('}')) {
	            isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
	            specifiers.push(parseExportSpecifier());
	            if (!match('}')) {
	                expect(',');
	                if (match('}')) {
	                    break;
	                }
	            }
	        }
	        expect('}');
	
	        if (matchContextualKeyword('from')) {
	            // covering:
	            // export {default} from 'foo';
	            // export {foo} from 'foo';
	            lex();
	            src = parseModuleSpecifier();
	            consumeSemicolon();
	        } else if (isExportFromIdentifier) {
	            // covering:
	            // export {default}; // missing fromClause
	            throwError(lookahead.value ?
	                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	        } else {
	            // cover
	            // export {foo};
	            consumeSemicolon();
	        }
	        return node.finishExportNamedDeclaration(declaration, specifiers, src);
	    }
	
	    function parseExportDefaultDeclaration(node) {
	        var declaration = null,
	            expression = null;
	
	        // covers:
	        // export default ...
	        expectKeyword('default');
	
	        if (matchKeyword('function')) {
	            // covers:
	            // export default function foo () {}
	            // export default function () {}
	            declaration = parseFunctionDeclaration(new Node(), true);
	            return node.finishExportDefaultDeclaration(declaration);
	        }
	        if (matchKeyword('class')) {
	            declaration = parseClassDeclaration(true);
	            return node.finishExportDefaultDeclaration(declaration);
	        }
	
	        if (matchContextualKeyword('from')) {
	            throwError(Messages.UnexpectedToken, lookahead.value);
	        }
	
	        // covers:
	        // export default {};
	        // export default [];
	        // export default (1 + 2);
	        if (match('{')) {
	            expression = parseObjectInitializer();
	        } else if (match('[')) {
	            expression = parseArrayInitializer();
	        } else {
	            expression = parseAssignmentExpression();
	        }
	        consumeSemicolon();
	        return node.finishExportDefaultDeclaration(expression);
	    }
	
	    function parseExportAllDeclaration(node) {
	        var src;
	
	        // covers:
	        // export * from 'foo';
	        expect('*');
	        if (!matchContextualKeyword('from')) {
	            throwError(lookahead.value ?
	                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	        }
	        lex();
	        src = parseModuleSpecifier();
	        consumeSemicolon();
	
	        return node.finishExportAllDeclaration(src);
	    }
	
	    function parseExportDeclaration() {
	        var node = new Node();
	        if (state.inFunctionBody) {
	            throwError(Messages.IllegalExportDeclaration);
	        }
	
	        expectKeyword('export');
	
	        if (matchKeyword('default')) {
	            return parseExportDefaultDeclaration(node);
	        }
	        if (match('*')) {
	            return parseExportAllDeclaration(node);
	        }
	        return parseExportNamedDeclaration(node);
	    }
	
	    // ECMA-262 15.2.2 Imports
	
	    function parseImportSpecifier() {
	        // import {<foo as bar>} ...;
	        var local, imported, node = new Node();
	
	        imported = parseNonComputedProperty();
	        if (matchContextualKeyword('as')) {
	            lex();
	            local = parseVariableIdentifier();
	        }
	
	        return node.finishImportSpecifier(local, imported);
	    }
	
	    function parseNamedImports() {
	        var specifiers = [];
	        // {foo, bar as bas}
	        expect('{');
	        while (!match('}')) {
	            specifiers.push(parseImportSpecifier());
	            if (!match('}')) {
	                expect(',');
	                if (match('}')) {
	                    break;
	                }
	            }
	        }
	        expect('}');
	        return specifiers;
	    }
	
	    function parseImportDefaultSpecifier() {
	        // import <foo> ...;
	        var local, node = new Node();
	
	        local = parseNonComputedProperty();
	
	        return node.finishImportDefaultSpecifier(local);
	    }
	
	    function parseImportNamespaceSpecifier() {
	        // import <* as foo> ...;
	        var local, node = new Node();
	
	        expect('*');
	        if (!matchContextualKeyword('as')) {
	            throwError(Messages.NoAsAfterImportNamespace);
	        }
	        lex();
	        local = parseNonComputedProperty();
	
	        return node.finishImportNamespaceSpecifier(local);
	    }
	
	    function parseImportDeclaration() {
	        var specifiers = [], src, node = new Node();
	
	        if (state.inFunctionBody) {
	            throwError(Messages.IllegalImportDeclaration);
	        }
	
	        expectKeyword('import');
	
	        if (lookahead.type === Token.StringLiteral) {
	            // import 'foo';
	            src = parseModuleSpecifier();
	        } else {
	
	            if (match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(parseNamedImports());
	            } else if (match('*')) {
	                // import * as foo
	                specifiers.push(parseImportNamespaceSpecifier());
	            } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {
	                // import foo
	                specifiers.push(parseImportDefaultSpecifier());
	                if (match(',')) {
	                    lex();
	                    if (match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(parseImportNamespaceSpecifier());
	                    } else if (match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(parseNamedImports());
	                    } else {
	                        throwUnexpectedToken(lookahead);
	                    }
	                }
	            } else {
	                throwUnexpectedToken(lex());
	            }
	
	            if (!matchContextualKeyword('from')) {
	                throwError(lookahead.value ?
	                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	            }
	            lex();
	            src = parseModuleSpecifier();
	        }
	
	        consumeSemicolon();
	        return node.finishImportDeclaration(specifiers, src);
	    }
	
	    // ECMA-262 15.1 Scripts
	
	    function parseScriptBody() {
	        var statement, body = [], token, directive, firstRestricted;
	
	        while (startIndex < length) {
	            token = lookahead;
	            if (token.type !== Token.StringLiteral) {
	                break;
	            }
	
	            statement = parseStatementListItem();
	            body.push(statement);
	            if (statement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.start + 1, token.end - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	
	        while (startIndex < length) {
	            statement = parseStatementListItem();
	            /* istanbul ignore if */
	            if (typeof statement === 'undefined') {
	                break;
	            }
	            body.push(statement);
	        }
	        return body;
	    }
	
	    function parseProgram() {
	        var body, node;
	
	        peek();
	        node = new Node();
	
	        body = parseScriptBody();
	        return node.finishProgram(body, state.sourceType);
	    }
	
	    function filterTokenLocation() {
	        var i, entry, token, tokens = [];
	
	        for (i = 0; i < extra.tokens.length; ++i) {
	            entry = extra.tokens[i];
	            token = {
	                type: entry.type,
	                value: entry.value
	            };
	            if (entry.regex) {
	                token.regex = {
	                    pattern: entry.regex.pattern,
	                    flags: entry.regex.flags
	                };
	            }
	            if (extra.range) {
	                token.range = entry.range;
	            }
	            if (extra.loc) {
	                token.loc = entry.loc;
	            }
	            tokens.push(token);
	        }
	
	        extra.tokens = tokens;
	    }
	
	    function tokenize(code, options) {
	        var toString,
	            tokens;
	
	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }
	
	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowIn: true,
	            allowYield: true,
	            labelSet: {},
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1,
	            curlyStack: []
	        };
	
	        extra = {};
	
	        // Options matching.
	        options = options || {};
	
	        // Of course we collect tokens here.
	        options.tokens = true;
	        extra.tokens = [];
	        extra.tokenize = true;
	        // The following two fields are necessary to compute the Regex tokens.
	        extra.openParenToken = -1;
	        extra.openCurlyToken = -1;
	
	        extra.range = (typeof options.range === 'boolean') && options.range;
	        extra.loc = (typeof options.loc === 'boolean') && options.loc;
	
	        if (typeof options.comment === 'boolean' && options.comment) {
	            extra.comments = [];
	        }
	        if (typeof options.tolerant === 'boolean' && options.tolerant) {
	            extra.errors = [];
	        }
	
	        try {
	            peek();
	            if (lookahead.type === Token.EOF) {
	                return extra.tokens;
	            }
	
	            lex();
	            while (lookahead.type !== Token.EOF) {
	                try {
	                    lex();
	                } catch (lexError) {
	                    if (extra.errors) {
	                        recordError(lexError);
	                        // We have to break on the first error
	                        // to avoid infinite loops.
	                        break;
	                    } else {
	                        throw lexError;
	                    }
	                }
	            }
	
	            filterTokenLocation();
	            tokens = extra.tokens;
	            if (typeof extra.comments !== 'undefined') {
	                tokens.comments = extra.comments;
	            }
	            if (typeof extra.errors !== 'undefined') {
	                tokens.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            extra = {};
	        }
	        return tokens;
	    }
	
	    function parse(code, options) {
	        var program, toString;
	
	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }
	
	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowIn: true,
	            allowYield: true,
	            labelSet: {},
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1,
	            curlyStack: [],
	            sourceType: 'script'
	        };
	        strict = false;
	
	        extra = {};
	        if (typeof options !== 'undefined') {
	            extra.range = (typeof options.range === 'boolean') && options.range;
	            extra.loc = (typeof options.loc === 'boolean') && options.loc;
	            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;
	
	            if (extra.loc && options.source !== null && options.source !== undefined) {
	                extra.source = toString(options.source);
	            }
	
	            if (typeof options.tokens === 'boolean' && options.tokens) {
	                extra.tokens = [];
	            }
	            if (typeof options.comment === 'boolean' && options.comment) {
	                extra.comments = [];
	            }
	            if (typeof options.tolerant === 'boolean' && options.tolerant) {
	                extra.errors = [];
	            }
	            if (extra.attachComment) {
	                extra.range = true;
	                extra.comments = [];
	                extra.bottomRightStack = [];
	                extra.trailingComments = [];
	                extra.leadingComments = [];
	            }
	            if (options.sourceType === 'module') {
	                // very restrictive condition for now
	                state.sourceType = options.sourceType;
	                strict = true;
	            }
	        }
	
	        try {
	            program = parseProgram();
	            if (typeof extra.comments !== 'undefined') {
	                program.comments = extra.comments;
	            }
	            if (typeof extra.tokens !== 'undefined') {
	                filterTokenLocation();
	                program.tokens = extra.tokens;
	            }
	            if (typeof extra.errors !== 'undefined') {
	                program.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            extra = {};
	        }
	
	        return program;
	    }
	
	    // Sync with *.json manifests.
	    exports.version = '2.6.0';
	
	    exports.tokenize = tokenize;
	
	    exports.parse = parse;
	
	    // Deep copy.
	    /* istanbul ignore next */
	    exports.Syntax = (function () {
	        var name, types = {};
	
	        if (typeof Object.create === 'function') {
	            types = Object.create(null);
	        }
	
	        for (name in Syntax) {
	            if (Syntax.hasOwnProperty(name)) {
	                types[name] = Syntax[name];
	            }
	        }
	
	        if (typeof Object.freeze === 'function') {
	            Object.freeze(types);
	        }
	
	        return types;
	    }());
	
	}));
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 251 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function BasicEvaluatedExpression() {
		this.range = null;
	}
	module.exports = BasicEvaluatedExpression;
	
	BasicEvaluatedExpression.prototype.isNull = function() {
		return !!this.null;
	};
	BasicEvaluatedExpression.prototype.isString = function() {
		return Object.prototype.hasOwnProperty.call(this, "string");
	};
	BasicEvaluatedExpression.prototype.isNumber = function() {
		return Object.prototype.hasOwnProperty.call(this, "number");
	};
	BasicEvaluatedExpression.prototype.isBoolean = function() {
		return Object.prototype.hasOwnProperty.call(this, "bool");
	};
	BasicEvaluatedExpression.prototype.isRegExp = function() {
		return Object.prototype.hasOwnProperty.call(this, "regExp");
	};
	BasicEvaluatedExpression.prototype.isConditional = function() {
		return Object.prototype.hasOwnProperty.call(this, "options");
	};
	BasicEvaluatedExpression.prototype.isArray = function() {
		return Object.prototype.hasOwnProperty.call(this, "items");
	};
	BasicEvaluatedExpression.prototype.isConstArray = function() {
		return Object.prototype.hasOwnProperty.call(this, "array");
	};
	BasicEvaluatedExpression.prototype.isIdentifier = function() {
		return Object.prototype.hasOwnProperty.call(this, "identifier");
	};
	BasicEvaluatedExpression.prototype.isWrapped = function() {
		return Object.prototype.hasOwnProperty.call(this, "prefix") || Object.prototype.hasOwnProperty.call(this, "postfix");
	};
	BasicEvaluatedExpression.prototype.asBool = function() {
		if(this.isBoolean()) return this.bool;
		else if(this.isNull()) return false;
		else if(this.isString()) return !!this.string;
		else if(this.isNumber()) return !!this.number;
		else if(this.isRegExp()) return true;
		else if(this.isArray()) return true;
		else if(this.isConstArray()) return true;
		else if(this.isWrapped()) return this.prefix && this.prefix.asBool() || this.postfix && this.postfix.asBool() ? true : undefined;
		return undefined;
	};
	BasicEvaluatedExpression.prototype.set = function(value) {
		if(typeof value === "string") return this.setString(value);
		if(typeof value === "number") return this.setNumber(value);
		if(typeof value === "boolean") return this.setBoolean(value);
		if(value === null) return this.setNull();
		if(value instanceof RegExp) return this.setRegExp(value);
		if(Array.isArray(value)) return this.setArray(value);
		return this;
	};
	BasicEvaluatedExpression.prototype.setString = function(str) {
		if(str === null)
			delete this.string;
		else
			this.string = str;
		return this;
	};
	BasicEvaluatedExpression.prototype.setNull = function() {
		this.null = true;
		return this;
	};
	BasicEvaluatedExpression.prototype.setNumber = function(num) {
		if(num === null)
			delete this.number;
		else
			this.number = num;
		return this;
	};
	BasicEvaluatedExpression.prototype.setBoolean = function(bool) {
		if(bool === null)
			delete this.bool;
		else
			this.bool = bool;
		return this;
	};
	BasicEvaluatedExpression.prototype.setRegExp = function(regExp) {
		if(regExp === null)
			delete this.regExp;
		else
			this.regExp = regExp;
		return this;
	};
	BasicEvaluatedExpression.prototype.setIdentifier = function(identifier) {
		if(identifier === null)
			delete this.identifier;
		else
			this.identifier = identifier;
		return this;
	};
	BasicEvaluatedExpression.prototype.setWrapped = function(prefix, postfix) {
		this.prefix = prefix;
		this.postfix = postfix;
		return this;
	};
	BasicEvaluatedExpression.prototype.unsetWrapped = function() {
		delete this.prefix;
		delete this.postfix;
		return this;
	};
	BasicEvaluatedExpression.prototype.setOptions = function(options) {
		if(options === null)
			delete this.options;
		else
			this.options = options;
		return this;
	};
	BasicEvaluatedExpression.prototype.setItems = function(items) {
		if(items === null)
			delete this.items;
		else
			this.items = items;
		return this;
	};
	BasicEvaluatedExpression.prototype.setArray = function(array) {
		if(array === null)
			delete this.array;
		else
			this.array = array;
		return this;
	};
	BasicEvaluatedExpression.prototype.addOptions = function(options) {
		if(!this.options) this.options = [];
		options.forEach(function(item) {
			this.options.push(item);
		}, this);
		return this;
	};
	BasicEvaluatedExpression.prototype.setRange = function(range) {
		this.range = range;
		return this;
	};


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Tapable = __webpack_require__(181);
	var createInnerCallback = __webpack_require__(253);
	
	function Resolver(fileSystem) {
		Tapable.call(this);
		this.fileSystem = fileSystem;
	}
	module.exports = Resolver;
	
	Resolver.prototype = Object.create(Tapable.prototype);
	
	Resolver.prototype.resolveSync = function resolveSync(context, request) {
		var err, result, sync = false;
		this.resolve(context, request, function(e, r) {
			err = e;
			result = r;
			sync = true;
		});
		if(!sync) throw new Error("Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!");
		if(err) throw err;
		return result;
	};
	
	Resolver.prototype.resolve = function resolve(context, request, callback) {
		if(typeof request === "string") request = this.parse(request);
		this.applyPlugins("resolve", context, request);
		var obj = {
			path: context,
			request: request.path,
			query: request.query,
			directory: request.directory
		};
		function onResolved(err, result) {
			if(err) return callback(err);
			return callback(null, result.path === false ? false : result.path + (result.query || ""));
		}
		onResolved.log = callback.log;
		onResolved.missing = callback.missing;
		if(request.module) return this.doResolve("module", obj, onResolved);
		if(request.directory) return this.doResolve("directory", obj, onResolved);
		return this.doResolve(["file", "directory"], obj, onResolved);
	};
	
	Resolver.prototype.doResolve = function doResolve(types, request, callback, noError) {
		if(!Array.isArray(types)) types = [types];
		var stackLine = types.join(" or ") + ": (" + request.path + ") " +
			(request.request || "") + (request.query || "") +
			(request.directory ? " directory" : "") +
			(request.module ? " module" : "");
		var newStack = [stackLine];
		if(callback.stack) {
			newStack = callback.stack.concat(newStack);
			if(callback.stack.indexOf(stackLine) >= 0) {
				// Prevent recursion
				var recursionError = new Error("Recursion in resolving\nStack:\n  " + newStack.join("\n  "));
				recursionError.recursion = true;
				if(callback.log) callback.log("abort resolving because of recursion");
				return callback(recursionError);
			}
		}
		this.applyPlugins("resolve-step", types, request);
		var localMissing = [];
		var missing = callback.missing ? {
			push: function(item) {
				callback.missing.push(item);
				localMissing.push(item);
			}
		} : localMissing;
		var log = [];
		function writeLog(msg) {
			log.push(msg);
		}
		function logAsString() {
			return log.join("\n");
		}
		var currentRequestString = request.request ? request.request + " in " + request.path : request.path;
		if(types.length == 1 && !noError) {
			// If only one type, we can pass the error.
			return this.applyPluginsParallelBailResult(types[0], request, createInnerCallback(function innerCallback(err, result) {
				if(callback.log) {
					for(var i = 0; i < log.length; i++)
						callback.log(log[i]);
				}
				if(err) return callback(err);
				if(result) return callback(null, result);
				if(types[0] === "result") return callback(null, request);
				var error = new Error("Cannot resolve " + types[0] + " '" + request.request + "' in " + request.path);
				error.details = logAsString();
				error.missing = localMissing;
				return callback(error);
			}, {
				log: writeLog,
				missing: missing,
				stack: newStack
			}, "resolve " + types[0] + " " + currentRequestString));
		}
		// For multiple type we list the errors in the details although some of them are not important
		this.forEachBail(types, function(type, callback) {
			this.applyPluginsParallelBailResult(type, request, createInnerCallback(function(err, result) {
				if(!err && result) return callback(result);
				if (err) {
					(err.message || "").split("\n").forEach(function(line) {
						log.push("  " + line);
					});
				}
				callback();
			}, {
				log: writeLog,
				missing: missing,
				stack: newStack
			}, "resolve " + type));
		}.bind(this), function(result) {
			if(callback.log) {
				callback.log("resolve '" + types.join("' or '") + "' " + currentRequestString);
				for(var i = 0; i < log.length; i++)
					callback.log("  " + log[i]);
			}
			if(noError && !result) return callback();
			if(result) return callback(null, result);
			var error = new Error("Cannot resolve '" + types.join("' or '") + "' " + currentRequestString);
			error.details = logAsString();
			error.missing = localMissing;
			return callback(error);
		});
	};
	
	Resolver.prototype.parse = function parse(identifier) {
		if(identifier === "") return null;
		var part = {
			path: null,
			query: null,
			module: false,
			directory: false,
			file: false
		};
		var idxQuery = identifier.indexOf("?");
		if(idxQuery == 0) {
			part.query = identifier;
		} else if(idxQuery > 0) {
			part.path = identifier.slice(0, idxQuery);
			part.query = identifier.slice(idxQuery);
		} else {
			part.path = identifier;
		}
		if(part.path) {
			part.module = this.isModule(part.path);
			if(part.directory = this.isDirectory(part.path)) {
				part.path = part.path.substr(0, part.path.length - 1);
			}
		}
		return part;
	};
	
	var notModuleRegExp = /^\.$|^\.[\\\/]|^\.\.$|^\.\.[\/\\]|^\/|^[A-Z]:[\\\/]/i;
	Resolver.prototype.isModule = function isModule(path) {
		return !notModuleRegExp.test(path);
	};
	
	var directoryRegExp = /[\/\\]$/i;
	Resolver.prototype.isDirectory = function isDirectory(path) {
		return directoryRegExp.test(path);
	};
	
	Resolver.prototype.join = __webpack_require__(254);
	
	Resolver.prototype.normalize = __webpack_require__(255);
	
	Resolver.prototype.forEachBail = function(array, iterator, callback) {
		if(array.length == 0) return callback();
		var currentPos = array.length;
		var currentError, currentResult;
		var done = [];
		for(var i = 0; i < array.length; i++) {
			var itCb = (function(i) {
				return function() {
					if(i >= currentPos) return; // ignore
					var args = Array.prototype.slice.call(arguments);
					done.push(i);
					if(args.length > 0) {
						currentPos = i + 1;
						done = done.filter(function(item) {
							return item <= i;
						});
						currentResult = args;
					}
					if(done.length == currentPos) {
						callback.apply(null, currentResult);
						currentPos = 0;
					}
				};
			}(i));
			iterator(array[i], itCb);
			if(currentPos == 0) break;
		}
	};
	


/***/ },
/* 253 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function createInnerCallback(callback, options, message) {
		var log = options.log;
		if(!log) {
			if(options.stack !== callback.stack) {
				function callbackWrapper() {
					return callback.apply(this, arguments);
				}
				callbackWrapper.stack = options.stack;
				callbackWrapper.missing = options.missing;
			}
			return callback;
		}
		function loggingCallbackWrapper() {
			log(message);
			for(var i = 0; i < theLog.length; i++)
				log("  " + theLog[i]);
			return callback.apply(this, arguments);
		}
		var theLog = [];
		loggingCallbackWrapper.log = function writeLog(msg) {
			theLog.push(msg);
		};
		loggingCallbackWrapper.stack = options.stack;
		loggingCallbackWrapper.missing = options.missing;
		return loggingCallbackWrapper;
	}

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	var normalize = __webpack_require__(255);
	
	var absoluteWinRegExp = /^[A-Z]:([\\\/]|$)/i;
	var absoluteNixRegExp = /^\//i;
	
	module.exports = function join(path, request) {
		if(request == "") return normalize(path);
		if(absoluteWinRegExp.test(request)) return normalize(request.replace(/\//g, "\\"));
		if(absoluteNixRegExp.test(request)) return normalize(request);
		if(path == "/") return normalize(path + request);
		if(absoluteWinRegExp.test(path)) return normalize(path + "\\" + request.replace(/\//g, "\\"));
		if(absoluteNixRegExp.test(path)) return normalize(path + "/" + request);
		return normalize(path + "/" + request);
	};

/***/ },
/* 255 */
/***/ function(module, exports) {

	var doubleSlashWinRegExp = /\\+/g;
	var doubleSlashNixRegExp = /\/+/g;
	var currentDirectoryWinMiddleRegExp = /\\(\.\\)+/;
	var currentDirectoryWinEndRegExp = /\\\.$/;
	var parentDirectoryWinMiddleRegExp = /\\+[^\\]+\\+\.\.\\/;
	var parentDirectoryWinEndRegExp1 = /([A-Z]:\\)\\*[^\\]+\\+\.\.$/i;
	var parentDirectoryWinEndRegExp2 = /\\+[^\\]+\\+\.\.$/;
	var currentDirectoryNixMiddleRegExp = /\/+(\.\/)+/;
	var currentDirectoryNixEndRegExp1 = /^\/+\.$/;
	var currentDirectoryNixEndRegExp2 = /\/+\.$/;
	var parentDirectoryNixMiddleRegExp = /(^|\/[^\/]+)\/+\.\.\/+/;
	var parentDirectoryNixEndRegExp1 = /^\/[^\/]+\/+\.\.$/;
	var parentDirectoryNixEndRegExp2 = /\/+[^\/]+\/+\.\.$/;
	var parentDirectoryNixEndRegExp3 = /^\/+\.\.$/;
	
	// RegExp magic :)
	
	module.exports = function normalize(path) {
		while(currentDirectoryWinMiddleRegExp.test(path))
			path = path.replace(currentDirectoryWinMiddleRegExp, "\\");
		path = path.replace(currentDirectoryWinEndRegExp, "");
		while(parentDirectoryWinMiddleRegExp.test(path))
			path = path.replace(parentDirectoryWinMiddleRegExp, "\\");
		path = path.replace(parentDirectoryWinEndRegExp1, "$1");
		path = path.replace(parentDirectoryWinEndRegExp2, "");
	
		while(currentDirectoryNixMiddleRegExp.test(path))
			path = path.replace(currentDirectoryNixMiddleRegExp, "/");
		path = path.replace(currentDirectoryNixEndRegExp1, "/");
		path = path.replace(currentDirectoryNixEndRegExp2, "");
		while(parentDirectoryNixMiddleRegExp.test(path))
			path = path.replace(parentDirectoryNixMiddleRegExp, "/");
		path = path.replace(parentDirectoryNixEndRegExp1, "/");
		path = path.replace(parentDirectoryNixEndRegExp2, "");
		path = path.replace(parentDirectoryNixEndRegExp3, "/");
	
		return path.replace(doubleSlashWinRegExp, "\\").replace(doubleSlashNixRegExp, "/");
	};

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var async = __webpack_require__(183);
	
	var Tapable = __webpack_require__(181);
	var NormalModule = __webpack_require__(257);
	var RawModule = __webpack_require__(267);
	var LoadersList = __webpack_require__(268);
	
	function NormalModuleFactory(context, resolvers, parser, options) {
		Tapable.call(this);
		this.resolvers = resolvers;
		this.parser = parser;
		this.loaders = new LoadersList(options.loaders);
		this.preLoaders = new LoadersList(options.preLoaders);
		this.postLoaders = new LoadersList(options.postLoaders);
		this.context = context || "";
		this.plugin("factory", function() {
			return function(result, callback) {
				var resolver = this.applyPluginsWaterfall("resolver", null);
	
				// Ignored
				if(!resolver) return callback();
	
				resolver(result, function onDoneResolving(err, data) {
					if(err) return callback(err);
	
					// Ignored
					if(!data) return callback();
	
					// direct module
					if(typeof data.source === "function")
						return callback(null, data);
	
					this.applyPluginsAsyncWaterfall("after-resolve", data, function(err, result) {
						if(err) return callback(err);
	
						// Ignored
						if(!result) return callback();
	
						var createdModule = this.applyPluginsBailResult("create-module", result);
						if(!createdModule) {
							createdModule = new NormalModule(
								result.request,
								result.userRequest,
								result.rawRequest,
								result.loaders,
								result.resource,
								result.parser
							);
						}
	
						createdModule = this.applyPluginsWaterfall("module", createdModule);
	
						return callback(null, createdModule);
					}.bind(this));
				}.bind(this));
			}.bind(this);
		});
		this.plugin("resolver", function() {
			return function(data, callback) {
				var context = data.context;
				var request = data.request;
	
				var noAutoLoaders = /^-?!/.test(request);
				var noPrePostAutoLoaders = /^!!/.test(request);
				var noPostAutoLoaders = /^-!/.test(request);
				var elements = request.replace(/^-?!+/, "").replace(/!!+/g, "!").split("!");
				var resource = elements.pop();
	
				async.parallel([
					function(callback) {
						this.resolveRequestArray(context, elements, this.resolvers.loader, callback);
					}.bind(this),
					function(callback) {
						if(resource === "" || resource[0] === "?")
							return callback(null, resource);
						this.resolvers.normal.resolve(context, resource, callback);
					}.bind(this)
				], function(err, results) {
					if(err) return callback(err);
					var loaders = results[0];
					resource = results[1];
	
					if(resource === false)
						return callback(null,
							new RawModule("/* (ignored) */",
								"ignored " + context + " " + request,
								request + " (ignored)")); // ignored
	
					var userRequest = loaders.concat([resource]).join("!");
	
					if(noPrePostAutoLoaders)
						return onDoneResolving.call(this);
					if(noAutoLoaders) {
						async.parallel([
							this.resolveRequestArray.bind(this, context, noPostAutoLoaders ? [] : this.postLoaders.match(resource), this.resolvers.loader),
							this.resolveRequestArray.bind(this, context, this.preLoaders.match(resource), this.resolvers.loader)
						], function(err, results) {
							if(err) return callback(err);
							loaders = results[0].concat(loaders).concat(results[1]);
							onDoneResolving.call(this);
						}.bind(this));
					} else {
						async.parallel([
							this.resolveRequestArray.bind(this, context, noPostAutoLoaders ? [] : this.postLoaders.match(resource), this.resolvers.loader),
							this.resolveRequestArray.bind(this, context, this.loaders.match(resource), this.resolvers.loader),
							this.resolveRequestArray.bind(this, context, this.preLoaders.match(resource), this.resolvers.loader)
						], function(err, results) {
							if(err) return callback(err);
							loaders = results[0].concat(loaders).concat(results[1]).concat(results[2]);
							onDoneResolving.call(this);
						}.bind(this));
					}
	
					function onDoneResolving() {
						callback(null, {
							context: context,
							request: loaders.concat([resource]).join("!"),
							userRequest: userRequest,
							rawRequest: request,
							loaders: loaders,
							resource: resource,
							parser: this.parser
						});
					}
				}.bind(this));
			}.bind(this);
		});
	}
	module.exports = NormalModuleFactory;
	
	NormalModuleFactory.prototype = Object.create(Tapable.prototype);
	NormalModuleFactory.prototype.constructor = NormalModuleFactory;
	
	NormalModuleFactory.prototype.create = function(context, dependency, callback) {
		context = context || this.context;
		var request = dependency.request;
		this.applyPluginsAsyncWaterfall("before-resolve", {
			context: context,
			request: request,
			dependency: dependency
		}, function(err, result) {
			if(err) return callback(err);
	
			// Ignored
			if(!result) return callback();
	
			var factory = this.applyPluginsWaterfall("factory", null);
	
			// Ignored
			if(!factory) return callback();
	
			factory(result, callback);
	
		}.bind(this));
	};
	
	NormalModuleFactory.prototype.resolveRequestArray = function resolveRequestArray(context, array, resolver, callback) {
		if(array.length === 0) return callback(null, []);
		async.map(array, function(item, callback) {
			if(item === "" || item[0] === "?")
				return callback(null, item);
			resolver.resolve(context, item, callback);
		}, callback);
	};


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(180);
	var Module = __webpack_require__(188);
	var NormalModuleMixin = __webpack_require__(258);
	var SourceMapSource = __webpack_require__(259);
	var OriginalSource = __webpack_require__(222);
	var RawSource = __webpack_require__(213);
	var ReplaceSource = __webpack_require__(191);
	var CachedSource = __webpack_require__(230);
	var ModuleParseError = __webpack_require__(264);
	var TemplateArgumentDependency = __webpack_require__(265);
	var AsyncDependenciesBlock = __webpack_require__(266);
	
	function NormalModule(request, userRequest, rawRequest, loaders, resource, parser) {
		Module.call(this);
		this.request = request;
		this.userRequest = userRequest;
		this.rawRequest = rawRequest;
		this.parser = parser;
		NormalModuleMixin.call(this, loaders, resource);
		this.meta = {};
		this.assets = {};
		this.built = false;
		this._cachedSource = null;
	}
	module.exports = NormalModule;
	
	NormalModule.prototype = Object.create(Module.prototype);
	NormalModuleMixin.mixin(NormalModule.prototype);
	
	NormalModule.prototype.identifier = function() {
		return this.request;
	};
	
	NormalModule.prototype.readableIdentifier = function(requestShortener) {
		return requestShortener.shorten(this.userRequest);
	};
	
	function contextify(options, request) {
		return request.split("!").map(function(r) {
			var rp = path.relative(options.context, r);
			if(path.sep === "\\")
				rp = rp.replace(/\\/g, "/");
			if(rp.indexOf("../") !== 0)
				rp = "./" + rp;
			return rp;
		}).join("!");
	}
	
	NormalModule.prototype.libIdent = function(options) {
		return contextify(options, this.userRequest);
	};
	
	NormalModule.prototype.fillLoaderContext = function fillLoaderContext(loaderContext, options, compilation) {
		loaderContext.webpack = true;
		loaderContext.sourceMap = !!this.useSourceMap;
		loaderContext.emitFile = function(name, content, sourceMap) {
			if(typeof sourceMap === "string") {
				this.assets[name] = new OriginalSource(content, sourceMap);
			} else if(sourceMap) {
				this.assets[name] = new SourceMapSource(content, name, sourceMap);
			} else {
				this.assets[name] = new RawSource(content);
			}
		}.bind(this);
		loaderContext._module = this;
		loaderContext._compilation = compilation;
		loaderContext._compiler = compilation.compiler;
		loaderContext.fs = compilation.compiler.inputFileSystem;
		compilation.applyPlugins("normal-module-loader", loaderContext, this);
	};
	
	NormalModule.prototype.disconnect = function disconnect() {
		this.built = false;
		Module.prototype.disconnect.call(this);
	};
	
	NormalModule.prototype.build = function build(options, compilation, resolver, fs, callback) {
		this.buildTimestamp = new Date().getTime();
		this.built = true;
		return this.doBuild(options, compilation, resolver, fs, function(err) {
			if(err) return callback(err);
			this.dependencies.length = 0;
			this.variables.length = 0;
			this.blocks.length = 0;
			this._cachedSource = null;
			if(options.module && options.module.noParse) {
				if(Array.isArray(options.module.noParse)) {
					if(options.module.noParse.some(function(regExp) {
							return typeof regExp === "string" ?
								this.request.indexOf(regExp) === 0 :
								regExp.test(this.request);
						}, this)) return callback();
				} else if(typeof options.module.noParse === "string" ?
					this.request.indexOf(options.module.noParse) === 0 :
					options.module.noParse.test(this.request)) {
					return callback();
				}
			}
			try {
				this.parser.parse(this._source.source(), {
					current: this,
					module: this,
					compilation: compilation,
					options: options
				});
			} catch(e) {
				var source = this._source.source();
				this._source = null;
				return callback(new ModuleParseError(this, source, e));
			}
			return callback();
		}.bind(this));
	};
	
	NormalModule.prototype.source = function(dependencyTemplates, outputOptions, requestShortener) {
		var hash = __webpack_require__(231).createHash("md5");
		this.updateHash(hash);
		hash = hash.digest("hex");
		if(this._cachedSource && this._cachedSource.hash === hash) {
			return this._cachedSource.source;
		}
		var _source = this._source;
		if(!_source) return new RawSource("throw new Error('No source available');");
		var source = new ReplaceSource(_source);
		this._cachedSource = {
			source: source,
			hash: hash
		};
		var topLevelBlock = this;
	
		function doDep(dep) {
			var template = dependencyTemplates.get(dep.Class);
			if(!template) throw new Error("No template for dependency: " + dep.Class.name);
			template.apply(dep, source, outputOptions, requestShortener, dependencyTemplates);
		}
	
		function doVariable(vars, variable) {
			var name = variable.name;
			var expr = variable.expressionSource(dependencyTemplates, outputOptions, requestShortener);
			vars.push({
				name: name,
				expression: expr
			});
		}
	
		function doBlock(block) {
			block.dependencies.forEach(doDep);
			block.blocks.forEach(doBlock);
			if(block.variables.length > 0) {
				var vars = [];
				block.variables.forEach(doVariable.bind(null, vars));
				var varNames = [];
				var varExpressions = [];
				var varStartCode = "";
				var varEndCode = "";
	
				function emitFunction() {
					if(varNames.length === 0) return;
	
					varStartCode += "/* WEBPACK VAR INJECTION */(function(" + varNames.join(", ") + ") {";
					// exports === this in the topLevelBlock, but exports do compress better...
					varEndCode = (topLevelBlock === block ? "}.call(exports, " : "}.call(this, ") +
						varExpressions.map(function(e) {
							return e.source();
						}).join(", ") + "))" + varEndCode;
	
					varNames.length = 0;
					varExpressions.length = 0;
				}
				vars.forEach(function(v) {
					if(varNames.indexOf(v.name) >= 0) emitFunction();
					varNames.push(v.name);
					varExpressions.push(v.expression);
				});
				emitFunction();
				var start = block.range ? block.range[0] : 0;
				var end = block.range ? block.range[1] : _source.size();
				if(varStartCode) source.insert(start + 0.5, varStartCode);
				if(varEndCode) source.insert(end + 0.5, "\n/* WEBPACK VAR INJECTION */" + varEndCode);
			}
		}
		doBlock(this);
		return new CachedSource(source);
	};
	
	NormalModule.prototype.needRebuild = function needRebuild(fileTimestamps, contextTimestamps) {
		var timestamp = 0;
		this.fileDependencies.forEach(function(file) {
			var ts = fileTimestamps[file];
			if(!ts) timestamp = Infinity;
			if(ts > timestamp) timestamp = ts;
		});
		this.contextDependencies.forEach(function(context) {
			var ts = contextTimestamps[context];
			if(!ts) timestamp = Infinity;
			if(ts > timestamp) timestamp = ts;
		});
		return timestamp >= this.buildTimestamp;
	};
	
	NormalModule.prototype.size = function() {
		return this._source ? this._source.size() : -1;
	};
	
	NormalModule.prototype.updateHash = function(hash) {
		if(this._source) {
			hash.update("source");
			this._source.updateHash(hash);
		} else
			hash.update("null");
		hash.update("meta");
		hash.update(JSON.stringify(this.meta));
		Module.prototype.updateHash.call(this, hash);
	};
	
	NormalModule.prototype.getSourceHash = function() {
		if(!this._source) return "";
		var hash = __webpack_require__(231).createHash("md5");
		hash.update(this._source.source());
		return hash.digest("hex");
	};
	
	NormalModule.prototype.getAllModuleDependencies = function() {
		var list = [];
	
		function doDep(dep) {
			if(dep.module && list.indexOf(dep.module) < 0)
				list.push(dep.module);
		}
	
		function doVariable(variable) {
			variable.dependencies.forEach(doDep);
		}
	
		function doBlock(block) {
			block.variables.forEach(doVariable);
			block.dependencies.forEach(doDep);
			block.blocks.forEach(doBlock);
		}
		doBlock(this);
		return list;
	};
	
	NormalModule.prototype.createTemplate = function(keepModules, roots) {
		roots.sort(function(a, b) {
			var ia = a.identifier();
			var ib = b.identifier();
			if(ia < ib) return -1;
			if(ib < ia) return 1;
			return 0;
		});
		var template = new NormalModule("", "", "", [], "", null);
		template._source = this._source;
		template.built = this.built;
		template.templateModules = keepModules;
		template._templateOrigin = this;
		template.readableIdentifier = function() {
			return "template of " + this._templateOrigin.id + " referencing " + keepModules.map(function(m) {
				return m.id;
			}).join(", ");
		};
		template.identifier = function() {
			var array = roots.map(function(m) {
				return m.identifier();
			});
			array.sort();
			return array.join("|");
		};
		var args = template.arguments = [];
	
		function doDeps(deps) {
			return deps.map(function(dep) {
				if(dep.module && keepModules.indexOf(dep.module) < 0) {
					var argName = "__webpack_module_template_argument_" + args.length + "__";
					args.push(argName);
					return new TemplateArgumentDependency(argName, dep);
				} else {
					return dep;
				}
			});
		}
	
		function doBlock(block, newBlock) {
			block.variables.forEach(function(variable) {
				var newDependencies = doDeps(variable.dependencies);
				newBlock.addVariable(variable.name, variable.expression, newDependencies);
			});
			newBlock.dependencies = doDeps(block.dependencies);
			block.blocks.forEach(function(childBlock) {
				var newChildBlock = new AsyncDependenciesBlock(childBlock.name, childBlock.module, childBlock.loc);
				newBlock.addBlock(newChildBlock);
				doBlock(childBlock, newChildBlock);
			});
		}
		doBlock(this, template);
		return template;
	};
	
	NormalModule.prototype.getTemplateArguments = function(keepModules) {
		var list = [];
	
		function doDep(dep) {
			if(dep.module && keepModules.indexOf(dep.module) < 0)
				list.push(dep.module);
		}
	
		function doVariable(variable) {
			variable.dependencies.forEach(doDep);
		}
	
		function doBlock(block) {
			block.variables.forEach(doVariable);
			block.dependencies.forEach(doDep);
			block.blocks.forEach(doBlock);
		}
		doBlock(this);
		return list;
	};


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RawSource = __webpack_require__(213);
	var OriginalSource = __webpack_require__(222);
	var SourceMapSource = __webpack_require__(259);
	var LineToLineMappedSource = __webpack_require__(260);
	var path = __webpack_require__(180); // TODO refactor
	
	var ModuleBuildError = __webpack_require__(261);
	var ModuleError = __webpack_require__(262);
	var ModuleWarning = __webpack_require__(263);
	
	function utf8BufferToString(buf) {
		var str = buf.toString("utf-8");
		if(str.charCodeAt(0) === 0xFEFF) {
			return str.substr(1);
		} else {
			return str;
		}
	}
	
	function NormalModuleMixin(loaders, resource) {
		this.resource = resource;
		this.loaders = loaders;
		var resourcePath = this.splitQuery(this.resource)[0];
		this.context = resourcePath ? path.dirname(resourcePath) : null;
		this.fileDependencies = [];
		this.contextDependencies = [];
		this.warnings = [];
		this.errors = [];
		this.error = null;
		this._source = null;
	}
	module.exports = NormalModuleMixin;
	
	NormalModuleMixin.mixin = function(pt) {
		for(var name in NormalModuleMixin.prototype)
			pt[name] = NormalModuleMixin.prototype[name];
	};
	
	NormalModuleMixin.prototype.splitQuery = function splitQuery(req) {
		var i = req.indexOf("?");
		if(i < 0) return [req, ""];
		return [req.substr(0, i), req.substr(i)];
	};
	
	NormalModuleMixin.prototype.doBuild = function doBuild(options, moduleContext, resolver, fs, callback) {
		var splitQuery = this.splitQuery.bind(this);
		var module = this;
		this.cacheable = true;
	
		// Prepare context
		var loaders = [];
		function addLoaderToList(loader) {
			var l = splitQuery(loader);
			loaders.push({
				request: loader,
				path: l[0],
				query: l[1],
				module: null
			});
		}
		this.loaders.forEach(addLoaderToList);
		var loaderContextCacheable;
		var loaderContext = {
			version: 1,
			context: this.context,
			loaders: loaders,
			loaderIndex: 0,
			resource: this.resource,
			resourcePath: splitQuery(this.resource)[0],
			resourceQuery: this.resource ? splitQuery(this.resource)[1] || null : undefined,
			emitWarning: function(warning) {
				this.warnings.push(new ModuleWarning(this, warning));
			}.bind(this),
			emitError: function(error) {
				this.errors.push(new ModuleError(this, error));
			}.bind(this),
			exec: function(code, filename) {
				if(false) {
					// TODO: check if in enhanced-require
					var Module = require("module");
					var m = new Module(filename, module);
					m.paths = Module._nodeModulePaths(loaderContext.context);
					m.filename = filename;
					m._compile(code, filename);
					return m.exports;
				} else {
					throw new Error("loaderContext.exec is not supported");
				}
			},
			resolve: function(context, request, callback) {
				resolver.resolve(context, request, callback);
			},
			resolveSync: function(context, request) {
				return resolver.resolveSync(context, request);
			},
			cacheable: function(flag) {
				loaderContextCacheable = flag !== false;
			},
			dependency: function(file) {
				this.fileDependencies.push(file);
			}.bind(this),
			addDependency: function(file) {
				this.fileDependencies.push(file);
			}.bind(this),
			addContextDependency: function(context) {
				this.contextDependencies.push(context);
			}.bind(this),
			clearDependencies: function() {
				this.fileDependencies.length = 0;
				this.contextDependencies.length = 0;
				module.cacheable = true;
			}.bind(this),
			inputValue: undefined,
			value: null,
			options: options,
			debug: options.debug
		};
		this.fillLoaderContext(loaderContext, options, moduleContext);
		if(options.loader) for(var key in options.loader)
			loaderContext[key] = options.loader[key];
	
	
		function runSyncOrAsync(fn, context, args, callback) {
			var isSync = true;
			var isDone = false;
			var isError = false; // internal error
			var reportedError = false;
			if(!context.async) context.async = function async() {
				if(isDone) {
					if(reportedError) return; // ignore
					throw new Error("async(): The callback was already called.");
				}
				isSync = false;
				return context.callback;
			};
			context.callback = function() {
				if(isDone) {
					if(reportedError) return; // ignore
					throw new Error("callback(): The callback was already called.");
				}
				isDone = true;
				isSync = false;
				try {
					callback.apply(null, arguments);
				} catch(e) {
					isError = true;
					throw e;
				}
			};
			try {
				var result = (function WEBPACK_CORE_LOADER_EXECUTION() { return fn.apply(context, args) }());
				if(isSync) {
					isDone = true;
					if(result === undefined)
						return callback();
					return callback(null, result);
				}
			} catch(e) {
				if(isError) throw e;
				if(isDone) {
					// loader is already "done", so we cannot use the callback function
					// for better debugging we print the error on the console
					if(typeof e === "object" && e.stack) console.error(e.stack);
					else console.error(e);
					return;
				}
				isDone = true;
				reportedError = true;
				callback(e);
			}
	
		}
	
		// Load and pitch loaders
		(function loadPitch() {
			var l = loaderContext.loaders[loaderContext.loaderIndex];
			if(!l) {
				return onLoadPitchDone.call(this);
			}
			if(l.module) {
				loaderContext.loaderIndex++;
				return loadPitch.call(this);
			}
			if(false) {
				if(require.supportQuery) {
					l.module = require(l.request);
				} else {
					try {
						l.module = require(l.path);
					} catch (e) {
						// it is possible for node to choke on a require if the FD descriptor
						// limit has been reached. give it a chance to recover.
						if (e instanceof Error && e.code === 'EMFILE') {
							if (typeof setImmediate === 'function') {
								// node >= 0.9.0
								return setImmediate(loadPitch.bind(this));
							} else  {
								// node < 0.9.0
								return process.nextTick(loadPitch.bind(this));
							}
						}
						throw e;
					}
				}
			} else if(typeof __webpack_require_loader__ === "function") {
				l.module = __webpack_require_loader__(l.request);
			} else {
				return callback(new Error("Cannot load loader, __webpack_require_loader__ not provided."));
			}
			if(typeof l.module !== "function")
				return callback(new Error("Loader " + l.request + " didn't return a function"));
			var pitchedLoaders = [];
			var remaining = [];
			for(var i = 0; i < loaderContext.loaderIndex; i++)
				pitchedLoaders.push(loaderContext.loaders[i].request);
			for(i = loaderContext.loaderIndex + 1; i < loaderContext.loaders.length; i++)
				remaining.push(loaderContext.loaders[i].request);
			remaining.push(loaderContext.resource);
			if(typeof l.module.pitch !== "function") return loadPitch.call(this);
			loaderContextCacheable = false;
			var privateLoaderContext = Object.create(loaderContext);
			privateLoaderContext.query = l.query;
			runSyncOrAsync(l.module.pitch, privateLoaderContext, [remaining.join("!"), pitchedLoaders.join("!"), l.data = {}], function(err) {
				if(err) return onModuleBuildFailed.call(this, err);
				if(!loaderContextCacheable) this.cacheable = false;
				var args = Array.prototype.slice.call(arguments, 1);
				loaderContext.resourcePath = privateLoaderContext.resourcePath;
				loaderContext.resourceQuery = privateLoaderContext.resourceQuery;
				loaderContext.resource = privateLoaderContext.resource;
				loaderContext.loaderIndex = privateLoaderContext.loaderIndex;
				if(args.length > 0) {
					nextLoader.apply(this, [null].concat(args));
				} else {
					loadPitch.call(this);
				}
			}.bind(this));
		}.call(this));
	
		var resourceBuffer;
		function onLoadPitchDone() {
			loaderContext.loaderIndex = loaderContext.loaders.length;
			var request = [];
			for(var i = 0; i < loaderContext.loaders.length; i++)
				request.push(loaderContext.loaders[i].request);
			request.push(loaderContext.resource);
			loaderContext.request = request.join("!");
			var resourcePath = loaderContext.resourcePath;
			loaderContextCacheable = true;
			if(resourcePath) {
				loaderContext.addDependency(resourcePath);
				fs.readFile(resourcePath, function(err, buffer) {
					if(err) return nextLoader(err);
					if(module.lineToLine)
						resourceBuffer = buffer;
					nextLoader(null, buffer);
				});
			} else
				nextLoader(null, null);
		}
	
		function nextLoader(err/*, paramBuffer1, param2, ...*/) {
			if(!loaderContextCacheable) module.cacheable = false;
			var args = Array.prototype.slice.call(arguments, 1);
			if(err) {
				// a loader emitted an error
				return onModuleBuildFailed.call(module, err);
			}
			if(loaderContext.loaderIndex === 0) {
				if(Buffer.isBuffer(args[0]))
					args[0] = utf8BufferToString(args[0]);
				return onModuleBuild.apply(module, args);
			}
			loaderContext.loaderIndex--;
			var l = loaderContext.loaders[loaderContext.loaderIndex];
			if(!l.module) return nextLoader.apply(null, [null].concat(args));
			var privateLoaderContext = Object.create(loaderContext);
			privateLoaderContext.data = l.data;
			privateLoaderContext.inputValue = loaderContext.inputValue;
			privateLoaderContext.query = l.query;
			if(!l.module.raw && Buffer.isBuffer(args[0])) {
				args[0] = utf8BufferToString(args[0]);
			} else if(l.module.raw && typeof args[0] === "string") {
				args[0] = new Buffer(args[0], "utf-8");
			}
			loaderContextCacheable = false;
			runSyncOrAsync(l.module, privateLoaderContext, args, function() {
				loaderContext.inputValue = privateLoaderContext.value;
				nextLoader.apply(null, arguments);
			});
		}
	
	
		function onModuleBuild(source, sourceMap) {
			if(!Buffer.isBuffer(source) && typeof source !== "string")
				return onModuleBuildFailed.call(this, new Error("Final loader didn't return a Buffer or String"));
			if(this.identifier && this.lineToLine && resourceBuffer) {
				this._source = new LineToLineMappedSource(source, this.identifier(),
					resourceBuffer.toString("utf-8"));
			} else if(this.identifier && this.useSourceMap && sourceMap) {
				this._source = new SourceMapSource(source, this.identifier(), sourceMap);
			} else if(this.identifier) {
				this._source = new OriginalSource(source, this.identifier());
			} else {
				this._source = new RawSource(source);
			}
			return callback();
		}
	
		function onModuleBuildFailed(err) {
			this.error = err;
			return callback(new ModuleBuildError(this, err));
		}
	};
	
	NormalModuleMixin.prototype.fillLoaderContext = function fillLoaderContext() {};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176).Buffer))

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(193).SourceNode;
	var SourceMapConsumer = __webpack_require__(193).SourceMapConsumer;
	var SourceMapGenerator = __webpack_require__(193).SourceMapGenerator;
	var SourceListMap = __webpack_require__(204).SourceListMap;
	var fromStringWithSourceMap = __webpack_require__(204).fromStringWithSourceMap;
	var Source = __webpack_require__(192);
	
	function SourceMapSource(value, name, sourceMap, originalSource, innerSourceMap) {
		Source.call(this);
		this._value = value;
		this._name = name;
		this._sourceMap = sourceMap;
		this._originalSource = originalSource;
		this._innerSourceMap = innerSourceMap;
	}
	module.exports = SourceMapSource;
	
	SourceMapSource.prototype = Object.create(Source.prototype);
	SourceMapSource.prototype.constructor = SourceMapSource;
	
	SourceMapSource.prototype.source = function() {
		return this._value;
	};
	
	__webpack_require__(212)(SourceMapSource.prototype);
	
	SourceMapSource.prototype.node = function(options) {
		var innerSourceMap = this._innerSourceMap;
		var sourceMap = this._sourceMap;
		if(innerSourceMap) {
			innerSourceMap = new SourceMapConsumer(innerSourceMap);
			sourceMap = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(sourceMap));
			sourceMap.setSourceContent(this._name, this._originalSource);
			sourceMap.applySourceMap(innerSourceMap, this._name);
			sourceMap = sourceMap.toJSON();
		}
		return SourceNode.fromStringWithSourceMap(this._value, new SourceMapConsumer(sourceMap));
	};
	
	SourceMapSource.prototype.listMap = function(options) {
		if(options.module === false)
			return new SourceListMap(this._value, this._name, this._value);
		return fromStringWithSourceMap(this._value, typeof this._sourceMap === "string" ? JSON.parse(this._sourceMap) : this._sourceMap);
	};
	
	SourceMapSource.prototype.updateHash = function(hash) {
		hash.update(this._value);
		if(this._originalSource)
			hash.update(this._originalSource);
	};


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(193).SourceNode;
	var SourceMapConsumer = __webpack_require__(193).SourceMapConsumer;
	var SourceListMap = __webpack_require__(204).SourceListMap;
	var Source = __webpack_require__(192);
	
	function LineToLineMappedSource(value, name, originalSource) {
		Source.call(this);
		this._value = value;
		this._name = name;
		this._originalSource = originalSource;
	}
	
	module.exports = LineToLineMappedSource;
	
	LineToLineMappedSource.prototype = Object.create(Source.prototype);
	LineToLineMappedSource.prototype.constructor = LineToLineMappedSource;
	
	LineToLineMappedSource.prototype.source = function() {
		return this._value;
	};
	
	__webpack_require__(212)(LineToLineMappedSource.prototype);
	
	LineToLineMappedSource.prototype.node = function(options) {
		var value = this._value;
		var name = this._name;
		var lines = value.split("\n");
		var node = new SourceNode(null, null, null,
			lines.map(function(line, idx) {
				return new SourceNode(idx+1, 0, name,
					(line + (idx != lines.length-1 ? "\n" : ""))
				);
			})
		);
		node.setSourceContent(name, this._originalSource);
		return node;
	};
	
	LineToLineMappedSource.prototype.listMap = function(options) {
		return new SourceListMap(this._value, this._name, this._originalSource)
	};
	
	LineToLineMappedSource.prototype.updateHash = function(hash) {
		hash.update(this._value);
		hash.update(this._originalSource);
	};


/***/ },
/* 261 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var loaderFlag = "WEBPACK_CORE_LOADER_EXECUTION";
	function ModuleBuildError(module, err) {
		Error.call(this);
		Error.captureStackTrace(this, ModuleBuildError);
		this.name = "ModuleBuildError";
		this.message = "Module build failed: ";
		if(err !== null && typeof err === "object") {
			if(typeof err.stack === "string" && err.stack) {
				var stack = err.stack.split("\n");
				for(var i = 0; i < stack.length; i++)
					if(stack[i].indexOf(loaderFlag) >= 0)
						stack.length = i;
				stack = stack.join("\n");
				if(!err.hideStack) {
					this.message += stack;
				} else {
					this.details = stack;
					if(typeof err.message === "string" && err.message) {
						this.message += err.message;
					} else {
						this.message += err;
					}
				}
			} else if(typeof err.message === "string" && err.message) {
				this.message += err.message;
			} else {
				this.message += err;
			}
		}
		this.module = module;
		this.error = err;
	}
	module.exports = ModuleBuildError;
	
	ModuleBuildError.prototype = Object.create(Error.prototype);


/***/ },
/* 262 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleError(module, err) {
		Error.call(this);
		Error.captureStackTrace(this, ModuleError);
		this.name = "ModuleError";
		this.module = module;
		this.message = err;
		this.error = err;
	}
	module.exports = ModuleError;
	
	ModuleError.prototype = Object.create(Error.prototype);


/***/ },
/* 263 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleWarning(module, warning) {
		Error.call(this);
		Error.captureStackTrace(this, ModuleWarning);
		this.name = "ModuleWarning";
		this.module = module;
		this.message = warning;
		this.warning = warning;
	}
	module.exports = ModuleWarning;
	
	ModuleWarning.prototype = Object.create(Error.prototype);


/***/ },
/* 264 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleParseError(module, source, err) {
		Error.call(this);
		Error.captureStackTrace(this, ModuleParseError);
		this.name = "ModuleParseError";
		this.message = "Module parse failed: " + module.request + " " + err.message;
		this.message += "\nYou may need an appropriate loader to handle this file type.";
		if(typeof err.lineNumber === "number") {
			if(/[\0\u0001\u0002\u0003\u0004\u0005\u0006\u0007]/.test(source)) { // binary file
				this.message += "\n(Source code omitted for this binary file)";
			} else {
				source = source.split("\n");
				this.message += "\n| " + source.slice(Math.max(0, err.lineNumber - 3), err.lineNumber + 2).join("\n| ");
			}
		} else {
			this.message += "\n" + err.stack;
		}
		this.module = module;
		this.error = err;
	}
	module.exports = ModuleParseError;
	
	ModuleParseError.prototype = Object.create(Error.prototype);


/***/ },
/* 265 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function TemplateArgumentDependency(name, dep) {
		this.name = name;
		this.Class = TemplateArgumentDependency;
		this.dep = dep;
	}
	module.exports = TemplateArgumentDependency;
	
	TemplateArgumentDependency.prototype.constructor = TemplateArgumentDependency;
	TemplateArgumentDependency.prototype.type = "template argument";
	
	TemplateArgumentDependency.prototype.updateHash = function(hash) {
		hash.update(this.name);
	};
	
	TemplateArgumentDependency.Template = function TemplateArgumentDependencyTemplate() {};
	
	TemplateArgumentDependency.Template.prototype.apply = function(dep, source, outputOptions, requestShortener, dependencyTemplates) {
		var d = dep.dep;
		var template = dependencyTemplates.get(d.Class);
		if(!template) throw new Error("No template for dependency: " + d.Class.name);
		if(!template.applyAsTemplateArgument) throw new Error("Template cannot be applied as TemplateArgument: " + d.Class.name);
		return template.applyAsTemplateArgument(dep.name, d, source, outputOptions, requestShortener, dependencyTemplates);
	};


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var DependenciesBlock = __webpack_require__(189);
	
	function AsyncDependenciesBlock(name, module, loc) {
		DependenciesBlock.call(this);
		this.chunkName = name;
		this.chunks = null;
		this.module = module;
		this.loc = loc;
	
		Object.defineProperty(this, "chunk", {
			get: function() {
				throw new Error("`chunk` was been renamed to `chunks` and is now an array");
			},
			set: function() {
				throw new Error("`chunk` was been renamed to `chunks` and is now an array");
			}
		});
	
	}
	module.exports = AsyncDependenciesBlock;
	
	AsyncDependenciesBlock.prototype = Object.create(DependenciesBlock.prototype);
	
	AsyncDependenciesBlock.prototype.updateHash = function updateHash(hash) {
		hash.update(this.chunkName || "");
		hash.update(this.chunks && this.chunks.map(function(chunk) {
			return typeof chunk.id === "number" ? chunk.id : "";
		}).join(",") || "");
		DependenciesBlock.prototype.updateHash.call(this, hash);
	};
	
	AsyncDependenciesBlock.prototype.disconnect = function() {
		this.chunks = null;
		DependenciesBlock.prototype.disconnect.call(this);
	};


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Module = __webpack_require__(188);
	var OriginalSource = __webpack_require__(222);
	var RawSource = __webpack_require__(213);
	
	function RawModule(source, identifier, readableIdentifier) {
		Module.call(this);
		this.sourceStr = source;
		this.identifierStr = identifier || this.sourceStr;
		this.readableIdentifierStr = readableIdentifier || this.identifierStr;
		this.cacheable = true;
		this.built = false;
	}
	module.exports = RawModule;
	
	RawModule.prototype = Object.create(Module.prototype);
	
	RawModule.prototype.identifier = function() {
		return this.identifierStr;
	};
	
	RawModule.prototype.readableIdentifier = function(requestShortener) {
		return requestShortener.shorten(this.readableIdentifierStr);
	};
	
	RawModule.prototype.needRebuild = function() {
		return false;
	};
	
	RawModule.prototype.build = function(options, compilation, resolver, fs, callback) {
		this.builtTime = new Date().getTime();
		callback();
	};
	
	RawModule.prototype.source = function() {
		if(this.useSourceMap)
			return new OriginalSource(this.sourceStr, this.identifier());
		else
			return new RawSource(this.sourceStr);
	};
	
	RawModule.prototype.size = function() {
		return this.sourceStr.length;
	};
	
	RawModule.prototype.getSourceHash = function() {
		var hash = __webpack_require__(231).createHash("md5");
		hash.update(this.sourceStr);
		return hash.digest("hex");
	};
	
	RawModule.prototype.getAllModuleDependencies = function() {
		return [];
	};
	
	RawModule.prototype.createTemplate = function() {
		return new RawModule(this.sourceStr, "template of " + this.id);
	};
	
	RawModule.prototype.getTemplateArguments = function() {
		return [];
	};


/***/ },
/* 268 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function LoadersList(list) {
		this.list = list || [];
		this.list.forEach(function(element) {
			if(element === null || typeof element !== "object")
				throw new Error("Each element of the loaders list must be an object or array");
		});
	}
	module.exports = LoadersList;
	
	function regExpAsMatcher(regExp) {
		return function(str) {
			return regExp.test(str);
		}
	}
	
	function asMatcher(test) {
		if(typeof test === "string") {
			return regExpAsMatcher(new RegExp("^"+test.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")));
		} else if(typeof test === "function") {
			return test;
		} else if(test instanceof RegExp) {
			return regExpAsMatcher(test);
		} else if(Array.isArray(test)) {
			var matchers = test.map(function(item) {
				if(Array.isArray(item)) {
					var matchers = item.map(asMatcher);
					return function(str) {
						return matchers.every(function(matcher) {
							return matcher(str);
						});
					};
				} else {
					return asMatcher(item);
				}
			});
			return function(str) {
				for(var i = 0; i < test.length; i++) {
					if(matchers[i](str))
						return true;
				}
				return false;
			};
		} else {
			throw new Error(test + " is not a valid test");
		}
	}
	
	function getLoadersFromObject(element) {
		if(element.query) {
			if(!element.loader || element.loader.indexOf("!") >= 0) throw new Error("Cannot define 'query' and multiple loaders in loaders list");
			if(typeof element.query === "string") return [element.loader + "?" + element.query];
			return [element.loader + "?" + JSON.stringify(element.query)];
		}
		if(element.loader) return element.loader.split("!");
		if(element.loaders) return element.loaders;
		throw new Error("Element from loaders list should have one of the fields 'loader' or 'loaders'");
	}
	
	LoadersList.prototype.matchPart = function matchPart(str, test) {
		if(!test) return true;
		var matcher = asMatcher(test);
		return matcher(str);
	};
	
	LoadersList.prototype.match = function match(str) {
		return this.list.map(function(element) {
			if(Array.isArray(element)) {
				for(var i = 0; i < element.length; i++) {
					if(this.matchObject(str, element[i]))
						return getLoadersFromObject(element[i]);
				}
			} else {
				if(this.matchObject(str, element))
					return getLoadersFromObject(element);
			}
		}, this).filter(Boolean).reduce(function(array, r) {
			r.forEach(function(r) {
				array.push(r);
			});
			return array;
		}, []) || [];
	};
	
	LoadersList.prototype.matchObject = function matchObject(str, obj) {
		if(obj.test)
			if(!this.matchPart(str, obj.test)) return false;
		if(obj.include)
			if(!this.matchPart(str, obj.include)) return false;
		if(obj.exclude)
			if(this.matchPart(str, obj.exclude)) return false;
		return true;
	};

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var async = __webpack_require__(183);
	var path = __webpack_require__(180);
	
	var Tapable = __webpack_require__(181);
	var ContextModule = __webpack_require__(270);
	var ContextElementDependency = __webpack_require__(271);
	
	function ContextModuleFactory(resolvers) {
		Tapable.call(this);
		this.resolvers = resolvers;
	}
	module.exports = ContextModuleFactory;
	
	ContextModuleFactory.prototype = Object.create(Tapable.prototype);
	ContextModuleFactory.prototype.constructor = ContextModuleFactory;
	
	ContextModuleFactory.prototype.create = function(context, dependency, callback) {
		this.applyPluginsAsyncWaterfall("before-resolve", {
			context: context,
			request: dependency.request,
			recursive: dependency.recursive,
			regExp: dependency.regExp
		}, function(err, result) {
			if(err) return callback(err);
	
			// Ignored
			if(!result) return callback();
	
			var context = result.context;
			var request = result.request;
			var recursive = result.recursive;
			var regExp = result.regExp;
	
			var loaders, resource, loadersPrefix = "";
			var idx = request.lastIndexOf("!");
			if(idx >= 0) {
				loaders = request.substr(0, idx + 1);
				for(var i = 0; i < loaders.length && loaders[i] === "!"; i++) {
					loadersPrefix += "!";
				}
				loaders = loaders.substr(i).replace(/!+$/, "").replace(/!!+/g, "!");
				if(loaders === "") loaders = [];
				else loaders = loaders.split("!");
				resource = request.substr(idx + 1);
			} else {
				loaders = [];
				resource = request;
			}
	
			async.parallel([
				this.resolvers.context.resolve.bind(this.resolvers.context, context, resource),
				async.map.bind(async, loaders, this.resolvers.loader.resolve.bind(this.resolvers.loader, context))
			], function(err, result) {
				if(err) return callback(err);
	
				this.applyPluginsAsyncWaterfall("after-resolve", {
					loaders: loadersPrefix + result[1].join("!") + (result[1].length > 0 ? "!" : ""),
					resource: result[0],
					recursive: recursive,
					regExp: regExp
				}, function(err, result) {
					if(err) return callback(err);
	
					// Ignored
					if(!result) return callback();
	
					return callback(null, new ContextModule(this.resolveDependencies.bind(this), result.resource, result.recursive, result.regExp, result.loaders));
				}.bind(this));
			}.bind(this));
		}.bind(this));
	};
	
	ContextModuleFactory.prototype.resolveDependencies = function resolveDependencies(fs, resource, recursive, regExp, callback) {
		(function addDirectory(directory, callback) {
			fs.readdir(directory, function(err, files) {
				if(err) return callback(err);
				if(!files || files.length === 0) return callback(null, []);
				async.map(files.filter(function(p) {
					return p.indexOf(".") !== 0;
				}), function(seqment, callback) {
	
					var subResource = path.join(directory, seqment);
	
					fs.stat(subResource, function(err, stat) {
						if(err) return callback(err);
	
						if(stat.isDirectory()) {
	
							if(!recursive) return callback();
							addDirectory.call(this, subResource, callback);
	
						} else if(stat.isFile()) {
	
							var obj = {
								context: resource,
								request: "." + subResource.substr(resource.length).replace(/\\/g, "/")
							};
							this.applyPluginsAsyncWaterfall("alternatives", [obj], function(err, alternatives) {
								if(err) return callback(err);
								alternatives = alternatives.filter(function(obj) {
									return regExp.test(obj.request);
								}).map(function(obj) {
									var dep = new ContextElementDependency(obj.request);
									dep.optional = true;
									return dep;
								});
								callback(null, alternatives);
							});
	
						} else callback();
	
					}.bind(this));
	
				}.bind(this), function(err, result) {
					if(err) return callback(err);
	
					if(!result) return callback(null, []);
	
					callback(null, result.filter(function(i) {
						return !!i;
					}).reduce(function(a, i) {
						return a.concat(i);
					}, []));
				});
			}.bind(this));
		}.call(this, resource, callback));
	};


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Module = __webpack_require__(188);
	var OriginalSource = __webpack_require__(222);
	var RawSource = __webpack_require__(213);
	
	function ContextModule(resolveDependencies, context, recursive, regExp, addon) {
		Module.call(this);
		this.resolveDependencies = resolveDependencies;
		this.context = context;
		this.recursive = recursive;
		this.regExp = regExp;
		this.addon = addon;
		this.cacheable = true;
		this.contextDependencies = [context];
		this.built = false;
	}
	module.exports = ContextModule;
	
	ContextModule.prototype = Object.create(Module.prototype);
	
	ContextModule.prototype.identifier = function() {
		var identifier = "";
		identifier += this.context + " ";
		if(!this.recursive)
			identifier += "nonrecursive ";
		if(this.addon)
			identifier += this.addon;
		if(this.regExp)
			identifier += this.regExp;
		return identifier.replace(/ $/, "");
	};
	
	function prettyRegExp(str) {
		return str.substring(1, str.length - 1);
	}
	
	ContextModule.prototype.readableIdentifier = function(requestShortener) {
		var identifier = "";
		identifier += requestShortener.shorten(this.context) + " ";
		if(!this.recursive)
			identifier += "nonrecursive ";
		if(this.addon)
			identifier += requestShortener.shorten(this.addon);
		if(this.regExp)
			identifier += prettyRegExp(this.regExp + "");
		return identifier.replace(/ $/, "");
	};
	
	ContextModule.prototype.needRebuild = function(fileTimestamps, contextTimestamps) {
		var ts = contextTimestamps[this.context];
		if(!ts) return true;
		return ts >= this.builtTime;
	};
	
	ContextModule.prototype.disconnect = function disconnect() {
		this.built = false;
		Module.prototype.disconnect.call(this);
	};
	
	ContextModule.prototype.build = function(options, compilation, resolver, fs, callback) {
		this.built = true;
		this.builtTime = new Date().getTime();
		var addon = this.addon;
		this.resolveDependencies(fs, this.context, this.recursive, this.regExp, function(err, dependencies) {
			if(err) return callback(err);
			if(dependencies) {
				dependencies.forEach(function(dep) {
					dep.loc = dep.userRequest;
					dep.userRequest = dep.request;
					dep.request = addon + dep.userRequest;
				});
			}
			this.dependencies = dependencies;
			callback();
		}.bind(this));
	};
	
	ContextModule.prototype.source = function() {
		var str;
		if(this.dependencies && this.dependencies.length > 0) {
			var map = {};
			this.dependencies.slice().sort(function(a, b) {
				if(a.userRequest === b.userRequest) return 0;
				return a.userRequest < b.userRequest ? -1 : 1;
			}).forEach(function(dep) {
				if(dep.module)
					map[dep.userRequest] = dep.module.id;
			});
			str = [
				"var map = ", JSON.stringify(map, null, "\t"), ";\n",
				"function webpackContext(req) {\n",
				"\treturn __webpack_require__(webpackContextResolve(req));\n",
				"};\n",
				"function webpackContextResolve(req) {\n",
				"\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n",
				"};\n",
				"webpackContext.keys = function webpackContextKeys() {\n",
				"\treturn Object.keys(map);\n",
				"};\n",
				"webpackContext.resolve = webpackContextResolve;\n",
				"module.exports = webpackContext;\n",
				"webpackContext.id = " + this.id + ";\n"
			];
		} else {
			str = [
				"function webpackContext(req) {\n",
				"\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n",
				"}\n",
				"webpackContext.keys = function() { return []; };\n",
				"webpackContext.resolve = webpackContext;\n",
				"module.exports = webpackContext;\n",
				"webpackContext.id = " + this.id + ";\n"
			];
		}
		if(this.useSourceMap) {
			return new OriginalSource(str.join(""), this.identifier());
		} else {
			return new RawSource(str.join(""));
		}
	};
	
	ContextModule.prototype.size = function() {
		return this.dependencies.map(function(dep) {
			return dep.userRequest.length + 5;
		}).reduce(function(a, b) {
			return a + b;
		}, 160);
	};


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(272);
	
	function ContextElementDependency(request) {
		ModuleDependency.call(this, request);
		this.Class = ContextElementDependency;
	}
	module.exports = ContextElementDependency;
	
	ContextElementDependency.prototype = Object.create(ModuleDependency.prototype);
	ContextElementDependency.prototype.constructor = ContextElementDependency;
	ContextElementDependency.prototype.type = "context element";


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Dependency = __webpack_require__(228);
	
	function ModuleDependency(request) {
		Dependency.call(this);
		this.request = request;
		this.userRequest = request;
		this.Class = ModuleDependency;
	}
	module.exports = ModuleDependency;
	
	ModuleDependency.prototype = Object.create(Dependency.prototype);
	ModuleDependency.prototype.constructor = ModuleDependency;
	ModuleDependency.prototype.isEqualResource = function isEqualResource(other) {
		if(!(other instanceof ModuleDependency))
			return false;
		return this.request === other.request;
	};


/***/ },
/* 273 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function WebEnvironmentPlugin(inputFileSystem, outputFileSystem) {
		this.inputFileSystem = inputFileSystem;
		this.outputFileSystem = outputFileSystem;
	}
	module.exports = WebEnvironmentPlugin;
	WebEnvironmentPlugin.prototype.apply = function(compiler) {
		var inputFileSystem = compiler.inputFileSystem = this.inputFileSystem;
		compiler.resolvers.normal.fileSystem = inputFileSystem;
		compiler.resolvers.context.fileSystem = inputFileSystem;
		compiler.resolvers.loader.fileSystem = inputFileSystem;
		compiler.outputFileSystem = this.outputFileSystem;
	};


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var OptionsApply = __webpack_require__(275);
	
	var LoaderTargetPlugin = __webpack_require__(276);
	var FunctionModulePlugin = __webpack_require__(277);
	var EvalDevToolModulePlugin = __webpack_require__(279);
	var SourceMapDevToolPlugin = __webpack_require__(282);
	var EvalSourceMapDevToolPlugin = __webpack_require__(284);
	
	var EntryOptionPlugin = __webpack_require__(286);
	var RecordIdsPlugin = __webpack_require__(293);
	
	var APIPlugin = __webpack_require__(294);
	var ConstPlugin = __webpack_require__(298);
	var RequireJsStuffPlugin = __webpack_require__(299);
	var NodeStuffPlugin = __webpack_require__(300);
	var CompatibilityPlugin = __webpack_require__(303);
	var DefinePlugin = __webpack_require__(305);
	
	var MovedToPluginWarningPlugin = __webpack_require__(306);
	var TemplatedPathPlugin = __webpack_require__(307);
	var WarnCaseSensitiveModulesPlugin = __webpack_require__(308);
	
	var LoaderPlugin = __webpack_require__(310);
	var CommonJsPlugin = __webpack_require__(312);
	var AMDPlugin = __webpack_require__(330);
	var RequireContextPlugin = __webpack_require__(341);
	var RequireEnsurePlugin = __webpack_require__(345);
	var RequireIncludePlugin = __webpack_require__(352);
	
	var RemoveParentModulesPlugin = __webpack_require__(355);
	var RemoveEmptyChunksPlugin = __webpack_require__(356);
	var MergeDuplicateChunksPlugin = __webpack_require__(357);
	var FlagIncludedChunksPlugin = __webpack_require__(358);
	
	var UnsafeCachePlugin = __webpack_require__(359);
	var ModulesInDirectoriesPlugin = __webpack_require__(360);
	var ModulesInRootPlugin = __webpack_require__(362);
	var ModuleTemplatesPlugin = __webpack_require__(363);
	var ModuleAsFilePlugin = __webpack_require__(364);
	var ModuleAsDirectoryPlugin = __webpack_require__(365);
	var ModuleAliasPlugin = __webpack_require__(304);
	var DirectoryDefaultFilePlugin = __webpack_require__(366);
	var DirectoryDescriptionFilePlugin = __webpack_require__(367);
	var DirectoryDescriptionFileFieldAliasPlugin = __webpack_require__(368);
	var FileAppendPlugin = __webpack_require__(369);
	var DirectoryResultPlugin = __webpack_require__(370);
	var ResultSymlinkPlugin = __webpack_require__(371);
	
	function WebpackOptionsApply() {
		OptionsApply.call(this);
	}
	module.exports = WebpackOptionsApply;
	
	WebpackOptionsApply.prototype = Object.create(OptionsApply.prototype);
	WebpackOptionsApply.prototype.process = function(options, compiler) {
		compiler.context = options.context;
		if(options.plugins && Array.isArray(options.plugins)) {
			compiler.apply.apply(compiler, options.plugins);
		}
		compiler.outputPath = options.output.path;
		compiler.recordsInputPath = options.recordsInputPath || options.recordsPath;
		compiler.recordsOutputPath = options.recordsOutputPath || options.recordsPath;
		compiler.name = options.name;
		if(typeof options.target === "string") {
			switch(options.target) {
				case "web":
					var JsonpTemplatePlugin = __webpack_require__(372);
					var NodeSourcePlugin = __webpack_require__(377);
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeSourcePlugin(options.node),
						new LoaderTargetPlugin("web")
					);
					break;
				case "webworker":
					var WebWorkerTemplatePlugin = __webpack_require__(389);
					var NodeSourcePlugin = __webpack_require__(377);
					compiler.apply(
						new WebWorkerTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeSourcePlugin(options.node),
						new LoaderTargetPlugin("webworker")
					);
					break;
				case "node":
				case "async-node":
					var NodeTemplatePlugin = __webpack_require__(392);
					var NodeTargetPlugin = __webpack_require__(516);
					compiler.apply(
						new NodeTemplatePlugin(options.output, options.target === "async-node"),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new LoaderTargetPlugin("node")
					);
					break;
				case "node-webkit":
					var JsonpTemplatePlugin = __webpack_require__(372);
					var NodeTargetPlugin = __webpack_require__(516);
					var ExternalsPlugin = __webpack_require__(517);
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", "nw.gui"),
						new LoaderTargetPlugin("node-webkit")
					);
					break;
				case "atom":
				case "electron":
					var NodeTemplatePlugin = __webpack_require__(392);
					var NodeTargetPlugin = __webpack_require__(516);
					var ExternalsPlugin = __webpack_require__(517);
					compiler.apply(
						new NodeTemplatePlugin(options.output, true),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", [
							"app",
							"auto-updater",
							"browser-window",
							"content-tracing",
							"dialog",
							"global-shortcut",
							"ipc",
							"menu",
							"menu-item",
							"power-monitor",
							"protocol",
							"tray",
							"remote",
							"web-view",
							"clipboard",
							"crash-reporter",
							"screen",
							"shell"
						]),
						new LoaderTargetPlugin(options.target)
					);
					break;
				default:
					throw new Error("Unsupported target '" + options.target + "'.");
			}
		} else if(options.target !== false) {
			options.target(compiler);
		} else {
			throw new Error("Unsupported target '" + options.target + "'.");
		}
		if(options.output.library || options.output.libraryTarget !== "var") {
			var LibraryTemplatePlugin = __webpack_require__(521);
			compiler.apply(new LibraryTemplatePlugin(options.output.library, options.output.libraryTarget, options.output.umdNamedDefine));
		}
		if(options.externals) {
			var ExternalsPlugin = __webpack_require__(517);
			compiler.apply(new ExternalsPlugin(options.output.libraryTarget, options.externals));
		}
	
		if(options.hot) {
			compiler.apply(new MovedToPluginWarningPlugin("hot", "HotModuleReplacementPlugin"));
			var HotModuleReplacementPlugin = __webpack_require__(526);
			compiler.apply(new HotModuleReplacementPlugin(options.output));
		}
	
		if(options.devtool && (options.devtool.indexOf("sourcemap") >= 0 || options.devtool.indexOf("source-map") >= 0)) {
			var hidden = options.devtool.indexOf("hidden") >= 0;
			var inline = options.devtool.indexOf("inline") >= 0;
			var evalWrapped = options.devtool.indexOf("eval") >= 0;
			var cheap = options.devtool.indexOf("cheap") >= 0;
			var moduleMaps = options.devtool.indexOf("module") >= 0;
			var legacy = options.devtool.indexOf("@") >= 0;
			var modern = options.devtool.indexOf("#") >= 0;
			var comment = legacy && modern ? "\n/*\n//@ sourceMappingURL=[url]\n//# sourceMappingURL=[url]\n*/" :
				legacy ? "\n/*\n//@ sourceMappingURL=[url]\n*/" :
				modern ? "\n//# sourceMappingURL=[url]" :
				null;
			var Plugin = evalWrapped ? EvalSourceMapDevToolPlugin : SourceMapDevToolPlugin;
			compiler.apply(new Plugin({
				filename: inline ? null : options.output.sourceMapFilename,
				moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
				fallbackModuleFilenameTemplate: options.output.devtoolFallbackModuleFilenameTemplate,
				append: hidden ? false : comment,
				module: moduleMaps ? true : cheap ? false : true,
				columns: cheap ? false : true,
				lineToLine: options.output.devtoolLineToLine
			}));
		} else if(options.devtool && options.devtool.indexOf("eval") >= 0) {
			var legacy = options.devtool.indexOf("@") >= 0;
			var modern = options.devtool.indexOf("#") >= 0;
			var comment = legacy && modern ? "//@ sourceURL=[url]\n//# sourceURL=[url]" :
				legacy ? "//@ sourceURL=[url]" :
				modern ? "//# sourceURL=[url]" :
				null;
			compiler.apply(new EvalDevToolModulePlugin(comment, options.output.devtoolModuleFilenameTemplate));
		}
	
		compiler.apply(new EntryOptionPlugin());
		compiler.applyPluginsBailResult("entry-option", options.context, options.entry);
	
		if(options.prefetch) {
			compiler.apply(new MovedToPluginWarningPlugin("prefetch", "PrefetchPlugin"));
			var PrefetchPlugin = __webpack_require__(530);
			options.prefetch.map(function(request) {
				compiler.apply(new PrefetchPlugin(options.context, request));
			});
		}
		compiler.apply(
			new CompatibilityPlugin(),
			new LoaderPlugin(),
			new NodeStuffPlugin(options.node),
			new RequireJsStuffPlugin(),
			new APIPlugin(),
			new ConstPlugin(),
			new RequireIncludePlugin(),
			new RequireEnsurePlugin(),
			new RequireContextPlugin(options.resolve.modulesDirectories, options.resolve.extensions),
			new AMDPlugin(options.module, options.amd || {}),
			new CommonJsPlugin(options.module)
		);
	
		compiler.apply(
			new RemoveParentModulesPlugin(),
			new RemoveEmptyChunksPlugin(),
			new MergeDuplicateChunksPlugin(),
			new FlagIncludedChunksPlugin()
		);
	
		compiler.apply(new TemplatedPathPlugin());
	
		compiler.apply(new RecordIdsPlugin());
	
		compiler.apply(new WarnCaseSensitiveModulesPlugin());
	
		if(options.optimize && options.optimize.occurenceOrder) {
			compiler.apply(new MovedToPluginWarningPlugin("optimize.occurenceOrder", "optimize.OccurrenceOrderPlugin"));
			var OccurrenceOrderPlugin = __webpack_require__(532);
			compiler.apply(new OccurrenceOrderPlugin(options.optimize.occurenceOrderPreferEntry));
		}
	
		if(options.optimize && options.optimize.minChunkSize) {
			compiler.apply(new MovedToPluginWarningPlugin("optimize.minChunkSize", "optimize.MinChunkSizePlugin"));
			var MinChunkSizePlugin = __webpack_require__(533);
			compiler.apply(new MinChunkSizePlugin(options.optimize));
		}
	
		if(options.optimize && options.optimize.maxChunks) {
			compiler.apply(new MovedToPluginWarningPlugin("optimize.maxChunks", "optimize.LimitChunkCountPlugin"));
			var LimitChunkCountPlugin = __webpack_require__(534);
			compiler.apply(new LimitChunkCountPlugin(options.optimize));
		}
	
		if(options.optimize.minimize) {
			compiler.apply(new MovedToPluginWarningPlugin("optimize.minimize", "optimize.UglifyJsPlugin"));
			var UglifyJsPlugin = __webpack_require__(535);
			if(options.optimize.minimize === true)
				compiler.apply(new UglifyJsPlugin());
			else
				compiler.apply(new UglifyJsPlugin(options.optimize.minimize));
		}
	
		if(options.cache === undefined ? options.watch : options.cache) {
			var CachePlugin = __webpack_require__(547);
			compiler.apply(new CachePlugin(typeof options.cache === "object" ? options.cache : null));
		}
	
		if(typeof options.provide === "object") {
			compiler.apply(new MovedToPluginWarningPlugin("provide", "ProvidePlugin"));
			var ProvidePlugin = __webpack_require__(548);
			compiler.apply(new ProvidePlugin(options.provide));
		}
	
		if(options.define) {
			compiler.apply(new MovedToPluginWarningPlugin("define", "DefinePlugin"));
			var defineObject = {};
			if(typeof options.define === "object") {
				Object.keys(options.define).forEach(function(key) {
					defineObject[key] = options.define[key];
				});
			}
			compiler.apply(new DefinePlugin(defineObject));
		}
		if(options.defineDebug !== false)
			compiler.apply(new DefinePlugin({
				DEBUG: !!options.debug
			}));
	
		compiler.applyPlugins("after-plugins", compiler);
		compiler.resolvers.normal.apply(
			new UnsafeCachePlugin(options.resolve.unsafeCache),
			options.resolve.packageAlias ? new DirectoryDescriptionFileFieldAliasPlugin("package.json", options.resolve.packageAlias) : function() {},
			new ModuleAliasPlugin(options.resolve.alias),
			makeRootPlugin("module", options.resolve.root),
			new ModulesInDirectoriesPlugin("module", options.resolve.modulesDirectories),
			makeRootPlugin("module", options.resolve.fallback),
			new ModuleAsFilePlugin("module"),
			new ModuleAsDirectoryPlugin("module"),
			new DirectoryDescriptionFilePlugin("package.json", options.resolve.packageMains),
			new DirectoryDefaultFilePlugin(["index"]),
			new FileAppendPlugin(options.resolve.extensions),
			new ResultSymlinkPlugin()
		);
		compiler.resolvers.context.apply(
			new UnsafeCachePlugin(options.resolve.unsafeCache),
			new ModuleAliasPlugin(options.resolve.alias),
			makeRootPlugin("module", options.resolve.root),
			new ModulesInDirectoriesPlugin("module", options.resolve.modulesDirectories),
			makeRootPlugin("module", options.resolve.fallback),
			new ModuleAsFilePlugin("module"),
			new ModuleAsDirectoryPlugin("module"),
			new DirectoryResultPlugin(),
			new ResultSymlinkPlugin()
		);
		compiler.resolvers.loader.apply(
			new UnsafeCachePlugin(options.resolve.unsafeCache),
			new ModuleAliasPlugin(options.resolveLoader.alias),
			makeRootPlugin("loader-module", options.resolveLoader.root),
			new ModulesInDirectoriesPlugin("loader-module", options.resolveLoader.modulesDirectories),
			makeRootPlugin("loader-module", options.resolveLoader.fallback),
			new ModuleTemplatesPlugin("loader-module", options.resolveLoader.moduleTemplates, "module"),
			new ModuleAsFilePlugin("module"),
			new ModuleAsDirectoryPlugin("module"),
			new DirectoryDescriptionFilePlugin("package.json", options.resolveLoader.packageMains),
			new DirectoryDefaultFilePlugin(["index"]),
			new FileAppendPlugin(options.resolveLoader.extensions),
			new ResultSymlinkPlugin()
		);
		compiler.applyPlugins("after-resolvers", compiler);
		return options;
	};
	
	function makeRootPlugin(name, root) {
		if(typeof root === "string")
			return new ModulesInRootPlugin(name, root);
		else if(Array.isArray(root)) {
			return function() {
				root.forEach(function(root) {
					this.apply(new ModulesInRootPlugin(name, root));
				}, this);
			};
		}
		return function() {};
	}


/***/ },
/* 275 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function OptionsApply() {}
	module.exports = OptionsApply;
	
	OptionsApply.prototype.process = function( /* options, compiler */ ) {
	
	};


/***/ },
/* 276 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function LoaderTargetPlugin(target) {
		this.target = target;
	}
	module.exports = LoaderTargetPlugin;
	LoaderTargetPlugin.prototype.apply = function(compiler) {
		var target = this.target;
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("normal-module-loader", function(loaderContext) {
				loaderContext.target = target;
			});
		});
	};


/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var FunctionModuleTemplatePlugin = __webpack_require__(278);
	var RequestShortener = __webpack_require__(219);
	
	function FunctionModulePlugin(options, requestShortener) {
		this.options = options;
		this.requestShortener = requestShortener;
	}
	module.exports = FunctionModulePlugin;
	FunctionModulePlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.moduleTemplate.requestShortener = this.requestShortener || new RequestShortener(compiler.context);
			compilation.moduleTemplate.apply(new FunctionModuleTemplatePlugin());
		}.bind(this));
	};


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(221);
	var PrefixSource = __webpack_require__(223);
	
	function FunctionModuleTemplatePlugin() {}
	module.exports = FunctionModuleTemplatePlugin;
	
	FunctionModuleTemplatePlugin.prototype.apply = function(moduleTemplate) {
		moduleTemplate.plugin("render", function(moduleSource, module) {
			var source = new ConcatSource();
			var defaultArguments = ["module", "exports"];
			if((module.arguments && module.arguments.length !== 0) || module.hasDependencies()) {
				defaultArguments.push("__webpack_require__");
			}
			source.add("/***/ function(" + defaultArguments.concat(module.arguments || []).join(", ") + ") {\n\n");
			source.add(new PrefixSource(this.outputOptions.sourcePrefix, moduleSource));
			source.add("\n\n/***/ }");
			return source;
		});
		moduleTemplate.plugin("package", function(moduleSource, module) {
			if(this.outputOptions.pathinfo) {
				var source = new ConcatSource();
				var req = module.readableIdentifier(this.requestShortener);
				source.add("/*!****" + req.replace(/./g, "*") + "****!*\\\n");
				source.add("  !*** " + req.replace(/\*\//g, "*_/") + " ***!\n");
				source.add("  \\****" + req.replace(/./g, "*") + "****/\n");
				source.add(moduleSource);
				return source;
			}
			return moduleSource;
		});
		moduleTemplate.plugin("hash", function(hash) {
			hash.update("FunctionModuleTemplatePlugin");
			hash.update("2");
		});
	};


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var EvalDevToolModuleTemplatePlugin = __webpack_require__(280);
	
	function EvalDevToolModulePlugin(sourceUrlComment, moduleFilenameTemplate) {
		this.sourceUrlComment = sourceUrlComment;
		this.moduleFilenameTemplate = moduleFilenameTemplate;
	}
	module.exports = EvalDevToolModulePlugin;
	EvalDevToolModulePlugin.prototype.apply = function(compiler) {
		var self = this;
		compiler.plugin("compilation", function(compilation) {
			compilation.moduleTemplate.apply(new EvalDevToolModuleTemplatePlugin(self.sourceUrlComment, self.moduleFilenameTemplate));
		});
	};


/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RawSource = __webpack_require__(213);
	var ModuleFilenameHelpers = __webpack_require__(281);
	
	function EvalDevToolModuleTemplatePlugin(sourceUrlComment, moduleFilenameTemplate) {
		this.sourceUrlComment = sourceUrlComment || "//# sourceURL=[url]";
		this.moduleFilenameTemplate = moduleFilenameTemplate || "webpack:///[resourcePath]?[loaders]";
	}
	module.exports = EvalDevToolModuleTemplatePlugin;
	
	EvalDevToolModuleTemplatePlugin.prototype.apply = function(moduleTemplate) {
		var self = this;
		moduleTemplate.plugin("module", function(source, module) {
			var content = source.source();
			var str = ModuleFilenameHelpers.createFilename(module, self.moduleFilenameTemplate, this.requestShortener);
			var footer = ["\n",
				ModuleFilenameHelpers.createFooter(module, this.requestShortener),
				self.sourceUrlComment.replace(/\[url\]/g, encodeURI(str).replace(/%2F/g, "/").replace(/%20/g, "_").replace(/%5E/g, "^").replace(/%5C/g, "\\").replace(/^\//, ""))
			].join("\n");
			return new RawSource("eval(" + JSON.stringify(content + footer) + ");");
		});
		moduleTemplate.plugin("hash", function(hash) {
			hash.update("EvalDevToolModuleTemplatePlugin");
			hash.update("2");
		});
	};


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleFilenameHelpers = exports;
	
	ModuleFilenameHelpers.ALL_LOADERS_RESOURCE = "[all-loaders][resource]";
	ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE = /\[all-?loaders\]\[resource\]/gi;
	ModuleFilenameHelpers.LOADERS_RESOURCE = "[loaders][resource]";
	ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE = /\[loaders\]\[resource\]/gi;
	ModuleFilenameHelpers.RESOURCE = "[resource]";
	ModuleFilenameHelpers.REGEXP_RESOURCE = /\[resource\]/gi;
	ModuleFilenameHelpers.ABSOLUTE_RESOURCE_PATH = "[absolute-resource-path]";
	ModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH = /\[abs(olute)?-?resource-?path\]/gi;
	ModuleFilenameHelpers.RESOURCE_PATH = "[resource-path]";
	ModuleFilenameHelpers.REGEXP_RESOURCE_PATH = /\[resource-?path\]/gi;
	ModuleFilenameHelpers.ALL_LOADERS = "[all-loaders]";
	ModuleFilenameHelpers.REGEXP_ALL_LOADERS = /\[all-?loaders\]/gi;
	ModuleFilenameHelpers.LOADERS = "[loaders]";
	ModuleFilenameHelpers.REGEXP_LOADERS = /\[loaders\]/gi;
	ModuleFilenameHelpers.QUERY = "[query]";
	ModuleFilenameHelpers.REGEXP_QUERY = /\[query\]/gi;
	ModuleFilenameHelpers.ID = "[id]";
	ModuleFilenameHelpers.REGEXP_ID = /\[id\]/gi;
	ModuleFilenameHelpers.HASH = "[hash]";
	ModuleFilenameHelpers.REGEXP_HASH = /\[hash\]/gi;
	
	function getAfter(str, token) {
		var idx = str.indexOf(token);
		return idx < 0 ? "" : str.substr(idx);
	}
	
	function getBefore(str, token) {
		var idx = str.lastIndexOf(token);
		return idx < 0 ? "" : str.substr(0, idx);
	}
	
	function getHash(str) {
		var hash = __webpack_require__(231).createHash("md5");
		hash.update(str);
		return hash.digest("hex").substr(0, 4);
	}
	
	function asRegExp(test) {
		if(typeof test === "string") test = new RegExp("^" + test.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"));
		return test;
	}
	
	ModuleFilenameHelpers.createFilename = function createFilename(module, moduleFilenameTemplate, requestShortener) {
		if(!module) module = "";
		if(typeof module === "string") {
			var shortIdentifier = requestShortener.shorten(module);
			var identifier = shortIdentifier;
			var moduleId = "";
			var absoluteResourcePath = module.split("!").pop();
			var hash = getHash(identifier);
		} else {
			var shortIdentifier = module.readableIdentifier(requestShortener);
			var identifier = requestShortener.shorten(module.identifier());
			var moduleId = module.id;
			var absoluteResourcePath = module.resourcePath || module.identifier().split("!").pop();
			var hash = getHash(identifier);
		}
		var resource = shortIdentifier.split("!").pop();
		var loaders = getBefore(shortIdentifier, "!");
		var allLoaders = getBefore(identifier, "!");
		var query = getAfter(resource, "?");
		var resourcePath = resource.substr(0, resource.length - query.length);
		if(typeof moduleFilenameTemplate === "function") {
			return moduleFilenameTemplate({
				identifier: identifier,
				shortIdentifier: shortIdentifier,
				resource: resource,
				resourcePath: resourcePath,
				absoluteResourcePath: absoluteResourcePath,
				allLoaders: allLoaders,
				query: query,
				moduleId: moduleId,
				hash: hash
			});
		}
		return moduleFilenameTemplate
			.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE, identifier)
			.replace(ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE, shortIdentifier)
			.replace(ModuleFilenameHelpers.REGEXP_RESOURCE, resource)
			.replace(ModuleFilenameHelpers.REGEXP_RESOURCE_PATH, resourcePath)
			.replace(ModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH, absoluteResourcePath)
			.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS, allLoaders)
			.replace(ModuleFilenameHelpers.REGEXP_LOADERS, loaders)
			.replace(ModuleFilenameHelpers.REGEXP_QUERY, query)
			.replace(ModuleFilenameHelpers.REGEXP_ID, moduleId)
			.replace(ModuleFilenameHelpers.REGEXP_HASH, hash);
	};
	
	ModuleFilenameHelpers.createFooter = function createFooter(module, requestShortener) {
		if(typeof module === "string") {
			return [
				"/** WEBPACK FOOTER **",
				" ** " + requestShortener.shorten(module),
				" **/"
			].join("\n");
		} else {
			return [
				"/*****************",
				" ** WEBPACK FOOTER",
				" ** " + module.readableIdentifier(requestShortener),
				" ** module id = " + module.id,
				" ** module chunks = " + module.chunks.map(function(c) {
					return c.id;
				}).join(" "),
				" **/"
			].join("\n");
		}
	};
	
	ModuleFilenameHelpers.replaceDuplicates = function replaceDuplicates(array, fn, comparator) {
		var countMap = {};
		var posMap = {};
		array.forEach(function(item, idx) {
			countMap[item] = (countMap[item] || []);
			countMap[item].push(idx);
			posMap[item] = 0;
		});
		if(comparator) {
			Object.keys(countMap).forEach(function(item) {
				countMap[item].sort(comparator);
			});
		}
		return array.map(function(item, i) {
			if(countMap[item].length > 1) {
				if(comparator && countMap[item][0] === i)
					return item;
				return fn(item, i, posMap[item]++);
			} else return item;
		});
	};
	
	ModuleFilenameHelpers.matchPart = function matchPart(str, test) {
		if(!test) return true;
		test = asRegExp(test);
		if(Array.isArray(test)) {
			return test.map(asRegExp).filter(function(regExp) {
				return regExp.test(str);
			}).length > 0;
		} else {
			return test.test(str);
		}
	};
	
	ModuleFilenameHelpers.matchObject = function matchObject(obj, str) {
		if(obj.test)
			if(!ModuleFilenameHelpers.matchPart(str, obj.test)) return false;
		if(obj.include)
			if(!ModuleFilenameHelpers.matchPart(str, obj.include)) return false;
		if(obj.exclude)
			if(ModuleFilenameHelpers.matchPart(str, obj.exclude)) return false;
		return true;
	};


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(180);
	var RequestShortener = __webpack_require__(219);
	var ConcatSource = __webpack_require__(221);
	var RawSource = __webpack_require__(213);
	var ModuleFilenameHelpers = __webpack_require__(281);
	var SourceMapDevToolModuleOptionsPlugin = __webpack_require__(283);
	
	function SourceMapDevToolPlugin(options, sourceMappingURLComment, moduleFilenameTemplate, fallbackModuleFilenameTemplate) {
		if(!options || typeof options !== "object") {
			this.sourceMapFilename = options;
			this.sourceMappingURLComment = sourceMappingURLComment === false ? false : sourceMappingURLComment || "\n//# sourceMappingURL=[url]";
			this.moduleFilenameTemplate = moduleFilenameTemplate || "webpack:///[resourcePath]";
			this.fallbackModuleFilenameTemplate = fallbackModuleFilenameTemplate || "webpack:///[resourcePath]?[hash]";
			this.options = {};
		} else {
			this.sourceMapFilename = options.filename;
			this.sourceMappingURLComment = options.append === false ? false : options.append || "\n//# sourceMappingURL=[url]";
			this.moduleFilenameTemplate = options.moduleFilenameTemplate || "webpack:///[resourcePath]";
			this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || "webpack:///[resourcePath]?[hash]";
			this.options = options;
		}
	}
	module.exports = SourceMapDevToolPlugin;
	SourceMapDevToolPlugin.prototype.apply = function(compiler) {
		var sourceMapFilename = this.sourceMapFilename;
		var sourceMappingURLComment = this.sourceMappingURLComment;
		var moduleFilenameTemplate = this.moduleFilenameTemplate;
		var fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;
		var requestShortener = new RequestShortener(compiler.context);
		var options = this.options;
		options.test = options.test || /\.(js|css)($|\?)/i;
		compiler.plugin("compilation", function(compilation) {
			new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);
			compilation.plugin("after-optimize-chunk-assets", function(chunks) {
				var allModules = [];
				var allModuleFilenames = [];
				var tasks = [];
				chunks.forEach(function(chunk) {
					chunk.files.filter(ModuleFilenameHelpers.matchObject.bind(undefined, options)).map(function(file) {
						var asset = this.assets[file];
						if(asset.__SourceMapDevToolData) {
							var data = asset.__SourceMapDevToolData;
							for(var cachedFile in data) {
								this.assets[cachedFile] = data[cachedFile];
								if(cachedFile !== file)
									chunk.files.push(cachedFile);
							}
							return;
						}
						if(asset.sourceAndMap) {
							var sourceAndMap = asset.sourceAndMap(options);
							var sourceMap = sourceAndMap.map;
							var source = sourceAndMap.source;
						} else {
							var sourceMap = asset.map(options);
							var source = asset.source();
						}
						if(sourceMap) {
							return {
								chunk: chunk,
								file: file,
								asset: asset,
								source: source,
								sourceMap: sourceMap
							};
						}
					}, this).filter(Boolean).map(function(task) {
						var modules = task.sourceMap.sources.map(function(source) {
							var module = compilation.findModule(source);
							return module || source;
						});
						var moduleFilenames = modules.map(function(module) {
							return ModuleFilenameHelpers.createFilename(module, moduleFilenameTemplate, requestShortener);
						});
						task.modules = modules;
						task.moduleFilenames = moduleFilenames;
						return task;
					}, this).forEach(function(task) {
						allModules = allModules.concat(task.modules);
						allModuleFilenames = allModuleFilenames.concat(task.moduleFilenames);
						tasks.push(task);
					}, this);
				}, this);
				allModuleFilenames = ModuleFilenameHelpers.replaceDuplicates(allModuleFilenames, function(filename, i) {
					return ModuleFilenameHelpers.createFilename(allModules[i], fallbackModuleFilenameTemplate, requestShortener);
				}, function(ai, bi) {
					var a = allModules[ai];
					var b = allModules[bi];
					a = !a ? "" : typeof a === "string" ? a : a.identifier();
					b = !b ? "" : typeof b === "string" ? b : b.identifier();
					return a.length - b.length;
				});
				allModuleFilenames = ModuleFilenameHelpers.replaceDuplicates(allModuleFilenames, function(filename, i, n) {
					for(var j = 0; j < n; j++)
						filename += "*";
					return filename;
				});
				tasks.forEach(function(task) {
					task.moduleFilenames = allModuleFilenames.slice(0, task.moduleFilenames.length);
					allModuleFilenames = allModuleFilenames.slice(task.moduleFilenames.length);
				}, this);
				tasks.forEach(function(task) {
					var chunk = task.chunk;
					var file = task.file;
					var asset = task.asset;
					var sourceMap = task.sourceMap;
					var source = task.source;
					var moduleFilenames = task.moduleFilenames;
					var modules = task.modules;
					sourceMap.sources = moduleFilenames;
					if(sourceMap.sourcesContent) {
						sourceMap.sourcesContent = sourceMap.sourcesContent.map(function(content, i) {
							return content + "\n\n\n" + ModuleFilenameHelpers.createFooter(modules[i], requestShortener);
						});
					} else {
						sourceMap.sourcesContent = undefined;
					}
					sourceMap.sourceRoot = "";
					sourceMap.file = file;
					asset.__SourceMapDevToolData = {};
					var currentSourceMappingURLComment = sourceMappingURLComment;
					if(currentSourceMappingURLComment !== false && /\.css($|\?)/i.test(file)) {
						currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\n\/\/(.*)$/, "\n/*$1*/");
					}
					if(sourceMapFilename) {
						var filename = file,
							query = "";
						var idx = filename.indexOf("?");
						if(idx >= 0) {
							query = filename.substr(idx);
							filename = filename.substr(0, idx);
						}
						var sourceMapFile = this.getPath(sourceMapFilename, {
							chunk: chunk,
							filename: filename,
							query: query,
							basename: basename(filename)
						});
						var sourceMapUrl = path.relative(path.dirname(file), sourceMapFile).replace(/\\/g, "/");
						if(currentSourceMappingURLComment !== false) {
							asset.__SourceMapDevToolData[file] = this.assets[file] = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\[url\]/g, sourceMapUrl));
						}
						asset.__SourceMapDevToolData[sourceMapFile] = this.assets[sourceMapFile] = new RawSource(JSON.stringify(sourceMap));
						chunk.files.push(sourceMapFile);
					} else {
						asset.__SourceMapDevToolData[file] = this.assets[file] = new ConcatSource(new RawSource(source), currentSourceMappingURLComment
							.replace(/\[map\]/g, function() {
								return JSON.stringify(sourceMap);
							})
							.replace(/\[url\]/g, function() {
								return "data:application/json;base64," +
									new Buffer(JSON.stringify(sourceMap)).toString("base64");
							})
						);
					}
				}, this);
			});
		});
	};
	
	function basename(name) {
		if(name.indexOf("/") < 0) return name;
		return name.substr(name.lastIndexOf("/") + 1);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176).Buffer))

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleFilenameHelpers = __webpack_require__(281);
	
	function SourceMapDevToolModuleOptionsPlugin(options) {
		this.options = options;
	}
	
	module.exports = SourceMapDevToolModuleOptionsPlugin;
	
	SourceMapDevToolModuleOptionsPlugin.prototype.apply = function(compilation) {
		var options = this.options;
		if(options.module !== false) {
			compilation.plugin("build-module", function(module) {
				module.useSourceMap = true;
			});
		}
		if(options.lineToLine === true) {
			compilation.plugin("build-module", function(module) {
				module.lineToLine = true;
			});
		} else if(options.lineToLine) {
			compilation.plugin("build-module", function(module) {
				if(!module.resource) return;
				var resourcePath = module.resource;
				var idx = resourcePath.indexOf("?");
				if(idx >= 0) resourcePath = resourcePath.substr(0, idx);
				module.lineToLine = ModuleFilenameHelpers.matchObject(options.lineToLine, resourcePath);
			});
		}
	};


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var EvalSourceMapDevToolModuleTemplatePlugin = __webpack_require__(285);
	var SourceMapDevToolModuleOptionsPlugin = __webpack_require__(283);
	
	function EvalSourceMapDevToolPlugin(options, moduleFilenameTemplate) {
		if(!options || typeof options !== "object") {
			this.options = {
				append: options,
				moduleFilenameTemplate: moduleFilenameTemplate
			};
		} else {
			this.options = options;
		}
	}
	module.exports = EvalSourceMapDevToolPlugin;
	EvalSourceMapDevToolPlugin.prototype.apply = function(compiler) {
		var options = this.options;
		compiler.plugin("compilation", function(compilation) {
			new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);
			compilation.moduleTemplate.apply(new EvalSourceMapDevToolModuleTemplatePlugin(compilation, options, options.append, options.moduleFilenameTemplate));
		});
	};


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RawSource = __webpack_require__(213);
	var ModuleFilenameHelpers = __webpack_require__(281);
	
	function EvalSourceMapDevToolModuleTemplatePlugin(compilation, options, sourceMapComment, moduleFilenameTemplate) {
		this.compilation = compilation;
		this.sourceMapComment = sourceMapComment || "//@ sourceMappingURL=[url]";
		this.moduleFilenameTemplate = moduleFilenameTemplate || "webpack:///[resource-path]?[hash]";
		this.options = options;
	}
	module.exports = EvalSourceMapDevToolModuleTemplatePlugin;
	
	EvalSourceMapDevToolModuleTemplatePlugin.prototype.apply = function(moduleTemplate) {
		var self = this;
		var options = this.options;
		moduleTemplate.plugin("module", function(source, module) {
			if(source.__EvalSourceMapDevToolData)
				return source.__EvalSourceMapDevToolData;
	
			if(source.sourceAndMap) {
				var sourceAndMap = source.sourceAndMap(options);
				var sourceMap = sourceAndMap.map;
				var content = sourceAndMap.source;
			} else {
				var sourceMap = source.map(options);
				var content = source.source();
			}
			if(!sourceMap) {
				return source;
			}
	
			// Clone (flat) the sourcemap to ensure that the mutations below do not persist.
			sourceMap = Object.keys(sourceMap).reduce(function(obj, key) {
				obj[key] = sourceMap[key];
				return obj;
			}, {});
			var modules = sourceMap.sources.map(function(source) {
				var module = self.compilation.findModule(source);
				return module || source;
			});
			var moduleFilenames = modules.map(function(module) {
				return ModuleFilenameHelpers.createFilename(module, self.moduleFilenameTemplate, this.requestShortener);
			}, this);
			moduleFilenames = ModuleFilenameHelpers.replaceDuplicates(moduleFilenames, function(filename, i, n) {
				for(var j = 0; j < n; j++)
					filename += "*";
				return filename;
			});
			sourceMap.sources = moduleFilenames;
			if(sourceMap.sourcesContent) {
				sourceMap.sourcesContent = sourceMap.sourcesContent.map(function(content, i) {
					return content + "\n\n\n" + ModuleFilenameHelpers.createFooter(modules[i], this.requestShortener);
				}, this);
			}
			sourceMap.sourceRoot = "";
			sourceMap.file = module.id + ".js";
			var footer = self.sourceMapComment.replace(/\[url\]/g, "data:application/json;base64," + new Buffer(JSON.stringify(sourceMap)).toString("base64"));
			source.__EvalSourceMapDevToolData = new RawSource("eval(" + JSON.stringify(content + footer) + ");");
			return source.__EvalSourceMapDevToolData;
		});
		moduleTemplate.plugin("hash", function(hash) {
			hash.update("eval-source-map");
			hash.update("1");
		});
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176).Buffer))

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SingleEntryPlugin = __webpack_require__(287);
	var MultiEntryPlugin = __webpack_require__(289);
	
	function EntryOptionPlugin() {}
	module.exports = EntryOptionPlugin;
	
	EntryOptionPlugin.prototype.apply = function(compiler) {
		compiler.plugin("entry-option", function(context, entry) {
			function itemToPlugin(item, name) {
				if(Array.isArray(item))
					return new MultiEntryPlugin(context, item, name);
				else
					return new SingleEntryPlugin(context, item, name);
			}
			if(typeof entry === "string" || Array.isArray(entry)) {
				compiler.apply(itemToPlugin(entry, "main"));
			} else if(typeof entry === "object") {
				Object.keys(entry).forEach(function(name) {
					compiler.apply(itemToPlugin(entry[name], name));
				});
			}
			return true;
		});
	};


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SingleEntryDependency = __webpack_require__(288);
	
	function SingleEntryPlugin(context, entry, name) {
		this.context = context;
		this.entry = entry;
		this.name = name;
	}
	module.exports = SingleEntryPlugin;
	SingleEntryPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation, params) {
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
		});
		compiler.plugin("make", function(compilation, callback) {
			var dep = new SingleEntryDependency(this.entry);
			dep.loc = this.name;
			compilation.addEntry(this.context, dep, this.name, callback);
		}.bind(this));
	};


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(272);
	
	function SingleEntryDependency(request) {
		ModuleDependency.call(this, request);
		this.Class = SingleEntryDependency;
	}
	module.exports = SingleEntryDependency;
	
	SingleEntryDependency.prototype = Object.create(ModuleDependency.prototype);
	SingleEntryDependency.prototype.constructor = SingleEntryDependency;
	SingleEntryDependency.prototype.type = "single entry";


/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var MultiEntryDependency = __webpack_require__(290);
	var SingleEntryDependency = __webpack_require__(288);
	var MultiModuleFactory = __webpack_require__(291);
	
	function MultiEntryPlugin(context, entries, name) {
		this.context = context;
		this.entries = entries;
		this.name = name;
	}
	module.exports = MultiEntryPlugin;
	MultiEntryPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation, params) {
			var multiModuleFactory = new MultiModuleFactory();
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(MultiEntryDependency, multiModuleFactory);
	
			compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
		});
		compiler.plugin("make", function(compilation, callback) {
			compilation.addEntry(this.context, new MultiEntryDependency(this.entries.map(function(e, idx) {
				var dep = new SingleEntryDependency(e);
				dep.loc = this.name + ":" + (100000 + idx);
				return dep;
			}, this), this.name), this.name, callback);
		}.bind(this));
	};


/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Dependency = __webpack_require__(228);
	
	function MultiEntryDependency(dependencies, name) {
		Dependency.call(this);
		this.Class = MultiEntryDependency;
		this.dependencies = dependencies;
		this.name = name;
	}
	module.exports = MultiEntryDependency;
	
	MultiEntryDependency.prototype = Object.create(Dependency.prototype);
	MultiEntryDependency.prototype.constructor = MultiEntryDependency;
	MultiEntryDependency.prototype.type = "multi entry";


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Tapable = __webpack_require__(181);
	var MultiModule = __webpack_require__(292);
	
	function MultiModuleFactory() {
		Tapable.call(this);
	}
	module.exports = MultiModuleFactory;
	
	MultiModuleFactory.prototype = Object.create(Tapable.prototype);
	MultiModuleFactory.prototype.constructor = MultiModuleFactory;
	
	MultiModuleFactory.prototype.create = function(context, dependency, callback) {
		callback(null, new MultiModule(context, dependency.dependencies, dependency.name));
	};


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Module = __webpack_require__(188);
	var RawSource = __webpack_require__(213);
	
	function MultiModule(context, dependencies, name) {
		Module.call(this);
		this.context = context;
		this.dependencies = dependencies;
		this.name = name;
		this.built = false;
		this.cacheable = true;
	}
	module.exports = MultiModule;
	
	MultiModule.prototype = Object.create(Module.prototype);
	
	MultiModule.prototype.identifier = function() {
		return "multi " + this.name;
	};
	
	MultiModule.prototype.readableIdentifier = function() {
		return "multi " + this.name;
	};
	
	MultiModule.prototype.disconnect = function disconnect() {
		this.built = false;
		Module.prototype.disconnect.call(this);
	};
	
	MultiModule.prototype.build = function build(options, compilation, resolver, fs, callback) {
		this.built = true;
		return callback();
	};
	
	MultiModule.prototype.source = function(dependencyTemplates, outputOptions) {
		var str = [];
		this.dependencies.forEach(function(dep, idx) {
			if(dep.module) {
				if(idx === this.dependencies.length - 1)
					str.push("module.exports = ");
				str.push("__webpack_require__(");
				if(outputOptions.pathinfo)
					str.push("/*! " + dep.request + " */");
				str.push("" + JSON.stringify(dep.module.id));
				str.push(")");
			} else {
				str.push("(function webpackMissingModule() { throw new Error(");
				str.push(JSON.stringify("Cannot find module \"" + dep.request + "\""));
				str.push("); }())");
			}
			str.push(";\n");
		}, this);
		return new RawSource(str.join(""));
	};
	
	MultiModule.prototype.needRebuild = function needRebuild() {
		return false;
	};
	
	MultiModule.prototype.size = function() {
		return 16 + this.dependencies.length * 12;
	};
	
	MultiModule.prototype.updateHash = function(hash) {
		hash.update("multi module");
		hash.update(this.name || "");
		Module.prototype.updateHash.call(this, hash);
	};


/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(180);
	
	function RecordIdsPlugin() {}
	module.exports = RecordIdsPlugin;
	
	function makeRelative(compiler, identifier) {
		var context = compiler.context;
		return identifier.split("|").map(function(str) {
			return path.relative(context, str);
		}).join("|");
	}
	
	RecordIdsPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("record-modules", function(modules, records) {
				records.nextFreeModuleId = compilation.nextFreeModuleId;
				if(!records.modules) records.modules = {};
				if(!records.modules.byIdentifier) records.modules.byIdentifier = {};
				modules.forEach(function(module) {
					var identifier = makeRelative(compiler, module.identifier());
					records.modules.byIdentifier[identifier] = module.id;
				});
			});
			compilation.plugin("revive-modules", function(modules, records) {
				if(records.nextFreeModuleId)
					compilation.nextFreeModuleId = records.nextFreeModuleId;
				if(!records.modules || !records.modules.byIdentifier) return;
				var usedIds = {
					0: true
				};
				modules.forEach(function(module) {
					if(module.id !== null) return;
					var identifier = makeRelative(compiler, module.identifier());
					var id = records.modules.byIdentifier[identifier];
					if(id === undefined) return;
					if(usedIds[id]) return;
					usedIds[id] = true;
					module.id = id;
				});
			});
	
			function getDepBlockIdent(chunk, block) {
				var ident = [];
				if(block.chunks.length > 1)
					ident.push(block.chunks.indexOf(chunk));
				while(block.parent) {
					var p = block.parent;
					var idx = p.blocks.indexOf(block);
					var l = p.blocks.length - 1;
					ident.unshift(idx + "/" + l);
					block = block.parent;
				}
				if(!block.identifier) return null;
				ident.unshift(makeRelative(compiler, block.identifier()));
				return ident.join(":");
			}
			compilation.plugin("record-chunks", function(chunks, records) {
				records.nextFreeChunkId = compilation.nextFreeChunkId;
				if(!records.chunks) records.chunks = {};
				if(!records.chunks.byName) records.chunks.byName = {};
				if(!records.chunks.byBlocks) records.chunks.byBlocks = {};
				chunks.forEach(function(chunk) {
					var name = chunk.name;
					var blockIdents = chunk.blocks.map(getDepBlockIdent.bind(null, chunk)).filter(Boolean);
					if(name) records.chunks.byName[name] = chunk.id;
					blockIdents.forEach(function(blockIdent) {
						records.chunks.byBlocks[blockIdent] = chunk.id;
					});
				});
			});
			compilation.plugin("revive-chunks", function(chunks, records) {
				if(records.nextFreeChunkId)
					compilation.nextFreeChunkId = records.nextFreeChunkId;
				if(!records.chunks) return;
				var usedIds = {};
				if(records.chunks.byName) {
					chunks.forEach(function(chunk) {
						if(chunk.id !== null) return;
						if(!chunk.name) return;
						var id = records.chunks.byName[chunk.name];
						if(id === undefined) return;
						if(usedIds[id]) return;
						usedIds[id] = true;
						chunk.id = id;
					});
				}
				if(records.chunks.byBlocks) {
					var argumentedChunks = chunks.filter(function(chunk) {
						return chunk.id === null;
					}).map(function(chunk) {
						return {
							chunk: chunk,
							blockIdents: chunk.blocks.map(getDepBlockIdent.bind(null, chunk)).filter(Boolean)
						};
					}).filter(function(arg) {
						return arg.blockIdents.length > 0;
					});
					var blockIdentsCount = {};
					argumentedChunks.forEach(function(arg, idx) {
						arg.blockIdents.forEach(function(blockIdent) {
							var id = records.chunks.byBlocks[blockIdent];
							if(typeof id !== "number") return;
							var accessor = id + ":" + idx;
							blockIdentsCount[accessor] = (blockIdentsCount[accessor] || 0) + 1;
						});
					});
					blockIdentsCount = Object.keys(blockIdentsCount).map(function(accessor) {
						return [blockIdentsCount[accessor]].concat(accessor.split(":").map(Number));
					}).sort(function(a, b) {
						return b[0] - a[0];
					});
					blockIdentsCount.forEach(function(arg) {
						var id = arg[1];
						if(usedIds[id]) return;
						var idx = arg[2];
						var chunk = argumentedChunks[idx].chunk;
						if(chunk.id !== null) return;
						usedIds[id] = true;
						chunk.id = id;
					});
				}
			});
		});
	};


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConstDependency = __webpack_require__(295);
	var BasicEvaluatedExpression = __webpack_require__(251);
	
	var NullFactory = __webpack_require__(297);
	
	function APIPlugin() {}
	module.exports = APIPlugin;
	
	var REPLACEMENTS = {
		__webpack_require__: "__webpack_require__", // eslint-disable-line camelcase
		__webpack_public_path__: "__webpack_require__.p", // eslint-disable-line camelcase
		__webpack_modules__: "__webpack_require__.m", // eslint-disable-line camelcase
		__webpack_chunk_load__: "__webpack_require__.e", // eslint-disable-line camelcase
		__non_webpack_require__: "require", // eslint-disable-line camelcase
		"require.onError": "__webpack_require__.onError" // eslint-disable-line camelcase
	};
	var REPLACEMENT_TYPES = {
		__webpack_public_path__: "string", // eslint-disable-line camelcase
		__webpack_require__: "function", // eslint-disable-line camelcase
		__webpack_modules__: "object", // eslint-disable-line camelcase
		__webpack_chunk_load__: "function" // eslint-disable-line camelcase
	};
	var IGNORES = [];
	APIPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
		});
		Object.keys(REPLACEMENTS).forEach(function(key) {
			compiler.parser.plugin("expression " + key, function(expr) {
				var dep = new ConstDependency(REPLACEMENTS[key], expr.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			});
			compiler.parser.plugin("evaluate typeof " + key, function(expr) {
				return new BasicEvaluatedExpression().setString(REPLACEMENT_TYPES[key]).setRange(expr.range);
			});
		});
		IGNORES.forEach(function(key) {
			compiler.parser.plugin(key, function() {
				return true;
			});
		});
	};


/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NullDependency = __webpack_require__(296);
	
	function ConstDependency(expression, range) {
		NullDependency.call(this);
		this.Class = ConstDependency;
		this.expression = expression;
		this.range = range;
	}
	module.exports = ConstDependency;
	
	ConstDependency.prototype = Object.create(NullDependency.prototype);
	ConstDependency.prototype.constructor = ConstDependency;
	
	ConstDependency.Template = function ConstDependencyTemplate() {};
	
	ConstDependency.Template.prototype.apply = function(dep, source) {
		if(typeof dep.range === "number")
			source.insert(dep.range, dep.expression);
		else
			source.replace(dep.range[0], dep.range[1] - 1, dep.expression);
	};
	
	ConstDependency.prototype.updateHash = function(hash) {
		hash.update(this.range + "");
		hash.update(this.expression + "");
	};


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Dependency = __webpack_require__(228);
	
	function NullDependency() {
		Dependency.call(this);
		this.Class = NullDependency;
	}
	module.exports = NullDependency;
	
	NullDependency.prototype = Object.create(Dependency.prototype);
	NullDependency.prototype.constructor = NullDependency;
	NullDependency.prototype.type = "null";
	NullDependency.prototype.isEqualResource = function() {
		return false;
	};


/***/ },
/* 297 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function NullFactory() {}
	module.exports = NullFactory;
	
	NullFactory.prototype.create = function(context, dependency, callback) {
		return callback();
	};


/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConstDependency = __webpack_require__(295);
	var BasicEvaluatedExpression = __webpack_require__(251);
	
	var NullFactory = __webpack_require__(297);
	
	function ConstPlugin() {}
	module.exports = ConstPlugin;
	
	ConstPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
		});
		compiler.parser.plugin("statement if", function(statement) {
			var param = this.evaluateExpression(statement.test);
			var bool = param.asBool();
			if(typeof bool === "boolean") {
				if(statement.test.type !== "Literal") {
					var dep = new ConstDependency(bool + "", param.range);
					dep.loc = statement.loc;
					this.state.current.addDependency(dep);
				}
				return bool;
			}
		});
		compiler.parser.plugin("expression ?:", function(expression) {
			var param = this.evaluateExpression(expression.test);
			var bool = param.asBool();
			if(typeof bool === "boolean") {
				if(expression.test.type !== "Literal") {
					var dep = new ConstDependency(" " + bool + "", param.range);
					dep.loc = expression.loc;
					this.state.current.addDependency(dep);
				}
				return bool;
			}
		});
		compiler.parser.plugin("evaluate Identifier __resourceQuery", function(expr) {
			if(!this.state.module) return;
			var res = new BasicEvaluatedExpression();
			res.setString(this.state.module.splitQuery(this.state.module.resource)[1]);
			res.setRange(expr.range);
			return res;
		});
		compiler.parser.plugin("expression __resourceQuery", function() {
			if(!this.state.module) return;
			this.state.current.addVariable("__resourceQuery", JSON.stringify(this.state.module.splitQuery(this.state.module.resource)[1]));
			return true;
		});
	};


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConstDependency = __webpack_require__(295);
	
	var NullFactory = __webpack_require__(297);
	
	function RequireJsStuffPlugin() {}
	module.exports = RequireJsStuffPlugin;
	RequireJsStuffPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
		});
	
		function remove(expr) {
			var dep = new ConstDependency(";", expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		}
		compiler.parser.plugin("call require.config", remove);
		compiler.parser.plugin("call requirejs.config", remove);
	
		compiler.parser.plugin("expression require.version", function(expr) {
			var dep = new ConstDependency(JSON.stringify("0.0.0"), expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		});
		compiler.parser.plugin("expression requirejs.onError", function(expr) {
			var dep = new ConstDependency(JSON.stringify("__webpack_require__.onError"), expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		});
	};


/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(180);
	var ModuleParserHelpers = __webpack_require__(301);
	var ConstDependency = __webpack_require__(295);
	var BasicEvaluatedExpression = __webpack_require__(251);
	var UnsupportedFeatureWarning = __webpack_require__(302);
	
	var NullFactory = __webpack_require__(297);
	
	function NodeStuffPlugin(options) {
		this.options = options;
	}
	module.exports = NodeStuffPlugin;
	NodeStuffPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
		});
	
		function ignore() {
			return true;
		}
	
		function setConstant(expressionName, value) {
			compiler.parser.plugin("expression " + expressionName, function() {
				this.state.current.addVariable(expressionName, JSON.stringify(value));
				return true;
			});
		}
	
		function setModuleConstant(expressionName, fn) {
			compiler.parser.plugin("expression " + expressionName, function() {
				this.state.current.addVariable(expressionName, JSON.stringify(fn(this.state.module)));
				return true;
			});
		}
		var context = compiler.context;
		if(this.options.__filename === "mock") {
			setConstant("__filename", "/index.js");
		} else if(this.options.__filename) {
			setModuleConstant("__filename", function(module) {
				return path.relative(context, module.resource);
			});
		}
		compiler.parser.plugin("evaluate Identifier __filename", function(expr) {
			if(!this.state.module) return;
			var res = new BasicEvaluatedExpression();
			res.setString(this.state.module.splitQuery(this.state.module.resource)[0]);
			res.setRange(expr.range);
			return res;
		});
		if(this.options.__dirname === "mock") {
			setConstant("__dirname", "/");
		} else if(this.options.__dirname) {
			setModuleConstant("__dirname", function(module) {
				return path.relative(context, module.context);
			});
		}
		compiler.parser.plugin("evaluate Identifier __dirname", function(expr) {
			if(!this.state.module) return;
			var res = new BasicEvaluatedExpression();
			res.setString(this.state.module.context);
			res.setRange(expr.range);
			return res;
		});
		compiler.parser.plugin("expression require.main", function(expr) {
			var dep = new ConstDependency("__webpack_require__.c[0]", expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		});
		compiler.parser.plugin("expression require.extensions", function(expr) {
			var dep = new ConstDependency("(void 0)", expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			if(!this.state.module) return;
			this.state.module.warnings.push(new UnsupportedFeatureWarning(this.state.module, "require.extensions is not supported by webpack. Use a loader instead."));
			return true;
		});
		compiler.parser.plugin("expression module.exports", ignore);
		compiler.parser.plugin("expression module.loaded", ignore);
		compiler.parser.plugin("expression module.id", ignore);
		compiler.parser.plugin("evaluate Identifier module.hot", function(expr) {
			return new BasicEvaluatedExpression().setBoolean(false).setRange(expr.range);
		});
		compiler.parser.plugin("expression module", function() {
			return ModuleParserHelpers.addParsedVariable(this, "module", "require(" + JSON.stringify(path.join(__dirname, "..", "buildin", "module.js")) + ")(module)");
		});
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 301 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleParserHelpers = exports;
	
	ModuleParserHelpers.addParsedVariable = function(parser, name, expression) {
		if(!parser.state.current.addVariable) return false;
		var deps = [];
		parser.parse(expression, {
			current: {
				addDependency: function(dep) {
					dep.userRequest = name;
					deps.push(dep);
				}
			},
			module: parser.state.module
		});
		parser.state.current.addVariable(name, expression, deps);
		return true;
	};


/***/ },
/* 302 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function UnsupportedFeatureWarning(module, message) {
		Error.call(this);
		Error.captureStackTrace(this, UnsupportedFeatureWarning);
		this.name = "UnsupportedFeatureWarning";
		this.message = message;
		this.origin = this.module = module;
	}
	module.exports = UnsupportedFeatureWarning;
	
	UnsupportedFeatureWarning.prototype = Object.create(Error.prototype);


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(180);
	var ConstDependency = __webpack_require__(295);
	
	var ModuleAliasPlugin = __webpack_require__(304);
	
	var NullFactory = __webpack_require__(297);
	
	function CompatibilityPlugin() {}
	module.exports = CompatibilityPlugin;
	
	CompatibilityPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
		});
		compiler.resolvers.normal.apply(
			new ModuleAliasPlugin({
				"enhanced-require": path.join(__dirname, "..", "buildin", "return-require.js")
			})
		);
		compiler.parser.plugin("call require", function(expr) {
			// support for browserify style require delegator: "require(o, !0)"
			if(expr.arguments.length !== 2) return;
			var second = this.evaluateExpression(expr.arguments[1]);
			if(!second.isBoolean()) return;
			if(second.asBool() !== true) return;
			var dep = new ConstDependency("require", expr.callee.range);
			dep.loc = expr.loc;
			if(this.state.current.dependencies.length > 1) {
				var last = this.state.current.dependencies[this.state.current.dependencies.length - 1];
				if(last.critical && last.request === "." && last.userRequest === "." && last.recursive)
					this.state.current.dependencies.pop();
			}
			dep.critical = "This seems to be a pre-built javascript file. Though this is possible, it's not recommended. Try to require the original source to get better results.";
			this.state.current.addDependency(dep);
			return true;
		});
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var createInnerCallback = __webpack_require__(253);
	
	function ModuleAliasPlugin(aliasMap) {
		this.aliasMap = aliasMap;
	}
	module.exports = ModuleAliasPlugin;
	
	ModuleAliasPlugin.prototype.apply = function(resolver) {
		var aliasMap = this.aliasMap;
		resolver.plugin("module", function(request, callback) {
			var fs = this.fileSystem;
			var keys = Object.keys(aliasMap);
			var i = 0;
			(function next() {
				for(;i < keys.length; i++) {
					var aliasName = keys[i];
					var onlyModule = /\$$/.test(aliasName);
					if(onlyModule) aliasName = aliasName.substr(0, aliasName.length-1);
					if((!onlyModule && request.request.indexOf(aliasName + "/") === 0) || request.request === aliasName) {
						var aliasValue = aliasMap[keys[i]];
						if(request.request.indexOf(aliasValue + "/") !== 0 && request.request != aliasValue) {
							var newRequestStr = aliasValue + request.request.substr(aliasName.length);
							var newRequest = this.parse(newRequestStr);
							var obj = {
								path: request.path,
								request: newRequest.path,
								query: newRequest.query,
								directory: newRequest.directory
							};
							var newCallback = createInnerCallback(callback, callback, "aliased with mapping " + JSON.stringify(aliasName) + ": " + JSON.stringify(aliasValue) + " to " + newRequestStr);
							if(newRequest.module) return this.doResolve("module", obj, newCallback);
							if(newRequest.directory) return this.doResolve("directory", obj, newCallback);
							return this.doResolve(["file", "directory"], obj, newCallback);
						}
					}
				}
				return callback();
			}.call(this));
		});
	};


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConstDependency = __webpack_require__(295);
	var BasicEvaluatedExpression = __webpack_require__(251);
	
	var NullFactory = __webpack_require__(297);
	
	function DefinePlugin(definitions) {
		this.definitions = definitions;
	}
	module.exports = DefinePlugin;
	DefinePlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
		});
		(function walkDefinitions(definitions, prefix) {
			Object.keys(definitions).forEach(function(key) {
				var code = definitions[key];
				if(code && typeof code === "object" && !(code instanceof RegExp)) {
					walkDefinitions(code, prefix + key + ".");
					applyObjectDefine(prefix + key, code);
					return;
				}
				applyDefineKey(prefix, key);
				applyDefine(prefix + key, code);
			});
		}(this.definitions, ""));
	
		function stringifyObj(obj) {
			return "{" + Object.keys(obj).map(function(key) {
				var code = obj[key];
				return JSON.stringify(key) + ":" + toCode(code);
			}).join(",") + "}";
		}
	
		function toCode(code) {
			if(code === null) return "null";
			else if(code === undefined) return "undefined";
			else if(code instanceof RegExp && code.toString) return code.toString();
			else if(typeof code === "function" && code.toString) return code.toString();
			else if(typeof code === "object") return stringifyObj(code);
			else return code + "";
		}
	
		function applyDefineKey(prefix, key) {
			var splittedKey = key.split(".");
			splittedKey.slice(1).forEach(function(_, i) {
				var fullKey = prefix + splittedKey.slice(0, i + 1).join(".");
				compiler.parser.plugin("can-rename " + fullKey, function() {
					return true;
				});
			});
		}
	
		function applyDefine(key, code) {
			var isTypeof = /^typeof\s+/.test(key);
			if(isTypeof) key = key.replace(/^typeof\s+/, "");
			var recurse = false;
			var recurseTypeof = false;
			code = toCode(code);
			if(!isTypeof) {
				compiler.parser.plugin("can-rename " + key, function() {
					return true;
				});
				compiler.parser.plugin("evaluate Identifier " + key, function(expr) {
					if(recurse) return;
					recurse = true;
					var res = compiler.parser.evaluate(code);
					recurse = false;
					res.setRange(expr.range);
					return res;
				});
				compiler.parser.plugin("expression " + key, function(expr) {
					var dep = new ConstDependency("(" + code + ")", expr.range);
					dep.loc = expr.loc;
					this.state.current.addDependency(dep);
					return true;
				});
			}
			var typeofCode = isTypeof ? code : "typeof (" + code + ")";
			compiler.parser.plugin("evaluate typeof " + key, function(expr) {
				if(recurseTypeof) return;
				recurseTypeof = true;
				var res = compiler.parser.evaluate(typeofCode);
				recurseTypeof = false;
				res.setRange(expr.range);
				return res;
			});
			compiler.parser.plugin("typeof " + key, function(expr) {
				var res = compiler.parser.evaluate(typeofCode);
				if(!res.isString()) return;
				var dep = new ConstDependency(JSON.stringify(res.string), expr.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			});
		}
	
		function applyObjectDefine(key, obj) {
			var code = stringifyObj(obj);
			compiler.parser.plugin("can-rename " + key, function() {
				return true;
			});
			compiler.parser.plugin("evaluate Identifier " + key, function(expr) {
				return new BasicEvaluatedExpression().setRange(expr.range);
			});
			compiler.parser.plugin("evaluate typeof " + key, function(expr) {
				return new BasicEvaluatedExpression().setString("object").setRange(expr.range);
			});
			compiler.parser.plugin("expression " + key, function(expr) {
				var dep = new ConstDependency("(" + code + ")", expr.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			});
			compiler.parser.plugin("typeof " + key, function(expr) {
				var dep = new ConstDependency("\"object\"", expr.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			});
		}
	};


/***/ },
/* 306 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function MovedToPluginWarningPlugin(optionName, pluginName) {
		this.optionName = optionName;
		this.pluginName = pluginName;
	}
	module.exports = MovedToPluginWarningPlugin;
	
	MovedToPluginWarningPlugin.prototype.apply = function(compiler) {
		var optionName = this.optionName;
		var pluginName = this.pluginName;
		compiler.plugin("compilation", function(compilation) {
			compilation.warnings.push(new Error("webpack options:\nDEPRECATED option '" + optionName + "' will be moved to the " + pluginName + ". Use this instead.\nFor more info about the usage of the " + pluginName + " see https://webpack.github.io/docs/list-of-plugins.html"));
		});
	};


/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Jason Anderson @diurnalist
	*/
	
	var REGEXP_HASH = /\[hash(?::(\d+))?\]/gi,
		REGEXP_CHUNKHASH = /\[chunkhash(?::(\d+))?\]/gi,
		REGEXP_NAME = /\[name\]/gi,
		REGEXP_ID = /\[id\]/gi,
		REGEXP_FILE = /\[file\]/gi,
		REGEXP_QUERY = /\[query\]/gi,
		REGEXP_FILEBASE = /\[filebase\]/gi;
	
	// Using global RegExp for .test is dangerous
	// We use a normal RegExp instead of .test
	var REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, "i"),
		REGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, "i"),
		REGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, "i");
	
	// Backwards compatibility; expose regexes on Template object
	var Template = __webpack_require__(224);
	Template.REGEXP_HASH = REGEXP_HASH;
	Template.REGEXP_CHUNKHASH = REGEXP_CHUNKHASH;
	Template.REGEXP_NAME = REGEXP_NAME;
	Template.REGEXP_ID = REGEXP_ID;
	Template.REGEXP_FILE = REGEXP_FILE;
	Template.REGEXP_QUERY = REGEXP_QUERY;
	Template.REGEXP_FILEBASE = REGEXP_FILEBASE;
	
	function TemplatedPathPlugin() {}
	
	module.exports = TemplatedPathPlugin;
	
	function withHashLength(replacer, handlerFn) {
		return function(_, hashLength) {
			var length = hashLength && parseInt(hashLength, 10);
			if(length && handlerFn) {
				return handlerFn(length);
			}
			var hash = replacer.apply(this, arguments);
			return length ? hash.slice(0, length) : hash;
		};
	}
	
	function getReplacer(value, allowEmpty) {
		return function(match) {
			// last argument in replacer is the entire input string
			var input = arguments[arguments.length - 1];
			if(value == null) {
				if(!allowEmpty) throw new Error("Path variable " + match + " not implemented in this context: " + input);
				return "";
			} else {
				return "" + value;
			}
		};
	}
	
	function replacePathVariables(path, data) {
		var chunk = data.chunk;
		var chunkId = chunk && chunk.id;
		var chunkName = chunk && (chunk.name || chunk.id);
		var chunkHash = chunk && (chunk.renderedHash || chunk.hash);
		var chunkHashWithLength = chunk && chunk.hashWithLength;
	
		if(data.noChunkHash && REGEXP_CHUNKHASH_FOR_TEST.test(path)) {
			throw new Error("Cannot use [chunkhash] for chunk in '" + path + "' (use [hash] instead)");
		}
	
		return path
			.replace(REGEXP_HASH, withHashLength(getReplacer(data.hash), data.hashWithLength))
			.replace(REGEXP_CHUNKHASH, withHashLength(getReplacer(chunkHash), chunkHashWithLength))
			.replace(REGEXP_ID, getReplacer(chunkId))
			.replace(REGEXP_NAME, getReplacer(chunkName))
			.replace(REGEXP_FILE, getReplacer(data.filename))
			.replace(REGEXP_FILEBASE, getReplacer(data.basename))
			// query is optional, it's OK if it's in a path but there's nothing to replace it with
			.replace(REGEXP_QUERY, getReplacer(data.query, true));
	}
	
	TemplatedPathPlugin.prototype.constructor = TemplatedPathPlugin;
	TemplatedPathPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			var mainTemplate = compilation.mainTemplate;
	
			mainTemplate.plugin("asset-path", replacePathVariables);
	
			mainTemplate.plugin("global-hash", function(chunk, paths) {
				var outputOptions = this.outputOptions;
				var publicPath = outputOptions.publicPath || "";
				var filename = outputOptions.filename || "";
				var chunkFilename = outputOptions.chunkFilename || outputOptions.filename;
				if(REGEXP_HASH_FOR_TEST.test(publicPath) || REGEXP_CHUNKHASH_FOR_TEST.test(publicPath) || REGEXP_NAME_FOR_TEST.test(publicPath))
					return true;
				if(REGEXP_HASH_FOR_TEST.test(filename))
					return true;
				if(REGEXP_HASH_FOR_TEST.test(chunkFilename))
					return true;
				if(REGEXP_HASH_FOR_TEST.test(paths.join("|")))
					return true;
			});
	
			mainTemplate.plugin("hash-for-chunk", function(hash, chunk) {
				var outputOptions = this.outputOptions;
				var chunkFilename = outputOptions.chunkFilename || outputOptions.filename;
				if(REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename))
					hash.update(JSON.stringify(chunk.getChunkMaps(true, true).hash));
				if(REGEXP_NAME_FOR_TEST.test(chunkFilename))
					hash.update(JSON.stringify(chunk.getChunkMaps(true, true).name));
			});
		});
	};


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var CaseSensitiveModulesWarning = __webpack_require__(309);
	
	function WarnCaseSensitiveModulesPlugin() {}
	module.exports = WarnCaseSensitiveModulesPlugin;
	
	WarnCaseSensitiveModulesPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("seal", function() {
				var moduleWithoutCase = {};
				this.modules.forEach(function(module) {
					var ident = module.identifier().toLowerCase();
					if(moduleWithoutCase["$" + ident]) {
						if(moduleWithoutCase["$" + ident] !== true)
							this.warnings.push(new CaseSensitiveModulesWarning(moduleWithoutCase["$" + ident]));
						this.warnings.push(new CaseSensitiveModulesWarning(module));
						moduleWithoutCase["$" + ident] = true;
					} else {
						moduleWithoutCase["$" + ident] = module;
					}
				}, this);
			});
		});
	};


/***/ },
/* 309 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function CaseSensitiveModulesWarning(module) {
		Error.call(this);
		Error.captureStackTrace(this, CaseSensitiveModulesWarning);
		this.name = "CaseSensitiveModulesWarning";
		this.message = "There is another module with an equal name when case is ignored.\n" +
			"This can lead to unexpected behavior when compiling on a filesystem with other case-semantic.\n" +
			"Rename module if multiple modules are expected or use equal casing if one module is expected.";
		this.origin = this.module = module;
	}
	module.exports = CaseSensitiveModulesWarning;
	
	CaseSensitiveModulesWarning.prototype = Object.create(Error.prototype);


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var LoaderDependency = __webpack_require__(311);
	
	function LoaderPlugin() {}
	module.exports = LoaderPlugin;
	
	LoaderPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation, params) {
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(LoaderDependency, normalModuleFactory);
		});
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("normal-module-loader", function(loaderContext, module) {
				loaderContext.loadModule = function loadModule(request, callback) {
					var dep = new LoaderDependency(request);
					dep.loc = request;
					compilation.addModuleDependencies(module, [
						[dep]
					], true, "lm", false, function(err) {
						if(err) return callback(err);
	
						module = dep.module;
						if(!module) return callback(new Error("Cannot load the module"));
						if(module.building) module.building.push(next);
						else next();
	
						function next(err) {
							if(err) return callback(err);
	
							if(dep.module.error) return callback(dep.module.error);
							if(!dep.module._source) throw new Error("The module created for a LoaderDependency must have a property _source");
							var source, map;
							var moduleSource = dep.module._source;
							if(moduleSource.sourceAndMap) {
								var sourceAndMap = moduleSource.sourceAndMap();
								map = sourceAndMap.map;
								source = sourceAndMap.source;
							} else {
								map = moduleSource.map();
								source = moduleSource.source();
							}
							if(dep.module.fileDependencies) {
								dep.module.fileDependencies.forEach(function(dep) {
									loaderContext.addDependency(dep);
								});
							}
							if(dep.module.contextDependencies) {
								dep.module.contextDependencies.forEach(function(dep) {
									loaderContext.addContextDependency(dep);
								});
							}
							return callback(null, source, map, dep.module);
						}
					});
				};
			});
		});
	};


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(272);
	
	function LoaderDependency(request) {
		ModuleDependency.call(this, request);
		this.Class = LoaderDependency;
	}
	module.exports = LoaderDependency;
	
	LoaderDependency.prototype = Object.create(ModuleDependency.prototype);
	LoaderDependency.prototype.constructor = LoaderDependency;
	LoaderDependency.prototype.type = "loader";


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConstDependency = __webpack_require__(295);
	var CommonJsRequireDependency = __webpack_require__(313);
	var CommonJsRequireContextDependency = __webpack_require__(316);
	var RequireResolveDependency = __webpack_require__(319);
	var RequireResolveContextDependency = __webpack_require__(320);
	var RequireResolveHeaderDependency = __webpack_require__(322);
	var RequireHeaderDependency = __webpack_require__(323);
	
	var NullFactory = __webpack_require__(297);
	
	var RequireResolveDependencyParserPlugin = __webpack_require__(324);
	var CommonJsRequireDependencyParserPlugin = __webpack_require__(326);
	
	var BasicEvaluatedExpression = __webpack_require__(251);
	
	function CommonJsPlugin(options) {
		this.options = options;
	}
	module.exports = CommonJsPlugin;
	
	CommonJsPlugin.prototype.apply = function(compiler) {
		function setTypeof(expr, value) {
			compiler.parser.plugin("evaluate typeof " + expr, function(expr) {
				return new BasicEvaluatedExpression().setString(value).setRange(expr.range);
			});
			compiler.parser.plugin("typeof " + expr, function(expr) {
				var dep = new ConstDependency(JSON.stringify(value), expr.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			});
		}
		compiler.plugin("compilation", function(compilation, params) {
			var normalModuleFactory = params.normalModuleFactory;
			var contextModuleFactory = params.contextModuleFactory;
	
			compilation.dependencyFactories.set(CommonJsRequireDependency, normalModuleFactory);
			compilation.dependencyTemplates.set(CommonJsRequireDependency, new CommonJsRequireDependency.Template());
	
			compilation.dependencyFactories.set(CommonJsRequireContextDependency, contextModuleFactory);
			compilation.dependencyTemplates.set(CommonJsRequireContextDependency, new CommonJsRequireContextDependency.Template());
	
			compilation.dependencyFactories.set(RequireResolveDependency, normalModuleFactory);
			compilation.dependencyTemplates.set(RequireResolveDependency, new RequireResolveDependency.Template());
	
			compilation.dependencyFactories.set(RequireResolveContextDependency, contextModuleFactory);
			compilation.dependencyTemplates.set(RequireResolveContextDependency, new RequireResolveContextDependency.Template());
	
			compilation.dependencyFactories.set(RequireResolveHeaderDependency, new NullFactory());
			compilation.dependencyTemplates.set(RequireResolveHeaderDependency, new RequireResolveHeaderDependency.Template());
	
			compilation.dependencyFactories.set(RequireHeaderDependency, new NullFactory());
			compilation.dependencyTemplates.set(RequireHeaderDependency, new RequireHeaderDependency.Template());
		});
		setTypeof("require", "function");
		setTypeof("require.resolve", "function");
		setTypeof("require.resolveWeak", "function");
		compiler.parser.plugin("evaluate typeof module", function(expr) {
			return new BasicEvaluatedExpression().setString("object").setRange(expr.range);
		});
		compiler.parser.plugin("assign require", function(expr) {
			// to not leak to global "require", we need to define a local require here.
			var dep = new ConstDependency("var require;", 0);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			this.scope.definitions.push("require");
			return true;
		});
		compiler.parser.plugin("can-rename require", function() {
			return true;
		});
		compiler.parser.plugin("rename require", function(expr) {
			// define the require variable. It's still undefined, but not "not defined".
			var dep = new ConstDependency("var require;", 0);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return false;
		});
		compiler.parser.plugin("typeof module", function() {
			return true;
		});
		compiler.parser.plugin("evaluate typeof exports", function(expr) {
			return new BasicEvaluatedExpression().setString("object").setRange(expr.range);
		});
		compiler.parser.apply(
			new CommonJsRequireDependencyParserPlugin(this.options),
			new RequireResolveDependencyParserPlugin(this.options)
		);
	};


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(272);
	
	function CommonJsRequireDependency(request, range) {
		ModuleDependency.call(this, request);
		this.Class = CommonJsRequireDependency;
		this.range = range;
	}
	module.exports = CommonJsRequireDependency;
	
	CommonJsRequireDependency.prototype = Object.create(ModuleDependency.prototype);
	CommonJsRequireDependency.prototype.constructor = CommonJsRequireDependency;
	CommonJsRequireDependency.prototype.type = "cjs require";
	
	CommonJsRequireDependency.Template = __webpack_require__(314);


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleDependencyTemplateAsId() {}
	module.exports = ModuleDependencyTemplateAsId;
	
	ModuleDependencyTemplateAsId.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		if(!dep.range) return;
		var comment = "";
		if(outputOptions.pathinfo) comment = "/*! " + requestShortener.shorten(dep.request) + " */ ";
		if(dep.module)
			var content = comment + JSON.stringify(dep.module.id);
		else
			var content = __webpack_require__(315).module(dep.request);
		source.replace(dep.range[0], dep.range[1] - 1, content);
	};
	
	ModuleDependencyTemplateAsId.prototype.applyAsTemplateArgument = function(name, dep, source) {
		if(!dep.range) return;
		source.replace(dep.range[0], dep.range[1] - 1, name);
	};


/***/ },
/* 315 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	exports.module = function(request) {
		return "!(function webpackMissingModule() { " +
			exports.moduleCode(request) +
			" }())";
	};
	
	exports.moduleCode = function(request) {
		return "var e = new Error(" + JSON.stringify("Cannot find module \"" + request + "\"") + "); " +
			"e.code = 'MODULE_NOT_FOUND'; " +
			"throw e;";
	};
	
	exports.moduleMetaInfo = function(request) {
		return "!(function webpackMissingModuleMetaInfo() { " +
			"var e = new Error(" + JSON.stringify("Module cannot be imported because no meta info about exports is available \"" + request + "\"") + "); " +
			"e.code = 'MODULE_NOT_FOUND'; " +
			"throw e; " +
			"}())";
	};


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ContextDependency = __webpack_require__(317);
	
	function CommonJsRequireContextDependency(request, recursive, regExp, range, valueRange) {
		ContextDependency.call(this, request, recursive, regExp);
		this.range = range;
		this.valueRange = valueRange;
		this.Class = CommonJsRequireContextDependency;
	}
	module.exports = CommonJsRequireContextDependency;
	
	CommonJsRequireContextDependency.prototype = Object.create(ContextDependency.prototype);
	CommonJsRequireContextDependency.prototype.constructor = CommonJsRequireContextDependency;
	CommonJsRequireContextDependency.prototype.type = "cjs require context";
	
	CommonJsRequireContextDependency.Template = __webpack_require__(318);


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Dependency = __webpack_require__(228);
	
	function ContextDependency(request, recursive, regExp) {
		Dependency.call(this);
		this.request = request;
		this.userRequest = request;
		this.recursive = recursive;
		this.regExp = regExp;
		this.Class = ContextDependency;
	}
	module.exports = ContextDependency;
	
	ContextDependency.prototype = Object.create(Dependency.prototype);
	ContextDependency.prototype.constructor = ContextDependency;
	ContextDependency.prototype.isEqualResource = function(other) {
		if(!(other instanceof ContextDependency))
			return false;
		return this.request === other.request &&
			this.recursive === other.recursive &&
			this.regExp === other.regExp;
	};


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ContextDependencyTemplateAsRequireCall() {}
	module.exports = ContextDependencyTemplateAsRequireCall;
	
	ContextDependencyTemplateAsRequireCall.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		var comment = "";
		if(outputOptions.pathinfo) comment = "/*! " + requestShortener.shorten(dep.request) + " */ ";
		if(dep.module && dep.module.dependencies && dep.module.dependencies.length > 0) {
			if(dep.valueRange) {
				source.replace(dep.valueRange[1], dep.range[1] - 1, ")");
				source.replace(dep.range[0], dep.valueRange[0] - 1, "__webpack_require__(" + comment + JSON.stringify(dep.module.id) + ")(" + (typeof dep.prepend === "string" ? JSON.stringify(dep.prepend) : "") + "");
			} else {
				source.replace(dep.range[0], dep.range[1] - 1, "__webpack_require__(" + comment + JSON.stringify(dep.module.id) + ")");
			}
		} else {
			var content = __webpack_require__(315).module(dep.request);
			source.replace(dep.range[0], dep.range[1] - 1, content);
		}
	};
	
	ContextDependencyTemplateAsRequireCall.prototype.applyAsTemplateArgument = function(name, dep, source) {
		if(dep.valueRange) {
			source.replace(dep.valueRange[1], dep.range[1] - 1, ")");
			source.replace(dep.range[0], dep.valueRange[0] - 1, "__webpack_require__(" + name + ")(" + (typeof dep.prepend === "string" ? JSON.stringify(dep.prepend) : "") + "");
		} else {
			source.replace(dep.range[0], dep.range[1] - 1, "__webpack_require__(" + name + ")");
		}
	};


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(272);
	
	function RequireResolveDependency(request, range) {
		ModuleDependency.call(this, request);
		this.Class = RequireResolveDependency;
		this.range = range;
	}
	module.exports = RequireResolveDependency;
	
	RequireResolveDependency.prototype = Object.create(ModuleDependency.prototype);
	RequireResolveDependency.prototype.constructor = RequireResolveDependency;
	RequireResolveDependency.prototype.type = "require.resolve";
	
	RequireResolveDependency.Template = __webpack_require__(314);


/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ContextDependency = __webpack_require__(317);
	
	function RequireResolveContextDependency(request, recursive, regExp, range, valueRange) {
		ContextDependency.call(this, request, recursive, regExp);
		this.range = range;
		this.valueRange = valueRange;
		this.Class = RequireResolveContextDependency;
	}
	module.exports = RequireResolveContextDependency;
	
	RequireResolveContextDependency.prototype = Object.create(ContextDependency.prototype);
	RequireResolveContextDependency.prototype.constructor = RequireResolveContextDependency;
	RequireResolveContextDependency.prototype.type = "amd require context";
	
	RequireResolveContextDependency.Template = __webpack_require__(321);


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ContextDependencyTemplateAsId() {}
	module.exports = ContextDependencyTemplateAsId;
	
	ContextDependencyTemplateAsId.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		var comment = "";
		if(outputOptions.pathinfo) comment = "/*! " + requestShortener.shorten(dep.request) + " */ ";
		if(dep.module && dep.module.dependencies && dep.module.dependencies.length > 0) {
			if(dep.valueRange) {
				source.replace(dep.valueRange[1], dep.range[1] - 1, ")");
				source.replace(dep.range[0], dep.valueRange[0] - 1, "__webpack_require__(" + comment + JSON.stringify(dep.module.id) + ").resolve(" + (typeof dep.prepend === "string" ? JSON.stringify(dep.prepend) : "") + "");
			} else {
				source.replace(dep.range[0], dep.range[1] - 1, "__webpack_require__(" + comment + JSON.stringify(dep.module.id) + ").resolve");
			}
		} else {
			var content = __webpack_require__(315).module(dep.request);
			source.replace(dep.range[0], dep.range[1] - 1, content);
		}
	};


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NullDependency = __webpack_require__(296);
	
	function RequireResolveHeaderDependency(range) {
		if(!Array.isArray(range)) throw new Error("range must be valid");
		NullDependency.call(this);
		this.Class = RequireResolveHeaderDependency;
		this.range = range;
	}
	module.exports = RequireResolveHeaderDependency;
	
	RequireResolveHeaderDependency.prototype = Object.create(NullDependency.prototype);
	RequireResolveHeaderDependency.prototype.constructor = RequireResolveHeaderDependency;
	
	RequireResolveHeaderDependency.Template = function RequireResolveHeaderDependencyTemplate() {};
	
	RequireResolveHeaderDependency.Template.prototype.apply = function(dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "/*require.resolve*/");
	};
	
	RequireResolveHeaderDependency.Template.prototype.applyAsTemplateArgument = function(name, dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "/*require.resolve*/");
	};


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NullDependency = __webpack_require__(296);
	
	function RequireHeaderDependency(range) {
		if(!Array.isArray(range)) throw new Error("range must be valid");
		NullDependency.call(this);
		this.Class = RequireHeaderDependency;
		this.range = range;
	}
	module.exports = RequireHeaderDependency;
	
	RequireHeaderDependency.prototype = Object.create(NullDependency.prototype);
	RequireHeaderDependency.prototype.constructor = RequireHeaderDependency;
	
	RequireHeaderDependency.Template = function RequireHeaderDependencyTemplate() {};
	
	RequireHeaderDependency.Template.prototype.apply = function(dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "__webpack_require__");
	};
	
	RequireHeaderDependency.Template.prototype.applyAsTemplateArgument = function(name, dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "require");
	};


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RequireResolveDependency = __webpack_require__(319);
	var RequireResolveContextDependency = __webpack_require__(320);
	var RequireResolveHeaderDependency = __webpack_require__(322);
	var ContextDependencyHelpers = __webpack_require__(325);
	
	function RequireResolveDependencyParserPlugin(options) {
		this.options = options;
	}
	
	module.exports = RequireResolveDependencyParserPlugin;
	
	RequireResolveDependencyParserPlugin.prototype.apply = function(parser) {
		var options = this.options;
		parser.plugin("call require.resolve", function(expr) {
			return this.applyPluginsBailResult("call require.resolve(Weak)", expr, false);
		});
		parser.plugin("call require.resolveWeak", function(expr) {
			return this.applyPluginsBailResult("call require.resolve(Weak)", expr, true);
		});
		parser.plugin("call require.resolve(Weak)", function(expr, weak) {
			if(expr.arguments.length !== 1) return;
			var param = this.evaluateExpression(expr.arguments[0]);
			var dep;
			if(param.isConditional()) {
				param.options.forEach(function(option) {
					var result = this.applyPluginsBailResult("call require.resolve(Weak):item", expr, option, weak);
					if(result === undefined) {
						this.applyPluginsBailResult("call require.resolve(Weak):context", expr, option, weak);
					}
				}, this);
				dep = new RequireResolveHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			} else {
				var result = this.applyPluginsBailResult("call require.resolve(Weak):item", expr, param, weak);
				if(result === undefined) {
					this.applyPluginsBailResult("call require.resolve(Weak):context", expr, param, weak);
				}
				dep = new RequireResolveHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			}
		});
		parser.plugin("call require.resolve(Weak):item", function(expr, param, weak) {
			if(param.isString()) {
				var dep = new RequireResolveDependency(param.string, param.range);
				dep.loc = expr.loc;
				dep.optional = !!this.scope.inTry;
				dep.weak = weak;
				this.state.current.addDependency(dep);
				return true;
			}
		});
		parser.plugin("call require.resolve(Weak):context", function(expr, param, weak) {
			var dep = ContextDependencyHelpers.create(RequireResolveContextDependency, param.range, param, expr, options);
			if(!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!this.scope.inTry;
			dep.weak = weak;
			this.state.current.addDependency(dep);
			return true;
		});
	};


/***/ },
/* 325 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ContextDependencyHelpers = exports;
	
	ContextDependencyHelpers.create = function(Dep, range, param, expr, options) {
		if(param.isWrapped() && (param.prefix && param.prefix.isString() || param.postfix && param.postfix.isString())) {
			var prefix = param.prefix && param.prefix.isString() ? param.prefix.string : "";
			var postfix = param.postfix && param.postfix.isString() ? param.postfix.string : "";
			var prefixRange = param.prefix && param.prefix.isString() ? param.prefix.range : null;
			var valueRange = [prefixRange ? prefixRange[1] : param.range[0], param.range[1]];
			var idx = prefix.lastIndexOf("/");
			var context = ".";
			if(idx >= 0) {
				context = prefix.substr(0, idx);
				prefix = "." + prefix.substr(idx);
			}
			var regExp = new RegExp("^" +
				prefix.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&") +
				options.wrappedContextRegExp.source +
				postfix.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&") + "$");
			var dep = new Dep(context, options.wrappedContextRecursive, regExp, range, valueRange);
			dep.loc = expr.loc;
			dep.prepend = param.prefix && param.prefix.isString() ? prefix : null;
			dep.critical = options.wrappedContextCritical && "a part of the request of a dependency is an expression";
			return dep;
		} else {
			var dep = new Dep(options.exprContextRequest, options.exprContextRecursive, options.exprContextRegExp, range, param.range);
			dep.loc = expr.loc;
			dep.critical = options.exprContextCritical && "the request of a dependency is an expression";
			return dep;
		}
	};


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConstDependency = __webpack_require__(295);
	var CommonJsRequireDependency = __webpack_require__(313);
	var CommonJsRequireContextDependency = __webpack_require__(316);
	var RequireHeaderDependency = __webpack_require__(323);
	var LocalModuleDependency = __webpack_require__(327);
	var ContextDependencyHelpers = __webpack_require__(325);
	var LocalModulesHelpers = __webpack_require__(328);
	
	function CommonJsRequireDependencyParserPlugin(options) {
		this.options = options;
	}
	
	module.exports = CommonJsRequireDependencyParserPlugin;
	
	CommonJsRequireDependencyParserPlugin.prototype.apply = function(parser) {
		var options = this.options;
		parser.plugin("expression require.cache", function(expr) {
			var dep = new ConstDependency("__webpack_require__.c", expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		});
		parser.plugin("expression require", function(expr) {
			var dep = new CommonJsRequireContextDependency(options.unknownContextRequest, options.unknownContextRecursive, options.unknownContextRegExp, expr.range);
			dep.critical = options.unknownContextCritical && "require function is used in a way in which dependencies cannot be statically extracted";
			dep.loc = expr.loc;
			dep.optional = !!this.scope.inTry;
			this.state.current.addDependency(dep);
			return true;
		});
		parser.plugin("call require", function(expr) {
			if(expr.arguments.length !== 1) return;
			var localModule, dep;
			var param = this.evaluateExpression(expr.arguments[0]);
			if(param.isConditional()) {
				var isExpression = false;
				var prevLength = this.state.current.dependencies.length;
				dep = new RequireHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				param.options.forEach(function(param) {
					var result = this.applyPluginsBailResult("call require:commonjs:item", expr, param);
					if(result === undefined) {
						isExpression = true;
					}
				}, this);
				if(isExpression) {
					this.state.current.dependencies.length = prevLength;
				} else {
					return true;
				}
			}
			if(param.isString() && (localModule = LocalModulesHelpers.getLocalModule(this.state, param.string))) {
				dep = new LocalModuleDependency(localModule, expr.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			} else {
				var result = this.applyPluginsBailResult("call require:commonjs:item", expr, param);
				if(result === undefined) {
					this.applyPluginsBailResult("call require:commonjs:context", expr, param);
				} else {
					dep = new RequireHeaderDependency(expr.callee.range);
					dep.loc = expr.loc;
					this.state.current.addDependency(dep);
				}
				return true;
			}
		});
		parser.plugin("call require:commonjs:item", function(expr, param) {
			if(param.isString()) {
				var dep = new CommonJsRequireDependency(param.string, param.range);
				dep.loc = expr.loc;
				dep.optional = !!this.scope.inTry;
				this.state.current.addDependency(dep);
				return true;
			}
		});
		parser.plugin("call require:commonjs:context", function(expr, param) {
			var dep = ContextDependencyHelpers.create(CommonJsRequireContextDependency, expr.range, param, expr, options);
			if(!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!this.scope.inTry;
			this.state.current.addDependency(dep);
			return true;
		});
	};


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NullDependency = __webpack_require__(296);
	
	function LocalModuleDependency(localModule, range) {
		NullDependency.call(this);
		this.Class = LocalModuleDependency;
		localModule.flagUsed();
		this.localModule = localModule;
		this.range = range;
	}
	module.exports = LocalModuleDependency;
	
	LocalModuleDependency.prototype = Object.create(NullDependency.prototype);
	LocalModuleDependency.prototype.constructor = LocalModuleDependency;
	
	LocalModuleDependency.Template = function LocalModuleDependencyTemplate() {};
	
	LocalModuleDependency.Template.prototype.apply = function(dep, source) {
		if(!dep.range) return;
		source.replace(dep.range[0], dep.range[1] - 1, dep.localModule.variableName());
	};


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var LocalModule = __webpack_require__(329);
	
	var LocalModulesHelpers = exports;
	
	LocalModulesHelpers.addLocalModule = function(state, name) {
		if(!state.localModules) state.localModules = [];
		var m = new LocalModule(state.module, name, state.localModules.length);
		state.localModules.push(m);
		return m;
	};
	
	LocalModulesHelpers.getLocalModule = function(state, name, namedModule) {
		if(!state.localModules) return null;
		if(namedModule) {
			// resolve dependency name relative to the defining named module
			name = lookup(namedModule, name);
		}
		for(var i = 0; i < state.localModules.length; i++) {
			if(state.localModules[i].name === name)
				return state.localModules[i];
		}
		return null;
	};
	
	function lookup(parent, mod) {
		if(mod.charAt(0) !== ".") return mod;
	
		var path = parent.split("/"),
			segs = mod.split("/");
		path.pop();
	
		for(var i = 0; i < segs.length; i++) {
			var seg = segs[i];
			if(seg === "..") path.pop();
			else if(seg !== ".") path.push(seg);
		}
	
		return path.join("/");
	}


/***/ },
/* 329 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function LocalModule(module, name, idx) {
		this.module = module;
		this.name = name;
		this.idx = idx;
		this.used = false;
	}
	module.exports = LocalModule;
	
	LocalModule.prototype.flagUsed = function() {
		this.used = true;
	};
	
	LocalModule.prototype.variableName = function() {
		return "__WEBPACK_LOCAL_MODULE_" + this.idx + "__";
	};


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(180);
	var AMDRequireDependency = __webpack_require__(331);
	var AMDRequireItemDependency = __webpack_require__(333);
	var AMDRequireArrayDependency = __webpack_require__(335);
	var AMDRequireContextDependency = __webpack_require__(336);
	var AMDDefineDependency = __webpack_require__(337);
	var LocalModuleDependency = __webpack_require__(327);
	var ConstDependency = __webpack_require__(295);
	
	var NullFactory = __webpack_require__(297);
	
	var AMDRequireDependenciesBlockParserPlugin = __webpack_require__(338);
	var AMDDefineDependencyParserPlugin = __webpack_require__(340);
	
	var ModuleAliasPlugin = __webpack_require__(304);
	
	var BasicEvaluatedExpression = __webpack_require__(251);
	
	function AMDPlugin(options, amdOptions) {
		this.amdOptions = amdOptions;
		this.options = options;
	}
	module.exports = AMDPlugin;
	
	AMDPlugin.prototype.apply = function(compiler) {
		function setTypeof(expr, value) {
			compiler.parser.plugin("evaluate typeof " + expr, function(expr) {
				return new BasicEvaluatedExpression().setString(value).setRange(expr.range);
			});
			compiler.parser.plugin("typeof " + expr, function(expr) {
				var dep = new ConstDependency(JSON.stringify(value), expr.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			});
		}
	
		function setExpressionToModule(expr, module) {
			compiler.parser.plugin("expression " + expr, function(expr) {
				var dep = new AMDRequireItemDependency(module, expr.range);
				dep.userRequest = expr;
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			});
		}
		var amdOptions = this.amdOptions;
		compiler.plugin("compilation", function(compilation, params) {
			var normalModuleFactory = params.normalModuleFactory;
			var contextModuleFactory = params.contextModuleFactory;
	
			compilation.dependencyFactories.set(AMDRequireDependency, new NullFactory());
			compilation.dependencyTemplates.set(AMDRequireDependency, new AMDRequireDependency.Template());
	
			compilation.dependencyFactories.set(AMDRequireItemDependency, normalModuleFactory);
			compilation.dependencyTemplates.set(AMDRequireItemDependency, new AMDRequireItemDependency.Template());
	
			compilation.dependencyFactories.set(AMDRequireArrayDependency, new NullFactory());
			compilation.dependencyTemplates.set(AMDRequireArrayDependency, new AMDRequireArrayDependency.Template());
	
			compilation.dependencyFactories.set(AMDRequireContextDependency, contextModuleFactory);
			compilation.dependencyTemplates.set(AMDRequireContextDependency, new AMDRequireContextDependency.Template());
	
			compilation.dependencyFactories.set(AMDDefineDependency, new NullFactory());
			compilation.dependencyTemplates.set(AMDDefineDependency, new AMDDefineDependency.Template());
	
			compilation.dependencyFactories.set(LocalModuleDependency, new NullFactory());
			compilation.dependencyTemplates.set(LocalModuleDependency, new LocalModuleDependency.Template());
		});
		compiler.parser.apply(
			new AMDRequireDependenciesBlockParserPlugin(this.options),
			new AMDDefineDependencyParserPlugin(this.options)
		);
		setExpressionToModule("require.amd", "!!webpack amd options");
		setExpressionToModule("define.amd", "!!webpack amd options");
		setExpressionToModule("define", "!!webpack amd define");
		compiler.parser.plugin("expression __webpack_amd_options__", function() {
			return this.state.current.addVariable("__webpack_amd_options__", JSON.stringify(amdOptions));
		});
		compiler.parser.plugin("evaluate typeof define.amd", function(expr) {
			return new BasicEvaluatedExpression().setString(typeof amdOptions).setRange(expr.range);
		});
		compiler.parser.plugin("evaluate typeof require.amd", function(expr) {
			return new BasicEvaluatedExpression().setString(typeof amdOptions).setRange(expr.range);
		});
		compiler.parser.plugin("evaluate Identifier define.amd", function(expr) {
			return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);
		});
		compiler.parser.plugin("evaluate Identifier require.amd", function(expr) {
			return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);
		});
		setTypeof("define", "function");
		compiler.parser.plugin("can-rename define", function() {
			return true;
		});
		compiler.parser.plugin("rename define", function(expr) {
			var dep = new AMDRequireItemDependency("!!webpack amd define", expr.range);
			dep.userRequest = "define";
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return false;
		});
		setTypeof("require", "function");
		compiler.resolvers.normal.apply(
			new ModuleAliasPlugin({
				"amdefine": path.join(__dirname, "..", "..", "buildin", "amd-define.js"),
				"webpack amd options": path.join(__dirname, "..", "..", "buildin", "amd-options.js"),
				"webpack amd define": path.join(__dirname, "..", "..", "buildin", "amd-define.js")
			})
		);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NullDependency = __webpack_require__(296);
	var DepBlockHelpers = __webpack_require__(332);
	
	function AMDRequireDependency(block) {
		NullDependency.call(this);
		this.Class = AMDRequireDependency;
		this.block = block;
	}
	module.exports = AMDRequireDependency;
	
	AMDRequireDependency.prototype = Object.create(NullDependency.prototype);
	AMDRequireDependency.prototype.constructor = AMDRequireDependency;
	
	AMDRequireDependency.Template = function AMDRequireDependencyTemplate() {};
	
	AMDRequireDependency.Template.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		var depBlock = dep.block;
		var wrapper = DepBlockHelpers.getLoadDepBlockWrapper(depBlock, outputOptions, requestShortener, "require");
		if(depBlock.arrayRange && !depBlock.functionRange) {
			if(wrapper) {
				source.replace(depBlock.outerRange[0], depBlock.arrayRange[0] - 1,
					wrapper[0] + "function() {");
				source.replace(depBlock.arrayRange[1], depBlock.outerRange[1] - 1, ";}" + wrapper[1]);
			} else {
				source.replace(depBlock.outerRange[0], depBlock.arrayRange[0] - 1,
					"!/* require */(" + asComment(depBlock.chunkReason));
				source.replace(depBlock.arrayRange[1], depBlock.outerRange[1] - 1, ")");
			}
		} else if(!depBlock.arrayRange && depBlock.functionRange) {
			if(wrapper) {
				source.replace(depBlock.outerRange[0], depBlock.functionRange[0] - 1,
					wrapper[0] + "function(__webpack_require__) {(");
				source.replace(depBlock.functionRange[1], depBlock.outerRange[1] - 1, ".call(exports, __webpack_require__, exports, module));}" + wrapper[1]);
			} else {
				source.replace(depBlock.outerRange[0], depBlock.functionRange[0] - 1,
					"!/* require */(" + asComment(depBlock.chunkReason));
				source.replace(depBlock.functionRange[1], depBlock.outerRange[1] - 1, ".call(exports, __webpack_require__, exports, module))");
			}
		} else if(depBlock.arrayRange && depBlock.functionRange) {
			if(wrapper) {
				source.replace(depBlock.outerRange[0], depBlock.arrayRange[0] - 1,
					wrapper[0] + "function(__webpack_require__) { ");
				source.insert(depBlock.arrayRange[0] + 0.9, "var __WEBPACK_AMD_REQUIRE_ARRAY__ = ");
				source.replace(depBlock.arrayRange[1], depBlock.functionRange[0] - 1, "; (");
				source.insert(depBlock.functionRange[1], ".apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));");
				source.replace(depBlock.functionRange[1], depBlock.outerRange[1] - 1, "}" + wrapper[1]);
			} else {
				source.replace(depBlock.outerRange[0], depBlock.arrayRange[0] - 1,
					"!/* require */(" + asComment(depBlock.chunkReason) + "function() { ");
				source.insert(depBlock.arrayRange[0] + 0.9, "var __WEBPACK_AMD_REQUIRE_ARRAY__ = ");
				source.replace(depBlock.arrayRange[1], depBlock.functionRange[0] - 1, "; (");
				source.insert(depBlock.functionRange[1], ".apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));");
				source.replace(depBlock.functionRange[1], depBlock.outerRange[1] - 1, "}())");
			}
		}
	};
	
	function asComment(str) {
		if(!str) return "";
		return "/* " + str + " */";
	}


/***/ },
/* 332 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var DepBlockHelpers = exports;
	
	DepBlockHelpers.getLoadDepBlockWrapper = function(depBlock, outputOptions, requestShortener, name) {
		if(depBlock.chunks) {
			var chunks = depBlock.chunks.filter(function(chunk) {
				return !chunk.entry && typeof chunk.id === "number";
			});
			if(chunks.length === 1) {
				var chunk = chunks[0];
				return [
					"__webpack_require__.e" + asComment(name) + "(" + chunk.id + "" +
					(outputOptions.pathinfo && depBlock.chunkName ? "/*! " + requestShortener.shorten(depBlock.chunkName) + " */" : "") +
					asComment(depBlock.chunkReason) + ", ",
					")"
				];
			} else if(chunks.length > 0) {
				return [
					"(function(" + asComment(name) + ") {" +
					"var __WEBPACK_REMAINING_CHUNKS__ = " + chunks.length + ";" +
					"var __WEBPACK_CALLBACK__ = function() {" +
					"if(--__WEBPACK_REMAINING_CHUNKS__ < 1) (",
	
					"(__webpack_require__));" +
					"};" +
					chunks.map(function(chunk) {
						return "__webpack_require__.e(" + chunk.id + ", __WEBPACK_CALLBACK__);";
					}).join("") +
					"}())"
				];
			}
		}
	};
	
	function asComment(str) {
		if(!str) return "";
		return "/* " + str + " */";
	}


/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(272);
	
	function AMDRequireItemDependency(request, range) {
		ModuleDependency.call(this, request);
		this.Class = AMDRequireItemDependency;
		this.range = range;
	}
	module.exports = AMDRequireItemDependency;
	
	AMDRequireItemDependency.prototype = Object.create(ModuleDependency.prototype);
	AMDRequireItemDependency.prototype.constructor = AMDRequireItemDependency;
	AMDRequireItemDependency.prototype.type = "amd require";
	
	AMDRequireItemDependency.Template = __webpack_require__(334);


/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleDependencyTemplateAsRequireId() {}
	module.exports = ModuleDependencyTemplateAsRequireId;
	
	ModuleDependencyTemplateAsRequireId.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		if(!dep.range) return;
		var comment = "";
		if(outputOptions.pathinfo) comment = "/*! " + requestShortener.shorten(dep.request) + " */ ";
		if(dep.module)
			var content = "__webpack_require__(" + comment + JSON.stringify(dep.module.id) + ")";
		else
			var content = __webpack_require__(315).module(dep.request);
		source.replace(dep.range[0], dep.range[1] - 1, content);
	};
	
	ModuleDependencyTemplateAsRequireId.prototype.applyAsTemplateArgument = function(name, dep, source) {
		if(!dep.range) return;
		source.replace(dep.range[0], dep.range[1] - 1, "(__webpack_require__(" + name + "))");
	};


/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Dependency = __webpack_require__(228);
	
	function AMDRequireArrayDependency(depsArray, range) {
		Dependency.call(this);
		this.Class = AMDRequireArrayDependency;
		this.depsArray = depsArray;
		this.range = range;
	}
	module.exports = AMDRequireArrayDependency;
	
	AMDRequireArrayDependency.prototype = Object.create(Dependency.prototype);
	AMDRequireArrayDependency.prototype.constructor = AMDRequireArrayDependency;
	AMDRequireArrayDependency.prototype.type = "amd require array";
	
	AMDRequireArrayDependency.Template = function AMDRequireArrayDependencyTemplate() {};
	
	AMDRequireArrayDependency.Template.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		var content = "[" + dep.depsArray.map(function(dep) {
			if(typeof dep === "string") {
				return dep;
			} else {
				var comment = "";
				if(outputOptions.pathinfo) comment = "/*! " + requestShortener.shorten(dep.request) + " */ ";
				if(dep.module)
					return "__webpack_require__(" + comment + JSON.stringify(dep.module.id) + ")";
				else
					return __webpack_require__(315).module(dep.request);
			}
		}).join(", ") + "]";
		source.replace(dep.range[0], dep.range[1] - 1, content);
	};


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ContextDependency = __webpack_require__(317);
	
	function AMDRequireContextDependency(request, recursive, regExp, range, valueRange) {
		ContextDependency.call(this, request, recursive, regExp);
		this.range = range;
		this.valueRange = valueRange;
		this.Class = AMDRequireContextDependency;
	}
	module.exports = AMDRequireContextDependency;
	
	AMDRequireContextDependency.prototype = Object.create(ContextDependency.prototype);
	AMDRequireContextDependency.prototype.constructor = AMDRequireContextDependency;
	AMDRequireContextDependency.prototype.type = "amd require context";
	
	AMDRequireContextDependency.Template = __webpack_require__(318);


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NullDependency = __webpack_require__(296);
	
	function AMDDefineDependency(range, arrayRange, functionRange, objectRange) {
		NullDependency.call(this);
		this.Class = AMDDefineDependency;
		this.range = range;
		this.arrayRange = arrayRange;
		this.functionRange = functionRange;
		this.objectRange = objectRange;
	}
	module.exports = AMDDefineDependency;
	
	AMDDefineDependency.prototype = Object.create(NullDependency.prototype);
	AMDDefineDependency.prototype.constructor = AMDDefineDependency;
	AMDDefineDependency.prototype.type = "amd define";
	
	AMDDefineDependency.Template = function AMDRequireDependencyTemplate() {};
	
	AMDDefineDependency.Template.prototype.apply = function(dep, source) {
		var localModuleVar = dep.localModule && dep.localModule.used && dep.localModule.variableName();
	
		function replace(def, text) {
			if(localModuleVar) text = text.replace(/XXX/g, localModuleVar.replace(/\$/g, "$$$$"));
			if(localModuleVar) def = def.replace(/XXX/g, localModuleVar.replace(/\$/g, "$$$$"));
			var texts = text.split("#");
			if(def)
				source.insert(0, def);
			var current = dep.range[0];
			if(dep.arrayRange) {
				source.replace(current, dep.arrayRange[0] - 1, texts.shift());
				current = dep.arrayRange[1];
			}
			if(dep.objectRange) {
				source.replace(current, dep.objectRange[0] - 1, texts.shift());
				current = dep.objectRange[1];
			} else if(dep.functionRange) {
				source.replace(current, dep.functionRange[0] - 1, texts.shift());
				current = dep.functionRange[1];
			}
			source.replace(current, dep.range[1] - 1, texts.shift());
			if(texts.length > 0)
				throw new Error("Implementation error");
		}
		var branch = (localModuleVar ? "l" : "") + (dep.arrayRange ? "a" : "") + (dep.objectRange ? "o" : "") + (dep.functionRange ? "f" : "");
		var defs = {
			f: ["var __WEBPACK_AMD_DEFINE_RESULT__;", "!(__WEBPACK_AMD_DEFINE_RESULT__ = #.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))"],
			o: ["", "!(module.exports = #)"],
			of: ["var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;", "!(__WEBPACK_AMD_DEFINE_FACTORY__ = (#), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))"],
			af: ["var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;", "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_RESULT__ = #.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))"],
			ao: ["", "!(#, module.exports = #)"],
			aof: ["var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;", "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_FACTORY__ = (#), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))"],
			lf: ["var XXX;", "!(XXX = #.call(exports, __webpack_require__, exports, module))"],
			lo: ["var XXX;", "!(XXX = #)"],
			lof: ["var __WEBPACK_AMD_DEFINE_FACTORY__, XXX;", "!(__WEBPACK_AMD_DEFINE_FACTORY__ = (#), XXX = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__))"],
			laf: ["var __WEBPACK_AMD_DEFINE_ARRAY__, XXX;", "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, XXX = (#.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)))"],
			lao: ["var XXX;", "!(#, XXX = #)"],
			laof: ["var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, XXX;", "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_FACTORY__ = (#), XXX = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__))"]
		};
		replace.apply(null, defs[branch]);
	};


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var AMDRequireItemDependency = __webpack_require__(333);
	var AMDRequireArrayDependency = __webpack_require__(335);
	var AMDRequireContextDependency = __webpack_require__(336);
	var AMDRequireDependenciesBlock = __webpack_require__(339);
	var LocalModuleDependency = __webpack_require__(327);
	var ContextDependencyHelpers = __webpack_require__(325);
	var LocalModulesHelpers = __webpack_require__(328);
	var ConstDependency = __webpack_require__(295);
	
	function AMDRequireDependenciesBlockParserPlugin(options) {
		this.options = options;
	}
	
	module.exports = AMDRequireDependenciesBlockParserPlugin;
	
	AMDRequireDependenciesBlockParserPlugin.prototype.apply = function(parser) {
		var options = this.options;
		parser.plugin("call require", function(expr) {
			switch(expr.arguments.length) {
				case 1:
					var param = this.evaluateExpression(expr.arguments[0]);
					var result;
					var dep = new AMDRequireDependenciesBlock(expr, param.range, null, this.state.module, expr.loc);
					var old = this.state.current;
					this.state.current = dep;
					this.inScope([], function() {
						result = this.applyPluginsBailResult("call require:amd:array", expr, param);
					}.bind(this));
					this.state.current = old;
					if(!result) return;
					this.state.current.addBlock(dep);
					return true;
				case 2:
					var param = this.evaluateExpression(expr.arguments[0]);
					var dep = new AMDRequireDependenciesBlock(expr, param.range, expr.arguments[1].range, this.state.module, expr.loc);
					dep.loc = expr.loc;
					var old = this.state.current;
					this.state.current = dep;
					try {
						var result;
						this.inScope([], function() {
							result = this.applyPluginsBailResult("call require:amd:array", expr, param);
						}.bind(this));
						if(!result) return;
						if(expr.arguments[1].type === "FunctionExpression") {
							this.inScope(expr.arguments[1].params.filter(function(i) {
								return ["require", "module", "exports"].indexOf(i.name) < 0;
							}), function() {
								if(expr.arguments[1].body.type === "BlockStatement")
									this.walkStatement(expr.arguments[1].body);
								else
									this.walkExpression(expr.arguments[1].body);
							}.bind(this));
						}
					} finally {
						this.state.current = old;
						this.state.current.addBlock(dep);
					}
					return true;
			}
		});
		parser.plugin("call require:amd:array", function(expr, param) {
			if(param.isArray()) {
				param.items.forEach(function(param) {
					var result = this.applyPluginsBailResult("call require:amd:item", expr, param);
					if(result === undefined) {
						this.applyPluginsBailResult("call require:amd:context", expr, param);
					}
				}, this);
				return true;
			} else if(param.isConstArray()) {
				var deps = [];
				param.array.forEach(function(request) {
					var dep, localModule;
					if(request === "require") {
						dep = "__webpack_require__";
					} else if(["exports", "module"].indexOf(request) >= 0) {
						dep = request;
					} else if(localModule = LocalModulesHelpers.getLocalModule(this.state, request)) { // eslint-disable-line no-cond-assign
						dep = new LocalModuleDependency(localModule);
						dep.loc = expr.loc;
						this.state.current.addDependency(dep);
					} else {
						dep = new AMDRequireItemDependency(request);
						dep.loc = expr.loc;
						dep.optional = !!this.scope.inTry;
						this.state.current.addDependency(dep);
					}
					deps.push(dep);
				}, this);
				var dep = new AMDRequireArrayDependency(deps, param.range);
				dep.loc = expr.loc;
				dep.optional = !!this.scope.inTry;
				this.state.current.addDependency(dep);
				return true;
			}
		});
		parser.plugin("call require:amd:item", function(expr, param) {
			if(param.isConditional()) {
				param.options.forEach(function(param) {
					var result = this.applyPluginsBailResult("call require:amd:item", expr, param);
					if(result === undefined) {
						this.applyPluginsBailResult("call require:amd:context", expr, param);
					}
				}, this);
				return true;
			} else if(param.isString()) {
				var dep, localModule;
				if(param.string === "require") {
					dep = new ConstDependency("__webpack_require__", param.string);
				} else if(["exports", "module"].indexOf(param.string) >= 0) {
					dep = new ConstDependency(param.string, param.range);
				} else if(localModule = LocalModulesHelpers.getLocalModule(this.state, param.string)) { // eslint-disable-line no-cond-assign
					dep = new LocalModuleDependency(localModule, param.range);
				} else {
					dep = new AMDRequireItemDependency(param.string, param.range);
				}
				dep.loc = expr.loc;
				dep.optional = !!this.scope.inTry;
				this.state.current.addDependency(dep);
				return true;
			}
		});
		parser.plugin("call require:amd:context", function(expr, param) {
			var dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, options);
			if(!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!this.scope.inTry;
			this.state.current.addDependency(dep);
			return true;
		});
	};


/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var AsyncDependenciesBlock = __webpack_require__(266);
	var AMDRequireDependency = __webpack_require__(331);
	
	function AMDRequireDependenciesBlock(expr, arrayRange, functionRange, module, loc) {
		AsyncDependenciesBlock.call(this, null, module, loc);
		this.expr = expr;
		this.outerRange = expr.range;
		this.arrayRange = arrayRange;
		this.functionRange = functionRange;
		this.range = arrayRange && functionRange ? [arrayRange[0], functionRange[1]] :
			arrayRange ? arrayRange :
			functionRange ? functionRange :
			expr.range;
		var dep = new AMDRequireDependency(this);
		dep.loc = loc;
		this.addDependency(dep);
	}
	module.exports = AMDRequireDependenciesBlock;
	
	AMDRequireDependenciesBlock.prototype = Object.create(AsyncDependenciesBlock.prototype);


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var AMDRequireItemDependency = __webpack_require__(333);
	var AMDRequireContextDependency = __webpack_require__(336);
	var ConstDependency = __webpack_require__(295);
	var AMDDefineDependency = __webpack_require__(337);
	var AMDRequireArrayDependency = __webpack_require__(335);
	var LocalModuleDependency = __webpack_require__(327);
	var ContextDependencyHelpers = __webpack_require__(325);
	var LocalModulesHelpers = __webpack_require__(328);
	
	function isBoundFunctionExpression(expr) {
		if(expr.type !== "CallExpression") return false;
		if(expr.callee.type !== "MemberExpression") return false;
		if(expr.callee.computed) return false;
		if(expr.callee.object.type !== "FunctionExpression") return false;
		if(expr.callee.property.type !== "Identifier") return false;
		if(expr.callee.property.name !== "bind") return false;
		return true;
	}
	
	function AMDDefineDependencyParserPlugin(options) {
		this.options = options;
	}
	
	module.exports = AMDDefineDependencyParserPlugin;
	AMDDefineDependencyParserPlugin.prototype.apply = function(parser) {
		var options = this.options;
		parser.plugin("call define", function(expr) {
			var array, fn, obj, namedModule;
			switch(expr.arguments.length) {
				case 1:
					if(expr.arguments[0].type === "FunctionExpression" || isBoundFunctionExpression(expr.arguments[0])) {
						// define(f() {...})
						fn = expr.arguments[0];
					} else if(expr.arguments[0].type === "ObjectExpression") {
						// define({...})
						obj = expr.arguments[0];
					} else {
						// define(expr)
						// unclear if function or object
						obj = fn = expr.arguments[0];
					}
					break;
				case 2:
					if(expr.arguments[0].type === "Literal") {
						namedModule = expr.arguments[0].value;
						// define("...", ...)
						if(expr.arguments[1].type === "FunctionExpression" || isBoundFunctionExpression(expr.arguments[1])) {
							// define("...", f() {...})
							fn = expr.arguments[1];
						} else if(expr.arguments[1].type === "ObjectExpression") {
							// define("...", {...})
							obj = expr.arguments[1];
						} else {
							// define("...", expr)
							// unclear if function or object
							obj = fn = expr.arguments[1];
						}
					} else {
						array = expr.arguments[0];
						if(expr.arguments[1].type === "FunctionExpression" || isBoundFunctionExpression(expr.arguments[1])) {
							// define([...], f() {})
							fn = expr.arguments[1];
						} else if(expr.arguments[1].type === "ObjectExpression") {
							// define([...], {...})
							obj = expr.arguments[1];
						} else {
							// define([...], expr)
							// unclear if function or object
							obj = fn = expr.arguments[1];
						}
					}
					break;
				case 3:
					// define("...", [...], f() {...})
					namedModule = expr.arguments[0].value;
					array = expr.arguments[1];
					if(expr.arguments[2].type === "FunctionExpression" || isBoundFunctionExpression(expr.arguments[2])) {
						// define("...", [...], f() {})
						fn = expr.arguments[2];
					} else if(expr.arguments[2].type === "ObjectExpression") {
						// define("...", [...], {...})
						obj = expr.arguments[2];
					} else {
						// define("...", [...], expr)
						// unclear if function or object
						obj = fn = expr.arguments[2];
					}
					break;
				default:
					return;
			}
			var fnParams = null;
			var fnParamsOffset = 0;
			if(fn) {
				if(fn.type === "FunctionExpression") fnParams = fn.params;
				else if(isBoundFunctionExpression(fn)) {
					fnParams = fn.callee.object.params;
					fnParamsOffset = fn.arguments.length - 1;
					if(fnParamsOffset < 0) fnParamsOffset = 0;
				}
			}
			var fnRenames = Object.create(this.scope.renames);
			var identifiers;
			if(array) {
				identifiers = {};
				var param = this.evaluateExpression(array);
				var result = this.applyPluginsBailResult("call define:amd:array", expr, param, identifiers, namedModule);
				if(!result) return;
				if(fnParams) fnParams = fnParams.slice(fnParamsOffset).filter(function(param, idx) {
					if(identifiers[idx]) {
						fnRenames["$" + param.name] = identifiers[idx];
						return false;
					}
					return true;
				});
			} else {
				identifiers = ["require", "exports", "module"];
				if(fnParams) fnParams = fnParams.slice(fnParamsOffset).filter(function(param, idx) {
					if(identifiers[idx]) {
						fnRenames["$" + param.name] = identifiers[idx];
						return false;
					}
					return true;
				});
			}
			var inTry;
			if(fn && fn.type === "FunctionExpression") {
				inTry = this.scope.inTry;
				this.inScope(fnParams, function() {
					this.scope.renames = fnRenames;
					this.scope.inTry = inTry;
					if(fn.body.type === "BlockStatement")
						this.walkStatement(fn.body);
					else
						this.walkExpression(fn.body);
				}.bind(this));
			} else if(fn && isBoundFunctionExpression(fn)) {
				inTry = this.scope.inTry;
				this.inScope(fn.callee.object.params.filter(function(i) {
					return ["require", "module", "exports"].indexOf(i.name) < 0;
				}), function() {
					this.scope.renames = fnRenames;
					this.scope.inTry = inTry;
					if(fn.callee.object.body.type === "BlockStatement")
						this.walkStatement(fn.callee.object.body);
					else
						this.walkExpression(fn.callee.object.body);
				}.bind(this));
				if(fn.arguments)
					this.walkExpressions(fn.arguments);
			} else if(fn || obj) {
				this.walkExpression(fn || obj);
			}
			var dep = new AMDDefineDependency(expr.range, array ? array.range : null, fn ? fn.range : null, obj ? obj.range : null);
			dep.loc = expr.loc;
			if(namedModule) {
				dep.localModule = LocalModulesHelpers.addLocalModule(this.state, namedModule);
			}
			this.state.current.addDependency(dep);
			return true;
		});
		parser.plugin("call define:amd:array", function(expr, param, identifiers, namedModule) {
			if(param.isArray()) {
				param.items.forEach(function(param, idx) {
					if(param.isString() && ["require", "module", "exports"].indexOf(param.string) >= 0)
						identifiers[idx] = param.string;
					var result = this.applyPluginsBailResult("call define:amd:item", expr, param, namedModule);
					if(result === undefined) {
						this.applyPluginsBailResult("call define:amd:context", expr, param);
					}
				}, this);
				return true;
			} else if(param.isConstArray()) {
				var deps = [];
				param.array.forEach(function(request, idx) {
					var dep, localModule;
					if(request === "require") {
						identifiers[idx] = request;
						dep = "__webpack_require__";
					} else if(["exports", "module"].indexOf(request) >= 0) {
						identifiers[idx] = request;
						dep = request;
					} else if(localModule = LocalModulesHelpers.getLocalModule(this.state, request)) { // eslint-disable-line no-cond-assign
						dep = new LocalModuleDependency(localModule);
						dep.loc = expr.loc;
						this.state.current.addDependency(dep);
					} else {
						dep = new AMDRequireItemDependency(request);
						dep.loc = expr.loc;
						dep.optional = !!this.scope.inTry;
						this.state.current.addDependency(dep);
					}
					deps.push(dep);
				}, this);
				var dep = new AMDRequireArrayDependency(deps, param.range);
				dep.loc = expr.loc;
				dep.optional = !!this.scope.inTry;
				this.state.current.addDependency(dep);
				return true;
			}
		});
		parser.plugin("call define:amd:item", function(expr, param, namedModule) {
			if(param.isConditional()) {
				param.options.forEach(function(param) {
					var result = this.applyPluginsBailResult("call define:amd:item", expr, param);
					if(result === undefined) {
						this.applyPluginsBailResult("call define:amd:context", expr, param);
					}
				}, this);
				return true;
			} else if(param.isString()) {
				var dep, localModule;
				if(param.string === "require") {
					dep = new ConstDependency("__webpack_require__", param.range);
				} else if(["require", "exports", "module"].indexOf(param.string) >= 0) {
					dep = new ConstDependency(param.string, param.range);
				} else if(localModule = LocalModulesHelpers.getLocalModule(this.state, param.string, namedModule)) { // eslint-disable-line no-cond-assign
					dep = new LocalModuleDependency(localModule, param.range);
				} else {
					dep = new AMDRequireItemDependency(param.string, param.range);
				}
				dep.loc = expr.loc;
				dep.optional = !!this.scope.inTry;
				this.state.current.addDependency(dep);
				return true;
			}
		});
		parser.plugin("call define:amd:context", function(expr, param) {
			var dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, options);
			if(!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!this.scope.inTry;
			this.state.current.addDependency(dep);
			return true;
		});
	};


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RequireContextDependency = __webpack_require__(342);
	var ContextElementDependency = __webpack_require__(271);
	
	var RequireContextDependencyParserPlugin = __webpack_require__(343);
	
	function RequireContextPlugin(modulesDirectories, extensions) {
		this.modulesDirectories = modulesDirectories;
		this.extensions = extensions;
	}
	module.exports = RequireContextPlugin;
	
	RequireContextPlugin.prototype.apply = function(compiler) {
		var modulesDirectories = this.modulesDirectories;
		var extensions = this.extensions;
		compiler.plugin("compilation", function(compilation, params) {
			var contextModuleFactory = params.contextModuleFactory;
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(RequireContextDependency, contextModuleFactory);
			compilation.dependencyTemplates.set(RequireContextDependency, new RequireContextDependency.Template());
	
			compilation.dependencyFactories.set(ContextElementDependency, normalModuleFactory);
		});
		compiler.plugin("context-module-factory", function(cmf) {
			cmf.plugin("alternatives", function(items, callback) {
				if(items.length === 0) return callback(null, items);
	
				callback(null, items.map(function(obj) {
					return extensions.filter(function(ext) {
						var l = obj.request.length;
						return l > ext.length && obj.request.substr(l - ext.length, l) === ext;
					}).map(function(ext) {
						var l = obj.request.length;
						return {
							context: obj.context,
							request: obj.request.substr(0, l - ext.length)
						};
					});
				}).reduce(function(a, b) {
					return a.concat(b);
				}, []));
			});
			cmf.plugin("alternatives", function(items, callback) {
				if(items.length === 0) return callback(null, items);
	
				callback(null, items.map(function(obj) {
					for(var i = 0; i < modulesDirectories.length; i++) {
						var dir = modulesDirectories[i];
						var idx = obj.request.indexOf("./" + dir + "/");
						if(idx === 0) {
							obj.request = obj.request.slice(dir.length + 3);
							break;
						}
					}
					return obj;
				}));
			});
		});
		new RequireContextDependencyParserPlugin().apply(compiler.parser);
	};


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ContextDependency = __webpack_require__(317);
	
	function RequireContextDependency(request, recursive, regExp, range) {
		ContextDependency.call(this, request, recursive, regExp);
		this.range = range;
		this.Class = RequireContextDependency;
	}
	module.exports = RequireContextDependency;
	
	RequireContextDependency.prototype = Object.create(ContextDependency.prototype);
	RequireContextDependency.prototype.constructor = RequireContextDependency;
	RequireContextDependency.prototype.type = "require.context";
	
	RequireContextDependency.Template = __webpack_require__(334);


/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var AbstractPlugin = __webpack_require__(344);
	var RequireContextDependency = __webpack_require__(342);
	
	module.exports = AbstractPlugin.create({
		"call require.context": function(expr) {
			var regExp = /^\.\/.*$/;
			var recursive = true;
			switch(expr.arguments.length) {
				case 3:
					var regExpExpr = this.evaluateExpression(expr.arguments[2]);
					if(!regExpExpr.isRegExp()) return;
					regExp = regExpExpr.regExp;
					// falls through
				case 2:
					var recursiveExpr = this.evaluateExpression(expr.arguments[1]);
					if(!recursiveExpr.isBoolean()) return;
					recursive = recursiveExpr.bool;
					// falls through
				case 1:
					var requestExpr = this.evaluateExpression(expr.arguments[0]);
					if(!requestExpr.isString()) return;
					var dep = new RequireContextDependency(requestExpr.string, recursive, regExp, expr.range);
					dep.loc = expr.loc;
					dep.optional = this.scope.inTry;
					this.state.current.addDependency(dep);
					return true;
			}
		}
	});


/***/ },
/* 344 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function AbstractPlugin(plugins) {
		this._plugins = plugins || {};
	}
	module.exports = AbstractPlugin;
	
	AbstractPlugin.create = function(plugins) {
		function Plugin() {
			AbstractPlugin.call(this, plugins);
		}
		Plugin.prototype = Object.create(AbstractPlugin.prototype);
		return Plugin;
	};
	
	AbstractPlugin.prototype.apply = function(object) {
		for(var name in this._plugins) {
			object.plugin(name, this._plugins[name]);
		}
	};


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RequireEnsureItemDependency = __webpack_require__(346);
	var RequireEnsureDependency = __webpack_require__(348);
	var ConstDependency = __webpack_require__(295);
	
	var NullFactory = __webpack_require__(297);
	
	var RequireEnsureDependenciesBlockParserPlugin = __webpack_require__(349);
	
	var BasicEvaluatedExpression = __webpack_require__(251);
	
	function RequireEnsurePlugin() {}
	module.exports = RequireEnsurePlugin;
	
	RequireEnsurePlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation, params) {
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(RequireEnsureItemDependency, normalModuleFactory);
			compilation.dependencyTemplates.set(RequireEnsureItemDependency, new RequireEnsureItemDependency.Template());
	
			compilation.dependencyFactories.set(RequireEnsureDependency, new NullFactory());
			compilation.dependencyTemplates.set(RequireEnsureDependency, new RequireEnsureDependency.Template());
		});
		new RequireEnsureDependenciesBlockParserPlugin().apply(compiler.parser);
		compiler.parser.plugin("evaluate typeof require.ensure", function(expr) {
			return new BasicEvaluatedExpression().setString("function").setRange(expr.range);
		});
		compiler.parser.plugin("typeof require.ensure", function(expr) {
			var dep = new ConstDependency("'function'", expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		});
	};


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(272);
	
	function RequireEnsureItemDependency(request) {
		ModuleDependency.call(this, request);
		this.Class = RequireEnsureItemDependency;
	}
	module.exports = RequireEnsureItemDependency;
	
	RequireEnsureItemDependency.prototype = Object.create(ModuleDependency.prototype);
	RequireEnsureItemDependency.prototype.constructor = RequireEnsureItemDependency;
	RequireEnsureItemDependency.prototype.type = "require.ensure item";
	
	RequireEnsureItemDependency.Template = __webpack_require__(347);


/***/ },
/* 347 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function NullDependencyTemplate() {}
	module.exports = NullDependencyTemplate;
	
	NullDependencyTemplate.prototype.apply = function() {};


/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NullDependency = __webpack_require__(296);
	var DepBlockHelpers = __webpack_require__(332);
	
	function RequireEnsureDependency(block) {
		NullDependency.call(this);
		this.Class = RequireEnsureDependency;
		this.block = block;
	}
	module.exports = RequireEnsureDependency;
	
	RequireEnsureDependency.prototype = Object.create(NullDependency.prototype);
	RequireEnsureDependency.prototype.constructor = RequireEnsureDependency;
	RequireEnsureDependency.prototype.type = "require.ensure";
	
	RequireEnsureDependency.Template = function RequireEnsureDependencyTemplate() {};
	
	RequireEnsureDependency.Template.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		var depBlock = dep.block;
		var wrapper = DepBlockHelpers.getLoadDepBlockWrapper(depBlock, outputOptions, requestShortener, /*require.e*/ "nsure");
		if(!wrapper) wrapper = [
			"!/* require.ensure */(",
			"(__webpack_require__))"
		];
		source.replace(depBlock.expr.range[0], depBlock.expr.arguments[1].range[0] - 1, wrapper[0]);
		source.replace(depBlock.expr.arguments[1].range[1], depBlock.expr.range[1] - 1, wrapper[1]);
	};


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var AbstractPlugin = __webpack_require__(344);
	var RequireEnsureDependenciesBlock = __webpack_require__(350);
	var RequireEnsureItemDependency = __webpack_require__(346);
	var getFunctionExpression = __webpack_require__(351);
	
	module.exports = AbstractPlugin.create({
		"call require.ensure": function(expr) {
			var chunkName = null,
				chunkNameRange = null;
			switch(expr.arguments.length) {
				case 3:
					var chunkNameExpr = this.evaluateExpression(expr.arguments[2]);
					if(!chunkNameExpr.isString()) return;
					chunkNameRange = chunkNameExpr.range;
					chunkName = chunkNameExpr.string;
					// falls through
				case 2:
					var dependenciesExpr = this.evaluateExpression(expr.arguments[0]);
					var dependenciesItems = dependenciesExpr.isArray() ? dependenciesExpr.items : [dependenciesExpr];
					var fnExpressionArg = expr.arguments[1];
					var fnExpression = getFunctionExpression(fnExpressionArg);
	
					if(fnExpression) {
						this.walkExpressions(fnExpression.expressions);
					}
	
					var dep = new RequireEnsureDependenciesBlock(expr, fnExpression ? fnExpression.fn : fnExpressionArg, chunkName, chunkNameRange, this.state.module, expr.loc);
					var old = this.state.current;
					this.state.current = dep;
					try {
						var failed = false;
						this.inScope([], function() {
							dependenciesItems.forEach(function(ee) {
								if(ee.isString()) {
									var edep = new RequireEnsureItemDependency(ee.string, ee.range);
									edep.loc = dep.loc;
									dep.addDependency(edep);
								} else {
									failed = true;
								}
							});
						});
						if(failed) {
							return;
						}
						if(fnExpression) {
							if(fnExpression.fn.body.type === "BlockStatement")
								this.walkStatement(fnExpression.fn.body);
							else
								this.walkExpression(fnExpression.fn.body);
						}
						old.addBlock(dep);
					} finally {
						this.state.current = old;
					}
					if(!fnExpression) {
						this.walkExpression(fnExpressionArg);
					}
					return true;
			}
		}
	});


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var AsyncDependenciesBlock = __webpack_require__(266);
	var RequireEnsureDependency = __webpack_require__(348);
	
	function RequireEnsureDependenciesBlock(expr, fnExpression, chunkName, chunkNameRange, module, loc) {
		AsyncDependenciesBlock.call(this, chunkName, module, loc);
		this.expr = expr;
		var bodyRange = fnExpression && fnExpression.body && fnExpression.body.range;
		this.range = bodyRange && [bodyRange[0] + 1, bodyRange[1] - 1] || null;
		this.chunkNameRange = chunkNameRange;
		var dep = new RequireEnsureDependency(this);
		dep.loc = loc;
		this.addDependency(dep);
	}
	module.exports = RequireEnsureDependenciesBlock;
	
	RequireEnsureDependenciesBlock.prototype = Object.create(AsyncDependenciesBlock.prototype);


/***/ },
/* 351 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(expr) {
		// <FunctionExpression>
		if(expr.type === "FunctionExpression") {
			return {
				fn: expr,
				expressions: []
			};
		}
		// <FunctionExpression>.bind(<Expression>)
		if(expr.type === "CallExpression" &&
			expr.callee.type === "MemberExpression" &&
			expr.callee.object.type === "FunctionExpression" &&
			expr.callee.property.type === "Identifier" &&
			expr.callee.property.name === "bind" &&
			expr.arguments.length === 1) {
			return {
				fn: expr.callee.object,
				expressions: [expr.arguments[0]]
			};
		}
		// (function(_this) {return <FunctionExpression>})(this) (Coffeescript)
		if(expr.type === "CallExpression" &&
			expr.callee.type === "FunctionExpression" &&
			expr.callee.body.type === "BlockStatement" &&
			expr.arguments.length === 1 &&
			expr.arguments[0].type === "ThisExpression" &&
			expr.callee.body.body &&
			expr.callee.body.body.length === 1 &&
			expr.callee.body.body[0].type === "ReturnStatement" &&
			expr.callee.body.body[0].argument &&
			expr.callee.body.body[0].argument.type === "FunctionExpression") {
			return {
				fn: expr.callee.body.body[0].argument,
				expressions: []
			};
		}
	};


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RequireIncludeDependency = __webpack_require__(353);
	var RequireIncludeDependencyParserPlugin = __webpack_require__(354);
	var ConstDependency = __webpack_require__(295);
	
	var BasicEvaluatedExpression = __webpack_require__(251);
	
	function RequireIncludePlugin() {}
	module.exports = RequireIncludePlugin;
	
	RequireIncludePlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation, params) {
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(RequireIncludeDependency, normalModuleFactory);
			compilation.dependencyTemplates.set(RequireIncludeDependency, new RequireIncludeDependency.Template());
		});
		new RequireIncludeDependencyParserPlugin().apply(compiler.parser);
		compiler.parser.plugin("evaluate typeof require.include", function(expr) {
			return new BasicEvaluatedExpression().setString("function").setRange(expr.range);
		});
		compiler.parser.plugin("typeof require.include", function(expr) {
			var dep = new ConstDependency("'function'", expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		});
	};


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(272);
	
	function RequireIncludeDependency(request, range) {
		ModuleDependency.call(this, request);
		this.Class = RequireIncludeDependency;
		this.range = range;
	}
	module.exports = RequireIncludeDependency;
	
	RequireIncludeDependency.prototype = Object.create(ModuleDependency.prototype);
	RequireIncludeDependency.prototype.constructor = RequireIncludeDependency;
	RequireIncludeDependency.prototype.type = "require.include";
	
	RequireIncludeDependency.Template = function RequireIncludeDependencyTemplate() {};
	
	RequireIncludeDependency.Template.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		var comment = "";
		if(outputOptions.pathinfo && dep.module)
			comment = "/*! require.include " + requestShortener.shorten(dep.request) + " */";
		source.replace(dep.range[0], dep.range[1] - 1,
			"undefined" + comment);
	};


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var AbstractPlugin = __webpack_require__(344);
	var RequireIncludeDependency = __webpack_require__(353);
	
	module.exports = AbstractPlugin.create({
		"call require.include": function(expr) {
			if(expr.arguments.length !== 1) return;
			var param = this.evaluateExpression(expr.arguments[0]);
			if(!param.isString()) return;
			var dep = new RequireIncludeDependency(param.string, expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		}
	});


/***/ },
/* 355 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function hasModule(chunk, module, checkedChunks) {
		if(chunk.modules.indexOf(module) >= 0) return [chunk];
		if(chunk.entry) return false;
		return allHaveModule(chunk.parents.filter(function(c) {
			return checkedChunks.indexOf(c) < 0;
		}), module, checkedChunks);
	}
	
	function allHaveModule(someChunks, module, checkedChunks) {
		if(!checkedChunks) checkedChunks = [];
		var chunks = [];
		for(var i = 0; i < someChunks.length; i++) {
			checkedChunks.push(someChunks[i]);
			var subChunks = hasModule(someChunks[i], module, checkedChunks);
			if(!subChunks) return false;
			addToSet(chunks, subChunks);
		}
		return chunks;
	}
	
	function addToSet(set, items) {
		items.forEach(function(item) {
			if(set.indexOf(item) < 0)
				set.push(item);
		});
	}
	
	function RemoveParentModulesPlugin() {}
	module.exports = RemoveParentModulesPlugin;
	
	RemoveParentModulesPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin(["optimize-chunks", "optimize-extracted-chunks"], function(chunks) {
				chunks.forEach(function(chunk) {
					chunk.modules.slice().forEach(function(module) {
						if(chunk.entry) return;
						var parentChunksWithModule = allHaveModule(chunk.parents, module);
						if(parentChunksWithModule) {
							module.rewriteChunkInReasons(chunk, parentChunksWithModule);
							chunk.removeModule(module);
						}
					});
				});
			});
		});
	};


/***/ },
/* 356 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function RemoveEmptyChunksPlugin() {}
	module.exports = RemoveEmptyChunksPlugin;
	
	RemoveEmptyChunksPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin(["optimize-chunks", "optimize-extracted-chunks"], function(chunks) {
				chunks.filter(function(chunk) {
					return chunk.isEmpty() && !chunk.initial;
				}).forEach(function(chunk) {
					chunk.remove("empty");
					chunks.splice(chunks.indexOf(chunk), 1);
				});
			});
		});
	};


/***/ },
/* 357 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function MergeDuplicateChunksPlugin() {}
	module.exports = MergeDuplicateChunksPlugin;
	
	function getChunkIdentifier(chunk) {
		return chunk.modules.map(function(m) {
			return m.identifier();
		}).sort().join(", ");
	}
	
	MergeDuplicateChunksPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("optimize-chunks", function(chunks) {
				var map = {};
				chunks.slice().forEach(function(chunk) {
					if(chunk.initial) return;
					var ident = getChunkIdentifier(chunk);
					if(map[ident]) {
						if(map[ident].integrate(chunk, "duplicate"))
							chunks.splice(chunks.indexOf(chunk), 1);
						return;
					}
					map[ident] = chunk;
				});
			});
		});
	};


/***/ },
/* 358 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function FlagIncludedChunksPlugin() {}
	module.exports = FlagIncludedChunksPlugin;
	
	FlagIncludedChunksPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("optimize-chunk-ids", function(chunks) {
				chunks.forEach(function(chunkA) {
					chunks.forEach(function(chunkB) {
						if(chunkA === chunkB) return;
						// is chunkB in chunkA?
						if(chunkA.modules.length < chunkB.modules.length) return;
						for(var i = 0; i < chunkB.modules.length; i++) {
							if(chunkA.modules.indexOf(chunkB.modules[i]) < 0) return;
						}
						chunkA.ids.push(chunkB.id);
					});
				});
			});
		});
	};


/***/ },
/* 359 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function UnsafeCachePlugin(regExps, cache) {
		this.regExps = regExps || [/./];
		if(this.regExps === true) this.regExps = [/./];
		else if(!Array.isArray(this.regExps)) this.regExps = [this.regExps];
		this.cache = cache || {};
	}
	module.exports = UnsafeCachePlugin;
	
	UnsafeCachePlugin.prototype.apply = function(resolver) {
		var oldResolve = resolver.resolve;
		var regExps = this.regExps;
		var cache = this.cache;
		resolver.resolve = function resolve(context, request, callback) {
			var id = context + "->" + request;
			if(cache[id]) {
				// From cache
				return callback(null, cache[id]);
			}
			oldResolve.call(resolver, context, request, function(err, result) {
				if(err) return callback(err);
				var doCache = regExps.some(function(regExp) {
					return regExp.test(result.path);
				});
				if(!doCache) return callback(null, result);
				callback(null, cache[id] = result);
			});
		};
	};


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var createInnerCallback = __webpack_require__(253);
	var popPathSeqment = __webpack_require__(361);
	
	function ModulesInDirectoriesPlugin(moduleType, directories) {
		this.moduleType = moduleType;
		this.directories = directories;
	}
	module.exports = ModulesInDirectoriesPlugin;
	
	ModulesInDirectoriesPlugin.prototype.apply = function(resolver) {
		var moduleType = this.moduleType;
		var directories = this.directories;
		resolver.plugin("module", function(request, callback) {
			var fs = this.fileSystem;
			var paths = [request.path];
			var addr = [request.path];
			var pathSeqment = popPathSeqment(addr);
			var topLevelCallback = callback;
			while(pathSeqment) {
				paths.push(addr[0]);
				pathSeqment = popPathSeqment(addr);
			}
			var addrs = paths.map(function(p) {
				return directories.map(function(d) {
					return this.join(p, d);
				}, this);
			}, this).reduce(function(array, p) {
				array.push.apply(array, p);
				return array;
			}, []);
			this.forEachBail(addrs, function(addr, callback) {
				fs.stat(addr, function(err, stat) {
					if(!err && stat && stat.isDirectory()) {
						this.applyPluginsParallelBailResult("module-" + moduleType, {
							path: addr,
							request: request.request,
							query: request.query,
							directory: request.directory
						}, createInnerCallback(function(err, result) {
							if(err) return callback(err);
							if(!result) return callback();
							return callback(null, result);
						}, topLevelCallback, "looking for modules in " + addr));
						return;
					}
					return callback();
				}.bind(this));
			}.bind(this), function(err, result) {
				if(err) return callback(err);
				if(!result) return callback();
				return callback(null, result);
			});
		});
	};


/***/ },
/* 361 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function popPathSeqment(pathInArray) {
		var i = pathInArray[0].lastIndexOf("/"),
			j = pathInArray[0].lastIndexOf("\\");
		var p = i < 0 ? j : j < 0 ? i : i < j ? j : i;
		if(p < 0) return null;
		var s = pathInArray[0].substr(p+1);
		pathInArray[0] = pathInArray[0].substr(0, p || 1);
		return s;
	};


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var createInnerCallback = __webpack_require__(253);
	
	function ModulesInRootPlugin(moduleType, path) {
		this.moduleType = moduleType;
		this.path = path;
	}
	module.exports = ModulesInRootPlugin;
	
	ModulesInRootPlugin.prototype.apply = function(resolver) {
		var moduleType = this.moduleType;
		var path = this.path;
		resolver.plugin("module", function(request, callback) {
			this.applyPluginsParallelBailResult("module-" + moduleType, {
				path: path,
				request: request.request,
				query: request.query,
				directory: request.directory
			}, createInnerCallback(function innerCallback(err, result) {
				if(err) return callback(err);
				if(!result) return callback();
				return callback(null, result);
			}, callback, "looking for modules in " + path));
		});
	};


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var createInnerCallback = __webpack_require__(253);
	
	function ModuleTemplatesPlugin(moduleType, templates, targetModuleType) {
		this.moduleType = moduleType;
		this.targetModuleType = targetModuleType;
		this.templates = templates;
	}
	module.exports = ModuleTemplatesPlugin;
	
	ModuleTemplatesPlugin.prototype.apply = function(resolver) {
		var templates = this.templates;
		var targetModuleType = this.targetModuleType;
		resolver.plugin("module-" + this.moduleType, function(request, callback) {
			var fs = this.fileSystem;
			var topLevelCallback = callback;
			var i = request.request.indexOf("/"),
				j = request.request.indexOf("\\");
			var p = i < 0 ? j : j < 0 ? i : i < j ? i : j;
			var moduleName, remainingRequest;
			if(p < 0) {
				moduleName = request.request;
				remainingRequest = "";
			} else {
				moduleName = request.request.substr(0, p);
				remainingRequest = request.request.substr(p);
			}
			this.forEachBail(templates, function(template, callback) {
				var moduleFinalName = template.replace(/\*/g, moduleName);
				this.applyPluginsParallelBailResult("module-" + targetModuleType, {
					path: request.path,
					request: moduleFinalName + remainingRequest,
					query: request.query,
					directory: request.directory
				}, createInnerCallback(function(err, result) {
					if(err) return callback(err);
					if(!result) return callback();
					return callback(null, result);
				}, topLevelCallback, "module variation " + moduleFinalName));
			}.bind(this), callback);
		});
	};


/***/ },
/* 364 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleAsFilePlugin(moduleType) {
		this.moduleType = moduleType;
	}
	module.exports = ModuleAsFilePlugin;
	
	ModuleAsFilePlugin.prototype.apply = function(resolver) {
		resolver.plugin("module-" + this.moduleType, function(request, callback) {
			var fs = this.fileSystem;
			var i = request.request.indexOf("/"),
				j = request.request.indexOf("\\");
			if(i >= 0 || j >= 0 || request.directory) return callback();
			return this.doResolve("file", request, callback, true);
		});
	};


/***/ },
/* 365 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleAsDirectoryPlugin(moduleType) {
		this.moduleType = moduleType;
	}
	module.exports = ModuleAsDirectoryPlugin;
	
	ModuleAsDirectoryPlugin.prototype.apply = function(resolver) {
		resolver.plugin("module-" + this.moduleType, function(request, callback) {
			var fs = this.fileSystem;
			var i = request.request.indexOf("/"),
				j = request.request.indexOf("\\");
			var p = i < 0 ? j : j < 0 ? i : i < j ? i : j;
			var moduleName, remainingRequest;
			if(p < 0) {
				moduleName = request.request;
				remainingRequest = "";
			} else {
				moduleName = request.request.substr(0, p);
				remainingRequest = request.request.substr(p+1);
			}
			var modulePath = this.join(request.path, moduleName);
			fs.stat(modulePath, function(err, stat) {
				if(err || !stat) {
					if(callback.missing)
						callback.missing.push(modulePath);
					if(callback.log) callback.log(modulePath + " doesn't exist (module as directory)");
					return callback();
				}
				if(stat.isDirectory()) {
					return this.doResolve(request.directory ? "directory" : ["file", "directory"], {
						path: modulePath,
						request: remainingRequest,
						query: request.query
					}, callback, true);
				}
				if(callback.log) callback.log(modulePath + " is not a directory (module as directory)");
				return callback();
			}.bind(this));
		});
	};


/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var createInnerCallback = __webpack_require__(253);
	
	function DirectoryDefaultFilePlugin(files) {
		this.files = files;
	}
	module.exports = DirectoryDefaultFilePlugin;
	
	DirectoryDefaultFilePlugin.prototype.apply = function(resolver) {
		var files = this.files;
		resolver.plugin("directory", function(request, callback) {
			var fs = this.fileSystem;
			var topLevelCallback = callback;
			var directory = this.join(request.path, request.request);
			fs.stat(directory, function(err, stat) {
				if(err || !stat) {
					if(callback.log) callback.log(directory + " doesn't exist (directory default file)");
					return callback();
				}
				if(!stat.isDirectory()) {
					if(callback.log) callback.log(directory + " is not a directory (directory default file)");
					return callback();
				}
				this.forEachBail(files, function(file, callback) {
					this.doResolve("file", {
						path: directory,
						query: request.query,
						request: file
					}, createInnerCallback(function(err, result) {
						if(!err && result) return callback(result);
						return callback();
					}, topLevelCallback, "directory default file " + file));
				}.bind(this), function(result) {
					if(!result) return callback();
					return callback(null, result);
				});
			}.bind(this));
		});
	};

/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var createInnerCallback = __webpack_require__(253);
	
	function DirectoryDescriptionFilePlugin(filename, fields) {
		this.filename = filename;
		this.fields = fields;
	}
	module.exports = DirectoryDescriptionFilePlugin;
	
	DirectoryDescriptionFilePlugin.prototype.apply = function(resolver) {
		var filename = this.filename;
		var fields = this.fields;
		resolver.plugin("directory", function(request, callback) {
			var fs = this.fileSystem;
			var directory = this.join(request.path, request.request);
			var descriptionFilePath = this.join(directory, filename);
			fs.readFile(descriptionFilePath, function(err, content) {
				if(err) {
					if(callback.log)
						callback.log(descriptionFilePath + " doesn't exist (directory description file)");
					return callback();
				}
				content = content.toString("utf-8");
				try {
					content = JSON.parse(content);
				} catch(e) {
					if(callback.log)
						callback.log(descriptionFilePath + " (directory description file): " + e);
					else
						e.message = descriptionFilePath + " (directory description file): " + e;
					return callback(e);
				}
				var mainModules = [];
				for(var i = 0; i < fields.length; i++) {
					if(Array.isArray(fields[i])) {
						var current = content;
						for(var j = 0; j < fields[i].length; j++) {
							if(current === null || typeof current !== "object") {
								current = null;
								break;
							}
							var field = fields[i][j];
							current = current[field];
						}
						if(typeof current === "string") {
							mainModules.push(current);
							continue;
						}
					} else {
						var field = fields[i];
						if(typeof content[field] === "string") {
							mainModules.push(content[field]);
							continue;
						}
					}
				}
				(function next() {
					if(mainModules.length == 0) return callback();
					var mainModule = mainModules.shift();
					return this.doResolve(["file", "directory"], {
						path: directory,
						query: request.query,
						request: mainModule
					}, createInnerCallback(function(err, result) {
						if(!err && result) return callback(null, result);
						return next.call(this);
					}.bind(this), callback, "use " + mainModule + " from " + filename));
				}.call(this))
			}.bind(this));
		});
	};

/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var createInnerCallback = __webpack_require__(253);
	
	function DirectoryDescriptionFileFieldAliasPlugin(filename, field) {
		this.filename = filename;
		this.field = field;
	}
	module.exports = DirectoryDescriptionFileFieldAliasPlugin;
	
	function findDescriptionFileField(resolver, directory, filename, field, callback) {
		(function findDescriptionFile() {
			var descriptionFilePath = resolver.join(directory, filename);
			resolver.fileSystem.readFile(descriptionFilePath, function(err, content) {
				if(err) {
					directory = cdUp(directory);
					if(!directory) {
						return callback();
					} else {
						return findDescriptionFile();
					}
				}
				try {
					content = JSON.parse(content);
				} catch(e) {
					if(callback.log)
						callback.log(descriptionFilePath + " (directory description file): " + e);
					else
						e.message = descriptionFilePath + " (directory description file): " + e;
					return callback(e);
				}
				var fieldData;
				if(Array.isArray(field)) {
					var current = content;
					for(var j = 0; j < field.length; j++) {
						if(current === null || typeof current !== "object") {
							current = null;
							break;
						}
						current = current[field[j]];
					}
					if(typeof current === "object") {
						fieldData = current;
					}
				} else {
					if(typeof content[field] === "object") {
						fieldData = content[field];
					}
				}
				if(!fieldData) return callback();
				callback(null, fieldData, directory);
			});
		}());
	}
	
	function cdUp(directory) {
		if(directory === "/") return null;
		var i = directory.lastIndexOf("/"),
			j = directory.lastIndexOf("\\");
		var p = i < 0 ? j : j < 0 ? i : i < j ? j : i;
		if(p < 0) return null;
		return directory.substr(0, p || 1);
	}
	
	DirectoryDescriptionFileFieldAliasPlugin.prototype.apply = function(resolver) {
		var filename = this.filename;
		var field = this.field;
		resolver.plugin("module", function(request, callback) {
			var directory = request.path;
			var moduleName = request.request;
			findDescriptionFileField(this, directory, filename, field, function(err, fieldData, directory) {
				if(err) return callback(err);
				if(!fieldData) return callback();
				var data = fieldData[moduleName];
				if(data === moduleName) return callback();
				if(data === false) return callback(null, {
					path: false,
					resolved: true
				});
				if(!data) return callback();
				var newRequest = this.parse(data);
				var obj = {
					path: directory,
					request: newRequest.path,
					query: newRequest.query,
					directory: newRequest.directory
				};
				var newCallback = createInnerCallback(callback, callback, "aliased from directory description file " + this.join(directory, filename) + " with mapping " + JSON.stringify(moduleName));
				if(newRequest.module) return this.doResolve("module", obj, newCallback);
				if(newRequest.directory) return this.doResolve("directory", obj, newCallback);
				return this.doResolve(["file", "directory"], obj, newCallback);
			}.bind(this));
		});
		resolver.plugin("result", function(request, callback) {
			var directory = cdUp(request.path);
			var requestPath = request.path;
			findDescriptionFileField(this, directory, filename, field, function(err, fieldData, directory) {
				if(err) return callback(err);
				if(!fieldData) return callback();
				var relative = requestPath.substr(directory.length+1).replace(/\\/g, "/");
				if(typeof fieldData[relative] !== "undefined")
					var data = fieldData[relative];
				else if(typeof fieldData["./" + relative] !== "undefined")
					var data = fieldData["./" + relative];
				if(data === relative || data === "./" + relative) return callback();
				if(data === false) return callback(null, {
					path: false,
					resolved: true
				});
				if(!data) return callback();
				var newRequest = this.parse(data);
				var obj = {
					path: directory,
					request: newRequest.path,
					query: newRequest.query,
					directory: newRequest.directory
				};
				var newCallback = createInnerCallback(callback, callback, "aliased from directory description file " + this.join(directory, filename) + " with mapping " + JSON.stringify(relative));
				if(newRequest.module) return this.doResolve("module", obj, newCallback);
				if(newRequest.directory) return this.doResolve("directory", obj, newCallback);
				return this.doResolve(["file", "directory"], obj, newCallback);
			}.bind(this));
		});
	};


/***/ },
/* 369 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function FileAppendPlugin(appendings) {
		this.appendings = appendings;
	}
	module.exports = FileAppendPlugin;
	
	FileAppendPlugin.prototype.apply = function(resolver) {
		var appendings = this.appendings;
		resolver.plugin("file", function(request, callback) {
			var fs = this.fileSystem;
			var addr = this.join(request.path, request.request);
			var addrs = appendings.map(function(a) { return addr + a });
			var log = callback.log;
			var missing = callback.missing;
			this.forEachBail(addrs, function(addr, callback) {
				fs.stat(addr, function(err, stat) {
					if(!err && stat && stat.isFile())
						return callback(addr);
					if(missing && err)
						missing.push(addr);
					if(log) {
						if(err) log(addr + " doesn't exist");
						else log(addr + " is not a file");
					}
					return callback();
				});
			}, function(validAddr) {
				if(!validAddr) return callback();
				return this.doResolve("result", {
					path: validAddr,
					query: request.query,
					file: true,
					resolved: true
				}, callback);
			}.bind(this));
		});
	};

/***/ },
/* 370 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function DirectoryResultPlugin(files) {
		this.files = files;
	}
	module.exports = DirectoryResultPlugin;
	
	DirectoryResultPlugin.prototype.apply = function(resolver) {
		var files = this.files;
		resolver.plugin("directory", function(request, callback) {
			var fs = this.fileSystem;
			var directory = this.join(request.path, request.request);
			fs.stat(directory, function(err, stat) {
				if(!err && stat && stat.isDirectory()) {
					return this.doResolve("result", {
						path: directory,
						query: request.query,
						directory: true,
						resolved: true
					}, callback);
				}
				if(callback.log) {
					if(err) callback.log(directory + " doesn't exist");
					else callback.log(directory + " is not a directory");
				}
				return callback();
			}.bind(this));
		});
	};

/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var popPathSeqment = __webpack_require__(361);
	
	function ResultSymlinkPlugin(appendings) {
	}
	module.exports = ResultSymlinkPlugin;
	
	ResultSymlinkPlugin.prototype.apply = function(resolver) {
		resolver.plugin("result", function pluginMethod(request, callback) {
			var fs = this.fileSystem;
			var paths = [request.path];
			var pathSeqments = [];
			var addr = [request.path];
			var pathSeqment = popPathSeqment(addr);
			while(pathSeqment) {
				pathSeqments.push(pathSeqment);
				paths.push(addr[0]);
				pathSeqment = popPathSeqment(addr);
			}
			pathSeqments.push(paths[paths.length-1]);
			var log = callback.log;
			var missing = callback.missing;
			var containsSymlink = false;
			this.forEachBail(paths.map(function(_, i) { return i; }), function(idx, callback) {
				fs.readlink(paths[idx], function(err, result) {
					if(!err && result) {
						pathSeqments[idx] = result;
						containsSymlink = true;
						// Shortcut when absolute symlink found
						if(/^(\/|[a-zA-z]:($|\\))/.test(result))
							return callback(null, idx);
					}
					callback();
				});
			}, function(err, idx) {
				if(!containsSymlink) return callback();
				var resultSeqments = typeof idx === "number" ? pathSeqments.slice(0, idx+1) : pathSeqments.slice();
				var result = resultSeqments.reverse().reduce(function(a, b) {
					return this.join(a, b);
				}.bind(this));
				log("resolved symlink to " + result);
				request.path = result;
				pluginMethod.call(this, request, callback);
			}.bind(this));
		});
	};

/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var JsonpMainTemplatePlugin = __webpack_require__(373);
	var JsonpChunkTemplatePlugin = __webpack_require__(375);
	var JsonpHotUpdateChunkTemplatePlugin = __webpack_require__(376);
	
	function JsonpTemplatePlugin() {}
	module.exports = JsonpTemplatePlugin;
	JsonpTemplatePlugin.prototype.apply = function(compiler) {
		compiler.plugin("this-compilation", function(compilation) {
			compilation.mainTemplate.apply(new JsonpMainTemplatePlugin());
			compilation.chunkTemplate.apply(new JsonpChunkTemplatePlugin());
			compilation.hotUpdateChunkTemplate.apply(new JsonpHotUpdateChunkTemplatePlugin());
		});
	};


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Template = __webpack_require__(224);
	
	function JsonpMainTemplatePlugin() {}
	module.exports = JsonpMainTemplatePlugin;
	
	JsonpMainTemplatePlugin.prototype.constructor = JsonpMainTemplatePlugin;
	JsonpMainTemplatePlugin.prototype.apply = function(mainTemplate) {
		mainTemplate.plugin("local-vars", function(source, chunk) {
			if(chunk.chunks.length > 0) {
				return this.asString([
					source,
					"",
					"// object to store loaded and loading chunks",
					"// \"0\" means \"already loaded\"",
					"// Array means \"loading\", array contains callbacks",
					"var installedChunks = {",
					this.indent(
						chunk.ids.map(function(id) {
							return id + ":0";
						}).join(",\n")
					),
					"};"
				]);
			}
			return source;
		});
		mainTemplate.plugin("require-ensure", function(_, chunk, hash) {
			var filename = this.outputOptions.filename || "bundle.js";
			var chunkFilename = this.outputOptions.chunkFilename || "[id]." + filename;
			var chunkMaps = chunk.getChunkMaps();
			var crossOriginLoading = this.outputOptions.crossOriginLoading;
			return this.asString([
				"// \"0\" is the signal for \"already loaded\"",
				"if(installedChunks[chunkId] === 0)",
				this.indent("return callback.call(null, " + this.requireFn + ");"),
				"",
				"// an array means \"currently loading\".",
				"if(installedChunks[chunkId] !== undefined) {",
				this.indent("installedChunks[chunkId].push(callback);"),
				"} else {",
				this.indent([
					"// start chunk loading",
					"installedChunks[chunkId] = [callback];",
					"var head = document.getElementsByTagName('head')[0];",
					"var script = document.createElement('script');",
					"script.type = 'text/javascript';",
					"script.charset = 'utf-8';",
					"script.async = true;",
					crossOriginLoading ? "script.crossOrigin = '" + crossOriginLoading + "';" : "",
					"script.src = " + this.requireFn + ".p + " +
					this.applyPluginsWaterfall("asset-path", JSON.stringify(chunkFilename), {
						hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
						hashWithLength: function(length) {
							return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
						}.bind(this),
						chunk: {
							id: "\" + chunkId + \"",
							hash: "\" + " + JSON.stringify(chunkMaps.hash) + "[chunkId] + \"",
							hashWithLength: function(length) {
								var shortChunkHashMap = {};
								Object.keys(chunkMaps.hash).forEach(function(chunkId) {
									if(typeof chunkMaps.hash[chunkId] === "string")
										shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length);
								});
								return "\" + " + JSON.stringify(shortChunkHashMap) + "[chunkId] + \"";
							},
							name: "\" + (" + JSON.stringify(chunkMaps.name) + "[chunkId]||chunkId) + \""
						}
					}) + ";",
					"head.appendChild(script);"
				]),
				"}"
			]);
		});
		mainTemplate.plugin("bootstrap", function(source, chunk, hash) {
			if(chunk.chunks.length > 0) {
				var jsonpFunction = this.outputOptions.jsonpFunction || Template.toIdentifier("webpackJsonp" + (this.outputOptions.library || ""));
				return this.asString([
					source,
					"",
					"// install a JSONP callback for chunk loading",
					"var parentJsonpFunction = window[" + JSON.stringify(jsonpFunction) + "];",
					"window[" + JSON.stringify(jsonpFunction) + "] = function webpackJsonpCallback(chunkIds, moreModules) {",
					this.indent([
						"// add \"moreModules\" to the modules object,",
						"// then flag all \"chunkIds\" as loaded and fire callback",
						"var moduleId, chunkId, i = 0, callbacks = [];",
						"for(;i < chunkIds.length; i++) {",
						this.indent([
							"chunkId = chunkIds[i];",
							"if(installedChunks[chunkId])",
							this.indent("callbacks.push.apply(callbacks, installedChunks[chunkId]);"),
							"installedChunks[chunkId] = 0;"
						]),
						"}",
						"for(moduleId in moreModules) {",
						this.indent(this.renderAddModule(hash, chunk, "moduleId", "moreModules[moduleId]")),
						"}",
						"if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);",
						"while(callbacks.length)",
						this.indent("callbacks.shift().call(null, " + this.requireFn + ");"), (this.entryPointInChildren(chunk) ? [
							"if(moreModules[0]) {",
							this.indent([
								"installedModules[0] = 0;",
								"return " + this.requireFn + "(0);"
							]),
							"}"
						] : "")
					]),
					"};"
				]);
			}
			return source;
		});
		mainTemplate.plugin("hot-bootstrap", function(source, chunk, hash) {
			var hotUpdateChunkFilename = this.outputOptions.hotUpdateChunkFilename;
			var hotUpdateMainFilename = this.outputOptions.hotUpdateMainFilename;
			var hotUpdateFunction = this.outputOptions.hotUpdateFunction || Template.toIdentifier("webpackHotUpdate" + (this.outputOptions.library || ""));
			var currentHotUpdateChunkFilename = this.applyPluginsWaterfall("asset-path", JSON.stringify(hotUpdateChunkFilename), {
				hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
				hashWithLength: function(length) {
					return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
				}.bind(this),
				chunk: {
					id: "\" + chunkId + \""
				}
			});
			var currentHotUpdateMainFilename = this.applyPluginsWaterfall("asset-path", JSON.stringify(hotUpdateMainFilename), {
				hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
				hashWithLength: function(length) {
					return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
				}.bind(this)
			});
	
			return source + "\n" +
				"var parentHotUpdateCallback = this[" + JSON.stringify(hotUpdateFunction) + "];\n" +
				"this[" + JSON.stringify(hotUpdateFunction) + "] = " + Template.getFunctionContent(__webpack_require__(374))
				.replace(/\$require\$/g, this.requireFn)
				.replace(/\$hotMainFilename\$/g, currentHotUpdateMainFilename)
				.replace(/\$hotChunkFilename\$/g, currentHotUpdateChunkFilename)
				.replace(/\$hash\$/g, JSON.stringify(hash));
		});
		mainTemplate.plugin("hash", function(hash) {
			hash.update("jsonp");
			hash.update("4");
			hash.update(this.outputOptions.filename + "");
			hash.update(this.outputOptions.chunkFilename + "");
			hash.update(this.outputOptions.jsonpFunction + "");
			hash.update(this.outputOptions.library + "");
		});
	};


/***/ },
/* 374 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*globals hotAddUpdateChunk parentHotUpdateCallback document XMLHttpRequest $require$ $hotChunkFilename$ $hotMainFilename$ */
	module.exports = function() {
		function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
			hotAddUpdateChunk(chunkId, moreModules);
			if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
		}
	
		function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
			var head = document.getElementsByTagName("head")[0];
			var script = document.createElement("script");
			script.type = "text/javascript";
			script.charset = "utf-8";
			script.src = $require$.p + $hotChunkFilename$;
			head.appendChild(script);
		}
	
		function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
			if(typeof XMLHttpRequest === "undefined")
				return callback(new Error("No browser support"));
			try {
				var request = new XMLHttpRequest();
				var requestPath = $require$.p + $hotMainFilename$;
				request.open("GET", requestPath, true);
				request.timeout = 10000;
				request.send(null);
			} catch(err) {
				return callback(err);
			}
			request.onreadystatechange = function() {
				if(request.readyState !== 4) return;
				if(request.status === 0) {
					// timeout
					callback(new Error("Manifest request to " + requestPath + " timed out."));
				} else if(request.status === 404) {
					// no update available
					callback();
				} else if(request.status !== 200 && request.status !== 304) {
					// other failure
					callback(new Error("Manifest request to " + requestPath + " failed."));
				} else {
					// success
					try {
						var update = JSON.parse(request.responseText);
					} catch(e) {
						callback(e);
						return;
					}
					callback(null, update);
				}
			};
		}
	};


/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(221);
	var Template = __webpack_require__(224);
	
	function JsonpChunkTemplatePlugin() {}
	module.exports = JsonpChunkTemplatePlugin;
	
	JsonpChunkTemplatePlugin.prototype.apply = function(chunkTemplate) {
		chunkTemplate.plugin("render", function(modules, chunk) {
			var jsonpFunction = this.outputOptions.jsonpFunction || Template.toIdentifier("webpackJsonp" + (this.outputOptions.library || ""));
			var source = new ConcatSource();
			source.add(jsonpFunction + "(" + JSON.stringify(chunk.ids) + ",");
			source.add(modules);
			source.add(")");
			return source;
		});
		chunkTemplate.plugin("hash", function(hash) {
			hash.update("JsonpChunkTemplatePlugin");
			hash.update("3");
			hash.update(this.outputOptions.jsonpFunction + "");
			hash.update(this.outputOptions.library + "");
		});
	};


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(221);
	var Template = __webpack_require__(224);
	
	function JsonpHotUpdateChunkTemplatePlugin() {}
	module.exports = JsonpHotUpdateChunkTemplatePlugin;
	
	JsonpHotUpdateChunkTemplatePlugin.prototype.apply = function(hotUpdateChunkTemplate) {
		hotUpdateChunkTemplate.plugin("render", function(modulesSource, modules, hash, id) {
			var jsonpFunction = this.outputOptions.hotUpdateFunction || Template.toIdentifier("webpackHotUpdate" + (this.outputOptions.library || ""));
			var source = new ConcatSource();
			source.add(jsonpFunction + "(" + JSON.stringify(id) + ",");
			source.add(modulesSource);
			source.add(")");
			return source;
		});
		hotUpdateChunkTemplate.plugin("hash", function(hash) {
			hash.update("JsonpHotUpdateChunkTemplatePlugin");
			hash.update("3");
			hash.update(this.outputOptions.hotUpdateFunction + "");
			hash.update(this.outputOptions.library + "");
		});
	};


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleAliasPlugin = __webpack_require__(304);
	var ModuleParserHelpers = __webpack_require__(301);
	var nodeLibsBrowser = __webpack_require__(378);
	
	function NodeSourcePlugin(options) {
		this.options = options;
	}
	module.exports = NodeSourcePlugin;
	NodeSourcePlugin.prototype.apply = function(compiler) {
		function getPathToModule(module, type) {
			if(type === true || (type === undefined && nodeLibsBrowser[module])) {
				if(!nodeLibsBrowser[module]) throw new Error("No browser version for node.js core module '" + module + "' available");
				return nodeLibsBrowser[module];
			} else if(type === "mock") {
				return /*require.resolve*/(__webpack_require__(379).resolve("./" + module));
			} else if(type === "empty") {
				return /*require.resolve*/(383);
			} else return module;
		}
		if(this.options.process) {
			var processType = this.options.process;
			compiler.parser.plugin("expression process", function() {
				return ModuleParserHelpers.addParsedVariable(this, "process", "require(" + JSON.stringify(getPathToModule("process", processType)) + ")");
			});
		}
		if(this.options.global) {
			compiler.parser.plugin("expression global", function() {
				this.state.module.addVariable("global", "(function() { return this; }())");
				return true;
			});
		}
		if(this.options.console) {
			var consoleType = this.options.console;
			compiler.parser.plugin("expression console", function() {
				return ModuleParserHelpers.addParsedVariable(this, "console", "require(" + JSON.stringify(getPathToModule("console", consoleType)) + ")");
			});
		}
		var bufferType = this.options.Buffer;
		if(typeof bufferType === "undefined") {
			bufferType = this.options.buffer;
			if(typeof bufferType === "undefined")
				bufferType = true;
		}
		if(bufferType) {
			compiler.parser.plugin("expression Buffer", function() {
				return ModuleParserHelpers.addParsedVariable(this, "Buffer", "require(" + JSON.stringify(getPathToModule("buffer", bufferType)) + ").Buffer");
			});
		}
		if(this.options.setImmediate) {
			var setImmediateType = this.options.setImmediate;
			compiler.parser.plugin("expression setImmediate", function() {
				return ModuleParserHelpers.addParsedVariable(this, "setImmediate", "require(" + JSON.stringify(getPathToModule("timers", setImmediateType)) + ").setImmediate");
			});
			compiler.parser.plugin("expression clearImmediate", function() {
				return ModuleParserHelpers.addParsedVariable(this, "clearImmediate", "require(" + JSON.stringify(getPathToModule("timers", setImmediateType)) + ").clearImmediate");
			});
		}
		var options = this.options;
		compiler.plugin("after-resolvers", function(compiler) {
			var alias = {};
			Object.keys(nodeLibsBrowser).forEach(function(lib) {
				if(options[lib] !== false)
					alias[lib + "$"] = getPathToModule(lib, options[lib]);
			});
			if(Object.keys(alias).length > 0) {
				compiler.resolvers.normal.apply(
					new ModuleAliasPlugin(alias)
				);
			}
		});
	};


/***/ },
/* 378 */
/***/ function(module, exports) {



/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./buffer": 380,
		"./buffer.js": 380,
		"./console": 381,
		"./console.js": 381,
		"./dns": 382,
		"./dns.js": 382,
		"./empty": 383,
		"./empty.js": 383,
		"./net": 384,
		"./net.js": 384,
		"./process": 385,
		"./process.js": 385,
		"./punycode": 386,
		"./punycode.js": 386,
		"./tls": 387,
		"./tls.js": 387,
		"./tty": 388,
		"./tty.js": 388
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 379;


/***/ },
/* 380 */
/***/ function(module, exports) {

	function Buffer() {
		throw new Error("Buffer is not included.");
	}
	Buffer.isBuffer = function() {
	  return false;
	};
	
	exports.INSPECT_MAX_BYTES = 50;
	exports.SlowBuffer = Buffer;
	exports.Buffer = Buffer;


/***/ },
/* 381 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {var console;
	if (typeof global !== "undefined" && global.console) {
	    console = global.console
	} else if (typeof window !== "undefined" && window.console) {
	    console = window.console
	} else {
	    console = window.console = {}
	}
	module.exports = console;
	for(var name in {log:1, info:1, error:1, warn:1, dir:1, trace:1, assert:1, time:1, timeEnd: 1})
		if(!console[name])
			console[name] = function() {};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 382 */
/***/ function(module, exports) {

	exports.lookup = exports.resolve4 =
	exports.resolve6 = exports.resolveCname =
	exports.resolveMx = exports.resolveNs =
	exports.resolveTxt = exports.resolveSrv =
	exports.resolveNaptr = exports.reverse =
	exports.resolve =
	function () {
	  if (!arguments.length) return;
	
	  var callback = arguments[arguments.length - 1];
	  if (callback && typeof callback === 'function') {
	    callback(null, '0.0.0.0')
	  }
	}
	


/***/ },
/* 383 */
/***/ function(module, exports) {



/***/ },
/* 384 */
/***/ function(module, exports) {

	exports.createServer =
	exports.createConnection =
	exports.connect =
	function () {};
	
	exports.isIP =
	exports.isIPv4 =
	exports.isIPv6 =
	function () { return true };
	


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	exports.nextTick = function nextTick(fn) {
		setTimeout(fn, 0);
	};
	
	exports.platform = exports.arch = 
	exports.execPath = exports.title = 'browser';
	exports.pid = 1;
	exports.browser = true;
	exports.env = {};
	exports.argv = [];
	
	exports.binding = function (name) {
		throw new Error('No such module. (Possibly not yet loaded)')
	};
	
	(function () {
	    var cwd = '/';
	    var path;
	    exports.cwd = function () { return cwd };
	    exports.chdir = function (dir) {
	        if (!path) path = __webpack_require__(180);
	        cwd = path.resolve(dir, cwd);
	    };
	})();
	
	exports.exit = exports.kill = 
	exports.umask = exports.dlopen = 
	exports.uptime = exports.memoryUsage = 
	exports.uvCounters = function() {};
	exports.features = {};


/***/ },
/* 386 */
/***/ function(module, exports) {

	exports.ucs2 = {};
	exports.encode = exports.decode =
	exports.ucs2.encode = exports.ucs2.decode =
	exports.toUnicode = exports.toASCII =
	function (s) { return s };
	exports.version = "0.0.0";

/***/ },
/* 387 */
/***/ function(module, exports) {

	// todo


/***/ },
/* 388 */
/***/ function(module, exports) {

	exports.isatty = function () {};
	exports.setRawMode = function () {};


/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var WebWorkerMainTemplatePlugin = __webpack_require__(390);
	var WebWorkerChunkTemplatePlugin = __webpack_require__(391);
	
	function WebWorkerTemplatePlugin() {}
	module.exports = WebWorkerTemplatePlugin;
	WebWorkerTemplatePlugin.prototype.apply = function(compiler) {
		compiler.plugin("this-compilation", function(compilation) {
			compilation.mainTemplate.apply(new WebWorkerMainTemplatePlugin());
			compilation.chunkTemplate.apply(new WebWorkerChunkTemplatePlugin());
		});
	};


/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Template = __webpack_require__(224);
	
	function WebWorkerMainTemplatePlugin() {}
	module.exports = WebWorkerMainTemplatePlugin;
	
	WebWorkerMainTemplatePlugin.prototype.apply = function(mainTemplate) {
		mainTemplate.plugin("local-vars", function(source, chunk) {
			if(chunk.chunks.length > 0) {
				return this.asString([
					source,
					"",
					"// object to store loaded chunks",
					"// \"1\" means \"already loaded\"",
					"var installedChunks = {",
					this.indent(
						chunk.ids.map(function(id) {
							return id + ":1";
						}).join(",\n")
					),
					"};"
				]);
			}
			return source;
		});
		mainTemplate.plugin("require-ensure", function(_, chunk, hash) {
			var filename = this.outputOptions.filename || "bundle.js";
			var chunkFilename = this.outputOptions.chunkFilename || "[id]." + filename;
			return this.asString([
				"// \"1\" is the signal for \"already loaded\"",
				"if(!installedChunks[chunkId]) {",
				this.indent([
					"importScripts(" +
					this.applyPluginsWaterfall("asset-path", JSON.stringify(chunkFilename), {
						hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
						hashWithLength: function(length) {
							return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
						}.bind(this),
						chunk: {
							id: "\" + chunkId + \""
						}
					}) + ");"
				]),
				"}",
				"callback.call(null, " + this.requireFn + ");"
			]);
		});
		mainTemplate.plugin("bootstrap", function(source, chunk, hash) {
			if(chunk.chunks.length > 0) {
				var chunkCallbackName = this.outputOptions.chunkCallbackName || Template.toIdentifier("webpackChunk" + (this.outputOptions.library || ""));
				return this.asString([
					source,
					"this[" + JSON.stringify(chunkCallbackName) + "] = function webpackChunkCallback(chunkIds, moreModules) {",
					this.indent([
						"for(var moduleId in moreModules) {",
						this.indent(this.renderAddModule(hash, chunk, "moduleId", "moreModules[moduleId]")),
						"}",
						"while(chunkIds.length)",
						this.indent("installedChunks[chunkIds.pop()] = 1;")
					]),
					"};"
				]);
			}
			return source;
		});
		mainTemplate.plugin("hash", function(hash) {
			hash.update("webworker");
			hash.update("3");
			hash.update(this.outputOptions.publicPath + "");
			hash.update(this.outputOptions.filename + "");
			hash.update(this.outputOptions.chunkFilename + "");
			hash.update(this.outputOptions.chunkCallbackName + "");
			hash.update(this.outputOptions.library + "");
		});
	};


/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(221);
	var Template = __webpack_require__(224);
	
	function WebWorkerChunkTemplatePlugin() {}
	module.exports = WebWorkerChunkTemplatePlugin;
	
	WebWorkerChunkTemplatePlugin.prototype.apply = function(chunkTemplate) {
		chunkTemplate.plugin("render", function(modules, chunk) {
			var chunkCallbackName = this.outputOptions.chunkCallbackName || Template.toIdentifier("webpackChunk" + (this.outputOptions.library || ""));
			var source = new ConcatSource();
			source.add(chunkCallbackName + "(" + JSON.stringify(chunk.ids) + ",");
			source.add(modules);
			source.add(")");
			return source;
		});
		chunkTemplate.plugin("hash", function(hash) {
			hash.update("webworker");
			hash.update("3");
			hash.update(this.outputOptions.chunkCallbackName + "");
			hash.update(this.outputOptions.library + "");
		});
	};


/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NodeMainTemplatePlugin = __webpack_require__(393);
	var NodeChunkTemplatePlugin = __webpack_require__(399);
	var NodeHotUpdateChunkTemplatePlugin = __webpack_require__(515);
	
	function NodeTemplatePlugin(options, asyncChunkLoading) {
		// TODO remove options parameter
		this.options = options;
		this.asyncChunkLoading = asyncChunkLoading;
	}
	module.exports = NodeTemplatePlugin;
	NodeTemplatePlugin.prototype.apply = function(compiler) {
		compiler.plugin("this-compilation", function(compilation) {
			compilation.mainTemplate.apply(new NodeMainTemplatePlugin(this.asyncChunkLoading));
			compilation.chunkTemplate.apply(new NodeChunkTemplatePlugin());
			compilation.hotUpdateChunkTemplate.apply(new NodeHotUpdateChunkTemplatePlugin());
		}.bind(this));
	};


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Template = __webpack_require__(224);
	
	function NodeMainTemplatePlugin(asyncChunkLoading) {
		this.asyncChunkLoading = asyncChunkLoading;
	}
	module.exports = NodeMainTemplatePlugin;
	NodeMainTemplatePlugin.prototype.apply = function(mainTemplate) {
		var self = this;
		mainTemplate.plugin("local-vars", function(source, chunk) {
			if(chunk.chunks.length > 0) {
				return this.asString([
					source,
					"",
					"// object to store loaded chunks",
					"// \"1\" means \"already loaded\"",
					"var installedChunks = {",
					this.indent(
						chunk.ids.map(function(id) {
							return id + ":1";
						}).join(",\n")
					),
					"};"
				]);
			}
			return source;
		});
		mainTemplate.plugin("require-ensure", function(_, chunk, hash) {
			var filename = this.outputOptions.filename || "bundle.js";
			var chunkFilename = this.outputOptions.chunkFilename || "[id]." + filename;
			var chunkMaps = chunk.getChunkMaps();
			var insertMoreModules = [
				"var moreModules = chunk.modules, chunkIds = chunk.ids;",
				"for(var moduleId in moreModules) {",
				this.indent(this.renderAddModule(hash, chunk, "moduleId", "moreModules[moduleId]")),
				"}"
			];
			if(self.asyncChunkLoading) {
				return this.asString([
					"if(installedChunks[chunkId] === 1) callback.call(null, " + this.requireFn + ");",
					"else if(!installedChunks[chunkId]) {",
					this.indent([
						"installedChunks[chunkId] = [callback];",
						"var filename = __dirname + " + this.applyPluginsWaterfall("asset-path", JSON.stringify("/" + chunkFilename), {
							hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
							hashWithLength: function(length) {
								return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
							}.bind(this),
							chunk: {
								id: "\" + chunkId + \"",
								hash: "\" + " + JSON.stringify(chunkMaps.hash) + "[chunkId] + \"",
								hashWithLength: function(length) {
									var shortChunkHashMap = {};
									Object.keys(chunkMaps.hash).forEach(function(chunkId) {
										if(typeof chunkMaps.hash[chunkId] === "string")
											shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length);
									});
									return "\" + " + JSON.stringify(shortChunkHashMap) + "[chunkId] + \"";
								},
								name: "\" + (" + JSON.stringify(chunkMaps.name) + "[chunkId]||chunkId) + \""
							}
						}) + ";",
						"require('fs').readFile(filename, 'utf-8',  function(err, content) {",
						this.indent([
							"if(err) { if(" + this.requireFn + ".onError) return " + this.requireFn + ".onError(err); else throw err; }",
							"var chunk = {};",
							"require('vm').runInThisContext('(function(exports, require, __dirname, __filename) {' + content + '\\n})', filename)" +
							"(chunk, require, require('path').dirname(filename), filename);"
						].concat(insertMoreModules).concat([
							"var callbacks = [];",
							"for(var i = 0; i < chunkIds.length; i++) {",
							this.indent([
								"if(Array.isArray(installedChunks[chunkIds[i]]))",
								this.indent([
									"callbacks = callbacks.concat(installedChunks[chunkIds[i]]);"
								]),
								"installedChunks[chunkIds[i]] = 1;"
							]),
							"}",
							"for(i = 0; i < callbacks.length; i++)",
							this.indent("callbacks[i].call(null, " + this.requireFn + ");")
						])),
						"});"
					]),
					"} else installedChunks[chunkId].push(callback);"
				]);
			} else {
				var request = this.applyPluginsWaterfall("asset-path", JSON.stringify("./" + chunkFilename), {
					hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
					hashWithLength: function(length) {
						return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
					}.bind(this),
					chunk: {
						id: "\" + chunkId + \"",
						hash: "\" + " + JSON.stringify(chunkMaps.hash) + "[chunkId] + \"",
						hashWithLength: function(length) {
							var shortChunkHashMap = {};
							Object.keys(chunkMaps.hash).forEach(function(chunkId) {
								if(typeof chunkMaps.hash[chunkId] === "string")
									shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length);
							});
							return "\" + " + JSON.stringify(shortChunkHashMap) + "[chunkId] + \"";
						},
						name: "\" + (" + JSON.stringify(chunkMaps.name) + "[chunkId]||chunkId) + \""
					}
				});
				return this.asString([
					"// \"1\" is the signal for \"already loaded\"",
					"if(!installedChunks[chunkId]) {",
					this.indent([
						"var chunk = require(" + request + ");"
					].concat(insertMoreModules).concat([
						"for(var i = 0; i < chunkIds.length; i++)",
						this.indent("installedChunks[chunkIds[i]] = 1;")
					])),
					"}",
					"callback.call(null, " + this.requireFn + ");"
				]);
			}
		});
		mainTemplate.plugin("hot-bootstrap", function(source, chunk, hash) {
			var hotUpdateChunkFilename = this.outputOptions.hotUpdateChunkFilename;
			var hotUpdateMainFilename = this.outputOptions.hotUpdateMainFilename;
			var chunkMaps = chunk.getChunkMaps();
			var currentHotUpdateChunkFilename = this.applyPluginsWaterfall("asset-path", JSON.stringify(hotUpdateChunkFilename), {
				hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
				hashWithLength: function(length) {
					return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
				}.bind(this),
				chunk: {
					id: "\" + chunkId + \"",
					hash: "\" + " + JSON.stringify(chunkMaps.hash) + "[chunkId] + \"",
					hashWithLength: function(length) {
						var shortChunkHashMap = {};
						Object.keys(chunkMaps.hash).forEach(function(chunkId) {
							if(typeof chunkMaps.hash[chunkId] === "string")
								shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length);
						});
						return "\" + " + JSON.stringify(shortChunkHashMap) + "[chunkId] + \"";
					},
					name: "\" + (" + JSON.stringify(chunkMaps.name) + "[chunkId]||chunkId) + \""
				}
			});
			var currentHotUpdateMainFilename = this.applyPluginsWaterfall("asset-path", JSON.stringify(hotUpdateMainFilename), {
				hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
				hashWithLength: function(length) {
					return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
				}.bind(this)
			});
			return Template.getFunctionContent(self.asyncChunkLoading ? __webpack_require__(394) : __webpack_require__(397))
				.replace(/\$require\$/g, this.requireFn)
				.replace(/\$hotMainFilename\$/g, currentHotUpdateMainFilename)
				.replace(/\$hotChunkFilename\$/g, currentHotUpdateChunkFilename);
		});
		mainTemplate.plugin("hash", function(hash) {
			hash.update("node");
			hash.update("3");
			hash.update(this.outputOptions.filename + "");
			hash.update(this.outputOptions.chunkFilename + "");
		});
	};


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*global $hotChunkFilename$ $require$ hotAddUpdateChunk $hotMainFilename$ */
	module.exports = function() {
		function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
			var filename = __webpack_require__(180).join(__dirname, $hotChunkFilename$);
			__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).readFile(filename, "utf-8", function(err, content) {
				if(err) {
					if($require$.onError)
						return $require$.onError(err);
					else
						throw err;
				}
				var chunk = {};
				__webpack_require__(395).runInThisContext("(function(exports) {" + content + "\n})", filename)(chunk);
				hotAddUpdateChunk(chunk.id, chunk.modules);
			});
		}
	
		function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
			var filename = __webpack_require__(180).join(__dirname, $hotMainFilename$);
			__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).readFile(filename, "utf-8", function(err, content) {
				if(err) return callback();
				try {
					var update = JSON.parse(content);
				} catch(e) {
					return callback(e);
				}
				callback(null, update);
			});
		}
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	var indexOf = __webpack_require__(396);
	
	var Object_keys = function (obj) {
	    if (Object.keys) return Object.keys(obj)
	    else {
	        var res = [];
	        for (var key in obj) res.push(key)
	        return res;
	    }
	};
	
	var forEach = function (xs, fn) {
	    if (xs.forEach) return xs.forEach(fn)
	    else for (var i = 0; i < xs.length; i++) {
	        fn(xs[i], i, xs);
	    }
	};
	
	var defineProp = (function() {
	    try {
	        Object.defineProperty({}, '_', {});
	        return function(obj, name, value) {
	            Object.defineProperty(obj, name, {
	                writable: true,
	                enumerable: false,
	                configurable: true,
	                value: value
	            })
	        };
	    } catch(e) {
	        return function(obj, name, value) {
	            obj[name] = value;
	        };
	    }
	}());
	
	var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
	'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
	'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
	'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
	'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];
	
	function Context() {}
	Context.prototype = {};
	
	var Script = exports.Script = function NodeScript (code) {
	    if (!(this instanceof Script)) return new Script(code);
	    this.code = code;
	};
	
	Script.prototype.runInContext = function (context) {
	    if (!(context instanceof Context)) {
	        throw new TypeError("needs a 'context' argument.");
	    }
	    
	    var iframe = document.createElement('iframe');
	    if (!iframe.style) iframe.style = {};
	    iframe.style.display = 'none';
	    
	    document.body.appendChild(iframe);
	    
	    var win = iframe.contentWindow;
	    var wEval = win.eval, wExecScript = win.execScript;
	
	    if (!wEval && wExecScript) {
	        // win.eval() magically appears when this is called in IE:
	        wExecScript.call(win, 'null');
	        wEval = win.eval;
	    }
	    
	    forEach(Object_keys(context), function (key) {
	        win[key] = context[key];
	    });
	    forEach(globals, function (key) {
	        if (context[key]) {
	            win[key] = context[key];
	        }
	    });
	    
	    var winKeys = Object_keys(win);
	
	    var res = wEval.call(win, this.code);
	    
	    forEach(Object_keys(win), function (key) {
	        // Avoid copying circular objects like `top` and `window` by only
	        // updating existing context properties or new properties in the `win`
	        // that was only introduced after the eval.
	        if (key in context || indexOf(winKeys, key) === -1) {
	            context[key] = win[key];
	        }
	    });
	
	    forEach(globals, function (key) {
	        if (!(key in context)) {
	            defineProp(context, key, win[key]);
	        }
	    });
	    
	    document.body.removeChild(iframe);
	    
	    return res;
	};
	
	Script.prototype.runInThisContext = function () {
	    return eval(this.code); // maybe...
	};
	
	Script.prototype.runInNewContext = function (context) {
	    var ctx = Script.createContext(context);
	    var res = this.runInContext(ctx);
	
	    forEach(Object_keys(ctx), function (key) {
	        context[key] = ctx[key];
	    });
	
	    return res;
	};
	
	forEach(Object_keys(Script.prototype), function (name) {
	    exports[name] = Script[name] = function (code) {
	        var s = Script(code);
	        return s[name].apply(s, [].slice.call(arguments, 1));
	    };
	});
	
	exports.createScript = function (code) {
	    return exports.Script(code);
	};
	
	exports.createContext = Script.createContext = function (context) {
	    var copy = new Context();
	    if(typeof context === 'object') {
	        forEach(Object_keys(context), function (key) {
	            copy[key] = context[key];
	        });
	    }
	    return copy;
	};


/***/ },
/* 396 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;
	
	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*global $hotChunkFilename$ hotAddUpdateChunk $hotMainFilename$ */
	module.exports = function() {
		function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
			var chunk = __webpack_require__(398)("./" + $hotChunkFilename$);
			hotAddUpdateChunk(chunk.id, chunk.modules);
		}
	
		function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
			try {
				var update = __webpack_require__(398)("./" + $hotMainFilename$);
			} catch(e) {
				return callback();
			}
			callback(null, update);
		}
	};


/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./NodeChunkTemplatePlugin": 399,
		"./NodeChunkTemplatePlugin.js": 399,
		"./NodeEnvironmentPlugin": 400,
		"./NodeEnvironmentPlugin.js": 400,
		"./NodeHotUpdateChunkTemplatePlugin": 515,
		"./NodeHotUpdateChunkTemplatePlugin.js": 515,
		"./NodeMainTemplate.runtime": 397,
		"./NodeMainTemplate.runtime.js": 397,
		"./NodeMainTemplateAsync.runtime": 394,
		"./NodeMainTemplateAsync.runtime.js": 394,
		"./NodeMainTemplatePlugin": 393,
		"./NodeMainTemplatePlugin.js": 393,
		"./NodeOutputFileSystem": 502,
		"./NodeOutputFileSystem.js": 502,
		"./NodeSourcePlugin": 377,
		"./NodeSourcePlugin.js": 377,
		"./NodeTargetPlugin": 516,
		"./NodeTargetPlugin.js": 516,
		"./NodeTemplatePlugin": 392,
		"./NodeTemplatePlugin.js": 392,
		"./NodeWatchFileSystem": 401,
		"./NodeWatchFileSystem.js": 401,
		"./OldNodeWatchFileSystem": 520,
		"./OldNodeWatchFileSystem.js": 520
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 398;


/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(221);
	
	function NodeChunkTemplatePlugin() {}
	module.exports = NodeChunkTemplatePlugin;
	
	NodeChunkTemplatePlugin.prototype.apply = function(chunkTemplate) {
		chunkTemplate.plugin("render", function(modules, chunk) {
			var source = new ConcatSource();
			source.add("exports.ids = " + JSON.stringify(chunk.ids) + ";\nexports.modules = ");
			source.add(modules);
			source.add(";");
			return source;
		});
		chunkTemplate.plugin("hash", function(hash) {
			hash.update("node");
			hash.update("3");
		});
	};


/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NodeWatchFileSystem = __webpack_require__(401);
	var NodeOutputFileSystem = __webpack_require__(502);
	var NodeJsInputFileSystem = __webpack_require__(503);
	var CachedInputFileSystem = __webpack_require__(514);
	
	function NodeEnvironmentPlugin() {}
	module.exports = NodeEnvironmentPlugin;
	NodeEnvironmentPlugin.prototype.apply = function(compiler) {
		compiler.inputFileSystem = new NodeJsInputFileSystem();
		var inputFileSystem = compiler.inputFileSystem = new CachedInputFileSystem(compiler.inputFileSystem, 60000);
		compiler.resolvers.normal.fileSystem = compiler.inputFileSystem;
		compiler.resolvers.context.fileSystem = compiler.inputFileSystem;
		compiler.resolvers.loader.fileSystem = compiler.inputFileSystem;
		compiler.outputFileSystem = new NodeOutputFileSystem();
		compiler.watchFileSystem = new NodeWatchFileSystem(compiler.inputFileSystem);
		compiler.plugin("run", function(compiler, callback) {
			if(compiler.inputFileSystem === inputFileSystem)
				inputFileSystem.purge();
			callback();
		});
	};


/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Watchpack = __webpack_require__(402);
	
	function NodeWatchFileSystem(inputFileSystem) {
		this.inputFileSystem = inputFileSystem;
		this.watcherOptions = {
			aggregateTimeout: 0
		};
		this.watcher = new Watchpack(this.watcherOptions);
	}
	
	module.exports = NodeWatchFileSystem;
	
	NodeWatchFileSystem.prototype.watch = function watch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {
		if(!Array.isArray(files))
			throw new Error("Invalid arguments: 'files'");
		if(!Array.isArray(dirs))
			throw new Error("Invalid arguments: 'dirs'");
		if(!Array.isArray(missing))
			throw new Error("Invalid arguments: 'missing'");
		if(typeof callback !== "function")
			throw new Error("Invalid arguments: 'callback'");
		if(typeof startTime !== "number" && startTime)
			throw new Error("Invalid arguments: 'startTime'");
		if(typeof options !== "object")
			throw new Error("Invalid arguments: 'options'");
		if(typeof callbackUndelayed !== "function" && callbackUndelayed)
			throw new Error("Invalid arguments: 'callbackUndelayed'");
		var oldWatcher = this.watcher;
		this.watcher = new Watchpack(options);
	
		if(callbackUndelayed)
			this.watcher.once("change", callbackUndelayed);
	
		this.watcher.once("aggregated", function(changes) {
			if(this.inputFileSystem && this.inputFileSystem.purge) {
				this.inputFileSystem.purge(changes);
			}
			var times = this.watcher.getTimes();
			callback(null, changes.filter(function(file) {
				return files.indexOf(file) >= 0;
			}).sort(), changes.filter(function(file) {
				return dirs.indexOf(file) >= 0;
			}).sort(), changes.filter(function(file) {
				return missing.indexOf(file) >= 0;
			}).sort(), times, times);
		}.bind(this));
	
		this.watcher.watch(files.concat(missing), dirs, startTime);
	
		if(oldWatcher) {
			oldWatcher.close();
		}
		return {
			close: function() {
				this.watcher.close();
			}.bind(this),
			pause: function() {
				this.watcher.pause();
			}.bind(this)
		};
	};


/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var watcherManager = __webpack_require__(403);
	var EventEmitter = __webpack_require__(405).EventEmitter;
	
	function Watchpack(options) {
		EventEmitter.call(this);
		if(!options) options = {};
		if(!options.aggregateTimeout) options.aggregateTimeout = 200;
		this.options = options;
		this.watcherOptions = {
			poll: options.poll
		};
		this.fileWatchers = [];
		this.dirWatchers = [];
		this.mtimes = {};
		this.paused = false;
		this.aggregatedChanges = [];
		this.aggregateTimeout = 0;
		this._onTimeout = this._onTimeout.bind(this);
	}
	
	module.exports = Watchpack;
	
	Watchpack.prototype = Object.create(EventEmitter.prototype);
	
	Watchpack.prototype.watch = function watch(files, directories, startTime) {
		this.paused = false;
		var oldFileWatchers = this.fileWatchers;
		var oldDirWatchers = this.dirWatchers;
		this.fileWatchers = files.map(function(file) {
			return this._fileWatcher(file, watcherManager.watchFile(file, this.watcherOptions, startTime));
		}, this);
		this.dirWatchers = directories.map(function(dir) {
			return this._dirWatcher(dir, watcherManager.watchDirectory(dir, this.watcherOptions, startTime));
		}, this);
		oldFileWatchers.forEach(function(w) {
			w.close();
		}, this);
		oldDirWatchers.forEach(function(w) {
			w.close();
		}, this);
	};
	
	Watchpack.prototype.close = function resume() {
		this.paused = true;
		if(this.aggregateTimeout)
			clearTimeout(this.aggregateTimeout);
		this.fileWatchers.forEach(function(w) {
			w.close();
		}, this);
		this.dirWatchers.forEach(function(w) {
			w.close();
		}, this);
		this.fileWatchers.length = 0;
		this.dirWatchers.length = 0;
	};
	
	Watchpack.prototype.pause = function pause() {
		this.paused = true;
		if(this.aggregateTimeout)
			clearTimeout(this.aggregateTimeout);
	};
	
	function addWatchersToArray(watchers, array) {
		watchers.forEach(function(w) {
			if(array.indexOf(w.directoryWatcher) < 0) {
				array.push(w.directoryWatcher);
				addWatchersToArray(Object.keys(w.directoryWatcher.directories).reduce(function(a, dir) {
					if(w.directoryWatcher.directories[dir] !== true)
						a.push(w.directoryWatcher.directories[dir]);
					return a;
				}, []), array);
			}
		});
	}
	
	Watchpack.prototype.getTimes = function() {
		var directoryWatchers = [];
		addWatchersToArray(this.fileWatchers.concat(this.dirWatchers), directoryWatchers);
		var obj = {};
		directoryWatchers.forEach(function(w) {
			var times = w.getTimes();
			Object.keys(times).forEach(function(file) {
				obj[file] = times[file];
			});
		});
		return obj;
	};
	
	Watchpack.prototype._fileWatcher = function _fileWatcher(file, watcher) {
		watcher.on("change", this._onChange.bind(this, file));
		return watcher;
	};
	
	Watchpack.prototype._dirWatcher = function _dirWatcher(item, watcher) {
		watcher.on("change", function(file, mtime) {
			this._onChange(item, mtime, file);
		}.bind(this));
		return watcher;
	};
	
	Watchpack.prototype._onChange = function _onChange(item, mtime, file) {
		file = file || item;
		this.mtimes[file] = mtime;
		if(this.paused) return;
		this.emit("change", file, mtime);
		if(this.aggregateTimeout)
			clearTimeout(this.aggregateTimeout);
		if(this.aggregatedChanges.indexOf(item) < 0)
			this.aggregatedChanges.push(item);
		this.aggregateTimeout = setTimeout(this._onTimeout, this.options.aggregateTimeout);
	};
	
	Watchpack.prototype._onTimeout = function _onTimeout() {
		this.aggregateTimeout = 0;
		var changes = this.aggregatedChanges;
		this.aggregatedChanges = [];
		this.emit("aggregated", changes);
	};


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(180);
	
	function WatcherManager() {
		this.directoryWatchers = {};
	}
	
	WatcherManager.prototype.getDirectoryWatcher = function(directory, options) {
		var DirectoryWatcher = __webpack_require__(404);
		options = options || {};
		var key = directory + " " + JSON.stringify(options);
		if(!this.directoryWatchers[key]) {
			this.directoryWatchers[key] = new DirectoryWatcher(directory, options);
			this.directoryWatchers[key].on("closed", function() {
				delete this.directoryWatchers[key];
			}.bind(this));
		}
		return this.directoryWatchers[key];
	};
	
	WatcherManager.prototype.watchFile = function watchFile(p, options, startTime) {
		var directory = path.dirname(p);
		return this.getDirectoryWatcher(directory, options).watch(p, startTime);
	};
	
	WatcherManager.prototype.watchDirectory = function watchDirectory(directory, options, startTime) {
		return this.getDirectoryWatcher(directory, options).watch(directory, startTime);
	};
	
	module.exports = new WatcherManager();


/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var EventEmitter = __webpack_require__(405).EventEmitter;
	var async = __webpack_require__(406);
	var chokidar = __webpack_require__(407);
	var fs = __webpack_require__(491);
	var path = __webpack_require__(180);
	
	var watcherManager = __webpack_require__(403);
	
	var FS_ACCURENCY = 10000;
	
	
	function withoutCase(str) {
		return str.toLowerCase();
	}
	
	
	function Watcher(directoryWatcher, filePath, startTime) {
		EventEmitter.call(this);
		this.directoryWatcher = directoryWatcher;
		this.path = filePath;
		this.startTime = startTime && +startTime;
		this.data = 0;
	}
	
	Watcher.prototype = Object.create(EventEmitter.prototype);
	Watcher.prototype.constructor = Watcher;
	
	Watcher.prototype.checkStartTime = function checkStartTime(mtime, initial) {
		if(typeof this.startTime !== "number") return !initial;
		var startTime = this.startTime && Math.floor(this.startTime / FS_ACCURENCY) * FS_ACCURENCY;
		return startTime <= mtime;
	};
	
	Watcher.prototype.close = function close() {
		this.emit("closed");
	};
	
	
	function DirectoryWatcher(directoryPath, options) {
		EventEmitter.call(this);
		this.path = directoryPath;
		this.files = {};
		this.directories = {};
		this.watcher = chokidar.watch(directoryPath, {
			ignoreInitial: true,
			persistent: true,
			followSymlinks: false,
			depth: 0,
			atomic: false,
			alwaysStat: true,
			ignorePermissionErrors: true,
			usePolling: options.poll ? true : undefined,
			interval: typeof options.poll === "number" ? options.poll : undefined
		});
		this.watcher.on("add", this.onFileAdded.bind(this));
		this.watcher.on("addDir", this.onDirectoryAdded.bind(this));
		this.watcher.on("change", this.onChange.bind(this));
		this.watcher.on("unlink", this.onFileUnlinked.bind(this));
		this.watcher.on("unlinkDir", this.onDirectoryUnlinked.bind(this));
		this.watcher.on("error", this.onWatcherError.bind(this));
		this.initialScan = true;
		this.nestedWatching = false;
		this.initialScanRemoved = [];
		this.doInitialScan();
		this.watchers = {};
		this.refs = 0;
	}
	module.exports = DirectoryWatcher;
	
	DirectoryWatcher.prototype = Object.create(EventEmitter.prototype);
	DirectoryWatcher.prototype.constructor = DirectoryWatcher;
	
	DirectoryWatcher.prototype.setFileTime = function setFileTime(filePath, mtime, initial, type) {
		var now = Date.now();
		var old = this.files[filePath];
		this.files[filePath] = [initial ? Math.min(now, mtime) : now, mtime];
		if(!old) {
			if(mtime) {
				if(this.watchers[withoutCase(filePath)]) {
					this.watchers[withoutCase(filePath)].forEach(function(w) {
						if(!initial || w.checkStartTime(mtime, initial)) {
							w.emit("change", mtime);
						}
					});
				}
			}
		} else if(!initial && mtime && type !== "add") {
			if(this.watchers[withoutCase(filePath)]) {
				this.watchers[withoutCase(filePath)].forEach(function(w) {
					w.emit("change", mtime);
				});
			}
		} else if(!initial && !mtime) {
			if(this.watchers[withoutCase(filePath)]) {
				this.watchers[withoutCase(filePath)].forEach(function(w) {
					w.emit("remove");
				});
			}
		}
		if(this.watchers[withoutCase(this.path)]) {
			this.watchers[withoutCase(this.path)].forEach(function(w) {
				if(!initial || w.checkStartTime(mtime, initial)) {
					w.emit("change", filePath, mtime);
				}
			});
		}
	};
	
	DirectoryWatcher.prototype.setDirectory = function setDirectory(directoryPath, exist, initial) {
		var old = this.directories[directoryPath];
		if(!old) {
			if(exist) {
				if(this.nestedWatching) {
					this.createNestedWatcher(directoryPath);
				} else {
					this.directories[directoryPath] = true;
				}
			}
		} else {
			if(!exist) {
				if(this.nestedWatching)
					this.directories[directoryPath].close();
				delete this.directories[directoryPath];
				if(!initial && this.watchers[withoutCase(this.path)]) {
					this.watchers[withoutCase(this.path)].forEach(function(w) {
						w.emit("change", directoryPath, w.data);
					});
				}
			}
		}
	};
	
	DirectoryWatcher.prototype.createNestedWatcher = function(directoryPath) {
		this.directories[directoryPath] = watcherManager.watchDirectory(directoryPath, this.options, 1);
		this.directories[directoryPath].on("change", function(filePath, mtime) {
			if(this.watchers[withoutCase(this.path)]) {
				this.watchers[withoutCase(this.path)].forEach(function(w) {
					if(w.checkStartTime(mtime, false)) {
						w.emit("change", filePath, mtime);
					}
				});
			}
		}.bind(this));
	};
	
	DirectoryWatcher.prototype.setNestedWatching = function(flag) {
		if(this.nestedWatching !== !!flag) {
			this.nestedWatching = !!flag;
			if(this.nestedWatching) {
				Object.keys(this.directories).forEach(function(directory) {
					this.createNestedWatcher(directory);
				}, this);
			} else {
				Object.keys(this.directories).forEach(function(directory) {
					this.directories[directory].close();
					this.directories[directory] = true;
				}, this);
			}
		}
	};
	
	DirectoryWatcher.prototype.watch = function watch(filePath, startTime) {
		this.watchers[withoutCase(filePath)] = this.watchers[withoutCase(filePath)] || [];
		this.refs++;
		var watcher = new Watcher(this, filePath, startTime);
		watcher.on("closed", function() {
			var idx = this.watchers[withoutCase(filePath)].indexOf(watcher);
			this.watchers[withoutCase(filePath)].splice(idx, 1);
			if(this.watchers[withoutCase(filePath)].length === 0) {
				delete this.watchers[withoutCase(filePath)];
				if(this.path === filePath)
					this.setNestedWatching(false);
			}
			if(--this.refs <= 0)
				this.close();
		}.bind(this));
		this.watchers[withoutCase(filePath)].push(watcher);
		var data;
		if(filePath === this.path) {
			this.setNestedWatching(true);
			data = false;
			Object.keys(this.files).forEach(function(file) {
				var d = this.files[file];
				if(!data)
					data = d;
				else
					data = [Math.max(data[0], d[0]), Math.max(data[1], d[1])];
			}, this);
		} else {
			data = this.files[filePath];
		}
		process.nextTick(function() {
			if(data) {
				if(data[0] > startTime)
					watcher.emit("change", data[1]);
			} else if(this.initialScan && this.initialScanRemoved.indexOf(filePath) >= 0) {
				watcher.emit("remove");
			}
		}.bind(this));
		return watcher;
	};
	
	DirectoryWatcher.prototype.onFileAdded = function onFileAdded(filePath, stat) {
		if(filePath.indexOf(this.path) !== 0) return;
		if(/[\\\/]/.test(filePath.substr(this.path.length + 1))) return;
	
		this.setFileTime(filePath, +stat.mtime, false, "add");
	};
	
	DirectoryWatcher.prototype.onDirectoryAdded = function onDirectoryAdded(directoryPath /*, stat */) {
		if(directoryPath.indexOf(this.path) !== 0) return;
		if(/[\\\/]/.test(directoryPath.substr(this.path.length + 1))) return;
		this.setDirectory(directoryPath, true, false);
	};
	
	DirectoryWatcher.prototype.onChange = function onChange(filePath, stat) {
		if(filePath.indexOf(this.path) !== 0) return;
		if(/[\\\/]/.test(filePath.substr(this.path.length + 1))) return;
		var mtime = +stat.mtime;
		if(FS_ACCURENCY > 1 && mtime % 1 !== 0)
			FS_ACCURENCY = 1;
		else if(FS_ACCURENCY > 10 && mtime % 10 !== 0)
			FS_ACCURENCY = 10;
		else if(FS_ACCURENCY > 100 && mtime % 100 !== 0)
			FS_ACCURENCY = 100;
		else if(FS_ACCURENCY > 1000 && mtime % 1000 !== 0)
			FS_ACCURENCY = 1000;
		else if(FS_ACCURENCY > 2000 && mtime % 2000 !== 0)
			FS_ACCURENCY = 2000;
		this.setFileTime(filePath, mtime, false, "change");
	};
	
	DirectoryWatcher.prototype.onFileUnlinked = function onFileUnlinked(filePath) {
		if(filePath.indexOf(this.path) !== 0) return;
		if(/[\\\/]/.test(filePath.substr(this.path.length + 1))) return;
		this.setFileTime(filePath, null, false, "unlink");
		if(this.initialScan) {
			this.initialScanRemoved.push(filePath);
		}
	};
	
	DirectoryWatcher.prototype.onDirectoryUnlinked = function onDirectoryUnlinked(directoryPath) {
		if(directoryPath.indexOf(this.path) !== 0) return;
		if(/[\\\/]/.test(directoryPath.substr(this.path.length + 1))) return;
		this.setDirectory(directoryPath, false, false);
		if(this.initialScan) {
			this.initialScanRemoved.push(directoryPath);
		}
	};
	
	DirectoryWatcher.prototype.onWatcherError = function onWatcherError(/* err */) {
	};
	
	DirectoryWatcher.prototype.doInitialScan = function doInitialScan() {
		fs.readdir(this.path, function(err, items) {
			if(err) {
				this.initialScan = false;
				return;
			}
			async.forEach(items, function(item, callback) {
				var itemPath = path.join(this.path, item);
				fs.stat(itemPath, function(err2, stat) {
					if(!this.initialScan) return;
					if(err2) {
						callback();
						return;
					}
					if(stat.isFile()) {
						if(!this.files[itemPath])
							this.setFileTime(itemPath, +stat.mtime, true);
					} else if(stat.isDirectory()) {
						if(!this.directories[itemPath])
							this.setDirectory(itemPath, true, true);
					}
					callback();
				}.bind(this));
			}.bind(this), function() {
				this.initialScan = false;
				this.initialScanRemoved = null;
			}.bind(this));
		}.bind(this));
	};
	
	DirectoryWatcher.prototype.getTimes = function() {
		var obj = {};
		var selfTime = 0;
		Object.keys(this.files).forEach(function(file) {
			var data = this.files[file];
			if(data[1]) {
				var time = Math.max(data[0], data[1]);
				obj[file] = time;
				if(time > selfTime)
					selfTime = time;
			}
		}, this);
		if(this.nestedWatching) {
			Object.keys(this.directories).forEach(function(dir) {
				var w = this.directories[dir];
				var times = w.directoryWatcher.getTimes();
				Object.keys(times).forEach(function(file) {
					var time = times[file];
					obj[file] = time;
					if(time > selfTime)
						selfTime = time;
				});
			}, this);
			obj[this.path] = selfTime;
		}
		return obj;
	};
	
	DirectoryWatcher.prototype.close = function() {
		this.initialScan = false;
		this.watcher.close();
		if(this.nestedWatching) {
			Object.keys(this.directories).forEach(function(dir) {
				this.directories[dir].close();
			}, this);
		}
		this.emit("closed");
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 405 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];
	
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate) {/*!
	 * async
	 * https://github.com/caolan/async
	 *
	 * Copyright 2010-2014 Caolan McMahon
	 * Released under the MIT license
	 */
	/*jshint onevar: false, indent:4 */
	/*global setImmediate: false, setTimeout: false, console: false */
	(function () {
	
	    var async = {};
	
	    // global on the server, window in the browser
	    var root, previous_async;
	
	    root = this;
	    if (root != null) {
	      previous_async = root.async;
	    }
	
	    async.noConflict = function () {
	        root.async = previous_async;
	        return async;
	    };
	
	    function only_once(fn) {
	        var called = false;
	        return function() {
	            if (called) throw new Error("Callback was already called.");
	            called = true;
	            fn.apply(root, arguments);
	        }
	    }
	
	    //// cross-browser compatiblity functions ////
	
	    var _toString = Object.prototype.toString;
	
	    var _isArray = Array.isArray || function (obj) {
	        return _toString.call(obj) === '[object Array]';
	    };
	
	    var _each = function (arr, iterator) {
	        for (var i = 0; i < arr.length; i += 1) {
	            iterator(arr[i], i, arr);
	        }
	    };
	
	    var _map = function (arr, iterator) {
	        if (arr.map) {
	            return arr.map(iterator);
	        }
	        var results = [];
	        _each(arr, function (x, i, a) {
	            results.push(iterator(x, i, a));
	        });
	        return results;
	    };
	
	    var _reduce = function (arr, iterator, memo) {
	        if (arr.reduce) {
	            return arr.reduce(iterator, memo);
	        }
	        _each(arr, function (x, i, a) {
	            memo = iterator(memo, x, i, a);
	        });
	        return memo;
	    };
	
	    var _keys = function (obj) {
	        if (Object.keys) {
	            return Object.keys(obj);
	        }
	        var keys = [];
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    };
	
	    //// exported async module functions ////
	
	    //// nextTick implementation with browser-compatible fallback ////
	    if (typeof process === 'undefined' || !(process.nextTick)) {
	        if (typeof setImmediate === 'function') {
	            async.nextTick = function (fn) {
	                // not a direct alias for IE10 compatibility
	                setImmediate(fn);
	            };
	            async.setImmediate = async.nextTick;
	        }
	        else {
	            async.nextTick = function (fn) {
	                setTimeout(fn, 0);
	            };
	            async.setImmediate = async.nextTick;
	        }
	    }
	    else {
	        async.nextTick = process.nextTick;
	        if (typeof setImmediate !== 'undefined') {
	            async.setImmediate = function (fn) {
	              // not a direct alias for IE10 compatibility
	              setImmediate(fn);
	            };
	        }
	        else {
	            async.setImmediate = async.nextTick;
	        }
	    }
	
	    async.each = function (arr, iterator, callback) {
	        callback = callback || function () {};
	        if (!arr.length) {
	            return callback();
	        }
	        var completed = 0;
	        _each(arr, function (x) {
	            iterator(x, only_once(done) );
	        });
	        function done(err) {
	          if (err) {
	              callback(err);
	              callback = function () {};
	          }
	          else {
	              completed += 1;
	              if (completed >= arr.length) {
	                  callback();
	              }
	          }
	        }
	    };
	    async.forEach = async.each;
	
	    async.eachSeries = function (arr, iterator, callback) {
	        callback = callback || function () {};
	        if (!arr.length) {
	            return callback();
	        }
	        var completed = 0;
	        var iterate = function () {
	            iterator(arr[completed], function (err) {
	                if (err) {
	                    callback(err);
	                    callback = function () {};
	                }
	                else {
	                    completed += 1;
	                    if (completed >= arr.length) {
	                        callback();
	                    }
	                    else {
	                        iterate();
	                    }
	                }
	            });
	        };
	        iterate();
	    };
	    async.forEachSeries = async.eachSeries;
	
	    async.eachLimit = function (arr, limit, iterator, callback) {
	        var fn = _eachLimit(limit);
	        fn.apply(null, [arr, iterator, callback]);
	    };
	    async.forEachLimit = async.eachLimit;
	
	    var _eachLimit = function (limit) {
	
	        return function (arr, iterator, callback) {
	            callback = callback || function () {};
	            if (!arr.length || limit <= 0) {
	                return callback();
	            }
	            var completed = 0;
	            var started = 0;
	            var running = 0;
	
	            (function replenish () {
	                if (completed >= arr.length) {
	                    return callback();
	                }
	
	                while (running < limit && started < arr.length) {
	                    started += 1;
	                    running += 1;
	                    iterator(arr[started - 1], function (err) {
	                        if (err) {
	                            callback(err);
	                            callback = function () {};
	                        }
	                        else {
	                            completed += 1;
	                            running -= 1;
	                            if (completed >= arr.length) {
	                                callback();
	                            }
	                            else {
	                                replenish();
	                            }
	                        }
	                    });
	                }
	            })();
	        };
	    };
	
	
	    var doParallel = function (fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [async.each].concat(args));
	        };
	    };
	    var doParallelLimit = function(limit, fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [_eachLimit(limit)].concat(args));
	        };
	    };
	    var doSeries = function (fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [async.eachSeries].concat(args));
	        };
	    };
	
	
	    var _asyncMap = function (eachfn, arr, iterator, callback) {
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        if (!callback) {
	            eachfn(arr, function (x, callback) {
	                iterator(x.value, function (err) {
	                    callback(err);
	                });
	            });
	        } else {
	            var results = [];
	            eachfn(arr, function (x, callback) {
	                iterator(x.value, function (err, v) {
	                    results[x.index] = v;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };
	    async.map = doParallel(_asyncMap);
	    async.mapSeries = doSeries(_asyncMap);
	    async.mapLimit = function (arr, limit, iterator, callback) {
	        return _mapLimit(limit)(arr, iterator, callback);
	    };
	
	    var _mapLimit = function(limit) {
	        return doParallelLimit(limit, _asyncMap);
	    };
	
	    // reduce only has a series version, as doing reduce in parallel won't
	    // work in many situations.
	    async.reduce = function (arr, memo, iterator, callback) {
	        async.eachSeries(arr, function (x, callback) {
	            iterator(memo, x, function (err, v) {
	                memo = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, memo);
	        });
	    };
	    // inject alias
	    async.inject = async.reduce;
	    // foldl alias
	    async.foldl = async.reduce;
	
	    async.reduceRight = function (arr, memo, iterator, callback) {
	        var reversed = _map(arr, function (x) {
	            return x;
	        }).reverse();
	        async.reduce(reversed, memo, iterator, callback);
	    };
	    // foldr alias
	    async.foldr = async.reduceRight;
	
	    var _filter = function (eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, callback) {
	            iterator(x.value, function (v) {
	                if (v) {
	                    results.push(x);
	                }
	                callback();
	            });
	        }, function (err) {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    };
	    async.filter = doParallel(_filter);
	    async.filterSeries = doSeries(_filter);
	    // select alias
	    async.select = async.filter;
	    async.selectSeries = async.filterSeries;
	
	    var _reject = function (eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, callback) {
	            iterator(x.value, function (v) {
	                if (!v) {
	                    results.push(x);
	                }
	                callback();
	            });
	        }, function (err) {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    };
	    async.reject = doParallel(_reject);
	    async.rejectSeries = doSeries(_reject);
	
	    var _detect = function (eachfn, arr, iterator, main_callback) {
	        eachfn(arr, function (x, callback) {
	            iterator(x, function (result) {
	                if (result) {
	                    main_callback(x);
	                    main_callback = function () {};
	                }
	                else {
	                    callback();
	                }
	            });
	        }, function (err) {
	            main_callback();
	        });
	    };
	    async.detect = doParallel(_detect);
	    async.detectSeries = doSeries(_detect);
	
	    async.some = function (arr, iterator, main_callback) {
	        async.each(arr, function (x, callback) {
	            iterator(x, function (v) {
	                if (v) {
	                    main_callback(true);
	                    main_callback = function () {};
	                }
	                callback();
	            });
	        }, function (err) {
	            main_callback(false);
	        });
	    };
	    // any alias
	    async.any = async.some;
	
	    async.every = function (arr, iterator, main_callback) {
	        async.each(arr, function (x, callback) {
	            iterator(x, function (v) {
	                if (!v) {
	                    main_callback(false);
	                    main_callback = function () {};
	                }
	                callback();
	            });
	        }, function (err) {
	            main_callback(true);
	        });
	    };
	    // all alias
	    async.all = async.every;
	
	    async.sortBy = function (arr, iterator, callback) {
	        async.map(arr, function (x, callback) {
	            iterator(x, function (err, criteria) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    callback(null, {value: x, criteria: criteria});
	                }
	            });
	        }, function (err, results) {
	            if (err) {
	                return callback(err);
	            }
	            else {
	                var fn = function (left, right) {
	                    var a = left.criteria, b = right.criteria;
	                    return a < b ? -1 : a > b ? 1 : 0;
	                };
	                callback(null, _map(results.sort(fn), function (x) {
	                    return x.value;
	                }));
	            }
	        });
	    };
	
	    async.auto = function (tasks, callback) {
	        callback = callback || function () {};
	        var keys = _keys(tasks);
	        var remainingTasks = keys.length
	        if (!remainingTasks) {
	            return callback();
	        }
	
	        var results = {};
	
	        var listeners = [];
	        var addListener = function (fn) {
	            listeners.unshift(fn);
	        };
	        var removeListener = function (fn) {
	            for (var i = 0; i < listeners.length; i += 1) {
	                if (listeners[i] === fn) {
	                    listeners.splice(i, 1);
	                    return;
	                }
	            }
	        };
	        var taskComplete = function () {
	            remainingTasks--
	            _each(listeners.slice(0), function (fn) {
	                fn();
	            });
	        };
	
	        addListener(function () {
	            if (!remainingTasks) {
	                var theCallback = callback;
	                // prevent final callback from calling itself if it errors
	                callback = function () {};
	
	                theCallback(null, results);
	            }
	        });
	
	        _each(keys, function (k) {
	            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
	            var taskCallback = function (err) {
	                var args = Array.prototype.slice.call(arguments, 1);
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                if (err) {
	                    var safeResults = {};
	                    _each(_keys(results), function(rkey) {
	                        safeResults[rkey] = results[rkey];
	                    });
	                    safeResults[k] = args;
	                    callback(err, safeResults);
	                    // stop subsequent errors hitting callback multiple times
	                    callback = function () {};
	                }
	                else {
	                    results[k] = args;
	                    async.setImmediate(taskComplete);
	                }
	            };
	            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
	            var ready = function () {
	                return _reduce(requires, function (a, x) {
	                    return (a && results.hasOwnProperty(x));
	                }, true) && !results.hasOwnProperty(k);
	            };
	            if (ready()) {
	                task[task.length - 1](taskCallback, results);
	            }
	            else {
	                var listener = function () {
	                    if (ready()) {
	                        removeListener(listener);
	                        task[task.length - 1](taskCallback, results);
	                    }
	                };
	                addListener(listener);
	            }
	        });
	    };
	
	    async.retry = function(times, task, callback) {
	        var DEFAULT_TIMES = 5;
	        var attempts = [];
	        // Use defaults if times not passed
	        if (typeof times === 'function') {
	            callback = task;
	            task = times;
	            times = DEFAULT_TIMES;
	        }
	        // Make sure times is a number
	        times = parseInt(times, 10) || DEFAULT_TIMES;
	        var wrappedTask = function(wrappedCallback, wrappedResults) {
	            var retryAttempt = function(task, finalAttempt) {
	                return function(seriesCallback) {
	                    task(function(err, result){
	                        seriesCallback(!err || finalAttempt, {err: err, result: result});
	                    }, wrappedResults);
	                };
	            };
	            while (times) {
	                attempts.push(retryAttempt(task, !(times-=1)));
	            }
	            async.series(attempts, function(done, data){
	                data = data[data.length - 1];
	                (wrappedCallback || callback)(data.err, data.result);
	            });
	        }
	        // If a callback is passed, run this as a controll flow
	        return callback ? wrappedTask() : wrappedTask
	    };
	
	    async.waterfall = function (tasks, callback) {
	        callback = callback || function () {};
	        if (!_isArray(tasks)) {
	          var err = new Error('First argument to waterfall must be an array of functions');
	          return callback(err);
	        }
	        if (!tasks.length) {
	            return callback();
	        }
	        var wrapIterator = function (iterator) {
	            return function (err) {
	                if (err) {
	                    callback.apply(null, arguments);
	                    callback = function () {};
	                }
	                else {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    var next = iterator.next();
	                    if (next) {
	                        args.push(wrapIterator(next));
	                    }
	                    else {
	                        args.push(callback);
	                    }
	                    async.setImmediate(function () {
	                        iterator.apply(null, args);
	                    });
	                }
	            };
	        };
	        wrapIterator(async.iterator(tasks))();
	    };
	
	    var _parallel = function(eachfn, tasks, callback) {
	        callback = callback || function () {};
	        if (_isArray(tasks)) {
	            eachfn.map(tasks, function (fn, callback) {
	                if (fn) {
	                    fn(function (err) {
	                        var args = Array.prototype.slice.call(arguments, 1);
	                        if (args.length <= 1) {
	                            args = args[0];
	                        }
	                        callback.call(null, err, args);
	                    });
	                }
	            }, callback);
	        }
	        else {
	            var results = {};
	            eachfn.each(_keys(tasks), function (k, callback) {
	                tasks[k](function (err) {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    if (args.length <= 1) {
	                        args = args[0];
	                    }
	                    results[k] = args;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };
	
	    async.parallel = function (tasks, callback) {
	        _parallel({ map: async.map, each: async.each }, tasks, callback);
	    };
	
	    async.parallelLimit = function(tasks, limit, callback) {
	        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
	    };
	
	    async.series = function (tasks, callback) {
	        callback = callback || function () {};
	        if (_isArray(tasks)) {
	            async.mapSeries(tasks, function (fn, callback) {
	                if (fn) {
	                    fn(function (err) {
	                        var args = Array.prototype.slice.call(arguments, 1);
	                        if (args.length <= 1) {
	                            args = args[0];
	                        }
	                        callback.call(null, err, args);
	                    });
	                }
	            }, callback);
	        }
	        else {
	            var results = {};
	            async.eachSeries(_keys(tasks), function (k, callback) {
	                tasks[k](function (err) {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    if (args.length <= 1) {
	                        args = args[0];
	                    }
	                    results[k] = args;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };
	
	    async.iterator = function (tasks) {
	        var makeCallback = function (index) {
	            var fn = function () {
	                if (tasks.length) {
	                    tasks[index].apply(null, arguments);
	                }
	                return fn.next();
	            };
	            fn.next = function () {
	                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
	            };
	            return fn;
	        };
	        return makeCallback(0);
	    };
	
	    async.apply = function (fn) {
	        var args = Array.prototype.slice.call(arguments, 1);
	        return function () {
	            return fn.apply(
	                null, args.concat(Array.prototype.slice.call(arguments))
	            );
	        };
	    };
	
	    var _concat = function (eachfn, arr, fn, callback) {
	        var r = [];
	        eachfn(arr, function (x, cb) {
	            fn(x, function (err, y) {
	                r = r.concat(y || []);
	                cb(err);
	            });
	        }, function (err) {
	            callback(err, r);
	        });
	    };
	    async.concat = doParallel(_concat);
	    async.concatSeries = doSeries(_concat);
	
	    async.whilst = function (test, iterator, callback) {
	        if (test()) {
	            iterator(function (err) {
	                if (err) {
	                    return callback(err);
	                }
	                async.whilst(test, iterator, callback);
	            });
	        }
	        else {
	            callback();
	        }
	    };
	
	    async.doWhilst = function (iterator, test, callback) {
	        iterator(function (err) {
	            if (err) {
	                return callback(err);
	            }
	            var args = Array.prototype.slice.call(arguments, 1);
	            if (test.apply(null, args)) {
	                async.doWhilst(iterator, test, callback);
	            }
	            else {
	                callback();
	            }
	        });
	    };
	
	    async.until = function (test, iterator, callback) {
	        if (!test()) {
	            iterator(function (err) {
	                if (err) {
	                    return callback(err);
	                }
	                async.until(test, iterator, callback);
	            });
	        }
	        else {
	            callback();
	        }
	    };
	
	    async.doUntil = function (iterator, test, callback) {
	        iterator(function (err) {
	            if (err) {
	                return callback(err);
	            }
	            var args = Array.prototype.slice.call(arguments, 1);
	            if (!test.apply(null, args)) {
	                async.doUntil(iterator, test, callback);
	            }
	            else {
	                callback();
	            }
	        });
	    };
	
	    async.queue = function (worker, concurrency) {
	        if (concurrency === undefined) {
	            concurrency = 1;
	        }
	        function _insert(q, data, pos, callback) {
	          if (!q.started){
	            q.started = true;
	          }
	          if (!_isArray(data)) {
	              data = [data];
	          }
	          if(data.length == 0) {
	             // call drain immediately if there are no tasks
	             return async.setImmediate(function() {
	                 if (q.drain) {
	                     q.drain();
	                 }
	             });
	          }
	          _each(data, function(task) {
	              var item = {
	                  data: task,
	                  callback: typeof callback === 'function' ? callback : null
	              };
	
	              if (pos) {
	                q.tasks.unshift(item);
	              } else {
	                q.tasks.push(item);
	              }
	
	              if (q.saturated && q.tasks.length === q.concurrency) {
	                  q.saturated();
	              }
	              async.setImmediate(q.process);
	          });
	        }
	
	        var workers = 0;
	        var q = {
	            tasks: [],
	            concurrency: concurrency,
	            saturated: null,
	            empty: null,
	            drain: null,
	            started: false,
	            paused: false,
	            push: function (data, callback) {
	              _insert(q, data, false, callback);
	            },
	            kill: function () {
	              q.drain = null;
	              q.tasks = [];
	            },
	            unshift: function (data, callback) {
	              _insert(q, data, true, callback);
	            },
	            process: function () {
	                if (!q.paused && workers < q.concurrency && q.tasks.length) {
	                    var task = q.tasks.shift();
	                    if (q.empty && q.tasks.length === 0) {
	                        q.empty();
	                    }
	                    workers += 1;
	                    var next = function () {
	                        workers -= 1;
	                        if (task.callback) {
	                            task.callback.apply(task, arguments);
	                        }
	                        if (q.drain && q.tasks.length + workers === 0) {
	                            q.drain();
	                        }
	                        q.process();
	                    };
	                    var cb = only_once(next);
	                    worker(task.data, cb);
	                }
	            },
	            length: function () {
	                return q.tasks.length;
	            },
	            running: function () {
	                return workers;
	            },
	            idle: function() {
	                return q.tasks.length + workers === 0;
	            },
	            pause: function () {
	                if (q.paused === true) { return; }
	                q.paused = true;
	            },
	            resume: function () {
	                if (q.paused === false) { return; }
	                q.paused = false;
	                // Need to call q.process once per concurrent
	                // worker to preserve full concurrency after pause
	                for (var w = 1; w <= q.concurrency; w++) {
	                    async.setImmediate(q.process);
	                }
	            }
	        };
	        return q;
	    };
	
	    async.priorityQueue = function (worker, concurrency) {
	
	        function _compareTasks(a, b){
	          return a.priority - b.priority;
	        };
	
	        function _binarySearch(sequence, item, compare) {
	          var beg = -1,
	              end = sequence.length - 1;
	          while (beg < end) {
	            var mid = beg + ((end - beg + 1) >>> 1);
	            if (compare(item, sequence[mid]) >= 0) {
	              beg = mid;
	            } else {
	              end = mid - 1;
	            }
	          }
	          return beg;
	        }
	
	        function _insert(q, data, priority, callback) {
	          if (!q.started){
	            q.started = true;
	          }
	          if (!_isArray(data)) {
	              data = [data];
	          }
	          if(data.length == 0) {
	             // call drain immediately if there are no tasks
	             return async.setImmediate(function() {
	                 if (q.drain) {
	                     q.drain();
	                 }
	             });
	          }
	          _each(data, function(task) {
	              var item = {
	                  data: task,
	                  priority: priority,
	                  callback: typeof callback === 'function' ? callback : null
	              };
	
	              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
	
	              if (q.saturated && q.tasks.length === q.concurrency) {
	                  q.saturated();
	              }
	              async.setImmediate(q.process);
	          });
	        }
	
	        // Start with a normal queue
	        var q = async.queue(worker, concurrency);
	
	        // Override push to accept second parameter representing priority
	        q.push = function (data, priority, callback) {
	          _insert(q, data, priority, callback);
	        };
	
	        // Remove unshift function
	        delete q.unshift;
	
	        return q;
	    };
	
	    async.cargo = function (worker, payload) {
	        var working     = false,
	            tasks       = [];
	
	        var cargo = {
	            tasks: tasks,
	            payload: payload,
	            saturated: null,
	            empty: null,
	            drain: null,
	            drained: true,
	            push: function (data, callback) {
	                if (!_isArray(data)) {
	                    data = [data];
	                }
	                _each(data, function(task) {
	                    tasks.push({
	                        data: task,
	                        callback: typeof callback === 'function' ? callback : null
	                    });
	                    cargo.drained = false;
	                    if (cargo.saturated && tasks.length === payload) {
	                        cargo.saturated();
	                    }
	                });
	                async.setImmediate(cargo.process);
	            },
	            process: function process() {
	                if (working) return;
	                if (tasks.length === 0) {
	                    if(cargo.drain && !cargo.drained) cargo.drain();
	                    cargo.drained = true;
	                    return;
	                }
	
	                var ts = typeof payload === 'number'
	                            ? tasks.splice(0, payload)
	                            : tasks.splice(0, tasks.length);
	
	                var ds = _map(ts, function (task) {
	                    return task.data;
	                });
	
	                if(cargo.empty) cargo.empty();
	                working = true;
	                worker(ds, function () {
	                    working = false;
	
	                    var args = arguments;
	                    _each(ts, function (data) {
	                        if (data.callback) {
	                            data.callback.apply(null, args);
	                        }
	                    });
	
	                    process();
	                });
	            },
	            length: function () {
	                return tasks.length;
	            },
	            running: function () {
	                return working;
	            }
	        };
	        return cargo;
	    };
	
	    var _console_fn = function (name) {
	        return function (fn) {
	            var args = Array.prototype.slice.call(arguments, 1);
	            fn.apply(null, args.concat([function (err) {
	                var args = Array.prototype.slice.call(arguments, 1);
	                if (typeof console !== 'undefined') {
	                    if (err) {
	                        if (console.error) {
	                            console.error(err);
	                        }
	                    }
	                    else if (console[name]) {
	                        _each(args, function (x) {
	                            console[name](x);
	                        });
	                    }
	                }
	            }]));
	        };
	    };
	    async.log = _console_fn('log');
	    async.dir = _console_fn('dir');
	    /*async.info = _console_fn('info');
	    async.warn = _console_fn('warn');
	    async.error = _console_fn('error');*/
	
	    async.memoize = function (fn, hasher) {
	        var memo = {};
	        var queues = {};
	        hasher = hasher || function (x) {
	            return x;
	        };
	        var memoized = function () {
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            var key = hasher.apply(null, args);
	            if (key in memo) {
	                async.nextTick(function () {
	                    callback.apply(null, memo[key]);
	                });
	            }
	            else if (key in queues) {
	                queues[key].push(callback);
	            }
	            else {
	                queues[key] = [callback];
	                fn.apply(null, args.concat([function () {
	                    memo[key] = arguments;
	                    var q = queues[key];
	                    delete queues[key];
	                    for (var i = 0, l = q.length; i < l; i++) {
	                      q[i].apply(null, arguments);
	                    }
	                }]));
	            }
	        };
	        memoized.memo = memo;
	        memoized.unmemoized = fn;
	        return memoized;
	    };
	
	    async.unmemoize = function (fn) {
	      return function () {
	        return (fn.unmemoized || fn).apply(null, arguments);
	      };
	    };
	
	    async.times = function (count, iterator, callback) {
	        var counter = [];
	        for (var i = 0; i < count; i++) {
	            counter.push(i);
	        }
	        return async.map(counter, iterator, callback);
	    };
	
	    async.timesSeries = function (count, iterator, callback) {
	        var counter = [];
	        for (var i = 0; i < count; i++) {
	            counter.push(i);
	        }
	        return async.mapSeries(counter, iterator, callback);
	    };
	
	    async.seq = function (/* functions... */) {
	        var fns = arguments;
	        return function () {
	            var that = this;
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            async.reduce(fns, args, function (newargs, fn, cb) {
	                fn.apply(that, newargs.concat([function () {
	                    var err = arguments[0];
	                    var nextargs = Array.prototype.slice.call(arguments, 1);
	                    cb(err, nextargs);
	                }]))
	            },
	            function (err, results) {
	                callback.apply(that, [err].concat(results));
	            });
	        };
	    };
	
	    async.compose = function (/* functions... */) {
	      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
	    };
	
	    var _applyEach = function (eachfn, fns /*args...*/) {
	        var go = function () {
	            var that = this;
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            return eachfn(fns, function (fn, cb) {
	                fn.apply(that, args.concat([cb]));
	            },
	            callback);
	        };
	        if (arguments.length > 2) {
	            var args = Array.prototype.slice.call(arguments, 2);
	            return go.apply(this, args);
	        }
	        else {
	            return go;
	        }
	    };
	    async.applyEach = doParallel(_applyEach);
	    async.applyEachSeries = doSeries(_applyEach);
	
	    async.forever = function (fn, callback) {
	        function next(err) {
	            if (err) {
	                if (callback) {
	                    return callback(err);
	                }
	                throw err;
	            }
	            fn(next);
	        }
	        next();
	    };
	
	    // Node.js
	    if (typeof module !== 'undefined' && module.exports) {
	        module.exports = async;
	    }
	    // AMD / RequireJS
	    else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return async;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    // included directly via <script> tag
	    else {
	        root.async = async;
	    }
	
	}());
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), __webpack_require__(184).setImmediate))

/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var EventEmitter = __webpack_require__(405).EventEmitter;
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var sysPath = __webpack_require__(180);
	var each = __webpack_require__(408);
	var anymatch = __webpack_require__(409);
	var globparent = __webpack_require__(439);
	var isglob = __webpack_require__(424);
	var arrify = __webpack_require__(410);
	var isAbsolute = __webpack_require__(443);
	
	var NodeFsHandler = __webpack_require__(444);
	var FsEventsHandler = __webpack_require__(490);
	
	// Public: Main class.
	// Watches files & directories for changes.
	//
	// * _opts - object, chokidar options hash
	//
	// Emitted events:
	// `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
	//
	// Examples
	//
	//  var watcher = new FSWatcher()
	//    .add(directories)
	//    .on('add', function(path) {console.log('File', path, 'was added');})
	//    .on('change', function(path) {console.log('File', path, 'was changed');})
	//    .on('unlink', function(path) {console.log('File', path, 'was removed');})
	//    .on('all', function(event, path) {console.log(path, ' emitted ', event);})
	//
	function FSWatcher(_opts) {
	  var opts = {};
	  // in case _opts that is passed in is a frozen object
	  if (_opts) for (var opt in _opts) opts[opt] = _opts[opt];
	  this._watched = Object.create(null);
	  this._closers = Object.create(null);
	  this._ignoredPaths = Object.create(null);
	  Object.defineProperty(this, '_globIgnored', {
	    get: function() { return Object.keys(this._ignoredPaths); }
	  });
	  this.closed = false;
	  this._throttled = Object.create(null);
	  this._symlinkPaths = Object.create(null);
	
	  function undef(key) {
	    return opts[key] === undefined;
	  }
	
	  // Set up default options.
	  if (undef('persistent')) opts.persistent = true;
	  if (undef('ignoreInitial')) opts.ignoreInitial = false;
	  if (undef('ignorePermissionErrors')) opts.ignorePermissionErrors = false;
	  if (undef('interval')) opts.interval = 100;
	  if (undef('binaryInterval')) opts.binaryInterval = 300;
	  this.enableBinaryInterval = opts.binaryInterval !== opts.interval;
	
	  // Enable fsevents on OS X when polling isn't explicitly enabled.
	  if (undef('useFsEvents')) opts.useFsEvents = !opts.usePolling;
	
	  // If we can't use fsevents, ensure the options reflect it's disabled.
	  if (!FsEventsHandler.canUse()) opts.useFsEvents = false;
	
	  // Use polling on Mac if not using fsevents.
	  // Other platforms use non-polling fs.watch.
	  if (undef('usePolling') && !opts.useFsEvents) {
	    opts.usePolling = process.platform === 'darwin';
	  }
	
	  // Editor atomic write normalization enabled by default with fs.watch
	  if (undef('atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
	  if (opts.atomic) this._pendingUnlinks = Object.create(null);
	
	  if (undef('followSymlinks')) opts.followSymlinks = true;
	
	  this._isntIgnored = function(path, stat) {
	    return !this._isIgnored(path, stat);
	  }.bind(this);
	
	  var readyCalls = 0;
	  this._emitReady = function() {
	    if (++readyCalls >= this._readyCount) {
	      this._emitReady = Function.prototype;
	      // use process.nextTick to allow time for listener to be bound
	      process.nextTick(this.emit.bind(this, 'ready'));
	    }
	  }.bind(this);
	
	  this.options = opts;
	
	  // You’re frozen when your heart’s not open.
	  Object.freeze(opts);
	}
	
	FSWatcher.prototype = Object.create(EventEmitter.prototype);
	
	// Common helpers
	// --------------
	
	// Private method: Normalize and emit events
	//
	// * event     - string, type of event
	// * path      - string, file or directory path
	// * val[1..3] - arguments to be passed with event
	//
	// Returns the error if defined, otherwise the value of the
	// FSWatcher instance's `closed` flag
	FSWatcher.prototype._emit = function(event, path, val1, val2, val3) {
	  if (this.options.cwd) path = sysPath.relative(this.options.cwd, path);
	  var args = [event, path];
	  if (val3 !== undefined) args.push(val1, val2, val3);
	  else if (val2 !== undefined) args.push(val1, val2);
	  else if (val1 !== undefined) args.push(val1);
	  if (this.options.atomic) {
	    if (event === 'unlink') {
	      this._pendingUnlinks[path] = args;
	      setTimeout(function() {
	        Object.keys(this._pendingUnlinks).forEach(function(path) {
	          this.emit.apply(this, this._pendingUnlinks[path]);
	          this.emit.apply(this, ['all'].concat(this._pendingUnlinks[path]));
	          delete this._pendingUnlinks[path];
	        }.bind(this));
	      }.bind(this), 100);
	      return this;
	    } else if (event === 'add' && this._pendingUnlinks[path]) {
	      event = args[0] = 'change';
	      delete this._pendingUnlinks[path];
	    }
	  }
	
	  if (event === 'change') {
	    if (!this._throttle('change', path, 50)) return this;
	  }
	
	  var emitEvent = function() {
	    this.emit.apply(this, args);
	    if (event !== 'error') this.emit.apply(this, ['all'].concat(args));
	  }.bind(this);
	
	  if (
	    this.options.alwaysStat && val1 === undefined &&
	    (event === 'add' || event === 'addDir' || event === 'change')
	  ) {
	    fs.stat(path, function(error, stats) {
	      // Suppress event when fs.stat fails, to avoid sending undefined 'stat'
	      if (error || !stats) return;
	
	      args.push(stats);
	      emitEvent();
	    });
	  } else {
	    emitEvent();
	  }
	
	  return this;
	};
	
	// Private method: Common handler for errors
	//
	// * error  - object, Error instance
	//
	// Returns the error if defined, otherwise the value of the
	// FSWatcher instance's `closed` flag
	FSWatcher.prototype._handleError = function(error) {
	  var code = error && error.code;
	  var ipe = this.options.ignorePermissionErrors;
	  if (error &&
	    code !== 'ENOENT' &&
	    code !== 'ENOTDIR' &&
	    (!ipe || (code !== 'EPERM' && code !== 'EACCES'))
	  ) this.emit('error', error);
	  return error || this.closed;
	};
	
	// Private method: Helper utility for throttling
	//
	// * action  - string, type of action being throttled
	// * path    - string, path being acted upon
	// * timeout - int, duration of time to suppress duplicate actions
	//
	// Returns throttle tracking object or false if action should be suppressed
	FSWatcher.prototype._throttle = function(action, path, timeout) {
	  if (!(action in this._throttled)) {
	    this._throttled[action] = Object.create(null);
	  }
	  var throttled = this._throttled[action];
	  if (path in throttled) return false;
	  function clear() {
	    delete throttled[path];
	    clearTimeout(timeoutObject);
	  }
	  var timeoutObject = setTimeout(clear, timeout);
	  throttled[path] = {timeoutObject: timeoutObject, clear: clear};
	  return throttled[path];
	};
	
	// Private method: Determines whether user has asked to ignore this path
	//
	// * path  - string, path to file or directory
	// * stats - object, result of fs.stat
	//
	// Returns boolean
	FSWatcher.prototype._isIgnored = function(path, stats) {
	  if (
	    this.options.atomic &&
	    /\..*\.(sw[px])$|\~$|\.subl.*\.tmp/.test(path)
	  ) return true;
	
	  if (!this._userIgnored) {
	    var cwd = this.options.cwd;
	    var ignored = this.options.ignored;
	    if (cwd && ignored) {
	      ignored = arrify(ignored).map(function (path) {
	        if (typeof path !== 'string') return path;
	        return isAbsolute(path) ? path : sysPath.join(cwd, path);
	      });
	    }
	    this._userIgnored = anymatch(this._globIgnored
	      .concat(ignored)
	      .concat(arrify(ignored)
	        .filter(function(path) {
	          return typeof path === 'string' && !isglob(path);
	        }).map(function(path) {
	          return path + '/**/*';
	        })
	      )
	    );
	  }
	
	  return this._userIgnored([path, stats]);
	};
	
	// Private method: Provides a set of common helpers and properties relating to
	// symlink and glob handling
	//
	// * path - string, file, directory, or glob pattern being watched
	// * depth - int, at any depth > 0, this isn't a glob
	//
	// Returns object containing helpers for this path
	FSWatcher.prototype._getWatchHelpers = function(path, depth) {
	  path = path.replace(/^\.[\/\\]/, '');
	  var watchPath = depth ? path : globparent(path);
	  var hasGlob = watchPath !== path;
	  var globFilter = hasGlob ? anymatch(path) : false;
	
	  var entryPath = function(entry) {
	    return sysPath.join(watchPath, sysPath.relative(watchPath, entry.fullPath));
	  }
	
	  var filterPath = function(entry) {
	    return (!hasGlob || globFilter(entryPath(entry))) &&
	      this._isntIgnored(entryPath(entry), entry.stat) &&
	      (this.options.ignorePermissionErrors ||
	        this._hasReadPermissions(entry.stat));
	  }.bind(this);
	
	  var getDirParts = function(path) {
	    if (!hasGlob) return false;
	    var parts = sysPath.relative(watchPath, path).split(/[\/\\]/);
	    return parts;
	  }
	  var dirParts = getDirParts(path);
	  if (dirParts && dirParts.length > 1) dirParts.pop();
	
	  var filterDir = function(entry) {
	    if (hasGlob) {
	      var entryParts = getDirParts(entry.fullPath);
	      var globstar = false;
	      var unmatchedGlob = !dirParts.every(function(part, i) {
	        if (part === '**') globstar = true;
	        return globstar || !entryParts[i] || anymatch(part, entryParts[i]);
	      });
	    }
	    return !unmatchedGlob && this._isntIgnored(entryPath(entry), entry.stat);
	  }.bind(this);
	
	  return {
	    followSymlinks: this.options.followSymlinks,
	    statMethod: this.options.followSymlinks ? 'stat' : 'lstat',
	    path: path,
	    watchPath: watchPath,
	    entryPath: entryPath,
	    hasGlob: hasGlob,
	    globFilter: globFilter,
	    filterPath: filterPath,
	    filterDir: filterDir
	  };
	}
	
	// Directory helpers
	// -----------------
	
	// Private method: Provides directory tracking objects
	//
	// * directory - string, path of the directory
	//
	// Returns the directory's tracking object
	FSWatcher.prototype._getWatchedDir = function(directory) {
	  var dir = sysPath.resolve(directory);
	  var watcherRemove = this._remove.bind(this);
	  if (!(dir in this._watched)) this._watched[dir] = {
	    _items: Object.create(null),
	    add: function(item) {this._items[item] = true;},
	    remove: function(item) {
	      delete this._items[item];
	      if (!this.children().length) {
	        fs.readdir(dir, function(err) {
	          if (err) watcherRemove(sysPath.dirname(dir), sysPath.basename(dir));
	        });
	      }
	    },
	    has: function(item) {return item in this._items;},
	    children: function() {return Object.keys(this._items);}
	  };
	  return this._watched[dir];
	};
	
	// File helpers
	// ------------
	
	// Private method: Check for read permissions
	// Based on this answer on SO: http://stackoverflow.com/a/11781404/1358405
	//
	// * stats - object, result of fs.stat
	//
	// Returns boolean
	FSWatcher.prototype._hasReadPermissions = function(stats) {
	  return Boolean(4 & parseInt(((stats && stats.mode) & 0x1ff).toString(8)[0], 10));
	};
	
	// Private method: Handles emitting unlink events for
	// files and directories, and via recursion, for
	// files and directories within directories that are unlinked
	//
	// * directory - string, directory within which the following item is located
	// * item      - string, base path of item/directory
	//
	// Returns nothing
	FSWatcher.prototype._remove = function(directory, item) {
	  // if what is being deleted is a directory, get that directory's paths
	  // for recursive deleting and cleaning of watched object
	  // if it is not a directory, nestedDirectoryChildren will be empty array
	  var path = sysPath.join(directory, item);
	  var fullPath = sysPath.resolve(path);
	  var isDirectory = this._watched[path] || this._watched[fullPath];
	
	  // prevent duplicate handling in case of arriving here nearly simultaneously
	  // via multiple paths (such as _handleFile and _handleDir)
	  if (!this._throttle('remove', path, 100)) return;
	
	  // if the only watched file is removed, watch for its return
	  var watchedDirs = Object.keys(this._watched);
	  if (!isDirectory && !this.options.useFsEvents && watchedDirs.length === 1) {
	    this.add(directory, item, true);
	  }
	
	  // This will create a new entry in the watched object in either case
	  // so we got to do the directory check beforehand
	  var nestedDirectoryChildren = this._getWatchedDir(path).children();
	
	  // Recursively remove children directories / files.
	  nestedDirectoryChildren.forEach(function(nestedItem) {
	    this._remove(path, nestedItem);
	  }, this);
	
	  // Check if item was on the watched list and remove it
	  var parent = this._getWatchedDir(directory);
	  var wasTracked = parent.has(item);
	  parent.remove(item);
	
	  // The Entry will either be a directory that just got removed
	  // or a bogus entry to a file, in either case we have to remove it
	  delete this._watched[path];
	  delete this._watched[fullPath];
	  var eventName = isDirectory ? 'unlinkDir' : 'unlink';
	  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);
	};
	
	// Public method: Adds paths to be watched on an existing FSWatcher instance
	
	// * paths     - string or array of strings, file/directory paths and/or globs
	// * _origAdd  - private boolean, for handling non-existent paths to be watched
	// * _internal - private boolean, indicates a non-user add
	
	// Returns an instance of FSWatcher for chaining.
	FSWatcher.prototype.add = function(paths, _origAdd, _internal) {
	  var cwd = this.options.cwd;
	  this.closed = false;
	  paths = arrify(paths);
	
	  if (cwd) paths = paths.map(function(path) {
	    if (isAbsolute(path)) {
	      return path;
	    } else if (path[0] === '!') {
	      return '!' + sysPath.join(cwd, path.substring(1));
	    } else {
	      return sysPath.join(cwd, path);
	    }
	  });
	
	  // set aside negated glob strings
	  paths = paths.filter(function(path) {
	    if (path[0] === '!') this._ignoredPaths[path.substring(1)] = true;
	    else {
	      // if a path is being added that was previously ignored, stop ignoring it
	      delete this._ignoredPaths[path];
	      delete this._ignoredPaths[path + '/**/*'];
	
	      // reset the cached userIgnored anymatch fn
	      // to make ignoredPaths changes effective
	      this._userIgnored = null;
	
	      return true;
	    }
	  }, this);
	
	  if (this.options.useFsEvents && FsEventsHandler.canUse()) {
	    if (!this._readyCount) this._readyCount = paths.length;
	    if (this.options.persistent) this._readyCount *= 2;
	    paths.forEach(this._addToFsEvents, this);
	  } else {
	    if (!this._readyCount) this._readyCount = 0;
	    this._readyCount += paths.length;
	    each(paths, function(path, next) {
	      this._addToNodeFs(path, !_internal, 0, 0, _origAdd, function(err, res) {
	        if (res) this._emitReady();
	        next(err, res);
	      }.bind(this));
	    }.bind(this), function(error, results) {
	      results.forEach(function(item) {
	        if (!item) return;
	        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
	      }, this);
	    }.bind(this));
	  }
	
	  return this;
	};
	
	// Public method: Close watchers or start ignoring events from specified paths.
	
	// * paths     - string or array of strings, file/directory paths and/or globs
	
	// Returns instance of FSWatcher for chaining.
	FSWatcher.prototype.unwatch = function(paths) {
	  if (this.closed) return this;
	  paths = arrify(paths);
	
	  paths.forEach(function(path) {
	    if (this._closers[path]) {
	      this._closers[path]();
	    } else {
	      this._ignoredPaths[path] = true;
	      if (path in this._watched) this._ignoredPaths[path + '/**/*'] = true;
	
	      // reset the cached userIgnored anymatch fn
	      // to make ignoredPaths changes effective
	      this._userIgnored = null;
	    }
	  }, this);
	
	  return this;
	};
	
	// Public method: Close watchers and remove all listeners from watched paths.
	
	// Returns instance of FSWatcher for chaining.
	FSWatcher.prototype.close = function() {
	  if (this.closed) return this;
	
	  this.closed = true;
	  Object.keys(this._closers).forEach(function(watchPath) {
	    this._closers[watchPath]();
	    delete this._closers[watchPath];
	  }, this);
	  this._watched = Object.create(null);
	
	  this.removeAllListeners();
	  return this;
	};
	
	// Attach watch handler prototype methods
	function importHandler(handler) {
	  Object.keys(handler.prototype).forEach(function(method) {
	    FSWatcher.prototype[method] = handler.prototype[method];
	  });
	}
	importHandler(NodeFsHandler);
	if (FsEventsHandler.canUse()) importHandler(FsEventsHandler);
	
	// Export FSWatcher class
	exports.FSWatcher = FSWatcher;
	
	// Public function: Instantiates watcher with paths to be tracked.
	
	// * paths     - string or array of strings, file/directory paths and/or globs
	// * options   - object, chokidar options
	
	// Returns an instance of FSWatcher for chaining.
	exports.watch = function(paths, options) {
	  return new FSWatcher(options).add(paths);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// async-each MIT license (by Paul Miller from http://paulmillr.com).
	(function(globals) {
	  'use strict';
	  var each = function(items, next, callback) {
	    if (!Array.isArray(items)) throw new TypeError('each() expects array as first argument');
	    if (typeof next !== 'function') throw new TypeError('each() expects function as second argument');
	    if (typeof callback !== 'function') callback = Function.prototype; // no-op
	
	    if (items.length === 0) return callback(undefined, items);
	
	    var transformed = new Array(items.length);
	    var count = 0;
	    var returned = false;
	
	    items.forEach(function(item, index) {
	      next(item, function(error, transformedItem) {
	        if (returned) return;
	        if (error) {
	          returned = true;
	          return callback(error);
	        }
	        transformed[index] = transformedItem;
	        count += 1;
	        if (count === items.length) return callback(undefined, transformed);
	      });
	    });
	  };
	
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return each;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // RequireJS
	  } else if (typeof module !== 'undefined' && module.exports) {
	    module.exports = each; // CommonJS
	  } else {
	    globals.asyncEach = each; // <script>
	  }
	})(this);


/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var arrify = __webpack_require__(410);
	var micromatch = __webpack_require__(411);
	var path = __webpack_require__(180);
	
	var anymatch = function(criteria, value, returnIndex, startIndex, endIndex) {
	  criteria = arrify(criteria);
	  value = arrify(value);
	  if (arguments.length === 1) {
	    return anymatch.bind(null, criteria.map(function(criterion) {
	      return typeof criterion === 'string' && criterion[0] !== '!' ?
	        micromatch.matcher(criterion) : criterion;
	    }));
	  }
	  startIndex = startIndex || 0;
	  var string = value[0];
	  var altString;
	  var matched = false;
	  var matchIndex = -1;
	  function testCriteria (criterion, index) {
	    var result;
	    switch (toString.call(criterion)) {
	    case '[object String]':
	      result = string === criterion || altString && altString === criterion;
	      result = result || micromatch.isMatch(string, criterion);
	      break;
	    case '[object RegExp]':
	      result = criterion.test(string) || altString && criterion.test(altString);
	      break;
	    case '[object Function]':
	      result = criterion.apply(null, value);
	      break;
	    default:
	      result = false;
	    }
	    if (result) {
	      matchIndex = index + startIndex;
	    }
	    return result;
	  }
	  var crit = criteria;
	  var negGlobs = crit.reduce(function(arr, criterion, index) {
	    if (typeof criterion === 'string' && criterion[0] === '!') {
	      if (crit === criteria) {
	        // make a copy before modifying
	        crit = crit.slice();
	      }
	      crit[index] = null;
	      arr.push(criterion.substr(1));
	    }
	    return arr;
	  }, []);
	  if (!negGlobs.length || !micromatch.any(string, negGlobs)) {
	    if (path.sep === '\\' && typeof string === 'string') {
	      altString = string.split('\\').join('/');
	      altString = altString === string ? null : altString;
	    }
	    matched = crit.slice(startIndex, endIndex).some(testCriteria);
	  }
	  return returnIndex === true ? matchIndex : matched;
	};
	
	module.exports = anymatch;


/***/ },
/* 410 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function (val) {
		if (val == null) {
			return [];
		}
	
		return Array.isArray(val) ? val : [val];
	};


/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * micromatch <https://github.com/jonschlinkert/micromatch>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var diff = __webpack_require__(412);
	var typeOf = __webpack_require__(415);
	var omit = __webpack_require__(416);
	var unique = __webpack_require__(420);
	var cache = __webpack_require__(421);
	var isGlob = __webpack_require__(424);
	var expand = __webpack_require__(425);
	var utils = __webpack_require__(426);
	
	/**
	 * The main function. Pass an array of filepaths,
	 * and a string or array of glob patterns
	 *
	 * @param  {Array|String} `files`
	 * @param  {Array|String} `patterns`
	 * @param  {Object} `opts`
	 * @return {Array} Array of matches
	 */
	
	function micromatch(files, patterns, opts) {
	  if (!files || !patterns) return [];
	  opts = opts || {};
	
	  if (typeof opts.cache === 'undefined') {
	    opts.cache = true;
	  }
	
	  if (!Array.isArray(patterns)) {
	    return match(files, patterns, opts);
	  }
	
	  var len = patterns.length, i = 0;
	  var omit = [], keep = [];
	
	  while (len--) {
	    var glob = patterns[i++];
	    if (glob.charCodeAt(0) === 33 /* ! */) {
	      omit.push.apply(omit, match(files, glob.slice(1), opts));
	    } else {
	      keep.push.apply(keep, match(files, glob, opts));
	    }
	  }
	  return diff(keep, omit);
	}
	
	/**
	 * Pass an array of files and a glob pattern as a string.
	 *
	 * This function is called by the main `micromatch` function
	 * If you only need to pass a single pattern you might get
	 * very minor speed improvements using this function.
	 *
	 * @param  {Array} `files`
	 * @param  {Array} `pattern`
	 * @param  {Object} `options`
	 * @return {Array}
	 */
	
	function match(files, pattern, opts) {
	  if (typeOf(files) !== 'string' && !Array.isArray(files)) {
	    throw new Error(msg('match', 'files', 'a string or array'));
	  }
	
	  files = utils.arrayify(files);
	  opts = opts || {};
	
	  var negate = opts.negate || false;
	  var orig = pattern;
	
	  if (typeof pattern === 'string' && opts.nonegate !== true) {
	    negate = pattern.charAt(0) === '!';
	    if (negate) {
	      pattern = pattern.slice(1);
	    }
	  }
	
	  var _isMatch = matcher(pattern, opts);
	  var len = files.length, i = 0;
	  var res = [];
	
	  while (i < len) {
	    var file = files[i++];
	    var fp = utils.unixify(file, opts);
	
	    if (!_isMatch(fp)) { continue; }
	    res.push(fp);
	  }
	
	  if (res.length === 0) {
	    if (opts.failglob === true) {
	      throw new Error('micromatch.match() found no matches for: "' + orig + '".');
	    }
	
	    if (opts.nonull || opts.nullglob) {
	      res.push(utils.unescapeGlob(orig));
	    }
	  }
	
	  // if `negate` was defined, diff negated files
	  if (negate) { res = diff(files, res); }
	
	  // if `ignore` was defined, diff ignored filed
	  if (opts.ignore && opts.ignore.length) {
	    pattern = opts.ignore;
	    opts = omit(opts, ['ignore']);
	    res = diff(res, micromatch(res, pattern, opts));
	  }
	
	  if (opts.nodupes) {
	    return unique(res);
	  }
	  return res;
	}
	
	/**
	 * Returns a function that takes a glob pattern or array of glob patterns
	 * to be used with `Array#filter()`. (Internally this function generates
	 * the matching function using the [matcher] method).
	 *
	 * ```js
	 * var fn = mm.filter('[a-c]');
	 * ['a', 'b', 'c', 'd', 'e'].filter(fn);
	 * //=> ['a', 'b', 'c']
	 * ```
	 *
	 * @param  {String|Array} `patterns` Can be a glob or array of globs.
	 * @param  {Options} `opts` Options to pass to the [matcher] method.
	 * @return {Function} Filter function to be passed to `Array#filter()`.
	 */
	
	function filter(patterns, opts) {
	  if (!Array.isArray(patterns) && typeof patterns !== 'string') {
	    throw new TypeError(msg('filter', 'patterns', 'a string or array'));
	  }
	
	  patterns = utils.arrayify(patterns);
	  return function (fp) {
	    if (fp == null) return [];
	    var len = patterns.length, i = 0;
	    var res = true;
	
	    fp = utils.unixify(fp, opts);
	    while (i < len) {
	      var fn = matcher(patterns[i++], opts);
	      if (!fn(fp)) {
	        res = false;
	        break;
	      }
	    }
	    return res;
	  };
	}
	
	/**
	 * Returns true if the filepath contains the given
	 * pattern. Can also return a function for matching.
	 *
	 * ```js
	 * isMatch('foo.md', '*.md', {});
	 * //=> true
	 *
	 * isMatch('*.md', {})('foo.md')
	 * //=> true
	 * ```
	 *
	 * @param  {String} `fp`
	 * @param  {String} `pattern`
	 * @param  {Object} `opts`
	 * @return {Boolean}
	 */
	
	function isMatch(fp, pattern, opts) {
	  if (typeof fp !== 'string') {
	    throw new TypeError(msg('isMatch', 'filepath', 'a string'));
	  }
	
	  fp = utils.unixify(fp, opts);
	  if (typeOf(pattern) === 'object') {
	    return matcher(fp, pattern);
	  }
	  return matcher(pattern, opts)(fp);
	}
	
	/**
	 * Returns true if the filepath matches the
	 * given pattern.
	 */
	
	function contains(fp, pattern, opts) {
	  if (typeof fp !== 'string') {
	    throw new TypeError(msg('contains', 'pattern', 'a string'));
	  }
	
	  opts = opts || {};
	  opts.contains = (pattern !== '');
	  fp = utils.unixify(fp, opts);
	
	  if (opts.contains && !isGlob(pattern)) {
	    return fp.indexOf(pattern) !== -1;
	  }
	  return matcher(pattern, opts)(fp);
	}
	
	/**
	 * Returns true if a file path matches any of the
	 * given patterns.
	 *
	 * @param  {String} `fp` The filepath to test.
	 * @param  {String|Array} `patterns` Glob patterns to use.
	 * @param  {Object} `opts` Options to pass to the `matcher()` function.
	 * @return {String}
	 */
	
	function any(fp, patterns, opts) {
	  if (!Array.isArray(patterns) && typeof patterns !== 'string') {
	    throw new TypeError(msg('any', 'patterns', 'a string or array'));
	  }
	
	  patterns = utils.arrayify(patterns);
	  var len = patterns.length;
	
	  fp = utils.unixify(fp, opts);
	  while (len--) {
	    var isMatch = matcher(patterns[len], opts);
	    if (isMatch(fp)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Filter the keys of an object with the given `glob` pattern
	 * and `options`
	 *
	 * @param  {Object} `object`
	 * @param  {Pattern} `object`
	 * @return {Array}
	 */
	
	function matchKeys(obj, glob, options) {
	  if (typeOf(obj) !== 'object') {
	    throw new TypeError(msg('matchKeys', 'first argument', 'an object'));
	  }
	
	  var fn = matcher(glob, options);
	  var res = {};
	
	  for (var key in obj) {
	    if (obj.hasOwnProperty(key) && fn(key)) {
	      res[key] = obj[key];
	    }
	  }
	  return res;
	}
	
	/**
	 * Return a function for matching based on the
	 * given `pattern` and `options`.
	 *
	 * @param  {String} `pattern`
	 * @param  {Object} `options`
	 * @return {Function}
	 */
	
	function matcher(pattern, opts) {
	  // pattern is a function
	  if (typeof pattern === 'function') {
	    return pattern;
	  }
	  // pattern is a regex
	  if (pattern instanceof RegExp) {
	    return function(fp) {
	      return pattern.test(fp);
	    };
	  }
	
	  // strings, all the way down...
	  pattern = utils.unixify(pattern, opts);
	
	  // pattern is a non-glob string
	  if (!isGlob(pattern)) {
	    return utils.matchPath(pattern, opts);
	  }
	  // pattern is a glob string
	  var re = makeRe(pattern, opts);
	
	  // `matchBase` is defined
	  if (opts && opts.matchBase) {
	    return utils.hasFilename(re, opts);
	  }
	  // `matchBase` is not defined
	  return function(fp) {
	    fp = utils.unixify(fp, opts);
	    return re.test(fp);
	  };
	}
	
	/**
	 * Create and cache a regular expression for matching
	 * file paths.
	 *
	 * If the leading character in the `glob` is `!`, a negation
	 * regex is returned.
	 *
	 * @param  {String} `glob`
	 * @param  {Object} `options`
	 * @return {RegExp}
	 */
	
	function toRegex(glob, options) {
	  if (typeOf(glob) !== 'string') {
	    throw new Error(msg('toRegex', 'glob', 'a string'));
	  }
	
	  // clone options to prevent  mutating the original object
	  var opts = Object.create(options || {});
	  var flags = opts.flags || '';
	  if (opts.nocase && flags.indexOf('i') === -1) {
	    flags += 'i';
	  }
	
	  var parsed = expand(glob, opts);
	
	  // pass in tokens to avoid parsing more than once
	  opts.negated = opts.negated || parsed.negated;
	  opts.negate = opts.negated;
	  glob = wrapGlob(parsed.pattern, opts);
	  var re;
	
	  try {
	    re = new RegExp(glob, flags);
	    return re;
	  } catch (err) {
	    var msg = 'micromatch invalid regex: (' + re + ')';
	    if (opts.strict) throw new SyntaxError(msg + err);
	  }
	  return /$^/;
	}
	
	/**
	 * Create the regex to do the matching. If the leading
	 * character in the `glob` is `!` a negation regex is returned.
	 *
	 * @param {String} `glob`
	 * @param {Boolean} `negate`
	 */
	
	function wrapGlob(glob, opts) {
	  var prefix = (opts && !opts.contains) ? '^' : '';
	  var after = (opts && !opts.contains) ? '$' : '';
	  glob = ('(?:' + glob + ')' + after);
	  if (opts && opts.negate) {
	    return prefix + ('(?!^' + glob + ').*$');
	  }
	  return prefix + glob;
	}
	
	/**
	 * Wrap `toRegex` to memoize the generated regex
	 * the string and options don't change
	 */
	
	function makeRe(glob, opts) {
	  return cache(toRegex, glob, opts);
	}
	
	/**
	 * Make error messages consistent. Follows this format:
	 *
	 * ```js
	 * msg(methodName, argNumber, nativeType);
	 * // example:
	 * msg('matchKeys', 'first', 'an object');
	 * ```
	 *
	 * @param  {String} `method`
	 * @param  {String} `num`
	 * @param  {String} `type`
	 * @return {String}
	 */
	
	function msg(method, what, type) {
	  return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';
	}
	
	/**
	 * Public methods
	 */
	
	micromatch.any       = any;
	micromatch.braces    = micromatch.braceExpand = __webpack_require__(429);
	micromatch.contains  = contains;
	micromatch.expand    = expand;
	micromatch.filter    = filter;
	micromatch.isMatch   = isMatch;
	micromatch.makeRe    = makeRe;
	micromatch.match     = match;
	micromatch.matcher   = matcher;
	micromatch.matchKeys = matchKeys;
	
	/**
	 * Expose `micromatch`
	 */
	
	module.exports = micromatch;


/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * arr-diff <https://github.com/jonschlinkert/arr-diff>
	 *
	 * Copyright (c) 2014 Jon Schlinkert, contributors.
	 * Licensed under the MIT License
	 */
	
	'use strict';
	
	var flatten = __webpack_require__(413);
	var slice = __webpack_require__(414);
	
	/**
	 * Return the difference between the first array and
	 * additional arrays.
	 *
	 * ```js
	 * var diff = require('{%= name %}');
	 *
	 * var a = ['a', 'b', 'c', 'd'];
	 * var b = ['b', 'c'];
	 *
	 * console.log(diff(a, b))
	 * //=> ['a', 'd']
	 * ```
	 *
	 * @param  {Array} `a`
	 * @param  {Array} `b`
	 * @return {Array}
	 * @api public
	 */
	
	function diff(arr, arrays) {
	  var argsLen = arguments.length;
	  var len = arr.length, i = -1;
	  var res = [], arrays;
	
	  if (argsLen === 1) {
	    return arr;
	  }
	
	  if (argsLen > 2) {
	    arrays = flatten(slice(arguments, 1));
	  }
	
	  while (++i < len) {
	    if (!~arrays.indexOf(arr[i])) {
	      res.push(arr[i]);
	    }
	  }
	  return res;
	}
	
	/**
	 * Expose `diff`
	 */
	
	module.exports = diff;


/***/ },
/* 413 */
/***/ function(module, exports) {

	/*!
	 * arr-flatten <https://github.com/jonschlinkert/arr-flatten>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	module.exports = function flatten(arr) {
	  return flat(arr, []);
	};
	
	function flat(arr, res) {
	  var len = arr.length;
	  var i = -1;
	
	  while (len--) {
	    var cur = arr[++i];
	    if (Array.isArray(cur)) {
	      flat(cur, res);
	    } else {
	      res.push(cur);
	    }
	  }
	  return res;
	}

/***/ },
/* 414 */
/***/ function(module, exports) {

	/*!
	 * array-slice <https://github.com/jonschlinkert/array-slice>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	module.exports = function slice(arr, start, end) {
	  var len = arr.length >>> 0;
	  var range = [];
	
	  start = idx(arr, start);
	  end = idx(arr, end, len);
	
	  while (start < end) {
	    range.push(arr[start++]);
	  }
	  return range;
	};
	
	
	function idx(arr, pos, end) {
	  var len = arr.length >>> 0;
	
	  if (pos == null) {
	    pos = end || 0;
	  } else if (pos < 0) {
	    pos = Math.max(len + pos, 0);
	  } else {
	    pos = Math.min(pos, len);
	  }
	
	  return pos;
	}

/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var toString = Object.prototype.toString;
	
	/**
	 * Get the native `typeof` a value.
	 *
	 * @param  {*} `val`
	 * @return {*} Native javascript type
	 */
	
	module.exports = function kindOf(val) {
	  if (val === undefined) {
	    return 'undefined';
	  }
	  if (val === null) {
	    return 'null';
	  }
	  if (val === true || val === false || val instanceof Boolean) {
	    return 'boolean';
	  }
	  if (typeof val !== 'object') {
	    return typeof val;
	  }
	  if (Array.isArray(val)) {
	    return 'array';
	  }
	
	  var type = toString.call(val);
	
	  if (val instanceof RegExp || type === '[object RegExp]') {
	    return 'regexp';
	  }
	  if (val instanceof Date || type === '[object Date]') {
	    return 'date';
	  }
	  if (type === '[object Function]') {
	    return 'function';
	  }
	  if (type === '[object Arguments]') {
	    return 'arguments';
	  }
	  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(val)) {
	    return 'buffer';
	  }
	  return type.slice(8, -1).toLowerCase();
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176).Buffer))

/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * object.omit <https://github.com/jonschlinkert/object.omit>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var isObject = __webpack_require__(417);
	var forOwn = __webpack_require__(418);
	
	module.exports = function omit(obj, keys) {
	  if (!isObject(obj)) return {};
	  if (!keys) return obj;
	
	  keys = Array.isArray(keys) ? keys : [keys];
	  var res = {};
	
	  forOwn(obj, function (value, key) {
	    if (keys.indexOf(key) === -1) {
	      res[key] = value;
	    }
	  });
	  return res;
	};


/***/ },
/* 417 */
/***/ function(module, exports) {

	/*!
	 * isobject <https://github.com/jonschlinkert/isobject>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	module.exports = function isObject(val) {
	  return val != null && typeof val === 'object'
	    && !Array.isArray(val);
	};


/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * for-own <https://github.com/jonschlinkert/for-own>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var forIn = __webpack_require__(419);
	var hasOwn = Object.prototype.hasOwnProperty;
	
	module.exports = function forOwn(o, fn, thisArg) {
	  forIn(o, function (val, key) {
	    if (hasOwn.call(o, key)) {
	      return fn.call(thisArg, o[key], key, o);
	    }
	  });
	};


/***/ },
/* 419 */
/***/ function(module, exports) {

	/*!
	 * for-in <https://github.com/jonschlinkert/for-in>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	module.exports = function forIn(o, fn, thisArg) {
	  for (var key in o) {
	    if (fn.call(thisArg, o[key], key, o) === false) {
	      break;
	    }
	  }
	};

/***/ },
/* 420 */
/***/ function(module, exports) {

	/*!
	 * array-unique <https://github.com/jonschlinkert/array-unique>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	module.exports = function unique(arr) {
	  if (!Array.isArray(arr)) {
	    throw new TypeError('array-unique expects an array.');
	  }
	
	  var len = arr.length;
	  var i = -1;
	
	  while (i++ < len) {
	    var j = i + 1;
	
	    for (; j < arr.length; ++j) {
	      if (arr[i] === arr[j]) {
	        arr.splice(j--, 1);
	      }
	    }
	  }
	  return arr;
	};


/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * regex-cache <https://github.com/jonschlinkert/regex-cache>
	 *
	 * Copyright (c) 2015 Jon Schlinkert.
	 * Licensed under the MIT license.
	 */
	
	'use strict';
	
	var isPrimitive = __webpack_require__(422);
	var equal = __webpack_require__(423);
	
	/**
	 * Expose `regexCache`
	 */
	
	module.exports = regexCache;
	
	/**
	 * Memoize the results of a call to the new RegExp constructor.
	 *
	 * @param  {Function} fn [description]
	 * @param  {String} str [description]
	 * @param  {Options} options [description]
	 * @param  {Boolean} nocompare [description]
	 * @return {RegExp}
	 */
	
	function regexCache(fn, str, opts) {
	  var key = '_default_', regex, cached;
	
	  if (!str && !opts) {
	    if (typeof fn !== 'function') {
	      return fn;
	    }
	    return basic[key] || (basic[key] = fn());
	  }
	
	  var isString = typeof str === 'string';
	  if (isString) {
	    if (!opts) {
	      return basic[str] || (basic[str] = fn(str));
	    }
	    key = str;
	  } else {
	    opts = str;
	  }
	
	  cached = cache[key];
	  if (cached && equal(cached.opts, opts)) {
	    return cached.regex;
	  }
	
	  memo(key, opts, (regex = fn(str, opts)));
	  return regex;
	}
	
	function memo(key, opts, regex) {
	  cache[key] = {regex: regex, opts: opts};
	}
	
	/**
	 * Expose `cache`
	 */
	
	var cache = module.exports.cache = {};
	var basic = module.exports.basic = {};


/***/ },
/* 422 */
/***/ function(module, exports) {

	/*!
	 * is-primitive <https://github.com/jonschlinkert/is-primitive>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	// see http://jsperf.com/testing-value-is-primitive/7
	module.exports = function isPrimitive(value) {
	  return value == null || (typeof value !== 'function' && typeof value !== 'object');
	};


/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * is-equal-shallow <https://github.com/jonschlinkert/is-equal-shallow>
	 *
	 * Copyright (c) 2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var isPrimitive = __webpack_require__(422);
	
	module.exports = function isEqual(a, b) {
	  if (!a && !b) { return true; }
	  if (!a && b || a && !b) { return false; }
	
	  var numKeysA = 0, numKeysB = 0, key;
	  for (key in b) {
	    numKeysB++;
	    if (!isPrimitive(b[key]) || !a.hasOwnProperty(key) || (a[key] !== b[key])) {
	      return false;
	    }
	  }
	  for (key in a) {
	    numKeysA++;
	  }
	  return numKeysA === numKeysB;
	};


/***/ },
/* 424 */
/***/ function(module, exports) {

	/*!
	 * is-glob <https://github.com/jonschlinkert/is-glob>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	module.exports = function isGlob(str) {
	  return typeof str === 'string'
	    && /[!*{}?(|)[\]]/.test(str);
	};


/***/ },
/* 425 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * micromatch <https://github.com/jonschlinkert/micromatch>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var utils = __webpack_require__(426);
	var Glob = __webpack_require__(428);
	
	/**
	 * Expose `expand`
	 */
	
	module.exports = expand;
	
	/**
	 * Expand a glob pattern to resolve braces and
	 * similar patterns before converting to regex.
	 *
	 * @param  {String|Array} `pattern`
	 * @param  {Array} `files`
	 * @param  {Options} `opts`
	 * @return {Array}
	 */
	
	function expand(pattern, options) {
	  if (typeof pattern !== 'string') {
	    throw new TypeError('micromatch.expand(): argument should be a string.');
	  }
	
	  var glob = new Glob(pattern, options || {});
	  var opts = glob.options;
	
	  if (typeof opts.braces !== 'boolean' && typeof opts.nobraces !== 'boolean') {
	    opts.braces = true;
	  }
	
	  // return early if glob pattern matches special patterns
	  if (specialCase(pattern) && opts.safemode) {
	    return new RegExp(utils.escapeRe(pattern), 'g');
	  }
	
	  if (glob.pattern === '.*') {
	    return {
	      pattern: '\\.' + star,
	      tokens: tok,
	      options: opts
	    };
	  }
	
	  if (glob.pattern === '.') {
	    return {
	      pattern: '\\.',
	      tokens: tok,
	      options: opts
	    };
	  }
	
	  if (glob.pattern === '*') {
	    return {
	      pattern: oneStar(opts.dot),
	      tokens: tok,
	      options: opts
	    };
	  }
	
	  // parse the glob pattern into tokens
	  glob.parse();
	  var tok = glob.tokens;
	  tok.is.negated = opts.negated;
	
	  // dotfile handling
	  if ((opts.dotfiles === true || tok.is.dotfile) && opts.dot !== false) {
	    opts.dotfiles = true;
	    opts.dot = true;
	  }
	
	  if ((opts.dotdirs === true || tok.is.dotdir) && opts.dot !== false) {
	    opts.dotdirs = true;
	    opts.dot = true;
	  }
	
	  // check for braces with a dotfile pattern
	  if (/[{,]\./.test(glob.pattern)) {
	    opts.makeRe = false;
	    opts.dot = true;
	  }
	
	  if (opts.nonegate !== true) {
	    opts.negated = glob.negated;
	  }
	
	  // if the leading character is a dot or a slash, escape it
	  if (glob.pattern.charAt(0) === '.' && glob.pattern.charAt(1) !== '/') {
	    glob.pattern = '\\' + glob.pattern;
	  }
	
	  /**
	   * Extended globs
	   */
	
	  // expand brackets, e.g `[[:alpha:]]`
	  glob.track('before brackets');
	  if (tok.is.brackets) {
	    glob.brackets();
	  }
	  glob.track('after brackets');
	
	  // expand braces, e.g `{1..5}`
	  glob.track('before braces');
	  if (tok.is.braces) {
	    glob.braces();
	  }
	  glob.track('after braces');
	
	  // expand extglobs, e.g `foo/!(a|b)`
	  glob.track('before extglob');
	  if (tok.is.extglob) {
	    glob.extglob();
	  }
	  glob.track('after extglob');
	
	  // special patterns
	  glob._replace('[!', '[^');
	  glob._replace('(?', '(%~');
	  glob._replace('[]', '\\[\\]');
	  glob._replace('/[', '/' + (opts.dot ? dotfiles : nodot) + '[', true);
	  glob._replace('/?', '/' + (opts.dot ? dotfiles : nodot) + '[^/]', true);
	  glob._replace('/.', '/(?=.)\\.', true);
	
	  // windows drives
	  glob._replace(/^(\w):([\\\/]+?)/gi, '(?=.)$1:$2', true);
	
	  // negate slashes in exclusion ranges
	  if (glob.pattern.indexOf('[^') !== -1) {
	    glob.pattern = negateSlash(glob.pattern);
	  }
	
	  if (opts.globstar !== false && glob.pattern === '**') {
	     glob.pattern = globstar(opts.dot);
	
	  } else {
	    // '/*/*/*' => '(?:/*){3}'
	    glob._replace(/(\/\*)+/g, function (match) {
	      var len = match.length / 2;
	      if (len === 1) { return match; }
	      return '(?:\\/*){' + len + '}';
	    });
	
	    glob.pattern = balance(glob.pattern, '[', ']');
	    glob.escape(glob.pattern);
	
	    // if the pattern has `**`
	    if (tok.is.globstar) {
	      glob.pattern = collapse(glob.pattern, '/**');
	      glob.pattern = collapse(glob.pattern, '**/');
	      glob._replace(/\*{2,}/g, '**');
	
	      // 'foo/*'
	      glob._replace(/(\w+)\*(?!\/)/g, '$1[^/]*?', true);
	      glob._replace(/\*\*\/\*(\w)/g, globstar(opts.dot) + '\\/' + (opts.dot ? dotfiles : nodot) + '[^/]*?$1', true);
	
	      if (opts.dot !== true) {
	        glob._replace(/\*\*\/(.)/g, '(?:**\\/|)$1');
	      }
	
	      // 'foo/**' or '{**,*}', but not 'foo**'
	      if (tok.path.dirname !== '' || /,\*\*|\*\*,/.test(glob.orig)) {
	        glob._replace('**', globstar(opts.dot), true);
	      }
	    }
	
	    // ends with /*
	    glob._replace(/\/\*$/, '\\/' + oneStar(opts.dot), true);
	    // ends with *, no slashes
	    glob._replace(/(?!\/)\*$/, star, true);
	    // has 'n*.' (partial wildcard w/ file extension)
	    glob._replace(/([^\/]+)\*/, '$1' + oneStar(true), true);
	    // has '*'
	    glob._replace('*', oneStar(opts.dot), true);
	    glob._replace('?.', '?\\.', true);
	    glob._replace('?:', '?:', true);
	
	    glob._replace(/\?+/g, function (match) {
	      var len = match.length;
	      if (len === 1) {
	        return qmark;
	      }
	      return qmark + '{' + len + '}';
	    });
	
	    // escape '.abc' => '\\.abc'
	    glob._replace(/\.([*\w]+)/g, '\\.$1');
	    // fix '[^\\\\/]'
	    glob._replace(/\[\^[\\\/]+\]/g, qmark);
	    // '///' => '\/'
	    glob._replace(/\/+/g, '\\/');
	    // '\\\\\\' => '\\'
	    glob._replace(/\\{2,}/g, '\\');
	  }
	
	  // unescape previously escaped patterns
	  glob.unescape(glob.pattern);
	  glob._replace('__UNESC_STAR__', '*');
	
	  // escape dots that follow qmarks
	  glob._replace('?.', '?\\.');
	
	  // remove unnecessary slashes in character classes
	  glob._replace('[^\\/]', qmark);
	
	  if (glob.pattern.length > 1) {
	    if (glob.pattern.indexOf('\\/') === 0 && glob.pattern.indexOf('\\/' + nodot) !== 0) {
	      glob.pattern = '\\/' + nodot + glob.pattern.slice(2);
	    } else if (/^[\[?*]/.test(glob.pattern)) {
	      // only prepend the string if we don't want to match dotfiles
	      glob.pattern = (opts.dot ? dotfiles : nodot) + glob.pattern;
	    }
	  }
	
	  return glob;
	}
	
	/**
	 * Special cases. This is somewhat of a placeholder
	 * for more advanced logic.
	 */
	
	function specialCase(glob) {
	  if (glob === '\\') {
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Collapse repeated character sequences.
	 *
	 * ```js
	 * collapse('a/../../../b', '../');
	 * //=> 'a/../b'
	 * ```
	 *
	 * @param  {String} `str`
	 * @param  {String} `ch` Character sequence to collapse
	 * @return {String}
	 */
	
	function collapse(str, ch) {
	  var res = str.split(ch);
	  var isFirst = res[0] === '';
	  var isLast = res[res.length - 1] === '';
	  res = res.filter(Boolean);
	  if (isFirst) res.unshift('');
	  if (isLast) res.push('');
	  return res.join(ch);
	}
	
	/**
	 * Negate slashes in exclusion ranges, per glob spec:
	 *
	 * ```js
	 * negateSlash('[^foo]');
	 * //=> '[^\\/foo]'
	 * ```
	 *
	 * @param  {String} `str` glob pattern
	 * @return {String}
	 */
	
	function negateSlash(str) {
	  return str.replace(/\[\^([^\]]*?)\]/g, function (match, inner) {
	    if (inner.indexOf('/') === -1) {
	      inner = '\\/' + inner;
	    }
	    return '[^' + inner + ']';
	  });
	}
	
	/**
	 * Escape imbalanced braces/bracket. This is a very
	 * basic, naive implementation that only does enough
	 * to serve the purpose.
	 */
	
	function balance(str, a, b) {
	  var aarr = str.split(a);
	  var alen = aarr.join('').length;
	  var blen = str.split(b).join('').length;
	
	  if (alen !== blen) {
	    str = aarr.join('\\' + a);
	    return str.split(b).join('\\' + b);
	  }
	  return str;
	}
	
	/**
	 * Special patterns to be converted to regex.
	 * Heuristics are used to simplify patterns
	 * and speed up processing.
	 */
	
	var qmark       = '[^/]';
	var star        = qmark + '*?';
	var nodot       = '(?!\\.)(?=.)';
	var dotfileGlob = '(?:\\/|^)\\.{1,2}($|\\/)';
	var dotfiles    = '(?!' + dotfileGlob + ')(?=.)';
	var twoStarDot  = '(?:(?!' + dotfileGlob + ').)*?';
	
	/**
	 * Create a regex for `*`.
	 *
	 * If `dot` is true, or the pattern does not begin with
	 * a leading star, then return the simpler regex.
	 */
	
	function oneStar(dotfile) {
	  return dotfile ? '(?!' + dotfileGlob + ')(?=.)' + star : (nodot + star);
	}
	
	function globstar(dotfile) {
	  if (dotfile) { return twoStarDot; }
	  return '(?:(?!(?:\\/|^)\\.).)*?';
	}


/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var path = __webpack_require__(180);
	var fileRe = __webpack_require__(427);
	var win32 = process && process.platform === 'win32';
	
	/**
	 * Expose `utils`
	 */
	
	var utils = module.exports;
	
	
	utils.filename = function filename(fp) {
	  var seg = fp.match(fileRe());
	  return seg && seg[0];
	};
	
	utils.isPath = function isPath(pattern, opts) {
	  return function (fp) {
	    return utils.unixify(fp, opts) === pattern;
	  };
	};
	
	utils.hasPath = function hasPath(pattern, opts) {
	  return function (fp) {
	    return utils.unixify(fp, opts).indexOf(pattern) !== -1;
	  };
	};
	
	utils.matchPath = function matchPath(pattern, opts) {
	  var fn = (opts && opts.contains)
	    ? utils.hasPath(pattern, opts)
	    : utils.isPath(pattern, opts);
	  return fn;
	};
	
	utils.hasFilename = function hasFilename(re) {
	  return function (fp) {
	    var name = utils.filename(fp);
	    return name && re.test(name);
	  };
	};
	
	/**
	 * Coerce `val` to an array
	 *
	 * @param  {*} val
	 * @return {Array}
	 */
	
	utils.arrayify = function arrayify(val) {
	  return !Array.isArray(val)
	    ? [val]
	    : val;
	};
	
	/**
	 * Normalize all slashes in a file path or glob pattern to
	 * forward slashes.
	 */
	
	utils.unixify = function unixify(fp, opts) {
	  if (opts && opts.unixify === false) return fp;
	  if (opts && opts.unixify === true || win32 || path.sep === '\\') {
	    return fp.split('\\').join('/');
	  }
	  if (opts && opts.unescape === true) {
	    return fp ? fp.toString().replace(/\\(\w)/g, '$1') : '';
	  }
	  return fp;
	};
	
	/**
	 * Escape/unescape utils
	 */
	
	utils.escapePath = function escapePath(fp) {
	  return fp.replace(/[\\.]/g, '\\$&');
	};
	
	utils.unescapeGlob = function unescapeGlob(fp) {
	  return fp.replace(/[\\"']/g, '');
	};
	
	utils.escapeRe = function escapeRe(str) {
	  return str.replace(/[-[\\$*+?.#^\s{}(|)\]]/g, '\\$&');
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 427 */
/***/ function(module, exports) {

	/*!
	 * filename-regex <https://github.com/regexps/filename-regex>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert
	 * Licensed under the MIT license.
	 */
	
	module.exports = function filenameRegex() {
	  return /([^\\\/]+)$/;
	};


/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var braces = __webpack_require__(429);
	var brackets = __webpack_require__(434);
	var extglob = __webpack_require__(435);
	var parse = __webpack_require__(437);
	var chars = __webpack_require__(442);
	
	/**
	 * Expose `Glob`
	 */
	
	module.exports = Glob;
	
	function Glob(pattern, options) {
	  this.options = options || {};
	  this.pattern = pattern;
	  this.history = [];
	  this.tokens = {};
	  this.init(pattern);
	}
	
	/**
	 * Initialize defaults
	 */
	
	Glob.prototype.init = function(pattern) {
	  this.orig = pattern;
	  this.negated = this.isNegated();
	  this.options.track = this.options.track || false;
	  this.options.makeRe = true;
	};
	
	/**
	 * Push a change into `glob.history`. Useful
	 * for debugging.
	 */
	
	Glob.prototype.track = function(msg) {
	  if (this.options.track) {
	    this.history.push({msg: msg, pattern: this.pattern});
	  }
	};
	
	/**
	 * Return true if the glob pattern has the given
	 * `ch`aracter.
	 *
	 * @param  {String} `pattern`
	 * @param  {String} `ch`
	 * @return {Boolean}
	 */
	
	Glob.prototype.has = function(pattern, ch) {
	  if (ch instanceof RegExp) {
	    return ch.test(pattern);
	  }
	  return pattern.indexOf(ch) !== -1;
	};
	
	/**
	 * Return true if `glob.pattern` was negated
	 * with `!`. Also removes the `!` from the pattern.
	 *
	 * @return {Boolean}
	 */
	
	Glob.prototype.isNegated = function() {
	  if (this.tokens.isNegated) return true;
	  if (this.pattern.charCodeAt(0) === 33 /* '!' */) {
	    this.pattern = this.pattern.slice(1);
	    return true;
	  }
	  return false;
	};
	
	/**
	 * Expand braces in the given glob pattern.
	 *
	 * We only need to use the [braces] lib when
	 * patterns are nested.
	 */
	
	Glob.prototype.braces = function() {
	  if (this.options.nobraces !== true && this.options.nobrace !== true) {
	    // naive/fast check for imbalanced characters
	    var a = this.pattern.match(/[\{\(\[]/g);
	    var b = this.pattern.match(/[\}\)\]]/g);
	
	    // if imbalanced, don't optimize the pattern
	    if (a && b && (a.length !== b.length)) {
	      this.options.makeRe = false;
	    }
	
	    // expand brace patterns and join the resulting array
	    var expanded = braces(this.pattern, this.options);
	    this.pattern = expanded.join('|');
	  }
	};
	
	/**
	 * Expand bracket expressions in `glob.pattern`
	 */
	
	Glob.prototype.brackets = function() {
	  if (this.options.nobrackets !== true) {
	    this.pattern = brackets(this.pattern);
	  }
	};
	
	/**
	 * Expand bracket expressions in `glob.pattern`
	 */
	
	Glob.prototype.extglob = function() {
	  if (this.options.noextglob !== true) {
	    this.pattern = extglob(this.pattern, {escape: true});
	  }
	};
	
	/**
	 * Parse the given glob `pattern` or `glob.pattern`
	 */
	
	Glob.prototype.parse = function(pattern) {
	  this.tokens = parse(pattern || this.pattern, true);
	  return this.tokens;
	};
	
	/**
	 * Replace `a` with `b`. Also tracks the change before and
	 * after each replacement. This is disabled by default, but
	 * can be enabled by setting `options.track` to true.
	 *
	 * Also, when the pattern is a string, `.split()` is used,
	 * because it's much faster than replace.
	 *
	 * @param  {RegExp|String} `a`
	 * @param  {String} `b`
	 * @param  {Boolean} `escape` When `true`, escapes `*` and `?` in the replacement.
	 * @return {String}
	 */
	
	Glob.prototype._replace = function(a, b, escape) {
	  this.track('before (find): "' + a + '" (replace with): "' + b + '"');
	  if (escape) b = esc(b);
	  if (a && b && typeof a === 'string') {
	    this.pattern = this.pattern.split(a).join(b);
	  } else if (a instanceof RegExp) {
	    this.pattern = this.pattern.replace(a, b);
	  }
	  this.track('after');
	};
	
	/**
	 * Escape special characters in the given string.
	 *
	 * @param  {String} `str` Glob pattern
	 * @return {String}
	 */
	
	Glob.prototype.escape = function(str) {
	  this.track('before escape: ');
	  var re = /["\\](['"]?[^"'\\]['"]?)/g;
	
	  this.pattern = str.replace(re, function($0, $1) {
	    var o = chars.ESC;
	    var ch = o && o[$1];
	    if (ch) {
	      return ch;
	    }
	    if (/[a-z]/i.test($0)) {
	      return $0.split('\\').join('');
	    }
	    return $0;
	  });
	
	  this.track('after escape: ');
	};
	
	/**
	 * Unescape special characters in the given string.
	 *
	 * @param  {String} `str`
	 * @return {String}
	 */
	
	Glob.prototype.unescape = function(str) {
	  var re = /__([A-Z]+)_([A-Z]+)__/g;
	  this.pattern = str.replace(re, function($0, $1) {
	    return chars[$1][$0];
	  });
	  this.pattern = unesc(this.pattern);
	};
	
	/**
	 * Escape/unescape utils
	 */
	
	function esc(str) {
	  str = str.split('?').join('%~');
	  str = str.split('*').join('%%');
	  return str;
	}
	
	function unesc(str) {
	  str = str.split('%~').join('?');
	  str = str.split('%%').join('*');
	  return str;
	}


/***/ },
/* 429 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * braces <https://github.com/jonschlinkert/braces>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT license.
	 */
	
	'use strict';
	
	/**
	 * Module dependencies
	 */
	
	var lazy = __webpack_require__(430)(__webpack_require__(431));
	lazy('expand-range', 'expand');
	lazy('repeat-element', 'repeat');
	lazy('preserve', 'tokens');
	
	/**
	 * Expose `braces`
	 */
	
	module.exports = function (str, options) {
	  if (typeof str !== 'string') {
	    throw new Error('braces expects a string');
	  }
	  return braces(str, options);
	};
	
	/**
	 * Expand `{foo,bar}` or `{1..5}` braces in the
	 * given `string`.
	 *
	 * @param  {String} `str`
	 * @param  {Array} `arr`
	 * @param  {Object} `options`
	 * @return {Array}
	 */
	
	function braces(str, arr, options) {
	  if (str === '') {
	    return [];
	  }
	
	  if (!Array.isArray(arr)) {
	    options = arr;
	    arr = [];
	  }
	
	  var opts = options || {};
	  arr = arr || [];
	
	  if (typeof opts.nodupes === 'undefined') {
	    opts.nodupes = true;
	  }
	
	  var fn = opts.fn;
	  var es6;
	
	  if (typeof opts === 'function') {
	    fn = opts;
	    opts = {};
	  }
	
	  if (!(patternRe instanceof RegExp)) {
	    patternRe = patternRegex();
	  }
	
	  var matches = str.match(patternRe) || [];
	  var m = matches[0];
	
	  switch(m) {
	    case '\\,':
	      return escapeCommas(str, arr, opts);
	    case '\\.':
	      return escapeDots(str, arr, opts);
	    case '\/.':
	      return escapePaths(str, arr, opts);
	    case ' ':
	      return splitWhitespace(str);
	    case '{,}':
	      return exponential(str, opts, braces);
	    case '{}':
	      return emptyBraces(str, arr, opts);
	    case '\\{':
	    case '\\}':
	      return escapeBraces(str, arr, opts);
	    case '${':
	      if (!/\{[^{]+\{/.test(str)) {
	        return arr.concat(str);
	      } else {
	        es6 = true;
	        str = lazy.tokens.before(str, es6Regex());
	      }
	  }
	
	  if (!(braceRe instanceof RegExp)) {
	    braceRe = braceRegex();
	  }
	
	  var match = braceRe.exec(str);
	  if (match == null) {
	    return [str];
	  }
	
	  var outter = match[1];
	  var inner = match[2];
	  if (inner === '') { return [str]; }
	
	  var segs, segsLength;
	
	  if (inner.indexOf('..') !== -1) {
	    segs = lazy.expand(inner, opts, fn) || inner.split(',');
	    segsLength = segs.length;
	
	  } else if (inner[0] === '"' || inner[0] === '\'') {
	    return arr.concat(str.split(/['"]/).join(''));
	
	  } else {
	    segs = inner.split(',');
	    if (opts.makeRe) {
	      return braces(str.replace(outter, wrap(segs, '|')), opts);
	    }
	
	    segsLength = segs.length;
	    if (segsLength === 1 && opts.bash) {
	      segs[0] = wrap(segs[0], '\\');
	    }
	  }
	
	  var len = segs.length;
	  var i = 0, val;
	
	  while (len--) {
	    var path = segs[i++];
	
	    if (/(\.[^.\/])/.test(path)) {
	      if (segsLength > 1) {
	        return segs;
	      } else {
	        return [str];
	      }
	    }
	
	    val = splice(str, outter, path);
	
	    if (/\{[^{}]+?\}/.test(val)) {
	      arr = braces(val, arr, opts);
	    } else if (val !== '') {
	      if (opts.nodupes && arr.indexOf(val) !== -1) { continue; }
	      arr.push(es6 ? lazy.tokens.after(val) : val);
	    }
	  }
	
	  if (opts.strict) { return filter(arr, filterEmpty); }
	  return arr;
	}
	
	/**
	 * Expand exponential ranges
	 *
	 *   `a{,}{,}` => ['a', 'a', 'a', 'a']
	 */
	
	function exponential(str, options, fn) {
	  if (typeof options === 'function') {
	    fn = options;
	    options = null;
	  }
	
	  var opts = options || {};
	  var esc = '__ESC_EXP__';
	  var exp = 0;
	  var res;
	
	  var parts = str.split('{,}');
	  if (opts.nodupes) {
	    return fn(parts.join(''), opts);
	  }
	
	  exp = parts.length - 1;
	  res = fn(parts.join(esc), opts);
	  var len = res.length;
	  var arr = [];
	  var i = 0;
	
	  while (len--) {
	    var ele = res[i++];
	    var idx = ele.indexOf(esc);
	
	    if (idx === -1) {
	      arr.push(ele);
	
	    } else {
	      ele = ele.split('__ESC_EXP__').join('');
	      if (!!ele && opts.nodupes !== false) {
	        arr.push(ele);
	
	      } else {
	        var num = Math.pow(2, exp);
	        arr.push.apply(arr, lazy.repeat(ele, num));
	      }
	    }
	  }
	  return arr;
	}
	
	/**
	 * Wrap a value with parens, brackets or braces,
	 * based on the given character/separator.
	 *
	 * @param  {String|Array} `val`
	 * @param  {String} `ch`
	 * @return {String}
	 */
	
	function wrap(val, ch) {
	  if (ch === '|') {
	    return '(' + val.join(ch) + ')';
	  }
	  if (ch === ',') {
	    return '{' + val.join(ch) + '}';
	  }
	  if (ch === '-') {
	    return '[' + val.join(ch) + ']';
	  }
	  if (ch === '\\') {
	    return '\\{' + val + '\\}';
	  }
	}
	
	/**
	 * Handle empty braces: `{}`
	 */
	
	function emptyBraces(str, arr, opts) {
	  return braces(str.split('{}').join('\\{\\}'), arr, opts);
	}
	
	/**
	 * Filter out empty-ish values
	 */
	
	function filterEmpty(ele) {
	  return !!ele && ele !== '\\';
	}
	
	/**
	 * Handle patterns with whitespace
	 */
	
	function splitWhitespace(str) {
	  var segs = str.split(' ');
	  var len = segs.length;
	  var res = [];
	  var i = 0;
	
	  while (len--) {
	    res.push.apply(res, braces(segs[i++]));
	  }
	  return res;
	}
	
	/**
	 * Handle escaped braces: `\\{foo,bar}`
	 */
	
	function escapeBraces(str, arr, opts) {
	  if (!/\{[^{]+\{/.test(str)) {
	    return arr.concat(str.split('\\').join(''));
	  } else {
	    str = str.split('\\{').join('__LT_BRACE__');
	    str = str.split('\\}').join('__RT_BRACE__');
	    return map(braces(str, arr, opts), function (ele) {
	      ele = ele.split('__LT_BRACE__').join('{');
	      return ele.split('__RT_BRACE__').join('}');
	    });
	  }
	}
	
	/**
	 * Handle escaped dots: `{1\\.2}`
	 */
	
	function escapeDots(str, arr, opts) {
	  if (!/[^\\]\..+\\\./.test(str)) {
	    return arr.concat(str.split('\\').join(''));
	  } else {
	    str = str.split('\\.').join('__ESC_DOT__');
	    return map(braces(str, arr, opts), function (ele) {
	      return ele.split('__ESC_DOT__').join('.');
	    });
	  }
	}
	
	/**
	 * Handle escaped dots: `{1\\.2}`
	 */
	
	function escapePaths(str, arr, opts) {
	  str = str.split('\/.').join('__ESC_PATH__');
	  return map(braces(str, arr, opts), function (ele) {
	    return ele.split('__ESC_PATH__').join('\/.');
	  });
	}
	
	/**
	 * Handle escaped commas: `{a\\,b}`
	 */
	
	function escapeCommas(str, arr, opts) {
	  if (!/\w,/.test(str)) {
	    return arr.concat(str.split('\\').join(''));
	  } else {
	    str = str.split('\\,').join('__ESC_COMMA__');
	    return map(braces(str, arr, opts), function (ele) {
	      return ele.split('__ESC_COMMA__').join(',');
	    });
	  }
	}
	
	/**
	 * Regex for common patterns
	 */
	
	function patternRegex() {
	  return /\$\{|[ \t]|{}|{,}|\\,(?=.*[{}])|\/\.(?=.*[{}])|\\\.(?={)|\\{|\\}/;
	}
	
	/**
	 * Braces regex.
	 */
	
	function braceRegex() {
	  return /.*(\\?\{([^}]+)\})/;
	}
	
	/**
	 * es6 delimiter regex.
	 */
	
	function es6Regex() {
	  return /\$\{([^}]+)\}/;
	}
	
	var braceRe;
	var patternRe;
	
	/**
	 * Faster alternative to `String.replace()` when the
	 * index of the token to be replaces can't be supplied
	 */
	
	function splice(str, token, replacement) {
	  var i = str.indexOf(token);
	  return str.substr(0, i) + replacement
	    + str.substr(i + token.length);
	}
	
	/**
	 * Fast array map
	 */
	
	function map(arr, fn) {
	  if (arr == null) {
	    return [];
	  }
	
	  var len = arr.length;
	  var res = new Array(len);
	  var i = -1;
	
	  while (++i < len) {
	    res[i] = fn(arr[i], i, arr);
	  }
	
	  return res;
	}
	
	/**
	 * Fast array filter
	 */
	
	function filter(arr, cb) {
	  if (arr == null) return [];
	  if (typeof cb !== 'function') {
	    throw new TypeError('braces: filter expects a callback function.');
	  }
	
	  var len = arr.length;
	  var res = arr.slice();
	  var i = 0;
	
	  while (len--) {
	    if (!cb(arr[len], i++)) {
	      res.splice(len, 1);
	    }
	  }
	  return res;
	}


/***/ },
/* 430 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';
	
	/**
	 * Cache results of the first function call to ensure only calling once.
	 *
	 * ```js
	 * var lazy = require('lazy-cache')(require);
	 * // cache the call to `require('ansi-yellow')`
	 * lazy('ansi-yellow', 'yellow');
	 * // use `ansi-yellow`
	 * console.log(lazy.yellow('this is yellow'));
	 * ```
	 *
	 * @param  {Function} `fn` Function that will be called only once.
	 * @return {Function} Function that can be called to get the cached function
	 * @api public
	 */
	
	function lazyCache(fn) {
	  var cache = {};
	  var proxy = function (mod, name) {
	    name = name || camelcase(mod);
	    Object.defineProperty(proxy, name, {
	      get: getter
	    });
	
	    function getter () {
	      if (cache.hasOwnProperty(name)) {
	        return cache[name];
	      }
	      try {
	        return (cache[name] = fn(mod));
	      } catch (err) {
	        err.message = 'lazy-cache ' + err.message + ' ' + __filename;
	        throw err;
	      }
	    };
	    return getter;
	  };
	  return proxy;
	}
	
	/**
	 * Used to camelcase the name to be stored on the `lazy` object.
	 *
	 * @param  {String} `str` String containing `_`, `.`, `-` or whitespace that will be camelcased.
	 * @return {String} camelcased string.
	 */
	
	function camelcase(str) {
	  if (str.length === 1) { return str.toLowerCase(); }
	  str = str.replace(/^[\W_]+|[\W_]+$/g, '').toLowerCase();
	  return str.replace(/[\W_]+(\w|$)/g, function (_, ch) {
	    return ch.toUpperCase();
	  });
	}
	
	/**
	 * Expose `lazyCache`
	 */
	
	module.exports = lazyCache;
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/index.js"))

/***/ },
/* 431 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./index": 429,
		"./index.js": 429
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 431;


/***/ },
/* 432 */,
/* 433 */,
/* 434 */
/***/ function(module, exports) {

	/*!
	 * expand-brackets <https://github.com/jonschlinkert/expand-brackets>
	 *
	 * Copyright (c) 2015 Jon Schlinkert.
	 * Licensed under the MIT license.
	 */
	
	'use strict';
	
	/**
	 * POSIX character classes
	 */
	
	var POSIX = {
	  alnum: 'a-zA-Z0-9',
	  alpha: 'a-zA-Z',
	  blank: ' \\t',
	  cntrl: '\\x00-\\x1F\\x7F',
	  digit: '0-9',
	  graph: '\\x21-\\x7E',
	  lower: 'a-z',
	  print: '\\x20-\\x7E',
	  punct: '!"#$%&\'()\\*+,-./:;<=>?@[\\]^_`{|}~',
	  space: ' \\t\\r\\n\\v\\f',
	  upper: 'A-Z',
	  word:  'A-Za-z0-9_',
	  xdigit: 'A-Fa-f0-9',
	};
	
	/**
	 * Expose `brackets`
	 */
	
	module.exports = brackets;
	
	function brackets(str) {
	  var negated = false;
	  if (str.indexOf('[^') !== -1) {
	    negated = true;
	    str = str.split('[^').join('[');
	  }
	  if (str.indexOf('[!') !== -1) {
	    negated = true;
	    str = str.split('[!').join('[');
	  }
	
	  var a = str.split('[');
	  var b = str.split(']');
	  var imbalanced = a.length !== b.length;
	
	  var parts = str.split(/(?::\]\[:|\[?\[:|:\]\]?)/);
	  var len = parts.length, i = 0;
	  var end = '', beg = '';
	  var res = [];
	
	  // start at the end (innermost) first
	  while (len--) {
	    var inner = parts[i++];
	    if (inner === '^[!' || inner === '[!') {
	      inner = '';
	      negated = true;
	    }
	
	    var prefix = negated ? '^' : '';
	    var ch = POSIX[inner];
	
	    if (ch) {
	      res.push('[' + prefix + ch + ']');
	    } else if (inner) {
	      if (/^\[?\w-\w\]?$/.test(inner)) {
	        if (i === parts.length) {
	          res.push('[' + prefix + inner);
	        } else if (i === 1) {
	          res.push(prefix + inner + ']');
	        } else {
	          res.push(prefix + inner);
	        }
	      } else {
	        if (i === 1) {
	          beg += inner;
	        } else if (i === parts.length) {
	          end += inner;
	        } else {
	          res.push('[' + prefix + inner + ']');
	        }
	      }
	    }
	  }
	
	  var result = res.join('|');
	  var rlen = res.length || 1;
	  if (rlen > 1) {
	    result = '(?:' + result + ')';
	    rlen = 1;
	  }
	  if (beg) {
	    rlen++;
	    if (beg.charAt(0) === '[') {
	      if (imbalanced) {
	        beg = '\\[' + beg.slice(1);
	      } else {
	        beg += ']';
	      }
	    }
	    result = beg + result;
	  }
	  if (end) {
	    rlen++;
	    if (end.slice(-1) === ']') {
	      if (imbalanced) {
	        end = end.slice(0, end.length - 1) + '\\]';
	      } else {
	        end = '[' + end;
	      }
	    }
	    result += end;
	  }
	
	  if (rlen > 1) {
	    result = result.split('][').join(']|[');
	    if (result.indexOf('|') !== -1 && !/\(\?/.test(result)) {
	      result = '(?:' + result + ')';
	    }
	  }
	
	  result = result.replace(/\[+=|=\]+/g, '\\b');
	  return result;
	}
	
	brackets.makeRe = function (pattern) {
	  try {
	    return new RegExp(brackets(pattern));
	  } catch (err) {}
	};
	
	brackets.isMatch = function (str, pattern) {
	  try {
	    return brackets.makeRe(pattern).test(str);
	  } catch (err) {
	    return false;
	  }
	};
	
	brackets.match = function (arr, pattern) {
	  var len = arr.length, i = 0;
	  var res = arr.slice();
	
	  var re = brackets.makeRe(pattern);
	  while (i < len) {
	    var ele = arr[i++];
	    if (!re.test(ele)) {
	      continue;
	    }
	    res.splice(i, 1);
	  }
	  return res;
	};


/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * extglob <https://github.com/jonschlinkert/extglob>
	 *
	 * Copyright (c) 2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	/**
	 * Module dependencies
	 */
	
	var isExtglob = __webpack_require__(436);
	var re, cache = {};
	
	/**
	 * Expose `extglob`
	 */
	
	module.exports = extglob;
	
	/**
	 * Convert the given extglob `string` to a regex-compatible
	 * string.
	 *
	 * ```js
	 * var extglob = require('extglob');
	 * extglob('!(a?(b))');
	 * //=> '(?!a(?:b)?)[^/]*?'
	 * ```
	 *
	 * @param {String} `str` The string to convert.
	 * @param {Object} `options`
	 *   @option {Boolean} [options] `esc` If `false` special characters will not be escaped. Defaults to `true`.
	 *   @option {Boolean} [options] `regex` If `true` a regular expression is returned instead of a string.
	 * @return {String}
	 * @api public
	 */
	
	
	function extglob(str, opts) {
	  opts = opts || {};
	  var o = {}, i = 0;
	
	  // fix common character reversals
	  // '*!(.js)' => '*.!(js)'
	  str = str.replace(/!\(([^\w*()])/g, '$1!(');
	
	  // support file extension negation
	  str = str.replace(/([*\/])\.!\([*]\)/g, function (m, ch) {
	    if (ch === '/') {
	      return escape('\\/[^.]+');
	    }
	    return escape('[^.]+');
	  });
	
	  // create a unique key for caching by
	  // combining the string and options
	  var key = str
	    + String(!!opts.regex)
	    + String(!!opts.contains)
	    + String(!!opts.escape);
	
	  if (cache.hasOwnProperty(key)) {
	    return cache[key];
	  }
	
	  if (!(re instanceof RegExp)) {
	    re = regex();
	  }
	
	  opts.negate = false;
	  var m;
	
	  while (m = re.exec(str)) {
	    var prefix = m[1];
	    var inner = m[3];
	    if (prefix === '!') {
	      opts.negate = true;
	    }
	
	    var id = '__EXTGLOB_' + (i++) + '__';
	    // use the prefix of the _last_ (outtermost) pattern
	    o[id] = wrap(inner, prefix, opts.escape);
	    str = str.split(m[0]).join(id);
	  }
	
	  var keys = Object.keys(o);
	  var len = keys.length;
	
	  // we have to loop again to allow us to convert
	  // patterns in reverse order (starting with the
	  // innermost/last pattern first)
	  while (len--) {
	    var prop = keys[len];
	    str = str.split(prop).join(o[prop]);
	  }
	
	  var result = opts.regex
	    ? toRegex(str, opts.contains, opts.negate)
	    : str;
	
	  result = result.split('.').join('\\.');
	
	  // cache the result and return it
	  return (cache[key] = result);
	}
	
	/**
	 * Convert `string` to a regex string.
	 *
	 * @param  {String} `str`
	 * @param  {String} `prefix` Character that determines how to wrap the string.
	 * @param  {Boolean} `esc` If `false` special characters will not be escaped. Defaults to `true`.
	 * @return {String}
	 */
	
	function wrap(inner, prefix, esc) {
	  if (esc) inner = escape(inner);
	
	  switch (prefix) {
	    case '!':
	      return '(?!' + inner + ')[^/]' + (esc ? '%%%~' : '*?');
	    case '@':
	      return '(?:' + inner + ')';
	    case '+':
	      return '(?:' + inner + ')+';
	    case '*':
	      return '(?:' + inner + ')' + (esc ? '%%' : '*')
	    case '?':
	      return '(?:' + inner + '|)';
	    default:
	      return inner;
	  }
	}
	
	function escape(str) {
	  str = str.split('*').join('[^/]%%%~');
	  str = str.split('.').join('\\.');
	  return str;
	}
	
	/**
	 * extglob regex.
	 */
	
	function regex() {
	  return /(\\?[@?!+*$]\\?)(\(([^()]*?)\))/;
	}
	
	/**
	 * Negation regex
	 */
	
	function negate(str) {
	  return '(?!^' + str + ').*$';
	}
	
	/**
	 * Create the regex to do the matching. If
	 * the leading character in the `pattern` is `!`
	 * a negation regex is returned.
	 *
	 * @param {String} `pattern`
	 * @param {Boolean} `contains` Allow loose matching.
	 * @param {Boolean} `isNegated` True if the pattern is a negation pattern.
	 */
	
	function toRegex(pattern, contains, isNegated) {
	  var prefix = contains ? '^' : '';
	  var after = contains ? '$' : '';
	  pattern = ('(?:' + pattern + ')' + after);
	  if (isNegated) {
	    pattern = prefix + negate(pattern);
	  }
	  return new RegExp(prefix + pattern);
	}


/***/ },
/* 436 */
/***/ function(module, exports) {

	/*!
	 * is-extglob <https://github.com/jonschlinkert/is-extglob>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	module.exports = function isExtglob(str) {
	  return typeof str === 'string'
	    && /[@?!+*]\(/.test(str);
	};


/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * parse-glob <https://github.com/jonschlinkert/parse-glob>
	 *
	 * Copyright (c) 2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var isGlob = __webpack_require__(424);
	var findBase = __webpack_require__(438);
	var extglob = __webpack_require__(440);
	var dotfile = __webpack_require__(441);
	
	/**
	 * Expose `cache`
	 */
	
	var cache = module.exports.cache = {};
	
	/**
	 * Parse a glob pattern into tokens.
	 *
	 * When no paths or '**' are in the glob, we use a
	 * different strategy for parsing the filename, since
	 * file names can contain braces and other difficult
	 * patterns. such as:
	 *
	 *  - `*.{a,b}`
	 *  - `(**|*.js)`
	 */
	
	module.exports = function parseGlob(glob) {
	  if (cache.hasOwnProperty(glob)) {
	    return cache[glob];
	  }
	
	  var tok = {};
	  tok.orig = glob;
	  tok.is = {};
	
	  // unescape dots and slashes in braces/brackets
	  glob = escape(glob);
	
	  var parsed = findBase(glob);
	  tok.is.glob = parsed.isGlob;
	
	  tok.glob = parsed.glob;
	  tok.base = parsed.base;
	  var segs = /([^\/]*)$/.exec(glob);
	
	  tok.path = {};
	  tok.path.dirname = '';
	  tok.path.basename = segs[1] || '';
	  tok.path.dirname = glob.split(tok.path.basename).join('') || '';
	  var basename = (tok.path.basename || '').split('.') || '';
	  tok.path.filename = basename[0] || '';
	  tok.path.extname = basename.slice(1).join('.') || '';
	  tok.path.ext = '';
	
	  if (isGlob(tok.path.dirname) && !tok.path.basename) {
	    if (!/\/$/.test(tok.glob)) {
	      tok.path.basename = tok.glob;
	    }
	    tok.path.dirname = tok.base;
	  }
	
	  if (glob.indexOf('/') === -1 && !tok.is.globstar) {
	    tok.path.dirname = '';
	    tok.path.basename = tok.orig;
	  }
	
	  var dot = tok.path.basename.indexOf('.');
	  if (dot !== -1) {
	    tok.path.filename = tok.path.basename.slice(0, dot);
	    tok.path.extname = tok.path.basename.slice(dot);
	  }
	
	  if (tok.path.extname.charAt(0) === '.') {
	    var exts = tok.path.extname.split('.');
	    tok.path.ext = exts[exts.length - 1];
	  }
	
	  // unescape dots and slashes in braces/brackets
	  tok.glob = unescape(tok.glob);
	  tok.path.dirname = unescape(tok.path.dirname);
	  tok.path.basename = unescape(tok.path.basename);
	  tok.path.filename = unescape(tok.path.filename);
	  tok.path.extname = unescape(tok.path.extname);
	
	  // Booleans
	  var is = (glob && tok.is.glob);
	  tok.is.negated  = glob && glob.charAt(0) === '!';
	  tok.is.extglob  = glob && extglob(glob);
	  tok.is.braces   = has(is, glob, '{');
	  tok.is.brackets = has(is, glob, '[:');
	  tok.is.globstar = has(is, glob, '**');
	  tok.is.dotfile  = dotfile(tok.path.basename) || dotfile(tok.path.filename);
	  tok.is.dotdir   = dotdir(tok.path.dirname);
	  return (cache[glob] = tok);
	}
	
	/**
	 * Returns true if the glob matches dot-directories.
	 *
	 * @param  {Object} `tok` The tokens object
	 * @param  {Object} `path` The path object
	 * @return {Object}
	 */
	
	function dotdir(base) {
	  if (base.indexOf('/.') !== -1) {
	    return true;
	  }
	  if (base.charAt(0) === '.' && base.charAt(1) !== '/') {
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Returns true if the pattern has the given `ch`aracter(s)
	 *
	 * @param  {Object} `glob` The glob pattern.
	 * @param  {Object} `ch` The character to test for
	 * @return {Object}
	 */
	
	function has(is, glob, ch) {
	  return is && glob.indexOf(ch) !== -1;
	}
	
	/**
	 * Escape/unescape utils
	 */
	
	function escape(str) {
	  var re = /\{([^{}]*?)}|\(([^()]*?)\)|\[([^\[\]]*?)\]/g;
	  return str.replace(re, function (outter, braces, parens, brackets) {
	    var inner = braces || parens || brackets;
	    if (!inner) { return outter; }
	    return outter.split(inner).join(esc(inner));
	  });
	}
	
	function esc(str) {
	  str = str.split('/').join('__SLASH__');
	  str = str.split('.').join('__DOT__');
	  return str;
	}
	
	function unescape(str) {
	  str = str.split('__SLASH__').join('/');
	  str = str.split('__DOT__').join('.');
	  return str;
	}


/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * glob-base <https://github.com/jonschlinkert/glob-base>
	 *
	 * Copyright (c) 2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var path = __webpack_require__(180);
	var parent = __webpack_require__(439);
	
	module.exports = function globBase(pattern) {
	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob-base expects a string.');
	  }
	
	  var res = {};
	  res.base = parent(pattern);
	  res.isGlob = res.base !== pattern;
	
	  if (res.base !== '.') {
	    res.glob = pattern.substr(res.base.length);
	    if (res.glob.charAt(0) === '/') {
	      res.glob = res.glob.substr(1);
	    }
	  } else {
	    res.glob = pattern;
	  }
	
	  if (!res.isGlob) {
	    res.base = dirname(pattern);
	    res.glob = res.base !== '.'
	      ? pattern.substr(res.base.length)
	      : pattern;
	  }
	
	  if (res.glob.substr(0, 2) === './') {
	    res.glob = res.glob.substr(2);
	  }
	  if (res.glob.charAt(0) === '/') {
	    res.glob = res.glob.substr(1);
	  }
	  return res;
	};
	
	function dirname(glob) {
	  if (glob.slice(-1) === '/') return glob;
	  return path.dirname(glob);
	}


/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var path = __webpack_require__(180);
	var isglob = __webpack_require__(424);
	
	module.exports = function globParent(str) {
		while (isglob(str)) str = path.dirname(str);
		return str;
	};


/***/ },
/* 440 */
/***/ function(module, exports) {

	/*!
	 * is-extglob <https://github.com/jonschlinkert/is-extglob>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	module.exports = function isExtglob(str) {
	  return typeof str === 'string'
	    && /[@?!+*]\(/.test(str);
	};


/***/ },
/* 441 */
/***/ function(module, exports) {

	/*!
	 * is-dotfile <https://github.com/regexps/is-dotfile>
	 *
	 * Copyright (c) 2015 Jon Schlinkert, contributors.
	 * Licensed under the MIT license.
	 */
	
	module.exports = function(str) {
	  if (str.charCodeAt(0) === 46 /* . */ && str.indexOf('/', 1) === -1) {
	    return true;
	  }
	
	  var last = str.lastIndexOf('/');
	  return last !== -1 ? str.charCodeAt(last + 1) === 46  /* . */ : false;
	};


/***/ },
/* 442 */
/***/ function(module, exports) {

	'use strict';
	
	var reverse = function(object, prepender) {
	  return Object.keys(object).reduce(function(reversed, key) {
	    var newKey = prepender ? prepender + key : key; // Optionally prepend a string to key.
	    reversed[object[key]] = newKey; // Swap key and value.
	    return reversed; // Return the result.
	  }, {});
	};
	
	var chars = {};
	
	/**
	 * Regex for common characters
	 */
	
	chars.escapeRegex = {
	  '?': /\?/g,
	  '@': /\@/g,
	  '!': /\!/g,
	  '+': /\+/g,
	  '*': /\*/g,
	  '(': /\(/g,
	  ')': /\)/g,
	  '[': /\[/g,
	  ']': /\]/g,
	};
	
	/**
	 * Escape characters
	 */
	
	chars.ESC = {
	  '?': '__UNESC_QMRK__',
	  '@': '__UNESC_AMPE__',
	  '!': '__UNESC_EXCL__',
	  '+': '__UNESC_PLUS__',
	  '*': '__UNESC_STAR__',
	  ',': '__UNESC_COMMA__',
	  '(': '__UNESC_LTPAREN__',
	  ')': '__UNESC_RTPAREN__',
	  '[': '__UNESC_LTBRACK__',
	  ']': '__UNESC_RTBRACK__',
	};
	
	/**
	 * Unescape characters
	 */
	
	chars.UNESC = reverse(chars.ESC, '\\');
	
	chars.ESC_TEMP = {
	  '?': '__TEMP_QMRK__',
	  '@': '__TEMP_AMPE__',
	  '!': '__TEMP_EXCL__',
	  '*': '__TEMP_STAR__',
	  '+': '__TEMP_PLUS__',
	  ',': '__TEMP_COMMA__',
	  '(': '__TEMP_LTPAREN__',
	  ')': '__TEMP_RTPAREN__',
	  '[': '__TEMP_LTBRACK__',
	  ']': '__TEMP_RTBRACK__',
	};
	
	chars.TEMP = reverse(chars.ESC_TEMP);
	
	module.exports = chars;


/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	function posix(path) {
		return path.charAt(0) === '/';
	};
	
	function win32(path) {
		// https://github.com/joyent/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
		var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
		var result = splitDeviceRe.exec(path);
		var device = result[1] || '';
		var isUnc = !!device && device.charAt(1) !== ':';
	
		// UNC paths are always absolute
		return !!result[2] || isUnc;
	};
	
	module.exports = process.platform === 'win32' ? win32 : posix;
	module.exports.posix = posix;
	module.exports.win32 = win32;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var sysPath = __webpack_require__(180);
	var readdirp = __webpack_require__(445);
	var isBinaryPath = __webpack_require__(489);
	
	// fs.watch helpers
	
	// object to hold per-process fs.watch instances
	// (may be shared across chokidar FSWatcher instances)
	var FsWatchInstances = Object.create(null);
	
	// Private function: Instantiates the fs.watch interface
	
	// * path       - string, path to be watched
	// * options    - object, options to be passed to fs.watch
	// * listener   - function, main event handler
	// * errHandler - function, handler which emits info about errors
	// * emitRaw    - function, handler which emits raw event data
	
	// Returns new fsevents instance
	function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
	  var handleEvent = function(rawEvent, evPath) {
	    listener(path);
	    emitRaw(rawEvent, evPath, {watchedPath: path});
	
	    // emit based on events occuring for files from a directory's watcher in
	    // case the file's watcher misses it (and rely on throttling to de-dupe)
	    if (evPath && path !== evPath) {
	      fsWatchBroadcast(
	        sysPath.resolve(path, evPath), 'listeners', sysPath.join(path, evPath)
	      );
	    }
	  };
	  try {
	    return fs.watch(path, options, handleEvent);
	  } catch (error) {
	    errHandler(error);
	  }
	}
	
	// Private function: Helper for passing fs.watch event data to a
	// collection of listeners
	
	// * fullPath   - string, absolute path bound to the fs.watch instance
	// * type       - string, listener type
	// * val[1..3]  - arguments to be passed to listeners
	
	// Returns nothing
	function fsWatchBroadcast(fullPath, type, val1, val2, val3) {
	  if (!FsWatchInstances[fullPath]) return;
	  FsWatchInstances[fullPath][type].forEach(function(listener) {
	    listener(val1, val2, val3);
	  });
	}
	
	// Private function: Instantiates the fs.watch interface or binds listeners
	// to an existing one covering the same file system entry
	
	// * path       - string, path to be watched
	// * fullPath   - string, absolute path
	// * options    - object, options to be passed to fs.watch
	// * handlers   - object, container for event listener functions
	
	// Returns close function
	function setFsWatchListener(path, fullPath, options, handlers) {
	  var listener = handlers.listener;
	  var errHandler = handlers.errHandler;
	  var rawEmitter = handlers.rawEmitter;
	  var container = FsWatchInstances[fullPath];
	  var watcher;
	  if (!options.persistent) {
	    watcher = createFsWatchInstance(
	      path, options, listener, errHandler, rawEmitter
	    );
	    return watcher.close.bind(watcher);
	  }
	  if (!container) {
	    watcher = createFsWatchInstance(
	      path,
	      options,
	      fsWatchBroadcast.bind(null, fullPath, 'listeners'),
	      errHandler, // no need to use broadcast here
	      fsWatchBroadcast.bind(null, fullPath, 'rawEmitters')
	    );
	    if (!watcher) return;
	    var broadcastErr = fsWatchBroadcast.bind(null, fullPath, 'errHandlers');
	    watcher.on('error', function(error) {
	      // Workaround for https://github.com/joyent/node/issues/4337
	      if (process.platform === 'win32' && error.code === 'EPERM') {
	        fs.open(path, 'r', function(err, fd) {
	          if (fd) fs.close(fd);
	          if (!err) broadcastErr(error);
	        });
	      } else {
	        broadcastErr(error);
	      }
	    });
	    container = FsWatchInstances[fullPath] = {
	      listeners: [listener],
	      errHandlers: [errHandler],
	      rawEmitters: [rawEmitter],
	      watcher: watcher
	    };
	  } else {
	    container.listeners.push(listener);
	    container.errHandlers.push(errHandler);
	    container.rawEmitters.push(rawEmitter);
	  }
	  var listenerIndex = container.listeners.length - 1;
	
	  // removes this instance's listeners and closes the underlying fs.watch
	  // instance if there are no more listeners left
	  return function close() {
	    delete container.listeners[listenerIndex];
	    delete container.errHandlers[listenerIndex];
	    delete container.rawEmitters[listenerIndex];
	    if (!Object.keys(container.listeners).length) {
	      container.watcher.close();
	      delete FsWatchInstances[fullPath];
	    }
	  };
	}
	
	// fs.watchFile helpers
	
	// object to hold per-process fs.watchFile instances
	// (may be shared across chokidar FSWatcher instances)
	var FsWatchFileInstances = Object.create(null);
	
	// Private function: Instantiates the fs.watchFile interface or binds listeners
	// to an existing one covering the same file system entry
	
	// * path       - string, path to be watched
	// * fullPath   - string, absolute path
	// * options    - object, options to be passed to fs.watchFile
	// * handlers   - object, container for event listener functions
	
	// Returns close function
	function setFsWatchFileListener(path, fullPath, options, handlers) {
	  var listener = handlers.listener;
	  var rawEmitter = handlers.rawEmitter;
	  var container = FsWatchFileInstances[fullPath];
	  var listeners = [];
	  var rawEmitters = [];
	  if (
	    container && (
	      container.options.persistent < options.persistent ||
	      container.options.interval > options.interval
	    )
	  ) {
	    // "Upgrade" the watcher to persistence or a quicker interval.
	    // This creates some unlikely edge case issues if the user mixes
	    // settings in a very weird way, but solving for those cases
	    // doesn't seem worthwhile for the added complexity.
	    listeners = container.listeners;
	    rawEmitters = container.rawEmitters;
	    fs.unwatchFile(fullPath);
	    container = false;
	  }
	  if (!container) {
	    listeners.push(listener);
	    rawEmitters.push(rawEmitter);
	    container = FsWatchFileInstances[fullPath] = {
	      listeners: listeners,
	      rawEmitters: rawEmitters,
	      options: options,
	      watcher: fs.watchFile(fullPath, options, function(curr, prev) {
	        container.rawEmitters.forEach(function(rawEmitter) {
	          rawEmitter('change', fullPath, {curr: curr, prev: prev});
	        });
	        var currmtime = curr.mtime.getTime();
	        if (curr.size !== prev.size || currmtime > prev.mtime.getTime() || currmtime === 0) {
	          container.listeners.forEach(function(listener) {
	            listener(path, curr);
	          });
	        }
	      })
	    };
	  } else {
	    container.listeners.push(listener);
	    container.rawEmitters.push(rawEmitter);
	  }
	  var listenerIndex = container.listeners.length - 1;
	
	  // removes this instance's listeners and closes the underlying fs.watchFile
	  // instance if there are no more listeners left
	  return function close() {
	    delete container.listeners[listenerIndex];
	    delete container.rawEmitters[listenerIndex];
	    if (!Object.keys(container.listeners).length) {
	      fs.unwatchFile(fullPath);
	      delete FsWatchFileInstances[fullPath];
	    }
	  }
	}
	
	// fake constructor for attaching nodefs-specific prototype methods that
	// will be copied to FSWatcher's prototype
	function NodeFsHandler() {}
	
	// Private method: Watch file for changes with fs.watchFile or fs.watch.
	
	// * path     - string, path to file or directory.
	// * listener - function, to be executed on fs change.
	
	// Returns close function for the watcher instance
	NodeFsHandler.prototype._watchWithNodeFs =
	function(path, listener) {
	  var directory = sysPath.dirname(path);
	  var basename = sysPath.basename(path);
	  var parent = this._getWatchedDir(directory);
	  parent.add(basename);
	  var absolutePath = sysPath.resolve(path);
	  var options = {persistent: this.options.persistent};
	  if (!listener) listener = Function.prototype; // empty function
	
	  var closer;
	  if (this.options.usePolling) {
	    options.interval = this.enableBinaryInterval && isBinaryPath(basename) ?
	      this.options.binaryInterval : this.options.interval;
	    closer = setFsWatchFileListener(path, absolutePath, options, {
	      listener: listener,
	      rawEmitter: this.emit.bind(this, 'raw')
	    });
	  } else {
	    closer = setFsWatchListener(path, absolutePath, options, {
	      listener: listener,
	      errHandler: this._handleError.bind(this),
	      rawEmitter: this.emit.bind(this, 'raw')
	    });
	  }
	  return closer;
	};
	
	// Private method: Watch a file and emit add event if warranted
	
	// * file       - string, the file's path
	// * stats      - object, result of fs.stat
	// * initialAdd - boolean, was the file added at watch instantiation?
	// * callback   - function, called when done processing as a newly seen file
	
	// Returns close function for the watcher instance
	NodeFsHandler.prototype._handleFile =
	function(file, stats, initialAdd, callback) {
	  var dirname = sysPath.dirname(file);
	  var basename = sysPath.basename(file);
	  var parent = this._getWatchedDir(dirname);
	
	  // if the file is already being watched, do nothing
	  if (parent.has(basename)) return callback();
	
	  // kick off the watcher
	  var closer = this._watchWithNodeFs(file, function(path, newStats) {
	    if (!this._throttle('watch', file, 5)) return;
	    if (!newStats || newStats && newStats.mtime.getTime() === 0) {
	      fs.stat(file, function(error, newStats) {
	        // Fix issues where mtime is null but file is still present
	        if (error) {
	          this._remove(dirname, basename);
	        } else {
	          this._emit('change', file, newStats);
	        }
	      }.bind(this));
	    // add is about to be emitted if file not already tracked in parent
	    } else if (parent.has(basename)) {
	      this._emit('change', file, newStats);
	    }
	  }.bind(this));
	
	  // emit an add event if we're supposed to
	  if (!(initialAdd && this.options.ignoreInitial)) {
	    if (!this._throttle('add', file, 0)) return;
	    this._emit('add', file, stats);
	  }
	
	  if (callback) callback();
	  return closer;
	};
	
	// Private method: Handle symlinks encountered while reading a dir
	
	// * entry      - object, entry object returned by readdirp
	// * directory  - string, path of the directory being read
	// * path       - string, path of this item
	// * item       - string, basename of this item
	
	// Returns true if no more processing is needed for this entry.
	NodeFsHandler.prototype._handleSymlink =
	function(entry, directory, path, item) {
	  var full = entry.fullPath;
	  var dir = this._getWatchedDir(directory);
	
	  if (!this.options.followSymlinks) {
	    // watch symlink directly (don't follow) and detect changes
	    this._readyCount++;
	    fs.realpath(path, function(error, linkPath) {
	      if (dir.has(item)) {
	        if (this._symlinkPaths[full] !== linkPath) {
	          this._symlinkPaths[full] = linkPath;
	          this._emit('change', path, entry.stat);
	        }
	      } else {
	        dir.add(item);
	        this._symlinkPaths[full] = linkPath;
	        this._emit('add', path, entry.stat);
	      }
	      this._emitReady();
	    }.bind(this));
	    return true;
	  }
	
	  // don't follow the same symlink more than once
	  if (this._symlinkPaths[full]) return true;
	  else this._symlinkPaths[full] = true;
	}
	
	// Private method: Read directory to add / remove files from `@watched` list
	// and re-read it on change.
	
	// * dir        - string, fs path.
	// * stats      - object, result of fs.stat
	// * initialAdd - boolean, was the file added at watch instantiation?
	// * depth      - int, depth relative to user-supplied path
	// * target     - string, child path actually targeted for watch
	// * wh         - object, common watch helpers for this path
	// * callback   - function, called when dir scan is complete
	
	// Returns close function for the watcher instance
	NodeFsHandler.prototype._handleDir =
	function(dir, stats, initialAdd, depth, target, wh, callback) {
	  if (!(initialAdd && this.options.ignoreInitial) && !target && !wh.hasGlob) {
	    this._emit('addDir', dir, stats);
	  }
	
	  // ensure dir is tracked
	  this._getWatchedDir(sysPath.dirname(dir)).add(sysPath.basename(dir));
	  this._getWatchedDir(dir);
	
	  var read = function(directory, initialAdd, done) {
	    // Normalize the directory name on Windows
	    directory = sysPath.join(directory, '');
	
	    if (!wh.hasGlob) {
	      var throttler = this._throttle('readdir', directory, 1000);
	      if (!throttler) return;
	    }
	
	    var previous = this._getWatchedDir(wh.path);
	    var current = [];
	
	    readdirp({
	      root: directory,
	      entryType: 'all',
	      fileFilter: wh.filterPath,
	      directoryFilter: wh.filterDir,
	      depth: 0,
	      lstat: true
	    }).on('data', function(entry) {
	      var item = entry.path;
	      var path = sysPath.join(directory, item);
	      current.push(item);
	
	      if (entry.stat.isSymbolicLink() &&
	        this._handleSymlink(entry, directory, path, item)) return;
	
	      // Files that present in current directory snapshot
	      // but absent in previous are added to watch list and
	      // emit `add` event.
	      if (item === target || !target && !previous.has(item)) {
	        this._readyCount++;
	
	        // ensure relativeness of path is preserved in case of watcher reuse
	        path = sysPath.join(dir, sysPath.relative(dir, path));
	
	        this._addToNodeFs(path, initialAdd, wh, depth + 1);
	      }
	    }.bind(this)).on('end', function() {
	      if (throttler) throttler.clear();
	      if (done) done();
	
	      // Files that absent in current directory snapshot
	      // but present in previous emit `remove` event
	      // and are removed from @watched[directory].
	      previous.children().filter(function(item) {
	        return item !== directory &&
	          current.indexOf(item) === -1 &&
	          // in case of intersecting globs;
	          // a path may have been filtered out of this readdir, but
	          // shouldn't be removed because it matches a different glob
	          (!wh.hasGlob || wh.filterPath({
	            fullPath: sysPath.resolve(directory, item)
	          }));
	      }).forEach(function(item) {
	        this._remove(directory, item);
	      }, this);
	    }.bind(this)).on('error', this._handleError.bind(this));
	  }.bind(this);
	
	  if (this.options.depth == null || depth <= this.options.depth) {
	    if (!target) read(dir, initialAdd, callback);
	    var closer = this._watchWithNodeFs(dir, function(dirPath, stats) {
	      // if current directory is removed, do nothing
	      if (stats && stats.mtime.getTime() === 0) return;
	
	      read(dirPath, false);
	    });
	  } else {
	    callback();
	  }
	  return closer;
	};
	
	// Private method: Handle added file, directory, or glob pattern.
	// Delegates call to _handleFile / _handleDir after checks.
	
	// * path       - string, path to file or directory.
	// * initialAdd - boolean, was the file added at watch instantiation?
	// * depth      - int, depth relative to user-supplied path
	// * target     - string, child path actually targeted for watch
	// * callback   - function, indicates whether the path was found or not
	
	// Returns nothing
	NodeFsHandler.prototype._addToNodeFs =
	function(path, initialAdd, priorWh, depth, target, callback) {
	  if (!callback) callback = Function.prototype;
	  var ready = this._emitReady;
	  if (this._isIgnored(path) || this.closed) {
	    ready();
	    return callback(null, false);
	  }
	
	  var wh = this._getWatchHelpers(path, depth);
	  if (!wh.hasGlob && priorWh) {
	    wh.hasGlob = priorWh.hasGlob;
	    wh.filterPath = priorWh.filterPath;
	    wh.filterDir = priorWh.filterDir;
	  }
	
	  // evaluate what is at the path we're being asked to watch
	  fs[wh.statMethod](wh.watchPath, function(error, stats) {
	    if (this._handleError(error)) return callback(null, path);
	    if (this._isIgnored(wh.watchPath, stats)) {
	      ready();
	      return callback(null, false);
	    }
	
	    var initDir = function(dir, target) {
	      return this._handleDir(dir, stats, initialAdd, depth, target, wh, ready);
	    }.bind(this);
	
	    var closer;
	    if (stats.isDirectory()) {
	      closer = initDir(wh.watchPath, target);
	    } else if (stats.isSymbolicLink()) {
	      var parent = sysPath.dirname(wh.watchPath);
	      this._getWatchedDir(parent).add(wh.watchPath);
	      this._emit('add', wh.watchPath, stats);
	      closer = initDir(parent, path);
	
	      // preserve this symlink's target path
	      fs.realpath(path, function(error, targetPath) {
	        this._symlinkPaths[sysPath.resolve(path)] = targetPath;
	        ready();
	      }.bind(this));
	    } else {
	      closer = this._handleFile(wh.watchPath, stats, initialAdd, ready);
	    }
	
	    if (closer) this._closers[path] = closer;
	    callback(null, false);
	  }.bind(this));
	};
	
	module.exports = NodeFsHandler;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fs        =  __webpack_require__(446)
	  , path      =  __webpack_require__(180)
	  , minimatch =  __webpack_require__(468)
	  , toString  =  Object.prototype.toString
	  ;
	
	// Standard helpers
	function isFunction (obj) {
	  return toString.call(obj) === '[object Function]';
	}
	
	function isString (obj) {
	  return toString.call(obj) === '[object String]';
	}
	
	function isRegExp (obj) {
	  return toString.call(obj) === '[object RegExp]';
	}
	
	function isUndefined (obj) {
	  return obj === void 0;
	}
	
	/** 
	 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
	 * @param { Object }   opts     Options to specify root (start directory), filters and recursion depth
	 * @param { function } callback1  When callback2 is given calls back for each processed file - function (fileInfo) { ... },
	 *                                when callback2 is not given, it behaves like explained in callback2
	 * @param { function } callback2  Calls back once all files have been processed with an array of errors and file infos
	 *                                function (err, fileInfos) { ... }
	 */
	function readdir(opts, callback1, callback2) {
	  var stream
	    , handleError
	    , handleFatalError
	    , pending = 0
	    , errors = []
	    , readdirResult = {
	        directories: []
	      , files: []
	    }
	    , fileProcessed
	    , allProcessed
	    , realRoot
	    , aborted = false
	    ;
	
	  // If no callbacks were given we will use a streaming interface
	  if (isUndefined(callback1)) {
	    var api          =  __webpack_require__(478)();
	    stream           =  api.stream;
	    callback1        =  api.processEntry;
	    callback2        =  api.done;
	    handleError      =  api.handleError;
	    handleFatalError =  api.handleFatalError;
	
	    stream.on('close', function () { aborted = true; });
	  } else {
	    handleError      =  function (err) { errors.push(err); };
	    handleFatalError =  function (err) {
	      handleError(err);
	      allProcessed(errors, null);
	    };
	  }
	
	  if (isUndefined(opts)){
	    handleFatalError(new Error (
	      'Need to pass at least one argument: opts! \n' +
	      'https://github.com/thlorenz/readdirp#options'
	      )
	    );
	    return stream;
	  }
	
	  opts.root            =  opts.root            || '.';
	  opts.fileFilter      =  opts.fileFilter      || function() { return true; };
	  opts.directoryFilter =  opts.directoryFilter || function() { return true; };
	  opts.depth           =  typeof opts.depth === 'undefined' ? 999999999 : opts.depth;
	  opts.entryType       =  opts.entryType       || 'files';
	
	  var statfn = opts.lstat === true ? fs.lstat.bind(fs) : fs.stat.bind(fs);
	
	  if (isUndefined(callback2)) {
	    fileProcessed = function() { };
	    allProcessed = callback1;
	  } else {
	    fileProcessed = callback1;
	    allProcessed = callback2;
	  }
	
	  function normalizeFilter (filter) {
	
	    if (isUndefined(filter)) return undefined;
	
	    function isNegated (filters) {
	
	      function negated(f) { 
	        return f.indexOf('!') === 0; 
	      }
	
	      var some = filters.some(negated);
	      if (!some) {
	        return false;
	      } else {
	        if (filters.every(negated)) {
	          return true;
	        } else {
	          // if we detect illegal filters, bail out immediately
	          throw new Error(
	            'Cannot mix negated with non negated glob filters: ' + filters + '\n' +
	            'https://github.com/thlorenz/readdirp#filters'
	          );
	        }
	      }
	    }
	
	    // Turn all filters into a function
	    if (isFunction(filter)) {
	
	      return filter;
	
	    } else if (isString(filter)) {
	
	      return function (entryInfo) {
	        return minimatch(entryInfo.name, filter.trim());
	      };
	
	    } else if (filter && Array.isArray(filter)) {
	
	      if (filter) filter = filter.map(function (f) {
	        return f.trim();
	      });
	
	      return isNegated(filter) ?
	        // use AND to concat multiple negated filters
	        function (entryInfo) {
	          return filter.every(function (f) {
	            return minimatch(entryInfo.name, f);
	          });
	        }
	        :
	        // use OR to concat multiple inclusive filters
	        function (entryInfo) {
	          return filter.some(function (f) {
	            return minimatch(entryInfo.name, f);
	          });
	        };
	    }
	  }
	
	  function processDir(currentDir, entries, callProcessed) {
	    if (aborted) return;
	    var total = entries.length
	      , processed = 0
	      , entryInfos = []
	      ;
	
	    fs.realpath(currentDir, function(err, realCurrentDir) {
	      if (aborted) return;
	      if (err) {
	        handleError(err);
	        callProcessed(entryInfos);
	        return;
	      }
	
	      var relDir = path.relative(realRoot, realCurrentDir);
	
	      if (entries.length === 0) {
	        callProcessed([]);
	      } else {
	        entries.forEach(function (entry) { 
	
	          var fullPath = path.join(realCurrentDir, entry)
	            , relPath  = path.join(relDir, entry);
	
	          statfn(fullPath, function (err, stat) {
	            if (err) {
	              handleError(err);
	            } else {
	              entryInfos.push({
	                  name          :  entry
	                , path          :  relPath   // relative to root
	                , fullPath      :  fullPath
	
	                , parentDir     :  relDir    // relative to root
	                , fullParentDir :  realCurrentDir
	
	                , stat          :  stat
	              });
	            }
	            processed++;
	            if (processed === total) callProcessed(entryInfos);
	          });
	        });
	      }
	    });
	  }
	
	  function readdirRec(currentDir, depth, callCurrentDirProcessed) {
	    if (aborted) return;
	
	    fs.readdir(currentDir, function (err, entries) {
	      if (err) {
	        handleError(err);
	        callCurrentDirProcessed();
	        return;
	      }
	
	      processDir(currentDir, entries, function(entryInfos) {
	
	        var subdirs = entryInfos
	          .filter(function (ei) { return ei.stat.isDirectory() && opts.directoryFilter(ei); });
	
	        subdirs.forEach(function (di) {
	          if(opts.entryType === 'directories' || opts.entryType === 'both' || opts.entryType === 'all') {
	            fileProcessed(di);
	          }
	          readdirResult.directories.push(di); 
	        });
	
	        entryInfos
	          .filter(function(ei) {
	            var isCorrectType = opts.entryType === 'all' ?
	              !ei.stat.isDirectory() : ei.stat.isFile() || ei.stat.isSymbolicLink();
	            return isCorrectType && opts.fileFilter(ei);
	          })
	          .forEach(function (fi) {
	            if(opts.entryType === 'files' || opts.entryType === 'both' || opts.entryType === 'all') {
	              fileProcessed(fi);
	            }
	            readdirResult.files.push(fi); 
	          });
	
	        var pendingSubdirs = subdirs.length;
	
	        // Be done if no more subfolders exist or we reached the maximum desired depth
	        if(pendingSubdirs === 0 || depth === opts.depth) {
	          callCurrentDirProcessed();
	        } else {
	          // recurse into subdirs, keeping track of which ones are done 
	          // and call back once all are processed
	          subdirs.forEach(function (subdir) {
	            readdirRec(subdir.fullPath, depth + 1, function () {
	              pendingSubdirs = pendingSubdirs - 1;
	              if(pendingSubdirs === 0) { 
	                callCurrentDirProcessed();
	              }
	            });
	          });
	        }
	      });
	    });
	  }
	
	  // Validate and normalize filters
	  try {
	    opts.fileFilter = normalizeFilter(opts.fileFilter);
	    opts.directoryFilter = normalizeFilter(opts.directoryFilter);
	  } catch (err) {
	    // if we detect illegal filters, bail out immediately
	    handleFatalError(err);
	    return stream;
	  }
	
	  // If filters were valid get on with the show
	  fs.realpath(opts.root, function(err, res) {
	    if (err) {
	      handleFatalError(err);
	      return stream;
	    }
	
	    realRoot = res;
	    readdirRec(opts.root, 0, function () { 
	      // All errors are collected into the errors array
	      if (errors.length > 0) {
	        allProcessed(errors, readdirResult); 
	      } else {
	        allProcessed(null, readdirResult);
	      }
	    });
	  });
	
	  return stream;
	}
	
	module.exports = readdir;


/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var polyfills = __webpack_require__(447)
	var legacy = __webpack_require__(449)
	var queue = []
	
	var util = __webpack_require__(238)
	
	function noop () {}
	
	var debug = noop
	if (util.debuglog)
	  debug = util.debuglog('gfs4')
	else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
	  debug = function() {
	    var m = util.format.apply(util, arguments)
	    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
	    console.error(m)
	  }
	
	if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
	  process.on('exit', function() {
	    debug(queue)
	    __webpack_require__(467).equal(queue.length, 0)
	  })
	}
	
	module.exports = patch(__webpack_require__(448))
	if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {
	  module.exports = patch(fs)
	}
	
	// Always patch fs.close/closeSync, because we want to
	// retry() whenever a close happens *anywhere* in the program.
	// This is essential when multiple graceful-fs instances are
	// in play at the same time.
	fs.close = (function (fs$close) { return function (fd, cb) {
	  return fs$close.call(fs, fd, function (err) {
	    if (!err)
	      retry()
	
	    if (typeof cb === 'function')
	      cb.apply(this, arguments)
	  })
	}})(fs.close)
	
	fs.closeSync = (function (fs$closeSync) { return function (fd) {
	  // Note that graceful-fs also retries when fs.closeSync() fails.
	  // Looks like a bug to me, although it's probably a harmless one.
	  var rval = fs$closeSync.apply(fs, arguments)
	  retry()
	  return rval
	}})(fs.closeSync)
	
	function patch (fs) {
	  // Everything that references the open() function needs to be in here
	  polyfills(fs)
	  fs.gracefulify = patch
	  fs.FileReadStream = ReadStream;  // Legacy name.
	  fs.FileWriteStream = WriteStream;  // Legacy name.
	  fs.createReadStream = createReadStream
	  fs.createWriteStream = createWriteStream
	  var fs$readFile = fs.readFile
	  fs.readFile = readFile
	  function readFile (path, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null
	
	    return go$readFile(path, options, cb)
	
	    function go$readFile (path, options, cb) {
	      return fs$readFile(path, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$readFile, [path, options, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }
	
	  var fs$writeFile = fs.writeFile
	  fs.writeFile = writeFile
	  function writeFile (path, data, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null
	
	    return go$writeFile(path, data, options, cb)
	
	    function go$writeFile (path, data, options, cb) {
	      return fs$writeFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$writeFile, [path, data, options, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }
	
	  var fs$appendFile = fs.appendFile
	  if (fs$appendFile)
	    fs.appendFile = appendFile
	  function appendFile (path, data, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null
	
	    return go$appendFile(path, data, options, cb)
	
	    function go$appendFile (path, data, options, cb) {
	      return fs$appendFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$appendFile, [path, data, options, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }
	
	  var fs$readdir = fs.readdir
	  fs.readdir = readdir
	  function readdir (path, cb) {
	    return go$readdir(path, cb)
	
	    function go$readdir () {
	      return fs$readdir(path, function (err, files) {
	        if (files && files.sort)
	          files.sort();  // Backwards compatibility with graceful-fs.
	
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$readdir, [path, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }
	
	
	  if (process.version.substr(0, 4) === 'v0.8') {
	    var legStreams = legacy(fs)
	    ReadStream = legStreams.ReadStream
	    WriteStream = legStreams.WriteStream
	  }
	
	  var fs$ReadStream = fs.ReadStream
	  ReadStream.prototype = Object.create(fs$ReadStream.prototype)
	  ReadStream.prototype.open = ReadStream$open
	
	  var fs$WriteStream = fs.WriteStream
	  WriteStream.prototype = Object.create(fs$WriteStream.prototype)
	  WriteStream.prototype.open = WriteStream$open
	
	  fs.ReadStream = ReadStream
	  fs.WriteStream = WriteStream
	
	  function ReadStream (path, options) {
	    if (this instanceof ReadStream)
	      return fs$ReadStream.apply(this, arguments), this
	    else
	      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
	  }
	
	  function ReadStream$open () {
	    var that = this
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        if (that.autoClose)
	          that.destroy()
	
	        that.emit('error', err)
	      } else {
	        that.fd = fd
	        that.emit('open', fd)
	        that.read()
	      }
	    })
	  }
	
	  function WriteStream (path, options) {
	    if (this instanceof WriteStream)
	      return fs$WriteStream.apply(this, arguments), this
	    else
	      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
	  }
	
	  function WriteStream$open () {
	    var that = this
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        that.destroy()
	        that.emit('error', err)
	      } else {
	        that.fd = fd
	        that.emit('open', fd)
	      }
	    })
	  }
	
	  function createReadStream (path, options) {
	    return new ReadStream(path, options)
	  }
	
	  function createWriteStream (path, options) {
	    return new WriteStream(path, options)
	  }
	
	  var fs$open = fs.open
	  fs.open = open
	  function open (path, flags, mode, cb) {
	    if (typeof mode === 'function')
	      cb = mode, mode = null
	
	    return go$open(path, flags, mode, cb)
	
	    function go$open (path, flags, mode, cb) {
	      return fs$open(path, flags, mode, function (err, fd) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$open, [path, flags, mode, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }
	
	  return fs
	}
	
	function enqueue (elem) {
	  debug('ENQUEUE', elem[0].name, elem[1])
	  queue.push(elem)
	}
	
	function retry () {
	  var elem = queue.shift()
	  if (elem) {
	    debug('RETRY', elem[0].name, elem[1])
	    elem[0].apply(null, elem[1])
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var fs = __webpack_require__(448)
	var constants = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"constants\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	
	var origCwd = process.cwd
	var cwd = null
	process.cwd = function() {
	  if (!cwd)
	    cwd = origCwd.call(process)
	  return cwd
	}
	try {
	  process.cwd()
	} catch (er) {}
	
	var chdir = process.chdir
	process.chdir = function(d) {
	  cwd = null
	  chdir.call(process, d)
	}
	
	module.exports = patch
	
	function patch (fs) {
	  // (re-)implement some things that are known busted or missing.
	
	  // lchmod, broken prior to 0.6.2
	  // back-port the fix here.
	  if (constants.hasOwnProperty('O_SYMLINK') &&
	      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
	    patchLchmod(fs)
	  }
	
	  // lutimes implementation, or no-op
	  if (!fs.lutimes) {
	    patchLutimes(fs)
	  }
	
	  // https://github.com/isaacs/node-graceful-fs/issues/4
	  // Chown should not fail on einval or eperm if non-root.
	  // It should not fail on enosys ever, as this just indicates
	  // that a fs doesn't support the intended operation.
	
	  fs.chown = chownFix(fs.chown)
	  fs.fchown = chownFix(fs.fchown)
	  fs.lchown = chownFix(fs.lchown)
	
	  fs.chmod = chownFix(fs.chmod)
	  fs.fchmod = chownFix(fs.fchmod)
	  fs.lchmod = chownFix(fs.lchmod)
	
	  fs.chownSync = chownFixSync(fs.chownSync)
	  fs.fchownSync = chownFixSync(fs.fchownSync)
	  fs.lchownSync = chownFixSync(fs.lchownSync)
	
	  fs.chmodSync = chownFix(fs.chmodSync)
	  fs.fchmodSync = chownFix(fs.fchmodSync)
	  fs.lchmodSync = chownFix(fs.lchmodSync)
	
	  // if lchmod/lchown do not exist, then make them no-ops
	  if (!fs.lchmod) {
	    fs.lchmod = function (path, mode, cb) {
	      process.nextTick(cb)
	    }
	    fs.lchmodSync = function () {}
	  }
	  if (!fs.lchown) {
	    fs.lchown = function (path, uid, gid, cb) {
	      process.nextTick(cb)
	    }
	    fs.lchownSync = function () {}
	  }
	
	  // on Windows, A/V software can lock the directory, causing this
	  // to fail with an EACCES or EPERM if the directory contains newly
	  // created files.  Try again on failure, for up to 1 second.
	  if (process.platform === "win32") {
	    fs.rename = (function (fs$rename) { return function (from, to, cb) {
	      var start = Date.now()
	      fs$rename(from, to, function CB (er) {
	        if (er
	            && (er.code === "EACCES" || er.code === "EPERM")
	            && Date.now() - start < 1000) {
	          return fs$rename(from, to, CB)
	        }
	        if (cb) cb(er)
	      })
	    }})(fs.rename)
	  }
	
	  // if read() returns EAGAIN, then just try it again.
	  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {
	    var callback
	    if (callback_ && typeof callback_ === 'function') {
	      var eagCounter = 0
	      callback = function (er, _, __) {
	        if (er && er.code === 'EAGAIN' && eagCounter < 10) {
	          eagCounter ++
	          return fs$read.call(fs, fd, buffer, offset, length, position, callback)
	        }
	        callback_.apply(this, arguments)
	      }
	    }
	    return fs$read.call(fs, fd, buffer, offset, length, position, callback)
	  }})(fs.read)
	
	  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
	    var eagCounter = 0
	    while (true) {
	      try {
	        return fs$readSync.call(fs, fd, buffer, offset, length, position)
	      } catch (er) {
	        if (er.code === 'EAGAIN' && eagCounter < 10) {
	          eagCounter ++
	          continue
	        }
	        throw er
	      }
	    }
	  }})(fs.readSync)
	}
	
	function patchLchmod (fs) {
	  fs.lchmod = function (path, mode, callback) {
	    callback = callback || noop
	    fs.open( path
	           , constants.O_WRONLY | constants.O_SYMLINK
	           , mode
	           , function (err, fd) {
	      if (err) {
	        callback(err)
	        return
	      }
	      // prefer to return the chmod error, if one occurs,
	      // but still try to close, and report closing errors if they occur.
	      fs.fchmod(fd, mode, function (err) {
	        fs.close(fd, function(err2) {
	          callback(err || err2)
	        })
	      })
	    })
	  }
	
	  fs.lchmodSync = function (path, mode) {
	    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)
	
	    // prefer to return the chmod error, if one occurs,
	    // but still try to close, and report closing errors if they occur.
	    var threw = true
	    var ret
	    try {
	      ret = fs.fchmodSync(fd, mode)
	      threw = false
	    } finally {
	      if (threw) {
	        try {
	          fs.closeSync(fd)
	        } catch (er) {}
	      } else {
	        fs.closeSync(fd)
	      }
	    }
	    return ret
	  }
	}
	
	function patchLutimes (fs) {
	  if (constants.hasOwnProperty("O_SYMLINK")) {
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.open(path, constants.O_SYMLINK, function (er, fd) {
	        cb = cb || noop
	        if (er) return cb(er)
	        fs.futimes(fd, at, mt, function (er) {
	          fs.close(fd, function (er2) {
	            return cb(er || er2)
	          })
	        })
	      })
	    }
	
	    fs.lutimesSync = function (path, at, mt) {
	      var fd = fs.openSync(path, constants.O_SYMLINK)
	      var ret
	      var threw = true
	      try {
	        ret = fs.futimesSync(fd, at, mt)
	        threw = false
	      } finally {
	        if (threw) {
	          try {
	            fs.closeSync(fd)
	          } catch (er) {}
	        } else {
	          fs.closeSync(fd)
	        }
	      }
	      return ret
	    }
	
	  } else {
	    fs.lutimes = function (_a, _b, _c, cb) { process.nextTick(cb) }
	    fs.lutimesSync = function () {}
	  }
	}
	
	function chownFix (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid, cb) {
	    return orig.call(fs, target, uid, gid, function (er, res) {
	      if (chownErOk(er)) er = null
	      cb(er, res)
	    })
	  }
	}
	
	function chownFixSync (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid) {
	    try {
	      return orig.call(fs, target, uid, gid)
	    } catch (er) {
	      if (!chownErOk(er)) throw er
	    }
	  }
	}
	
	// ENOSYS means that the fs doesn't support the op. Just ignore
	// that, because it doesn't matter.
	//
	// if there's no getuid, or if getuid() is something other
	// than 0, and the error is EINVAL or EPERM, then just ignore
	// it.
	//
	// This specific case is a silent failure in cp, install, tar,
	// and most other unix tools that manage permissions.
	//
	// When running as root, or if other types of errors are
	// encountered, then it's strict.
	function chownErOk (er) {
	  if (!er)
	    return true
	
	  if (er.code === "ENOSYS")
	    return true
	
	  var nonroot = !process.getuid || process.getuid() !== 0
	  if (nonroot) {
	    if (er.code === "EINVAL" || er.code === "EPERM")
	      return true
	  }
	
	  return false
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	
	module.exports = clone(fs)
	
	function clone (obj) {
	  if (obj === null || typeof obj !== 'object')
	    return obj
	
	  if (obj instanceof Object)
	    var copy = { __proto__: obj.__proto__ }
	  else
	    var copy = Object.create(null)
	
	  Object.getOwnPropertyNames(obj).forEach(function (key) {
	    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
	  })
	
	  return copy
	}


/***/ },
/* 449 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Stream = __webpack_require__(450).Stream
	
	module.exports = legacy
	
	function legacy (fs) {
	  return {
	    ReadStream: ReadStream,
	    WriteStream: WriteStream
	  }
	
	  function ReadStream (path, options) {
	    if (!(this instanceof ReadStream)) return new ReadStream(path, options);
	
	    Stream.call(this);
	
	    var self = this;
	
	    this.path = path;
	    this.fd = null;
	    this.readable = true;
	    this.paused = false;
	
	    this.flags = 'r';
	    this.mode = 438; /*=0666*/
	    this.bufferSize = 64 * 1024;
	
	    options = options || {};
	
	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }
	
	    if (this.encoding) this.setEncoding(this.encoding);
	
	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.end === undefined) {
	        this.end = Infinity;
	      } else if ('number' !== typeof this.end) {
	        throw TypeError('end must be a Number');
	      }
	
	      if (this.start > this.end) {
	        throw new Error('start must be <= end');
	      }
	
	      this.pos = this.start;
	    }
	
	    if (this.fd !== null) {
	      process.nextTick(function() {
	        self._read();
	      });
	      return;
	    }
	
	    fs.open(this.path, this.flags, this.mode, function (err, fd) {
	      if (err) {
	        self.emit('error', err);
	        self.readable = false;
	        return;
	      }
	
	      self.fd = fd;
	      self.emit('open', fd);
	      self._read();
	    })
	  }
	
	  function WriteStream (path, options) {
	    if (!(this instanceof WriteStream)) return new WriteStream(path, options);
	
	    Stream.call(this);
	
	    this.path = path;
	    this.fd = null;
	    this.writable = true;
	
	    this.flags = 'w';
	    this.encoding = 'binary';
	    this.mode = 438; /*=0666*/
	    this.bytesWritten = 0;
	
	    options = options || {};
	
	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }
	
	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.start < 0) {
	        throw new Error('start must be >= zero');
	      }
	
	      this.pos = this.start;
	    }
	
	    this.busy = false;
	    this._queue = [];
	
	    if (this.fd === null) {
	      this._open = fs.open;
	      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
	      this.flush();
	    }
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Stream;
	
	var EE = __webpack_require__(405).EventEmitter;
	var inherits = __webpack_require__(451);
	
	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(452);
	Stream.Writable = __webpack_require__(463);
	Stream.Duplex = __webpack_require__(464);
	Stream.Transform = __webpack_require__(465);
	Stream.PassThrough = __webpack_require__(466);
	
	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;
	
	
	
	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.
	
	function Stream() {
	  EE.call(this);
	}
	
	Stream.prototype.pipe = function(dest, options) {
	  var source = this;
	
	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }
	
	  source.on('data', ondata);
	
	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }
	
	  dest.on('drain', ondrain);
	
	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }
	
	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    dest.end();
	  }
	
	
	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    if (typeof dest.destroy === 'function') dest.destroy();
	  }
	
	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }
	
	  source.on('error', onerror);
	  dest.on('error', onerror);
	
	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);
	
	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);
	
	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);
	
	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);
	
	    dest.removeListener('close', cleanup);
	  }
	
	  source.on('end', cleanup);
	  source.on('close', cleanup);
	
	  dest.on('close', cleanup);
	
	  dest.emit('pipe', source);
	
	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 451 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(453);
	exports.Stream = __webpack_require__(450);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(459);
	exports.Duplex = __webpack_require__(458);
	exports.Transform = __webpack_require__(461);
	exports.PassThrough = __webpack_require__(462);


/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Readable;
	
	/*<replacement>*/
	var isArray = __webpack_require__(454);
	/*</replacement>*/
	
	
	/*<replacement>*/
	var Buffer = __webpack_require__(176).Buffer;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	var EE = __webpack_require__(405).EventEmitter;
	
	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	var Stream = __webpack_require__(450);
	
	/*<replacement>*/
	var util = __webpack_require__(455);
	util.inherits = __webpack_require__(456);
	/*</replacement>*/
	
	var StringDecoder;
	
	
	/*<replacement>*/
	var debug = __webpack_require__(457);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	
	util.inherits(Readable, Stream);
	
	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(458);
	
	  options = options || {};
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(460).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  var Duplex = __webpack_require__(458);
	
	  if (!(this instanceof Readable))
	    return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;
	
	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);
	
	      if (!addToFront)
	        state.reading = false;
	
	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);
	
	        if (state.needReadable)
	          emitReadable(stream);
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(460).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}
	
	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;
	
	  if (state.objectMode)
	    return n === 0 ? 0 : 1;
	
	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }
	
	  if (n <= 0)
	    return 0;
	
	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);
	
	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }
	
	  return n;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }
	
	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }
	
	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);
	
	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;
	
	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }
	
	  state.length -= n;
	
	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;
	
	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);
	
	  if (!util.isNull(ret))
	    this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	
	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};
	
	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }
	
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];
	
	
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	
	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;
	
	    if (!dest)
	      dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }
	
	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;
	
	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }
	
	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}
	
	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}
	
	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;
	
	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;
	
	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);
	
	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);
	
	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);
	
	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();
	
	        c += cpy;
	      }
	    }
	  }
	
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 454 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	function isBuffer(arg) {
	  return Buffer.isBuffer(arg);
	}
	exports.isBuffer = isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176).Buffer))

/***/ },
/* 456 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 457 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/
	
	
	/*<replacement>*/
	var util = __webpack_require__(455);
	util.inherits = __webpack_require__(456);
	/*</replacement>*/
	
	var Readable = __webpack_require__(453);
	var Writable = __webpack_require__(459);
	
	util.inherits(Duplex, Readable);
	
	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});
	
	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false)
	    this.readable = false;
	
	  if (options && options.writable === false)
	    this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.
	
	module.exports = Writable;
	
	/*<replacement>*/
	var Buffer = __webpack_require__(176).Buffer;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	
	/*<replacement>*/
	var util = __webpack_require__(455);
	util.inherits = __webpack_require__(456);
	/*</replacement>*/
	
	var Stream = __webpack_require__(450);
	
	util.inherits(Writable, Stream);
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}
	
	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(458);
	
	  options = options || {};
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.buffer = [];
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}
	
	function Writable(options) {
	  var Duplex = __webpack_require__(458);
	
	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};
	
	
	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;
	
	  if (!util.isFunction(cb))
	    cb = function() {};
	
	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function() {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function() {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;
	
	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);
	
	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	
	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);
	
	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });
	
	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }
	
	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }
	
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};
	
	
	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(176).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(458);
	
	/*<replacement>*/
	var util = __webpack_require__(455);
	util.inherits = __webpack_require__(456);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	
	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (!util.isNullOrUndefined(data))
	    stream.push(data);
	
	  if (cb)
	    cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	
	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(options, this);
	
	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}
	
	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};
	
	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;
	
	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	
	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');
	
	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');
	
	  return stream.push(null);
	}


/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(461);
	
	/*<replacement>*/
	var util = __webpack_require__(455);
	util.inherits = __webpack_require__(456);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(459)


/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(458)


/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(461)


/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(462)


/***/ },
/* 467 */
/***/ function(module, exports, __webpack_require__) {

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// when used in node, this will actually load the util module we depend on
	// versus loading the builtin util module as happens otherwise
	// this is a bug in node module loading as far as I am concerned
	var util = __webpack_require__(238);
	
	var pSlice = Array.prototype.slice;
	var hasOwn = Object.prototype.hasOwnProperty;
	
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.
	
	var assert = module.exports = ok;
	
	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })
	
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  }
	  else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;
	
	      // try to strip useless frames
	      var fn_name = stackStartFunction.name;
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }
	
	      this.stack = out;
	    }
	  }
	};
	
	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);
	
	function replacer(key, value) {
	  if (util.isUndefined(value)) {
	    return '' + value;
	  }
	  if (util.isNumber(value) && !isFinite(value)) {
	    return value.toString();
	  }
	  if (util.isFunction(value) || util.isRegExp(value)) {
	    return value.toString();
	  }
	  return value;
	}
	
	function truncate(s, n) {
	  if (util.isString(s)) {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	
	function getMessage(self) {
	  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(JSON.stringify(self.expected, replacer), 128);
	}
	
	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.
	
	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.
	
	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}
	
	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;
	
	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.
	
	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;
	
	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);
	
	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};
	
	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);
	
	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};
	
	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);
	
	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};
	
	function _deepEqual(actual, expected) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	
	  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
	    if (actual.length != expected.length) return false;
	
	    for (var i = 0; i < actual.length; i++) {
	      if (actual[i] !== expected[i]) return false;
	    }
	
	    return true;
	
	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;
	
	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!util.isObject(actual) && !util.isObject(expected)) {
	    return actual == expected;
	
	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected);
	  }
	}
	
	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}
	
	function objEquiv(a, b) {
	  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b)) {
	    return a === b;
	  }
	  var aIsArgs = isArguments(a),
	      bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b);
	  }
	  var ka = objectKeys(a),
	      kb = objectKeys(b),
	      key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key])) return false;
	  }
	  return true;
	}
	
	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);
	
	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};
	
	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);
	
	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};
	
	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
	
	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};
	
	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }
	
	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  } else if (actual instanceof expected) {
	    return true;
	  } else if (expected.call({}, actual) === true) {
	    return true;
	  }
	
	  return false;
	}
	
	function _throws(shouldThrow, block, expected, message) {
	  var actual;
	
	  if (util.isString(expected)) {
	    message = expected;
	    expected = null;
	  }
	
	  try {
	    block();
	  } catch (e) {
	    actual = e;
	  }
	
	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');
	
	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }
	
	  if (!shouldThrow && expectedException(actual, expected)) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }
	
	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}
	
	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);
	
	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws.apply(this, [true].concat(pSlice.call(arguments)));
	};
	
	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/message) {
	  _throws.apply(this, [false].concat(pSlice.call(arguments)));
	};
	
	assert.ifError = function(err) { if (err) {throw err;}};
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};


/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;/* WEBPACK VAR INJECTION */(function(module, process) {;(function (require, exports, module, platform) {
	
	if (module) module.exports = minimatch
	else exports.minimatch = minimatch
	
	if (!__webpack_require__(470)) {
	  require = function (id) {
	    switch (id) {
	      case "sigmund": return function sigmund (obj) {
	        return JSON.stringify(obj)
	      }
	      case "path": return { basename: function (f) {
	        f = f.split(/[\/\\]/)
	        var e = f.pop()
	        if (!e) e = f.pop()
	        return e
	      }}
	      case "lru-cache": return function LRUCache () {
	        // not quite an LRU, but still space-limited.
	        var cache = {}
	        var cnt = 0
	        this.set = function (k, v) {
	          cnt ++
	          if (cnt >= 100) cache = {}
	          cache[k] = v
	        }
	        this.get = function (k) { return cache[k] }
	      }
	    }
	  }
	}
	
	minimatch.Minimatch = Minimatch
	
	var LRU = require("lru-cache")
	  , cache = minimatch.cache = new LRU({max: 100})
	  , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
	  , sigmund = require("sigmund")
	
	var path = require("path")
	  // any single thing other than /
	  // don't need to escape / when using new RegExp()
	  , qmark = "[^/]"
	
	  // * => any number of characters
	  , star = qmark + "*?"
	
	  // ** when dots are allowed.  Anything goes, except .. and .
	  // not (^ or / followed by one or two dots followed by $ or /),
	  // followed by anything, any number of times.
	  , twoStarDot = "(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?"
	
	  // not a ^ or / followed by a dot,
	  // followed by anything, any number of times.
	  , twoStarNoDot = "(?:(?!(?:\\\/|^)\\.).)*?"
	
	  // characters that need to be escaped in RegExp.
	  , reSpecials = charSet("().*{}+?[]^$\\!")
	
	// "abc" -> { a:true, b:true, c:true }
	function charSet (s) {
	  return s.split("").reduce(function (set, c) {
	    set[c] = true
	    return set
	  }, {})
	}
	
	// normalizes slashes.
	var slashSplit = /\/+/
	
	minimatch.filter = filter
	function filter (pattern, options) {
	  options = options || {}
	  return function (p, i, list) {
	    return minimatch(p, pattern, options)
	  }
	}
	
	function ext (a, b) {
	  a = a || {}
	  b = b || {}
	  var t = {}
	  Object.keys(b).forEach(function (k) {
	    t[k] = b[k]
	  })
	  Object.keys(a).forEach(function (k) {
	    t[k] = a[k]
	  })
	  return t
	}
	
	minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return minimatch
	
	  var orig = minimatch
	
	  var m = function minimatch (p, pattern, options) {
	    return orig.minimatch(p, pattern, ext(def, options))
	  }
	
	  m.Minimatch = function Minimatch (pattern, options) {
	    return new orig.Minimatch(pattern, ext(def, options))
	  }
	
	  return m
	}
	
	Minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return Minimatch
	  return minimatch.defaults(def).Minimatch
	}
	
	
	function minimatch (p, pattern, options) {
	  if (typeof pattern !== "string") {
	    throw new TypeError("glob pattern string required")
	  }
	
	  if (!options) options = {}
	
	  // shortcut: comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === "#") {
	    return false
	  }
	
	  // "" only matches ""
	  if (pattern.trim() === "") return p === ""
	
	  return new Minimatch(pattern, options).match(p)
	}
	
	function Minimatch (pattern, options) {
	  if (!(this instanceof Minimatch)) {
	    return new Minimatch(pattern, options, cache)
	  }
	
	  if (typeof pattern !== "string") {
	    throw new TypeError("glob pattern string required")
	  }
	
	  if (!options) options = {}
	  pattern = pattern.trim()
	
	  // windows: need to use /, not \
	  // On other platforms, \ is a valid (albeit bad) filename char.
	  if (platform === "win32") {
	    pattern = pattern.split("\\").join("/")
	  }
	
	  // lru storage.
	  // these things aren't particularly big, but walking down the string
	  // and turning it into a regexp can get pretty costly.
	  var cacheKey = pattern + "\n" + sigmund(options)
	  var cached = minimatch.cache.get(cacheKey)
	  if (cached) return cached
	  minimatch.cache.set(cacheKey, this)
	
	  this.options = options
	  this.set = []
	  this.pattern = pattern
	  this.regexp = null
	  this.negate = false
	  this.comment = false
	  this.empty = false
	
	  // make the set of regexps etc.
	  this.make()
	}
	
	Minimatch.prototype.debug = function() {}
	
	Minimatch.prototype.make = make
	function make () {
	  // don't do it more than once.
	  if (this._made) return
	
	  var pattern = this.pattern
	  var options = this.options
	
	  // empty patterns and comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === "#") {
	    this.comment = true
	    return
	  }
	  if (!pattern) {
	    this.empty = true
	    return
	  }
	
	  // step 1: figure out negation, etc.
	  this.parseNegate()
	
	  // step 2: expand braces
	  var set = this.globSet = this.braceExpand()
	
	  if (options.debug) this.debug = console.error
	
	  this.debug(this.pattern, set)
	
	  // step 3: now we have a set, so turn each one into a series of path-portion
	  // matching patterns.
	  // These will be regexps, except in the case of "**", which is
	  // set to the GLOBSTAR object for globstar behavior,
	  // and will not contain any / characters
	  set = this.globParts = set.map(function (s) {
	    return s.split(slashSplit)
	  })
	
	  this.debug(this.pattern, set)
	
	  // glob --> regexps
	  set = set.map(function (s, si, set) {
	    return s.map(this.parse, this)
	  }, this)
	
	  this.debug(this.pattern, set)
	
	  // filter out everything that didn't compile properly.
	  set = set.filter(function (s) {
	    return -1 === s.indexOf(false)
	  })
	
	  this.debug(this.pattern, set)
	
	  this.set = set
	}
	
	Minimatch.prototype.parseNegate = parseNegate
	function parseNegate () {
	  var pattern = this.pattern
	    , negate = false
	    , options = this.options
	    , negateOffset = 0
	
	  if (options.nonegate) return
	
	  for ( var i = 0, l = pattern.length
	      ; i < l && pattern.charAt(i) === "!"
	      ; i ++) {
	    negate = !negate
	    negateOffset ++
	  }
	
	  if (negateOffset) this.pattern = pattern.substr(negateOffset)
	  this.negate = negate
	}
	
	// Brace expansion:
	// a{b,c}d -> abd acd
	// a{b,}c -> abc ac
	// a{0..3}d -> a0d a1d a2d a3d
	// a{b,c{d,e}f}g -> abg acdfg acefg
	// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
	//
	// Invalid sets are not expanded.
	// a{2..}b -> a{2..}b
	// a{b}c -> a{b}c
	minimatch.braceExpand = function (pattern, options) {
	  return new Minimatch(pattern, options).braceExpand()
	}
	
	Minimatch.prototype.braceExpand = braceExpand
	function braceExpand (pattern, options) {
	  options = options || this.options
	  pattern = typeof pattern === "undefined"
	    ? this.pattern : pattern
	
	  if (typeof pattern === "undefined") {
	    throw new Error("undefined pattern")
	  }
	
	  if (options.nobrace ||
	      !pattern.match(/\{.*\}/)) {
	    // shortcut. no need to expand.
	    return [pattern]
	  }
	
	  var escaping = false
	
	  // examples and comments refer to this crazy pattern:
	  // a{b,c{d,e},{f,g}h}x{y,z}
	  // expected:
	  // abxy
	  // abxz
	  // acdxy
	  // acdxz
	  // acexy
	  // acexz
	  // afhxy
	  // afhxz
	  // aghxy
	  // aghxz
	
	  // everything before the first \{ is just a prefix.
	  // So, we pluck that off, and work with the rest,
	  // and then prepend it to everything we find.
	  if (pattern.charAt(0) !== "{") {
	    this.debug(pattern)
	    var prefix = null
	    for (var i = 0, l = pattern.length; i < l; i ++) {
	      var c = pattern.charAt(i)
	      this.debug(i, c)
	      if (c === "\\") {
	        escaping = !escaping
	      } else if (c === "{" && !escaping) {
	        prefix = pattern.substr(0, i)
	        break
	      }
	    }
	
	    // actually no sets, all { were escaped.
	    if (prefix === null) {
	      this.debug("no sets")
	      return [pattern]
	    }
	
	   var tail = braceExpand.call(this, pattern.substr(i), options)
	    return tail.map(function (t) {
	      return prefix + t
	    })
	  }
	
	  // now we have something like:
	  // {b,c{d,e},{f,g}h}x{y,z}
	  // walk through the set, expanding each part, until
	  // the set ends.  then, we'll expand the suffix.
	  // If the set only has a single member, then'll put the {} back
	
	  // first, handle numeric sets, since they're easier
	  var numset = pattern.match(/^\{(-?[0-9]+)\.\.(-?[0-9]+)\}/)
	  if (numset) {
	    this.debug("numset", numset[1], numset[2])
	    var suf = braceExpand.call(this, pattern.substr(numset[0].length), options)
	      , start = +numset[1]
	      , end = +numset[2]
	      , inc = start > end ? -1 : 1
	      , set = []
	    for (var i = start; i != (end + inc); i += inc) {
	      // append all the suffixes
	      for (var ii = 0, ll = suf.length; ii < ll; ii ++) {
	        set.push(i + suf[ii])
	      }
	    }
	    return set
	  }
	
	  // ok, walk through the set
	  // We hope, somewhat optimistically, that there
	  // will be a } at the end.
	  // If the closing brace isn't found, then the pattern is
	  // interpreted as braceExpand("\\" + pattern) so that
	  // the leading \{ will be interpreted literally.
	  var i = 1 // skip the \{
	    , depth = 1
	    , set = []
	    , member = ""
	    , sawEnd = false
	    , escaping = false
	
	  function addMember () {
	    set.push(member)
	    member = ""
	  }
	
	  this.debug("Entering for")
	  FOR: for (i = 1, l = pattern.length; i < l; i ++) {
	    var c = pattern.charAt(i)
	    this.debug("", i, c)
	
	    if (escaping) {
	      escaping = false
	      member += "\\" + c
	    } else {
	      switch (c) {
	        case "\\":
	          escaping = true
	          continue
	
	        case "{":
	          depth ++
	          member += "{"
	          continue
	
	        case "}":
	          depth --
	          // if this closes the actual set, then we're done
	          if (depth === 0) {
	            addMember()
	            // pluck off the close-brace
	            i ++
	            break FOR
	          } else {
	            member += c
	            continue
	          }
	
	        case ",":
	          if (depth === 1) {
	            addMember()
	          } else {
	            member += c
	          }
	          continue
	
	        default:
	          member += c
	          continue
	      } // switch
	    } // else
	  } // for
	
	  // now we've either finished the set, and the suffix is
	  // pattern.substr(i), or we have *not* closed the set,
	  // and need to escape the leading brace
	  if (depth !== 0) {
	    this.debug("didn't close", pattern)
	    return braceExpand.call(this, "\\" + pattern, options)
	  }
	
	  // x{y,z} -> ["xy", "xz"]
	  this.debug("set", set)
	  this.debug("suffix", pattern.substr(i))
	  var suf = braceExpand.call(this, pattern.substr(i), options)
	  // ["b", "c{d,e}","{f,g}h"] ->
	  //   [["b"], ["cd", "ce"], ["fh", "gh"]]
	  var addBraces = set.length === 1
	  this.debug("set pre-expanded", set)
	  set = set.map(function (p) {
	    return braceExpand.call(this, p, options)
	  }, this)
	  this.debug("set expanded", set)
	
	
	  // [["b"], ["cd", "ce"], ["fh", "gh"]] ->
	  //   ["b", "cd", "ce", "fh", "gh"]
	  set = set.reduce(function (l, r) {
	    return l.concat(r)
	  })
	
	  if (addBraces) {
	    set = set.map(function (s) {
	      return "{" + s + "}"
	    })
	  }
	
	  // now attach the suffixes.
	  var ret = []
	  for (var i = 0, l = set.length; i < l; i ++) {
	    for (var ii = 0, ll = suf.length; ii < ll; ii ++) {
	      ret.push(set[i] + suf[ii])
	    }
	  }
	  return ret
	}
	
	// parse a component of the expanded set.
	// At this point, no pattern may contain "/" in it
	// so we're going to return a 2d array, where each entry is the full
	// pattern, split on '/', and then turned into a regular expression.
	// A regexp is made at the end which joins each array with an
	// escaped /, and another full one which joins each regexp with |.
	//
	// Following the lead of Bash 4.1, note that "**" only has special meaning
	// when it is the *only* thing in a path portion.  Otherwise, any series
	// of * is equivalent to a single *.  Globstar behavior is enabled by
	// default, and can be disabled by setting options.noglobstar.
	Minimatch.prototype.parse = parse
	var SUBPARSE = {}
	function parse (pattern, isSub) {
	  var options = this.options
	
	  // shortcuts
	  if (!options.noglobstar && pattern === "**") return GLOBSTAR
	  if (pattern === "") return ""
	
	  var re = ""
	    , hasMagic = !!options.nocase
	    , escaping = false
	    // ? => one single character
	    , patternListStack = []
	    , plType
	    , stateChar
	    , inClass = false
	    , reClassStart = -1
	    , classStart = -1
	    // . and .. never match anything that doesn't start with .,
	    // even when options.dot is set.
	    , patternStart = pattern.charAt(0) === "." ? "" // anything
	      // not (start or / followed by . or .. followed by / or end)
	      : options.dot ? "(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))"
	      : "(?!\\.)"
	    , self = this
	
	  function clearStateChar () {
	    if (stateChar) {
	      // we had some state-tracking character
	      // that wasn't consumed by this pass.
	      switch (stateChar) {
	        case "*":
	          re += star
	          hasMagic = true
	          break
	        case "?":
	          re += qmark
	          hasMagic = true
	          break
	        default:
	          re += "\\"+stateChar
	          break
	      }
	      self.debug('clearStateChar %j %j', stateChar, re)
	      stateChar = false
	    }
	  }
	
	  for ( var i = 0, len = pattern.length, c
	      ; (i < len) && (c = pattern.charAt(i))
	      ; i ++ ) {
	
	    this.debug("%s\t%s %s %j", pattern, i, re, c)
	
	    // skip over any that are escaped.
	    if (escaping && reSpecials[c]) {
	      re += "\\" + c
	      escaping = false
	      continue
	    }
	
	    SWITCH: switch (c) {
	      case "/":
	        // completely not allowed, even escaped.
	        // Should already be path-split by now.
	        return false
	
	      case "\\":
	        clearStateChar()
	        escaping = true
	        continue
	
	      // the various stateChar values
	      // for the "extglob" stuff.
	      case "?":
	      case "*":
	      case "+":
	      case "@":
	      case "!":
	        this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c)
	
	        // all of those are literals inside a class, except that
	        // the glob [!a] means [^a] in regexp
	        if (inClass) {
	          this.debug('  in class')
	          if (c === "!" && i === classStart + 1) c = "^"
	          re += c
	          continue
	        }
	
	        // if we already have a stateChar, then it means
	        // that there was something like ** or +? in there.
	        // Handle the stateChar, then proceed with this one.
	        self.debug('call clearStateChar %j', stateChar)
	        clearStateChar()
	        stateChar = c
	        // if extglob is disabled, then +(asdf|foo) isn't a thing.
	        // just clear the statechar *now*, rather than even diving into
	        // the patternList stuff.
	        if (options.noext) clearStateChar()
	        continue
	
	      case "(":
	        if (inClass) {
	          re += "("
	          continue
	        }
	
	        if (!stateChar) {
	          re += "\\("
	          continue
	        }
	
	        plType = stateChar
	        patternListStack.push({ type: plType
	                              , start: i - 1
	                              , reStart: re.length })
	        // negation is (?:(?!js)[^/]*)
	        re += stateChar === "!" ? "(?:(?!" : "(?:"
	        this.debug('plType %j %j', stateChar, re)
	        stateChar = false
	        continue
	
	      case ")":
	        if (inClass || !patternListStack.length) {
	          re += "\\)"
	          continue
	        }
	
	        clearStateChar()
	        hasMagic = true
	        re += ")"
	        plType = patternListStack.pop().type
	        // negation is (?:(?!js)[^/]*)
	        // The others are (?:<pattern>)<type>
	        switch (plType) {
	          case "!":
	            re += "[^/]*?)"
	            break
	          case "?":
	          case "+":
	          case "*": re += plType
	          case "@": break // the default anyway
	        }
	        continue
	
	      case "|":
	        if (inClass || !patternListStack.length || escaping) {
	          re += "\\|"
	          escaping = false
	          continue
	        }
	
	        clearStateChar()
	        re += "|"
	        continue
	
	      // these are mostly the same in regexp and glob
	      case "[":
	        // swallow any state-tracking char before the [
	        clearStateChar()
	
	        if (inClass) {
	          re += "\\" + c
	          continue
	        }
	
	        inClass = true
	        classStart = i
	        reClassStart = re.length
	        re += c
	        continue
	
	      case "]":
	        //  a right bracket shall lose its special
	        //  meaning and represent itself in
	        //  a bracket expression if it occurs
	        //  first in the list.  -- POSIX.2 2.8.3.2
	        if (i === classStart + 1 || !inClass) {
	          re += "\\" + c
	          escaping = false
	          continue
	        }
	
	        // finish up the class.
	        hasMagic = true
	        inClass = false
	        re += c
	        continue
	
	      default:
	        // swallow any state char that wasn't consumed
	        clearStateChar()
	
	        if (escaping) {
	          // no need
	          escaping = false
	        } else if (reSpecials[c]
	                   && !(c === "^" && inClass)) {
	          re += "\\"
	        }
	
	        re += c
	
	    } // switch
	  } // for
	
	
	  // handle the case where we left a class open.
	  // "[abc" is valid, equivalent to "\[abc"
	  if (inClass) {
	    // split where the last [ was, and escape it
	    // this is a huge pita.  We now have to re-walk
	    // the contents of the would-be class to re-translate
	    // any characters that were passed through as-is
	    var cs = pattern.substr(classStart + 1)
	      , sp = this.parse(cs, SUBPARSE)
	    re = re.substr(0, reClassStart) + "\\[" + sp[0]
	    hasMagic = hasMagic || sp[1]
	  }
	
	  // handle the case where we had a +( thing at the *end*
	  // of the pattern.
	  // each pattern list stack adds 3 chars, and we need to go through
	  // and escape any | chars that were passed through as-is for the regexp.
	  // Go through and escape them, taking care not to double-escape any
	  // | chars that were already escaped.
	  var pl
	  while (pl = patternListStack.pop()) {
	    var tail = re.slice(pl.reStart + 3)
	    // maybe some even number of \, then maybe 1 \, followed by a |
	    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
	      if (!$2) {
	        // the | isn't already escaped, so escape it.
	        $2 = "\\"
	      }
	
	      // need to escape all those slashes *again*, without escaping the
	      // one that we need for escaping the | character.  As it works out,
	      // escaping an even number of slashes can be done by simply repeating
	      // it exactly after itself.  That's why this trick works.
	      //
	      // I am sorry that you have to see this.
	      return $1 + $1 + $2 + "|"
	    })
	
	    this.debug("tail=%j\n   %s", tail, tail)
	    var t = pl.type === "*" ? star
	          : pl.type === "?" ? qmark
	          : "\\" + pl.type
	
	    hasMagic = true
	    re = re.slice(0, pl.reStart)
	       + t + "\\("
	       + tail
	  }
	
	  // handle trailing things that only matter at the very end.
	  clearStateChar()
	  if (escaping) {
	    // trailing \\
	    re += "\\\\"
	  }
	
	  // only need to apply the nodot start if the re starts with
	  // something that could conceivably capture a dot
	  var addPatternStart = false
	  switch (re.charAt(0)) {
	    case ".":
	    case "[":
	    case "(": addPatternStart = true
	  }
	
	  // if the re is not "" at this point, then we need to make sure
	  // it doesn't match against an empty path part.
	  // Otherwise a/* will match a/, which it should not.
	  if (re !== "" && hasMagic) re = "(?=.)" + re
	
	  if (addPatternStart) re = patternStart + re
	
	  // parsing just a piece of a larger pattern.
	  if (isSub === SUBPARSE) {
	    return [ re, hasMagic ]
	  }
	
	  // skip the regexp for non-magical patterns
	  // unescape anything in it, though, so that it'll be
	  // an exact match against a file etc.
	  if (!hasMagic) {
	    return globUnescape(pattern)
	  }
	
	  var flags = options.nocase ? "i" : ""
	    , regExp = new RegExp("^" + re + "$", flags)
	
	  regExp._glob = pattern
	  regExp._src = re
	
	  return regExp
	}
	
	minimatch.makeRe = function (pattern, options) {
	  return new Minimatch(pattern, options || {}).makeRe()
	}
	
	Minimatch.prototype.makeRe = makeRe
	function makeRe () {
	  if (this.regexp || this.regexp === false) return this.regexp
	
	  // at this point, this.set is a 2d array of partial
	  // pattern strings, or "**".
	  //
	  // It's better to use .match().  This function shouldn't
	  // be used, really, but it's pretty convenient sometimes,
	  // when you just want to work with a regex.
	  var set = this.set
	
	  if (!set.length) return this.regexp = false
	  var options = this.options
	
	  var twoStar = options.noglobstar ? star
	      : options.dot ? twoStarDot
	      : twoStarNoDot
	    , flags = options.nocase ? "i" : ""
	
	  var re = set.map(function (pattern) {
	    return pattern.map(function (p) {
	      return (p === GLOBSTAR) ? twoStar
	           : (typeof p === "string") ? regExpEscape(p)
	           : p._src
	    }).join("\\\/")
	  }).join("|")
	
	  // must match entire pattern
	  // ending in a * or ** will make it less strict.
	  re = "^(?:" + re + ")$"
	
	  // can match anything, as long as it's not this.
	  if (this.negate) re = "^(?!" + re + ").*$"
	
	  try {
	    return this.regexp = new RegExp(re, flags)
	  } catch (ex) {
	    return this.regexp = false
	  }
	}
	
	minimatch.match = function (list, pattern, options) {
	  var mm = new Minimatch(pattern, options)
	  list = list.filter(function (f) {
	    return mm.match(f)
	  })
	  if (options.nonull && !list.length) {
	    list.push(pattern)
	  }
	  return list
	}
	
	Minimatch.prototype.match = match
	function match (f, partial) {
	  this.debug("match", f, this.pattern)
	  // short-circuit in the case of busted things.
	  // comments, etc.
	  if (this.comment) return false
	  if (this.empty) return f === ""
	
	  if (f === "/" && partial) return true
	
	  var options = this.options
	
	  // windows: need to use /, not \
	  // On other platforms, \ is a valid (albeit bad) filename char.
	  if (platform === "win32") {
	    f = f.split("\\").join("/")
	  }
	
	  // treat the test path as a set of pathparts.
	  f = f.split(slashSplit)
	  this.debug(this.pattern, "split", f)
	
	  // just ONE of the pattern sets in this.set needs to match
	  // in order for it to be valid.  If negating, then just one
	  // match means that we have failed.
	  // Either way, return on the first hit.
	
	  var set = this.set
	  this.debug(this.pattern, "set", set)
	
	  var splitFile = path.basename(f.join("/")).split("/")
	
	  for (var i = 0, l = set.length; i < l; i ++) {
	    var pattern = set[i], file = f
	    if (options.matchBase && pattern.length === 1) {
	      file = splitFile
	    }
	    var hit = this.matchOne(file, pattern, partial)
	    if (hit) {
	      if (options.flipNegate) return true
	      return !this.negate
	    }
	  }
	
	  // didn't get any hits.  this is success if it's a negative
	  // pattern, failure otherwise.
	  if (options.flipNegate) return false
	  return this.negate
	}
	
	// set partial to true to test if, for example,
	// "/a/b" matches the start of "/*/b/*/d"
	// Partial means, if you run out of file before you run
	// out of pattern, then that's fine, as long as all
	// the parts match.
	Minimatch.prototype.matchOne = function (file, pattern, partial) {
	  var options = this.options
	
	  this.debug("matchOne",
	              { "this": this
	              , file: file
	              , pattern: pattern })
	
	  this.debug("matchOne", file.length, pattern.length)
	
	  for ( var fi = 0
	          , pi = 0
	          , fl = file.length
	          , pl = pattern.length
	      ; (fi < fl) && (pi < pl)
	      ; fi ++, pi ++ ) {
	
	    this.debug("matchOne loop")
	    var p = pattern[pi]
	      , f = file[fi]
	
	    this.debug(pattern, p, f)
	
	    // should be impossible.
	    // some invalid regexp stuff in the set.
	    if (p === false) return false
	
	    if (p === GLOBSTAR) {
	      this.debug('GLOBSTAR', [pattern, p, f])
	
	      // "**"
	      // a/**/b/**/c would match the following:
	      // a/b/x/y/z/c
	      // a/x/y/z/b/c
	      // a/b/x/b/x/c
	      // a/b/c
	      // To do this, take the rest of the pattern after
	      // the **, and see if it would match the file remainder.
	      // If so, return success.
	      // If not, the ** "swallows" a segment, and try again.
	      // This is recursively awful.
	      //
	      // a/**/b/**/c matching a/b/x/y/z/c
	      // - a matches a
	      // - doublestar
	      //   - matchOne(b/x/y/z/c, b/**/c)
	      //     - b matches b
	      //     - doublestar
	      //       - matchOne(x/y/z/c, c) -> no
	      //       - matchOne(y/z/c, c) -> no
	      //       - matchOne(z/c, c) -> no
	      //       - matchOne(c, c) yes, hit
	      var fr = fi
	        , pr = pi + 1
	      if (pr === pl) {
	        this.debug('** at the end')
	        // a ** at the end will just swallow the rest.
	        // We have found a match.
	        // however, it will not swallow /.x, unless
	        // options.dot is set.
	        // . and .. are *never* matched by **, for explosively
	        // exponential reasons.
	        for ( ; fi < fl; fi ++) {
	          if (file[fi] === "." || file[fi] === ".." ||
	              (!options.dot && file[fi].charAt(0) === ".")) return false
	        }
	        return true
	      }
	
	      // ok, let's see if we can swallow whatever we can.
	      WHILE: while (fr < fl) {
	        var swallowee = file[fr]
	
	        this.debug('\nglobstar while',
	                    file, fr, pattern, pr, swallowee)
	
	        // XXX remove this slice.  Just pass the start index.
	        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
	          this.debug('globstar found match!', fr, fl, swallowee)
	          // found a match.
	          return true
	        } else {
	          // can't swallow "." or ".." ever.
	          // can only swallow ".foo" when explicitly asked.
	          if (swallowee === "." || swallowee === ".." ||
	              (!options.dot && swallowee.charAt(0) === ".")) {
	            this.debug("dot detected!", file, fr, pattern, pr)
	            break WHILE
	          }
	
	          // ** swallows a segment, and continue.
	          this.debug('globstar swallow a segment, and continue')
	          fr ++
	        }
	      }
	      // no match was found.
	      // However, in partial mode, we can't say this is necessarily over.
	      // If there's more *pattern* left, then 
	      if (partial) {
	        // ran out of file
	        this.debug("\n>>> no match, partial?", file, fr, pattern, pr)
	        if (fr === fl) return true
	      }
	      return false
	    }
	
	    // something other than **
	    // non-magic patterns just have to match exactly
	    // patterns with magic have been turned into regexps.
	    var hit
	    if (typeof p === "string") {
	      if (options.nocase) {
	        hit = f.toLowerCase() === p.toLowerCase()
	      } else {
	        hit = f === p
	      }
	      this.debug("string match", p, f, hit)
	    } else {
	      hit = f.match(p)
	      this.debug("pattern match", p, f, hit)
	    }
	
	    if (!hit) return false
	  }
	
	  // Note: ending in / means that we'll get a final ""
	  // at the end of the pattern.  This can only match a
	  // corresponding "" at the end of the file.
	  // If the file ends in /, then it can only match a
	  // a pattern that ends in /, unless the pattern just
	  // doesn't have any more for it. But, a/b/ should *not*
	  // match "a/b/*", even though "" matches against the
	  // [^/]*? pattern, except in partial mode, where it might
	  // simply not be reached yet.
	  // However, a/b/ should still satisfy a/*
	
	  // now either we fell off the end of the pattern, or we're done.
	  if (fi === fl && pi === pl) {
	    // ran out of pattern and filename at the same time.
	    // an exact hit!
	    return true
	  } else if (fi === fl) {
	    // ran out of file, but still had pattern left.
	    // this is ok if we're doing the match as part of
	    // a glob fs traversal.
	    return partial
	  } else if (pi === pl) {
	    // ran out of pattern, still have file left.
	    // this is only acceptable if we're on the very last
	    // empty segment of a file with a trailing slash.
	    // a/* should match a/b/
	    var emptyFileEnd = (fi === fl - 1) && (file[fi] === "")
	    return emptyFileEnd
	  }
	
	  // should be unreachable.
	  throw new Error("wtf?")
	}
	
	
	// replace stuff like \* with *
	function globUnescape (s) {
	  return s.replace(/\\(.)/g, "$1")
	}
	
	
	function regExpEscape (s) {
	  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
	}
	
	})( typeof require === "function" ? require : null,
	    this,
	     true ? module : null,
	    typeof process === "object" ? process.platform : "win32"
	  )
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(469)(module), __webpack_require__(5)))

/***/ },
/* 469 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 470 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./minimatch": 468,
		"./minimatch.js": 468,
		"./test/basic": 473,
		"./test/basic.js": 473,
		"./test/brace-expand": 474,
		"./test/brace-expand.js": 474,
		"./test/caching": 475,
		"./test/caching.js": 475,
		"./test/defaults": 476,
		"./test/defaults.js": 476,
		"./test/extglob-ending-with-state-char": 477,
		"./test/extglob-ending-with-state-char.js": 477
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 470;


/***/ },
/* 471 */,
/* 472 */,
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// http://www.bashcookbook.com/bashinfo/source/bash-1.14.7/tests/glob-test
	//
	// TODO: Some of these tests do very bad things with backslashes, and will
	// most likely fail badly on windows.  They should probably be skipped.
	
	var tap = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , globalBefore = Object.keys(global)
	  , mm = __webpack_require__(468)
	  , files = [ "a", "b", "c", "d", "abc"
	            , "abd", "abe", "bb", "bcd"
	            , "ca", "cb", "dd", "de"
	            , "bdir/", "bdir/cfile"]
	  , next = files.concat([ "a-b", "aXb"
	                        , ".x", ".y" ])
	
	
	var patterns =
	  [ "http://www.bashcookbook.com/bashinfo/source/bash-1.14.7/tests/glob-test"
	  , ["a*", ["a", "abc", "abd", "abe"]]
	  , ["X*", ["X*"], {nonull: true}]
	
	  // allow null glob expansion
	  , ["X*", []]
	
	  // isaacs: Slightly different than bash/sh/ksh
	  // \\* is not un-escaped to literal "*" in a failed match,
	  // but it does make it get treated as a literal star
	  , ["\\*", ["\\*"], {nonull: true}]
	  , ["\\**", ["\\**"], {nonull: true}]
	  , ["\\*\\*", ["\\*\\*"], {nonull: true}]
	
	  , ["b*/", ["bdir/"]]
	  , ["c*", ["c", "ca", "cb"]]
	  , ["**", files]
	
	  , ["\\.\\./*/", ["\\.\\./*/"], {nonull: true}]
	  , ["s/\\..*//", ["s/\\..*//"], {nonull: true}]
	
	  , "legendary larry crashes bashes"
	  , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\\1/"
	    , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\\1/"], {nonull: true}]
	  , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\1/"
	    , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\1/"], {nonull: true}]
	
	  , "character classes"
	  , ["[a-c]b*", ["abc", "abd", "abe", "bb", "cb"]]
	  , ["[a-y]*[^c]", ["abd", "abe", "bb", "bcd",
	     "bdir/", "ca", "cb", "dd", "de"]]
	  , ["a*[^c]", ["abd", "abe"]]
	  , function () { files.push("a-b", "aXb") }
	  , ["a[X-]b", ["a-b", "aXb"]]
	  , function () { files.push(".x", ".y") }
	  , ["[^a-c]*", ["d", "dd", "de"]]
	  , function () { files.push("a*b/", "a*b/ooo") }
	  , ["a\\*b/*", ["a*b/ooo"]]
	  , ["a\\*?/*", ["a*b/ooo"]]
	  , ["*\\\\!*", [], {null: true}, ["echo !7"]]
	  , ["*\\!*", ["echo !7"], null, ["echo !7"]]
	  , ["*.\\*", ["r.*"], null, ["r.*"]]
	  , ["a[b]c", ["abc"]]
	  , ["a[\\b]c", ["abc"]]
	  , ["a?c", ["abc"]]
	  , ["a\\*c", [], {null: true}, ["abc"]]
	  , ["", [""], { null: true }, [""]]
	
	  , "http://www.opensource.apple.com/source/bash/bash-23/" +
	    "bash/tests/glob-test"
	  , function () { files.push("man/", "man/man1/", "man/man1/bash.1") }
	  , ["*/man*/bash.*", ["man/man1/bash.1"]]
	  , ["man/man1/bash.1", ["man/man1/bash.1"]]
	  , ["a***c", ["abc"], null, ["abc"]]
	  , ["a*****?c", ["abc"], null, ["abc"]]
	  , ["?*****??", ["abc"], null, ["abc"]]
	  , ["*****??", ["abc"], null, ["abc"]]
	  , ["?*****?c", ["abc"], null, ["abc"]]
	  , ["?***?****c", ["abc"], null, ["abc"]]
	  , ["?***?****?", ["abc"], null, ["abc"]]
	  , ["?***?****", ["abc"], null, ["abc"]]
	  , ["*******c", ["abc"], null, ["abc"]]
	  , ["*******?", ["abc"], null, ["abc"]]
	  , ["a*cd**?**??k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a**?**cd**?**??k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a**?**cd**?**??k***", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a**?**cd**?**??***k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a**?**cd**?**??***k**", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a****c**?**??*****", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["[-abc]", ["-"], null, ["-"]]
	  , ["[abc-]", ["-"], null, ["-"]]
	  , ["\\", ["\\"], null, ["\\"]]
	  , ["[\\\\]", ["\\"], null, ["\\"]]
	  , ["[[]", ["["], null, ["["]]
	  , ["[", ["["], null, ["["]]
	  , ["[*", ["[abc"], null, ["[abc"]]
	  , "a right bracket shall lose its special meaning and\n" +
	    "represent itself in a bracket expression if it occurs\n" +
	    "first in the list.  -- POSIX.2 2.8.3.2"
	  , ["[]]", ["]"], null, ["]"]]
	  , ["[]-]", ["]"], null, ["]"]]
	  , ["[a-\z]", ["p"], null, ["p"]]
	  , ["??**********?****?", [], { null: true }, ["abc"]]
	  , ["??**********?****c", [], { null: true }, ["abc"]]
	  , ["?************c****?****", [], { null: true }, ["abc"]]
	  , ["*c*?**", [], { null: true }, ["abc"]]
	  , ["a*****c*?**", [], { null: true }, ["abc"]]
	  , ["a********???*******", [], { null: true }, ["abc"]]
	  , ["[]", [], { null: true }, ["a"]]
	  , ["[abc", [], { null: true }, ["["]]
	
	  , "nocase tests"
	  , ["XYZ", ["xYz"], { nocase: true, null: true }
	    , ["xYz", "ABC", "IjK"]]
	  , ["ab*", ["ABC"], { nocase: true, null: true }
	    , ["xYz", "ABC", "IjK"]]
	  , ["[ia]?[ck]", ["ABC", "IjK"], { nocase: true, null: true }
	    , ["xYz", "ABC", "IjK"]]
	
	  // [ pattern, [matches], MM opts, files, TAP opts]
	  , "onestar/twostar"
	  , ["{/*,*}", [], {null: true}, ["/asdf/asdf/asdf"]]
	  , ["{/?,*}", ["/a", "bb"], {null: true}
	    , ["/a", "/b/b", "/a/b/c", "bb"]]
	
	  , "dots should not match unless requested"
	  , ["**", ["a/b"], {}, ["a/b", "a/.d", ".a/.d"]]
	
	  // .. and . can only match patterns starting with .,
	  // even when options.dot is set.
	  , function () {
	      files = ["a/./b", "a/../b", "a/c/b", "a/.d/b"]
	    }
	  , ["a/*/b", ["a/c/b", "a/.d/b"], {dot: true}]
	  , ["a/.*/b", ["a/./b", "a/../b", "a/.d/b"], {dot: true}]
	  , ["a/*/b", ["a/c/b"], {dot:false}]
	  , ["a/.*/b", ["a/./b", "a/../b", "a/.d/b"], {dot: false}]
	
	
	  // this also tests that changing the options needs
	  // to change the cache key, even if the pattern is
	  // the same!
	  , ["**", ["a/b","a/.d",".a/.d"], { dot: true }
	    , [ ".a/.d", "a/.d", "a/b"]]
	
	  , "paren sets cannot contain slashes"
	  , ["*(a/b)", ["*(a/b)"], {nonull: true}, ["a/b"]]
	
	  // brace sets trump all else.
	  //
	  // invalid glob pattern.  fails on bash4 and bsdglob.
	  // however, in this implementation, it's easier just
	  // to do the intuitive thing, and let brace-expansion
	  // actually come before parsing any extglob patterns,
	  // like the documentation seems to say.
	  //
	  // XXX: if anyone complains about this, either fix it
	  // or tell them to grow up and stop complaining.
	  //
	  // bash/bsdglob says this:
	  // , ["*(a|{b),c)}", ["*(a|{b),c)}"], {}, ["a", "ab", "ac", "ad"]]
	  // but we do this instead:
	  , ["*(a|{b),c)}", ["a", "ab", "ac"], {}, ["a", "ab", "ac", "ad"]]
	
	  // test partial parsing in the presence of comment/negation chars
	  , ["[!a*", ["[!ab"], {}, ["[!ab", "[ab"]]
	  , ["[#a*", ["[#ab"], {}, ["[#ab", "[ab"]]
	
	  // like: {a,b|c\\,d\\\|e} except it's unclosed, so it has to be escaped.
	  , ["+(a|*\\|c\\\\|d\\\\\\|e\\\\\\\\|f\\\\\\\\\\|g"
	    , ["+(a|b\\|c\\\\|d\\\\|e\\\\\\\\|f\\\\\\\\|g"]
	    , {}
	    , ["+(a|b\\|c\\\\|d\\\\|e\\\\\\\\|f\\\\\\\\|g", "a", "b\\c"]]
	
	
	  // crazy nested {,,} and *(||) tests.
	  , function () {
	      files = [ "a", "b", "c", "d"
	              , "ab", "ac", "ad"
	              , "bc", "cb"
	              , "bc,d", "c,db", "c,d"
	              , "d)", "(b|c", "*(b|c"
	              , "b|c", "b|cc", "cb|c"
	              , "x(a|b|c)", "x(a|c)"
	              , "(a|b|c)", "(a|c)"]
	    }
	  , ["*(a|{b,c})", ["a", "b", "c", "ab", "ac"]]
	  , ["{a,*(b|c,d)}", ["a","(b|c", "*(b|c", "d)"]]
	  // a
	  // *(b|c)
	  // *(b|d)
	  , ["{a,*(b|{c,d})}", ["a","b", "bc", "cb", "c", "d"]]
	  , ["*(a|{b|c,c})", ["a", "b", "c", "ab", "ac", "bc", "cb"]]
	
	
	  // test various flag settings.
	  , [ "*(a|{b|c,c})", ["x(a|b|c)", "x(a|c)", "(a|b|c)", "(a|c)"]
	    , { noext: true } ]
	  , ["a?b", ["x/y/acb", "acb/"], {matchBase: true}
	    , ["x/y/acb", "acb/", "acb/d/e", "x/y/acb/d"] ]
	  , ["#*", ["#a", "#b"], {nocomment: true}, ["#a", "#b", "c#d"]]
	
	
	  // begin channelling Boole and deMorgan...
	  , "negation tests"
	  , function () {
	      files = ["d", "e", "!ab", "!abc", "a!b", "\\!a"]
	    }
	
	  // anything that is NOT a* matches.
	  , ["!a*", ["\\!a", "d", "e", "!ab", "!abc"]]
	
	  // anything that IS !a* matches.
	  , ["!a*", ["!ab", "!abc"], {nonegate: true}]
	
	  // anything that IS a* matches
	  , ["!!a*", ["a!b"]]
	
	  // anything that is NOT !a* matches
	  , ["!\\!a*", ["a!b", "d", "e", "\\!a"]]
	
	  // negation nestled within a pattern
	  , function () {
	      files = [ "foo.js"
	              , "foo.bar"
	              // can't match this one without negative lookbehind.
	              , "foo.js.js"
	              , "blar.js"
	              , "foo."
	              , "boo.js.boo" ]
	    }
	  , ["*.!(js)", ["foo.bar", "foo.", "boo.js.boo"] ]
	
	  // https://github.com/isaacs/minimatch/issues/5
	  , function () {
	      files = [ 'a/b/.x/c'
	              , 'a/b/.x/c/d'
	              , 'a/b/.x/c/d/e'
	              , 'a/b/.x'
	              , 'a/b/.x/'
	              , 'a/.x/b'
	              , '.x'
	              , '.x/'
	              , '.x/a'
	              , '.x/a/b'
	              , 'a/.x/b/.x/c'
	              , '.x/.x' ]
	  }
	  , ["**/.x/**", [ '.x/'
	                 , '.x/a'
	                 , '.x/a/b'
	                 , 'a/.x/b'
	                 , 'a/b/.x/'
	                 , 'a/b/.x/c'
	                 , 'a/b/.x/c/d'
	                 , 'a/b/.x/c/d/e' ] ]
	
	  ]
	
	var regexps =
	  [ '/^(?:(?=.)a[^/]*?)$/',
	    '/^(?:(?=.)X[^/]*?)$/',
	    '/^(?:(?=.)X[^/]*?)$/',
	    '/^(?:\\*)$/',
	    '/^(?:(?=.)\\*[^/]*?)$/',
	    '/^(?:\\*\\*)$/',
	    '/^(?:(?=.)b[^/]*?\\/)$/',
	    '/^(?:(?=.)c[^/]*?)$/',
	    '/^(?:(?:(?!(?:\\/|^)\\.).)*?)$/',
	    '/^(?:\\.\\.\\/(?!\\.)(?=.)[^/]*?\\/)$/',
	    '/^(?:s\\/(?=.)\\.\\.[^/]*?\\/)$/',
	    '/^(?:\\/\\^root:\\/\\{s\\/(?=.)\\^[^:][^/]*?:[^:][^/]*?:\\([^:]\\)[^/]*?\\.[^/]*?\\$\\/1\\/)$/',
	    '/^(?:\\/\\^root:\\/\\{s\\/(?=.)\\^[^:][^/]*?:[^:][^/]*?:\\([^:]\\)[^/]*?\\.[^/]*?\\$\\/\u0001\\/)$/',
	    '/^(?:(?!\\.)(?=.)[a-c]b[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[a-y][^/]*?[^c])$/',
	    '/^(?:(?=.)a[^/]*?[^c])$/',
	    '/^(?:(?=.)a[X-]b)$/',
	    '/^(?:(?!\\.)(?=.)[^a-c][^/]*?)$/',
	    '/^(?:a\\*b\\/(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:(?=.)a\\*[^/]\\/(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\\\\\![^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\![^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\.\\*)$/',
	    '/^(?:(?=.)a[b]c)$/',
	    '/^(?:(?=.)a[b]c)$/',
	    '/^(?:(?=.)a[^/]c)$/',
	    '/^(?:a\\*c)$/',
	    'false',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\/(?=.)man[^/]*?\\/(?=.)bash\\.[^/]*?)$/',
	    '/^(?:man\\/man1\\/bash\\.1)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?c)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]c)$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/])$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/])$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]c)$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?c)$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/])$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?c)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/])$/',
	    '/^(?:(?=.)a[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/]k)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/]k)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/]k[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/][^/]*?[^/]*?[^/]*?k)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/][^/]*?[^/]*?[^/]*?k[^/]*?[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?c[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[-abc])$/',
	    '/^(?:(?!\\.)(?=.)[abc-])$/',
	    '/^(?:\\\\)$/',
	    '/^(?:(?!\\.)(?=.)[\\\\])$/',
	    '/^(?:(?!\\.)(?=.)[\\[])$/',
	    '/^(?:\\[)$/',
	    '/^(?:(?=.)\\[(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[\\]])$/',
	    '/^(?:(?!\\.)(?=.)[\\]-])$/',
	    '/^(?:(?!\\.)(?=.)[a-z])$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/])$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?c)$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?c[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?c[^/]*?[^/][^/]*?[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?c[^/]*?[^/][^/]*?[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:\\[\\])$/',
	    '/^(?:\\[abc)$/',
	    '/^(?:(?=.)XYZ)$/i',
	    '/^(?:(?=.)ab[^/]*?)$/i',
	    '/^(?:(?!\\.)(?=.)[ia][^/][ck])$/i',
	    '/^(?:\\/(?!\\.)(?=.)[^/]*?|(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:\\/(?!\\.)(?=.)[^/]|(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:(?:(?!(?:\\/|^)\\.).)*?)$/',
	    '/^(?:a\\/(?!(?:^|\\/)\\.{1,2}(?:$|\\/))(?=.)[^/]*?\\/b)$/',
	    '/^(?:a\\/(?=.)\\.[^/]*?\\/b)$/',
	    '/^(?:a\\/(?!\\.)(?=.)[^/]*?\\/b)$/',
	    '/^(?:a\\/(?=.)\\.[^/]*?\\/b)$/',
	    '/^(?:(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\(a\\/b\\))$/',
	    '/^(?:(?!\\.)(?=.)(?:a|b)*|(?!\\.)(?=.)(?:a|c)*)$/',
	    '/^(?:(?=.)\\[(?=.)\\!a[^/]*?)$/',
	    '/^(?:(?=.)\\[(?=.)#a[^/]*?)$/',
	    '/^(?:(?=.)\\+\\(a\\|[^/]*?\\|c\\\\\\\\\\|d\\\\\\\\\\|e\\\\\\\\\\\\\\\\\\|f\\\\\\\\\\\\\\\\\\|g)$/',
	    '/^(?:(?!\\.)(?=.)(?:a|b)*|(?!\\.)(?=.)(?:a|c)*)$/',
	    '/^(?:a|(?!\\.)(?=.)[^/]*?\\(b\\|c|d\\))$/',
	    '/^(?:a|(?!\\.)(?=.)(?:b|c)*|(?!\\.)(?=.)(?:b|d)*)$/',
	    '/^(?:(?!\\.)(?=.)(?:a|b|c)*|(?!\\.)(?=.)(?:a|c)*)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\(a\\|b\\|c\\)|(?!\\.)(?=.)[^/]*?\\(a\\|c\\))$/',
	    '/^(?:(?=.)a[^/]b)$/',
	    '/^(?:(?=.)#[^/]*?)$/',
	    '/^(?!^(?:(?=.)a[^/]*?)$).*$/',
	    '/^(?:(?=.)\\!a[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?)$/',
	    '/^(?!^(?:(?=.)\\!a[^/]*?)$).*$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\.(?:(?!js)[^/]*?))$/',
	    '/^(?:(?:(?!(?:\\/|^)\\.).)*?\\/\\.x\\/(?:(?!(?:\\/|^)\\.).)*?)$/' ]
	var re = 0;
	
	tap.test("basic tests", function (t) {
	  var start = Date.now()
	
	  // [ pattern, [matches], MM opts, files, TAP opts]
	  patterns.forEach(function (c) {
	    if (typeof c === "function") return c()
	    if (typeof c === "string") return t.comment(c)
	
	    var pattern = c[0]
	      , expect = c[1].sort(alpha)
	      , options = c[2] || {}
	      , f = c[3] || files
	      , tapOpts = c[4] || {}
	
	    // options.debug = true
	    var m = new mm.Minimatch(pattern, options)
	    var r = m.makeRe()
	    var expectRe = regexps[re++]
	    tapOpts.re = String(r) || JSON.stringify(r)
	    tapOpts.files = JSON.stringify(f)
	    tapOpts.pattern = pattern
	    tapOpts.set = m.set
	    tapOpts.negated = m.negate
	
	    var actual = mm.match(f, pattern, options)
	    actual.sort(alpha)
	
	    t.equivalent( actual, expect
	                , JSON.stringify(pattern) + " " + JSON.stringify(expect)
	                , tapOpts )
	
	    t.equal(tapOpts.re, expectRe, tapOpts)
	  })
	
	  t.comment("time=" + (Date.now() - start) + "ms")
	  t.end()
	})
	
	tap.test("global leak test", function (t) {
	  var globalAfter = Object.keys(global)
	  t.equivalent(globalAfter, globalBefore, "no new globals, please")
	  t.end()
	})
	
	function alpha (a, b) {
	  return a > b ? 1 : -1
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	var tap = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , minimatch = __webpack_require__(468)
	
	tap.test("brace expansion", function (t) {
	  // [ pattern, [expanded] ]
	  ; [ [ "a{b,c{d,e},{f,g}h}x{y,z}"
	      , [ "abxy"
	        , "abxz"
	        , "acdxy"
	        , "acdxz"
	        , "acexy"
	        , "acexz"
	        , "afhxy"
	        , "afhxz"
	        , "aghxy"
	        , "aghxz" ] ]
	    , [ "a{1..5}b"
	      , [ "a1b"
	        , "a2b"
	        , "a3b"
	        , "a4b"
	        , "a5b" ] ]
	    , [ "a{b}c", ["a{b}c"] ]
	  ].forEach(function (tc) {
	    var p = tc[0]
	      , expect = tc[1]
	    t.equivalent(minimatch.braceExpand(p), expect, p)
	  })
	  console.error("ending")
	  t.end()
	})
	
	


/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	var Minimatch = __webpack_require__(468).Minimatch
	var tap = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	tap.test("cache test", function (t) {
	  var mm1 = new Minimatch("a?b")
	  var mm2 = new Minimatch("a?b")
	  t.equal(mm1, mm2, "should get the same object")
	  // the lru should drop it after 100 entries
	  for (var i = 0; i < 100; i ++) {
	    new Minimatch("a"+i)
	  }
	  mm2 = new Minimatch("a?b")
	  t.notEqual(mm1, mm2, "cache should have dropped")
	  t.end()
	})


/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// http://www.bashcookbook.com/bashinfo/source/bash-1.14.7/tests/glob-test
	//
	// TODO: Some of these tests do very bad things with backslashes, and will
	// most likely fail badly on windows.  They should probably be skipped.
	
	var tap = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , globalBefore = Object.keys(global)
	  , mm = __webpack_require__(468)
	  , files = [ "a", "b", "c", "d", "abc"
	            , "abd", "abe", "bb", "bcd"
	            , "ca", "cb", "dd", "de"
	            , "bdir/", "bdir/cfile"]
	  , next = files.concat([ "a-b", "aXb"
	                        , ".x", ".y" ])
	
	tap.test("basic tests", function (t) {
	  var start = Date.now()
	
	  // [ pattern, [matches], MM opts, files, TAP opts]
	  ; [ "http://www.bashcookbook.com/bashinfo" +
	      "/source/bash-1.14.7/tests/glob-test"
	    , ["a*", ["a", "abc", "abd", "abe"]]
	    , ["X*", ["X*"], {nonull: true}]
	
	    // allow null glob expansion
	    , ["X*", []]
	
	    // isaacs: Slightly different than bash/sh/ksh
	    // \\* is not un-escaped to literal "*" in a failed match,
	    // but it does make it get treated as a literal star
	    , ["\\*", ["\\*"], {nonull: true}]
	    , ["\\**", ["\\**"], {nonull: true}]
	    , ["\\*\\*", ["\\*\\*"], {nonull: true}]
	
	    , ["b*/", ["bdir/"]]
	    , ["c*", ["c", "ca", "cb"]]
	    , ["**", files]
	
	    , ["\\.\\./*/", ["\\.\\./*/"], {nonull: true}]
	    , ["s/\\..*//", ["s/\\..*//"], {nonull: true}]
	
	    , "legendary larry crashes bashes"
	    , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\\1/"
	      , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\\1/"], {nonull: true}]
	    , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\1/"
	      , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\1/"], {nonull: true}]
	
	    , "character classes"
	    , ["[a-c]b*", ["abc", "abd", "abe", "bb", "cb"]]
	    , ["[a-y]*[^c]", ["abd", "abe", "bb", "bcd",
	       "bdir/", "ca", "cb", "dd", "de"]]
	    , ["a*[^c]", ["abd", "abe"]]
	    , function () { files.push("a-b", "aXb") }
	    , ["a[X-]b", ["a-b", "aXb"]]
	    , function () { files.push(".x", ".y") }
	    , ["[^a-c]*", ["d", "dd", "de"]]
	    , function () { files.push("a*b/", "a*b/ooo") }
	    , ["a\\*b/*", ["a*b/ooo"]]
	    , ["a\\*?/*", ["a*b/ooo"]]
	    , ["*\\\\!*", [], {null: true}, ["echo !7"]]
	    , ["*\\!*", ["echo !7"], null, ["echo !7"]]
	    , ["*.\\*", ["r.*"], null, ["r.*"]]
	    , ["a[b]c", ["abc"]]
	    , ["a[\\b]c", ["abc"]]
	    , ["a?c", ["abc"]]
	    , ["a\\*c", [], {null: true}, ["abc"]]
	    , ["", [""], { null: true }, [""]]
	
	    , "http://www.opensource.apple.com/source/bash/bash-23/" +
	      "bash/tests/glob-test"
	    , function () { files.push("man/", "man/man1/", "man/man1/bash.1") }
	    , ["*/man*/bash.*", ["man/man1/bash.1"]]
	    , ["man/man1/bash.1", ["man/man1/bash.1"]]
	    , ["a***c", ["abc"], null, ["abc"]]
	    , ["a*****?c", ["abc"], null, ["abc"]]
	    , ["?*****??", ["abc"], null, ["abc"]]
	    , ["*****??", ["abc"], null, ["abc"]]
	    , ["?*****?c", ["abc"], null, ["abc"]]
	    , ["?***?****c", ["abc"], null, ["abc"]]
	    , ["?***?****?", ["abc"], null, ["abc"]]
	    , ["?***?****", ["abc"], null, ["abc"]]
	    , ["*******c", ["abc"], null, ["abc"]]
	    , ["*******?", ["abc"], null, ["abc"]]
	    , ["a*cd**?**??k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a**?**cd**?**??k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a**?**cd**?**??k***", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a**?**cd**?**??***k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a**?**cd**?**??***k**", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a****c**?**??*****", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["[-abc]", ["-"], null, ["-"]]
	    , ["[abc-]", ["-"], null, ["-"]]
	    , ["\\", ["\\"], null, ["\\"]]
	    , ["[\\\\]", ["\\"], null, ["\\"]]
	    , ["[[]", ["["], null, ["["]]
	    , ["[", ["["], null, ["["]]
	    , ["[*", ["[abc"], null, ["[abc"]]
	    , "a right bracket shall lose its special meaning and\n" +
	      "represent itself in a bracket expression if it occurs\n" +
	      "first in the list.  -- POSIX.2 2.8.3.2"
	    , ["[]]", ["]"], null, ["]"]]
	    , ["[]-]", ["]"], null, ["]"]]
	    , ["[a-\z]", ["p"], null, ["p"]]
	    , ["??**********?****?", [], { null: true }, ["abc"]]
	    , ["??**********?****c", [], { null: true }, ["abc"]]
	    , ["?************c****?****", [], { null: true }, ["abc"]]
	    , ["*c*?**", [], { null: true }, ["abc"]]
	    , ["a*****c*?**", [], { null: true }, ["abc"]]
	    , ["a********???*******", [], { null: true }, ["abc"]]
	    , ["[]", [], { null: true }, ["a"]]
	    , ["[abc", [], { null: true }, ["["]]
	
	    , "nocase tests"
	    , ["XYZ", ["xYz"], { nocase: true, null: true }
	      , ["xYz", "ABC", "IjK"]]
	    , ["ab*", ["ABC"], { nocase: true, null: true }
	      , ["xYz", "ABC", "IjK"]]
	    , ["[ia]?[ck]", ["ABC", "IjK"], { nocase: true, null: true }
	      , ["xYz", "ABC", "IjK"]]
	
	    // [ pattern, [matches], MM opts, files, TAP opts]
	    , "onestar/twostar"
	    , ["{/*,*}", [], {null: true}, ["/asdf/asdf/asdf"]]
	    , ["{/?,*}", ["/a", "bb"], {null: true}
	      , ["/a", "/b/b", "/a/b/c", "bb"]]
	
	    , "dots should not match unless requested"
	    , ["**", ["a/b"], {}, ["a/b", "a/.d", ".a/.d"]]
	
	    // .. and . can only match patterns starting with .,
	    // even when options.dot is set.
	    , function () {
	        files = ["a/./b", "a/../b", "a/c/b", "a/.d/b"]
	      }
	    , ["a/*/b", ["a/c/b", "a/.d/b"], {dot: true}]
	    , ["a/.*/b", ["a/./b", "a/../b", "a/.d/b"], {dot: true}]
	    , ["a/*/b", ["a/c/b"], {dot:false}]
	    , ["a/.*/b", ["a/./b", "a/../b", "a/.d/b"], {dot: false}]
	
	
	    // this also tests that changing the options needs
	    // to change the cache key, even if the pattern is
	    // the same!
	    , ["**", ["a/b","a/.d",".a/.d"], { dot: true }
	      , [ ".a/.d", "a/.d", "a/b"]]
	
	    , "paren sets cannot contain slashes"
	    , ["*(a/b)", ["*(a/b)"], {nonull: true}, ["a/b"]]
	
	    // brace sets trump all else.
	    //
	    // invalid glob pattern.  fails on bash4 and bsdglob.
	    // however, in this implementation, it's easier just
	    // to do the intuitive thing, and let brace-expansion
	    // actually come before parsing any extglob patterns,
	    // like the documentation seems to say.
	    //
	    // XXX: if anyone complains about this, either fix it
	    // or tell them to grow up and stop complaining.
	    //
	    // bash/bsdglob says this:
	    // , ["*(a|{b),c)}", ["*(a|{b),c)}"], {}, ["a", "ab", "ac", "ad"]]
	    // but we do this instead:
	    , ["*(a|{b),c)}", ["a", "ab", "ac"], {}, ["a", "ab", "ac", "ad"]]
	
	    // test partial parsing in the presence of comment/negation chars
	    , ["[!a*", ["[!ab"], {}, ["[!ab", "[ab"]]
	    , ["[#a*", ["[#ab"], {}, ["[#ab", "[ab"]]
	
	    // like: {a,b|c\\,d\\\|e} except it's unclosed, so it has to be escaped.
	    , ["+(a|*\\|c\\\\|d\\\\\\|e\\\\\\\\|f\\\\\\\\\\|g"
	      , ["+(a|b\\|c\\\\|d\\\\|e\\\\\\\\|f\\\\\\\\|g"]
	      , {}
	      , ["+(a|b\\|c\\\\|d\\\\|e\\\\\\\\|f\\\\\\\\|g", "a", "b\\c"]]
	
	
	    // crazy nested {,,} and *(||) tests.
	    , function () {
	        files = [ "a", "b", "c", "d"
	                , "ab", "ac", "ad"
	                , "bc", "cb"
	                , "bc,d", "c,db", "c,d"
	                , "d)", "(b|c", "*(b|c"
	                , "b|c", "b|cc", "cb|c"
	                , "x(a|b|c)", "x(a|c)"
	                , "(a|b|c)", "(a|c)"]
	      }
	    , ["*(a|{b,c})", ["a", "b", "c", "ab", "ac"]]
	    , ["{a,*(b|c,d)}", ["a","(b|c", "*(b|c", "d)"]]
	    // a
	    // *(b|c)
	    // *(b|d)
	    , ["{a,*(b|{c,d})}", ["a","b", "bc", "cb", "c", "d"]]
	    , ["*(a|{b|c,c})", ["a", "b", "c", "ab", "ac", "bc", "cb"]]
	
	
	    // test various flag settings.
	    , [ "*(a|{b|c,c})", ["x(a|b|c)", "x(a|c)", "(a|b|c)", "(a|c)"]
	      , { noext: true } ]
	    , ["a?b", ["x/y/acb", "acb/"], {matchBase: true}
	      , ["x/y/acb", "acb/", "acb/d/e", "x/y/acb/d"] ]
	    , ["#*", ["#a", "#b"], {nocomment: true}, ["#a", "#b", "c#d"]]
	
	
	    // begin channelling Boole and deMorgan...
	    , "negation tests"
	    , function () {
	        files = ["d", "e", "!ab", "!abc", "a!b", "\\!a"]
	      }
	
	    // anything that is NOT a* matches.
	    , ["!a*", ["\\!a", "d", "e", "!ab", "!abc"]]
	
	    // anything that IS !a* matches.
	    , ["!a*", ["!ab", "!abc"], {nonegate: true}]
	
	    // anything that IS a* matches
	    , ["!!a*", ["a!b"]]
	
	    // anything that is NOT !a* matches
	    , ["!\\!a*", ["a!b", "d", "e", "\\!a"]]
	
	    // negation nestled within a pattern
	    , function () {
	        files = [ "foo.js"
	                , "foo.bar"
	                // can't match this one without negative lookbehind.
	                , "foo.js.js"
	                , "blar.js"
	                , "foo."
	                , "boo.js.boo" ]
	      }
	    , ["*.!(js)", ["foo.bar", "foo.", "boo.js.boo"] ]
	
	    ].forEach(function (c) {
	      if (typeof c === "function") return c()
	      if (typeof c === "string") return t.comment(c)
	
	      var pattern = c[0]
	        , expect = c[1].sort(alpha)
	        , options = c[2] || {}
	        , f = c[3] || files
	        , tapOpts = c[4] || {}
	
	      // options.debug = true
	      var Class = mm.defaults(options).Minimatch
	      var m = new Class(pattern, {})
	      var r = m.makeRe()
	      tapOpts.re = String(r) || JSON.stringify(r)
	      tapOpts.files = JSON.stringify(f)
	      tapOpts.pattern = pattern
	      tapOpts.set = m.set
	      tapOpts.negated = m.negate
	
	      var actual = mm.match(f, pattern, options)
	      actual.sort(alpha)
	
	      t.equivalent( actual, expect
	                  , JSON.stringify(pattern) + " " + JSON.stringify(expect)
	                  , tapOpts )
	    })
	
	  t.comment("time=" + (Date.now() - start) + "ms")
	  t.end()
	})
	
	tap.test("global leak test", function (t) {
	  var globalAfter = Object.keys(global)
	  t.equivalent(globalAfter, globalBefore, "no new globals, please")
	  t.end()
	})
	
	function alpha (a, b) {
	  return a > b ? 1 : -1
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	var test = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).test
	var minimatch = __webpack_require__(468)
	
	test('extglob ending with statechar', function(t) {
	  t.notOk(minimatch('ax', 'a?(b*)'))
	  t.ok(minimatch('ax', '?(a*|b)'))
	  t.end()
	})


/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {'use strict';
	
	var si = typeof setImmediate !== 'undefined' ? setImmediate : function (fn) { setTimeout(fn, 0) };
	
	var stream = __webpack_require__(479);
	var util = __webpack_require__(238);
	
	var Readable = stream.Readable;
	
	module.exports = ReaddirpReadable;
	
	util.inherits(ReaddirpReadable, Readable);
	
	function ReaddirpReadable (opts) {
	  if (!(this instanceof ReaddirpReadable)) return new ReaddirpReadable(opts);
	
	  opts = opts || {};
	  
	  opts.objectMode = true;
	  Readable.call(this, opts);
	
	  // backpressure not implemented at this point
	  this.highWaterMark = Infinity;
	
	  this._destroyed = false;
	  this._paused = false;
	  this._warnings = [];
	  this._errors = [];
	
	  this._pauseResumeErrors();
	}
	
	var proto = ReaddirpReadable.prototype;
	
	proto._pauseResumeErrors = function () {
	  var self = this;
	  self.on('pause', function () { self._paused = true });
	  self.on('resume', function () {
	    if (self._destroyed) return;
	    self._paused = false;
	
	    self._warnings.forEach(function (err) { self.emit('warn', err) });
	    self._warnings.length = 0;
	
	    self._errors.forEach(function (err) { self.emit('error', err) });
	    self._errors.length = 0;
	  })
	}
	
	// called for each entry
	proto._processEntry = function (entry) {
	  if (this._destroyed) return;
	  this.push(entry);
	}
	
	proto._read = function () { }
	
	proto.destroy = function () {
	  // when stream is destroyed it will emit nothing further, not even errors or warnings
	  this.push(null);
	  this.readable = false;
	  this._destroyed = true;
	  this.emit('close');
	}
	
	proto._done = function () {
	  this.push(null);
	}
	
	// we emit errors and warnings async since we may handle errors like invalid args
	// within the initial event loop before any event listeners subscribed
	proto._handleError = function (err) {
	  var self = this;
	  si(function () { 
	    if (self._paused) return self._warnings.push(err);
	    if (!self._destroyed) self.emit('warn', err);
	  });
	}
	
	proto._handleFatalError = function (err) {
	  var self = this;
	  si(function () { 
	    if (self._paused) return self._errors.push(err);
	    if (!self._destroyed) self.emit('error', err);
	  });
	}
	
	function createStreamAPI () {
	  var stream = new ReaddirpReadable();
	
	  return { 
	      stream           :  stream
	    , processEntry     :  stream._processEntry.bind(stream)
	    , done             :  stream._done.bind(stream)
	    , handleError      :  stream._handleError.bind(stream)
	    , handleFatalError :  stream._handleFatalError.bind(stream)
	  };
	}
	
	module.exports = createStreamAPI;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(184).setImmediate))

/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(450); // hack to fix a circular dependency issue when used with browserify
	exports = module.exports = __webpack_require__(480);
	exports.Stream = Stream;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(485);
	exports.Duplex = __webpack_require__(486);
	exports.Transform = __webpack_require__(487);
	exports.PassThrough = __webpack_require__(488);


/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Readable;
	
	/*<replacement>*/
	var isArray = __webpack_require__(481);
	/*</replacement>*/
	
	
	/*<replacement>*/
	var Buffer = __webpack_require__(176).Buffer;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	var EE = __webpack_require__(405).EventEmitter;
	
	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	var Stream = __webpack_require__(450);
	
	/*<replacement>*/
	var util = __webpack_require__(482);
	util.inherits = __webpack_require__(483);
	/*</replacement>*/
	
	var StringDecoder;
	
	util.inherits(Readable, Stream);
	
	function ReadableState(options, stream) {
	  options = options || {};
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = false;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // In streams that never have any data, and do push(null) right away,
	  // the consumer can miss the 'end' event if they do some I/O before
	  // consuming the stream.  So, we don't emit('end') until some reading
	  // happens.
	  this.calledRead = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(484).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  if (!(this instanceof Readable))
	    return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;
	
	  if (typeof chunk === 'string' && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null || chunk === undefined) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);
	
	      // update the buffer info.
	      state.length += state.objectMode ? 1 : chunk.length;
	      if (addToFront) {
	        state.buffer.unshift(chunk);
	      } else {
	        state.reading = false;
	        state.buffer.push(chunk);
	      }
	
	      if (state.needReadable)
	        emitReadable(stream);
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(484).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	};
	
	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}
	
	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;
	
	  if (state.objectMode)
	    return n === 0 ? 0 : 1;
	
	  if (n === null || isNaN(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }
	
	  if (n <= 0)
	    return 0;
	
	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);
	
	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }
	
	  return n;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  var state = this._readableState;
	  state.calledRead = true;
	  var nOrig = n;
	  var ret;
	
	  if (typeof n !== 'number' || n > 0)
	    state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    ret = null;
	
	    // In cases where the decoder did not receive enough data
	    // to produce a full chunk, then immediately received an
	    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
	    // howMuchToRead will see this and coerce the amount to
	    // read to zero (because it's looking at the length of the
	    // first <Buffer > in state.buffer), and we'll end up here.
	    //
	    // This can only happen via state.decoder -- no other venue
	    // exists for pushing a zero-length chunk into state.buffer
	    // and triggering this behavior. In this case, we return our
	    // remaining data and end the stream, if appropriate.
	    if (state.length > 0 && state.decoder) {
	      ret = fromList(n, state);
	      state.length -= ret.length;
	    }
	
	    if (state.length === 0)
	      endReadable(this);
	
	    return ret;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length - n <= state.highWaterMark)
	    doRead = true;
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading)
	    doRead = false;
	
	  if (doRead) {
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }
	
	  // If _read called its callback synchronously, then `reading`
	  // will be false, and we need to re-evaluate how much data we
	  // can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);
	
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;
	
	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  }
	
	  state.length -= n;
	
	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;
	
	  // If we happened to read() exactly the remaining amount in the
	  // buffer, and the EOF has been seen at this point, then make sure
	  // that we emit 'end' on the very next tick.
	  if (state.ended && !state.endEmitted && state.length === 0)
	    endReadable(this);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	
	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // if we've ended and we have some data left, then emit
	  // 'readable' now to make sure it gets picked up.
	  if (state.length > 0)
	    emitReadable(stream);
	  else
	    endReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (state.emittedReadable)
	    return;
	
	  state.emittedReadable = true;
	  if (state.sync)
	    process.nextTick(function() {
	      emitReadable_(stream);
	    });
	  else
	    emitReadable_(stream);
	}
	
	function emitReadable_(stream) {
	  stream.emit('readable');
	}
	
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};
	
	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    if (readable !== src) return;
	    cleanup();
	  }
	
	  function onend() {
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  function cleanup() {
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (!dest._writableState || dest._writableState.needDrain)
	      ondrain();
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];
	
	
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    // the handler that waits for readable events after all
	    // the data gets sucked out in flow.
	    // This would be easier to follow with a .once() handler
	    // in flow(), but that is too slow.
	    this.on('readable', pipeOnReadable);
	
	    state.flowing = true;
	    process.nextTick(function() {
	      flow(src);
	    });
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function() {
	    var dest = this;
	    var state = src._readableState;
	    state.awaitDrain--;
	    if (state.awaitDrain === 0)
	      flow(src);
	  };
	}
	
	function flow(src) {
	  var state = src._readableState;
	  var chunk;
	  state.awaitDrain = 0;
	
	  function write(dest, i, list) {
	    var written = dest.write(chunk);
	    if (false === written) {
	      state.awaitDrain++;
	    }
	  }
	
	  while (state.pipesCount && null !== (chunk = src.read())) {
	
	    if (state.pipesCount === 1)
	      write(state.pipes, 0, null);
	    else
	      forEach(state.pipes, write);
	
	    src.emit('data', chunk);
	
	    // if anyone needs a drain, then we have to wait for that.
	    if (state.awaitDrain > 0)
	      return;
	  }
	
	  // if every destination was unpiped, either before entering this
	  // function, or in the while loop, then stop flowing.
	  //
	  // NB: This is a pretty rare edge case.
	  if (state.pipesCount === 0) {
	    state.flowing = false;
	
	    // if there were data event listeners added, then switch to old mode.
	    if (EE.listenerCount(src, 'data') > 0)
	      emitDataEvents(src);
	    return;
	  }
	
	  // at this point, no one needed a drain, so we just ran out of data
	  // on the next readable event, start it over again.
	  state.ranOut = true;
	}
	
	function pipeOnReadable() {
	  if (this._readableState.ranOut) {
	    this._readableState.ranOut = false;
	    flow(this);
	  }
	}
	
	
	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;
	
	    if (!dest)
	      dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }
	
	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;
	
	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  if (ev === 'data' && !this._readableState.flowing)
	    emitDataEvents(this);
	
	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        this.read(0);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  emitDataEvents(this);
	  this.read(0);
	  this.emit('resume');
	};
	
	Readable.prototype.pause = function() {
	  emitDataEvents(this, true);
	  this.emit('pause');
	};
	
	function emitDataEvents(stream, startPaused) {
	  var state = stream._readableState;
	
	  if (state.flowing) {
	    // https://github.com/isaacs/readable-stream/issues/16
	    throw new Error('Cannot switch to old mode now.');
	  }
	
	  var paused = startPaused || false;
	  var readable = false;
	
	  // convert to an old-style stream.
	  stream.readable = true;
	  stream.pipe = Stream.prototype.pipe;
	  stream.on = stream.addListener = Stream.prototype.on;
	
	  stream.on('readable', function() {
	    readable = true;
	
	    var c;
	    while (!paused && (null !== (c = stream.read())))
	      stream.emit('data', c);
	
	    if (c === null) {
	      readable = false;
	      stream._readableState.needReadable = true;
	    }
	  });
	
	  stream.pause = function() {
	    paused = true;
	    this.emit('pause');
	  };
	
	  stream.resume = function() {
	    paused = false;
	    if (readable)
	      process.nextTick(function() {
	        stream.emit('readable');
	      });
	    else
	      this.read(0);
	    this.emit('resume');
	  };
	
	  // now make it start, just in case it hadn't already.
	  stream.emit('readable');
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function() {
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function(chunk) {
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	
	    // don't skip over falsy values in objectMode
	    //if (state.objectMode && util.isNullOrUndefined(chunk))
	    if (state.objectMode && (chunk === null || chunk === undefined))
	      return;
	    else if (!state.objectMode && (!chunk || !chunk.length))
	      return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (typeof stream[i] === 'function' &&
	        typeof this[i] === 'undefined') {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;
	
	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;
	
	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);
	
	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);
	
	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);
	
	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();
	
	        c += cpy;
	      }
	    }
	  }
	
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');
	
	  if (!state.endEmitted && state.calledRead) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 481 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	function isBuffer(arg) {
	  return Buffer.isBuffer(arg);
	}
	exports.isBuffer = isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176).Buffer))

/***/ },
/* 483 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(176).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.
	
	module.exports = Writable;
	
	/*<replacement>*/
	var Buffer = __webpack_require__(176).Buffer;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	
	/*<replacement>*/
	var util = __webpack_require__(482);
	util.inherits = __webpack_require__(483);
	/*</replacement>*/
	
	var Stream = __webpack_require__(450);
	
	util.inherits(Writable, Stream);
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}
	
	function WritableState(options, stream) {
	  options = options || {};
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.buffer = [];
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}
	
	function Writable(options) {
	  var Duplex = __webpack_require__(486);
	
	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};
	
	
	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;
	
	  if (typeof cb !== 'function')
	    cb = function() {};
	
	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb))
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	
	  return ret;
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      typeof chunk === 'string') {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;
	
	  if (state.writing)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, len, chunk, encoding, cb);
	
	  return ret;
	}
	
	function doWrite(stream, state, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      cb(er);
	    });
	  else
	    cb(er);
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);
	
	    if (!finished && !state.bufferProcessing && state.buffer.length)
	      clearBuffer(stream, state);
	
	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  cb();
	  if (finished)
	    finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	
	  for (var c = 0; c < state.buffer.length; c++) {
	    var entry = state.buffer[c];
	    var chunk = entry.chunk;
	    var encoding = entry.encoding;
	    var cb = entry.callback;
	    var len = state.objectMode ? 1 : chunk.length;
	
	    doWrite(stream, state, len, chunk, encoding, cb);
	
	    // if we didn't call the onwrite immediately, then
	    // it means that we need to wait until it does.
	    // also, that means that the chunk and cb are currently
	    // being processed, so move the buffer counter past them.
	    if (state.writing) {
	      c++;
	      break;
	    }
	  }
	
	  state.bufferProcessing = false;
	  if (c < state.buffer.length)
	    state.buffer = state.buffer.slice(c);
	  else
	    state.buffer.length = 0;
	}
	
	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};
	
	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (typeof chunk !== 'undefined' && chunk !== null)
	    this.write(chunk, encoding);
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};
	
	
	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    state.finished = true;
	    stream.emit('finish');
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/
	
	
	/*<replacement>*/
	var util = __webpack_require__(482);
	util.inherits = __webpack_require__(483);
	/*</replacement>*/
	
	var Readable = __webpack_require__(480);
	var Writable = __webpack_require__(485);
	
	util.inherits(Duplex, Readable);
	
	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});
	
	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false)
	    this.readable = false;
	
	  if (options && options.writable === false)
	    this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(486);
	
	/*<replacement>*/
	var util = __webpack_require__(482);
	util.inherits = __webpack_require__(483);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	
	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (data !== null && data !== undefined)
	    stream.push(data);
	
	  if (cb)
	    cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	
	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);
	
	  Duplex.call(this, options);
	
	  var ts = this._transformState = new TransformState(options, this);
	
	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  this.once('finish', function() {
	    if ('function' === typeof this._flush)
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}
	
	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};
	
	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;
	
	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	
	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var rs = stream._readableState;
	  var ts = stream._transformState;
	
	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');
	
	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');
	
	  return stream.push(null);
	}


/***/ },
/* 488 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(487);
	
	/*<replacement>*/
	var util = __webpack_require__(482);
	util.inherits = __webpack_require__(483);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 489 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path = __webpack_require__(180);
	var binaryExtensions = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"binary-extensions\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var exts = Object.create(null);
	
	binaryExtensions.forEach(function (el) {
		exts[el] = true;
	});
	
	module.exports = function (filepath) {
		return path.extname(filepath).slice(1).toLowerCase() in exts;
	};


/***/ },
/* 490 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var sysPath = __webpack_require__(180);
	var readdirp = __webpack_require__(445);
	var fsevents;
	try { fsevents = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fsevents\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())); } catch (error) {}
	
	// fsevents instance helper functions
	
	// object to hold per-process fsevents instances
	// (may be shared across chokidar FSWatcher instances)
	var FSEventsWatchers = Object.create(null);
	
	// Private function: Instantiates the fsevents interface
	
	// * path       - string, path to be watched
	// * callback   - function, called when fsevents is bound and ready
	
	// Returns new fsevents instance
	function createFSEventsInstance(path, callback) {
	  return (new fsevents(path)).on('fsevent', callback).start();
	}
	
	// Private function: Instantiates the fsevents interface or binds listeners
	// to an existing one covering the same file tree
	
	// * path       - string, path to be watched
	// * realPath   - string, real path (in case of symlinks)
	// * listener   - function, called when fsevents emits events
	// * rawEmitter - function, passes data to listeners of the 'raw' event
	
	// Returns close function
	function setFSEventsListener(path, realPath, listener, rawEmitter) {
	  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;
	  var watchContainer;
	
	  var resolvedPath = sysPath.resolve(path);
	  var hasSymlink = resolvedPath !== realPath;
	  function filteredListener(fullPath, flags, info) {
	    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
	    if (
	      fullPath === resolvedPath ||
	      !fullPath.indexOf(resolvedPath + sysPath.sep)
	    ) listener(fullPath, flags, info);
	  }
	
	  // check if there is already a watcher on a parent path
	  // modifies `watchPath` to the parent path when it finds a match
	  function watchedParent() {
	    return Object.keys(FSEventsWatchers).some(function(watchedPath) {
	      // condition is met when indexOf returns 0
	      if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) {
	        watchPath = watchedPath;
	        return true;
	      }
	    });
	  }
	
	  if (watchPath in FSEventsWatchers || watchedParent()) {
	    watchContainer = FSEventsWatchers[watchPath];
	    watchContainer.listeners.push(filteredListener);
	  } else {
	    watchContainer = FSEventsWatchers[watchPath] = {
	      listeners: [filteredListener],
	      rawEmitters: [rawEmitter],
	      watcher: createFSEventsInstance(watchPath, function(fullPath, flags) {
	        var info = fsevents.getInfo(fullPath, flags);
	        watchContainer.listeners.forEach(function(listener) {
	          listener(fullPath, flags, info);
	        });
	        watchContainer.rawEmitters.forEach(function(emitter) {
	          emitter(info.event, fullPath, info);
	        });
	      })
	    };
	  }
	  var listenerIndex = watchContainer.listeners.length - 1;
	
	  // removes this instance's listeners and closes the underlying fsevents
	  // instance if there are no more listeners left
	  return function close() {
	    delete watchContainer.listeners[listenerIndex];
	    delete watchContainer.rawEmitters[listenerIndex];
	    if (!Object.keys(watchContainer.listeners).length) {
	      watchContainer.watcher.stop();
	      delete FSEventsWatchers[watchPath];
	    }
	  }
	}
	
	// returns boolean indicating whether fsevents can be used
	function canUse() {
	  return fsevents && Object.keys(FSEventsWatchers).length < 128;
	}
	
	// determines subdirectory traversal levels from root to path
	function depth(path, root) {
	  var i = 0;
	  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;
	  return i;
	}
	
	// fake constructor for attaching fsevents-specific prototype methods that
	// will be copied to FSWatcher's prototype
	function FsEventsHandler() {}
	
	// Private method: Handle symlinks encountered during directory scan
	
	// * wathPath   - string, file/dir path to be watched with fsevents
	// * realPath   - string, real path (in case of symlinks)
	// * transform  - function, path transformer
	// * globFilter - function, path filter in case a glob pattern was provided
	
	// Returns close function for the watcher instance
	FsEventsHandler.prototype._watchWithFsEvents =
	function(watchPath, realPath, transform, globFilter) {
	  if (this._isIgnored(watchPath)) return;
	  var watchCallback = function(fullPath, flags, info) {
	    if (
	      this.options.depth !== undefined &&
	      depth(fullPath, realPath) > this.options.depth
	    ) return;
	    var path = transform(sysPath.join(
	      watchPath, sysPath.relative(watchPath, fullPath)
	    ));
	    if (globFilter && !globFilter(path)) return;
	    // ensure directories are tracked
	    var parent = sysPath.dirname(path);
	    var item = sysPath.basename(path);
	    var watchedDir = this._getWatchedDir(
	      info.type === 'directory' ? path : parent
	    );
	    var checkIgnored = function(stats) {
	      if (this._isIgnored(path, stats)) {
	        this._ignoredPaths[path] = true;
	        if (stats && stats.isDirectory()) {
	          this._ignoredPaths[path + '/**/*'] = true;
	        }
	        return true;
	      } else {
	        delete this._ignoredPaths[path];
	        delete this._ignoredPaths[path + '/**/*'];
	      }
	    }.bind(this);
	
	    var handleEvent = function(event) {
	      if (checkIgnored()) return;
	
	      if (event === 'unlink') {
	        // suppress unlink events on never before seen files
	        if (info.type === 'directory' || watchedDir.has(item)) {
	          this._remove(parent, item);
	        }
	      } else {
	        if (event === 'add') {
	          // track new directories
	          if (info.type === 'directory') this._getWatchedDir(path);
	
	          if (info.type === 'symlink' && this.options.followSymlinks) {
	            // push symlinks back to the top of the stack to get handled
	            var curDepth = this.options.depth === undefined ?
	              undefined : depth(fullPath, realPath) + 1;
	            return this._addToFsEvents(path, false, true, curDepth);
	          } else {
	            // track new paths
	            // (other than symlinks being followed, which will be tracked soon)
	            this._getWatchedDir(parent).add(item);
	          }
	        }
	        var eventName = info.type === 'directory' ? event + 'Dir' : event;
	        this._emit(eventName, path);
	      }
	    }.bind(this);
	
	    function addOrChange() {
	      handleEvent(watchedDir.has(item) ? 'change' : 'add');
	    }
	    function checkFd() {
	      fs.open(path, 'r', function(error, fd) {
	        if (fd) fs.close(fd);
	        error && error.code !== 'EACCES' ?
	          handleEvent('unlink') : addOrChange();
	      });
	    }
	    // correct for wrong events emitted
	    var wrongEventFlags = [
	      69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912
	    ];
	    if (wrongEventFlags.indexOf(flags) !== -1 || info.event === 'unknown') {
	      if (typeof this.options.ignored === 'function') {
	        fs.stat(path, function(error, stats) {
	          if (checkIgnored(stats)) return;
	          stats ? addOrChange() : handleEvent('unlink');
	        });
	      } else {
	        checkFd();
	      }
	    } else {
	      switch (info.event) {
	      case 'created':
	      case 'modified':
	        return addOrChange();
	      case 'deleted':
	      case 'moved':
	        return checkFd();
	      }
	    }
	  }.bind(this);
	
	  var closer = setFSEventsListener(
	    watchPath,
	    realPath,
	    watchCallback,
	    this.emit.bind(this, 'raw')
	  );
	
	  this._emitReady();
	  return closer;
	};
	
	// Private method: Handle symlinks encountered during directory scan
	
	// * linkPath   - string, path to symlink
	// * fullPath   - string, absolute path to the symlink
	// * transform  - function, pre-existing path transformer
	// * curDepth   - int, level of subdirectories traversed to where symlink is
	
	// Returns nothing
	FsEventsHandler.prototype._fsEventsSymlink =
	function(linkPath, fullPath, transform, curDepth) {
	  // don't follow the same symlink more than once
	  if (this._symlinkPaths[fullPath]) return;
	  else this._symlinkPaths[fullPath] = true;
	
	  this._readyCount++;
	
	  fs.realpath(linkPath, function(error, linkTarget) {
	    if (this._handleError(error) || this._isIgnored(linkTarget)) {
	      return this._emitReady();
	    }
	
	    this._readyCount++;
	
	    // add the linkTarget for watching with a wrapper for transform
	    // that causes emitted paths to incorporate the link's path
	    this._addToFsEvents(linkTarget || linkPath, function(path) {
	      var dotSlash = '.' + sysPath.sep;
	      var aliasedPath = linkPath;
	      if (linkTarget && linkTarget !== dotSlash) {
	        aliasedPath = path.replace(linkTarget, linkPath);
	      } else if (path !== dotSlash) {
	        aliasedPath = sysPath.join(linkPath, path);
	      }
	      return transform(aliasedPath);
	    }, false, curDepth);
	  }.bind(this));
	};
	
	// Private method: Handle added path with fsevents
	
	// * path       - string, file/directory path or glob pattern
	// * transform  - function, converts working path to what the user expects
	// * forceAdd   - boolean, ensure add is emitted
	// * priorDepth - int, level of subdirectories already traversed
	
	// Returns nothing
	FsEventsHandler.prototype._addToFsEvents =
	function(path, transform, forceAdd, priorDepth) {
	
	  // applies transform if provided, otherwise returns same value
	  var processPath = typeof transform === 'function' ?
	    transform : function(val) { return val; };
	
	  var emitAdd = function(newPath, stats) {
	    var pp = processPath(newPath);
	    var isDir = stats.isDirectory();
	    var dirObj = this._getWatchedDir(sysPath.dirname(pp));
	    var base = sysPath.basename(pp);
	
	    // ensure empty dirs get tracked
	    if (isDir) this._getWatchedDir(pp);
	
	    if (dirObj.has(base)) return;
	    dirObj.add(base);
	
	    if (!this.options.ignoreInitial || forceAdd === true) {
	      this._emit(isDir ? 'addDir' : 'add', pp, stats);
	    }
	  }.bind(this);
	
	  var wh = this._getWatchHelpers(path);
	
	  // evaluate what is at the path we're being asked to watch
	  fs[wh.statMethod](wh.watchPath, function(error, stats) {
	    if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) {
	      this._emitReady();
	      return this._emitReady();
	    }
	
	    if (stats.isDirectory()) {
	      // emit addDir unless this is a glob parent
	      if (!wh.globFilter) emitAdd(processPath(path), stats);
	
	      // don't recurse further if it would exceed depth setting
	      if (priorDepth && priorDepth > this.options.depth) return;
	
	      // scan the contents of the dir
	      readdirp({
	        root: wh.watchPath,
	        entryType: 'all',
	        fileFilter: wh.filterPath,
	        directoryFilter: wh.filterDir,
	        lstat: true,
	        depth: this.options.depth - (priorDepth || 0)
	      }).on('data', function(entry) {
	        // need to check filterPath on dirs b/c filterDir is less restrictive
	        if (entry.stat.isDirectory() && !wh.filterPath(entry)) return;
	
	        var joinedPath = sysPath.join(wh.watchPath, entry.path);
	        var fullPath = entry.fullPath;
	
	        if (wh.followSymlinks && entry.stat.isSymbolicLink()) {
	          // preserve the current depth here since it can't be derived from
	          // real paths past the symlink
	          var curDepth = this.options.depth === undefined ?
	            undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
	
	          this._fsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
	        } else {
	          emitAdd(joinedPath, entry.stat);
	        }
	      }.bind(this)).on('end', this._emitReady);
	    } else {
	      emitAdd(wh.watchPath, stats);
	      this._emitReady();
	    }
	  }.bind(this));
	
	  if (this.options.persistent) {
	    var initWatch = function(error, realPath) {
	      var closer = this._watchWithFsEvents(
	        wh.watchPath,
	        sysPath.resolve(realPath || wh.watchPath),
	        processPath,
	        wh.globFilter
	      );
	      if (closer) this._closers[path] = closer;
	    }.bind(this);
	
	    if (typeof transform === 'function') {
	      // realpath has already been resolved
	      initWatch();
	    } else {
	      fs.realpath(wh.watchPath, initWatch);
	    }
	  }
	};
	
	module.exports = FsEventsHandler;
	module.exports.canUse = canUse;


/***/ },
/* 491 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Monkey-patching the fs module.
	// It's ugly, but there is simply no other way to do this.
	var fs = module.exports = __webpack_require__(492)
	
	var assert = __webpack_require__(467)
	
	// fix up some busted stuff, mostly on windows and old nodes
	__webpack_require__(496)
	
	var util = __webpack_require__(238)
	
	function noop () {}
	
	var debug = noop
	if (util.debuglog)
	  debug = util.debuglog('gfs')
	else if (/\bgfs\b/i.test(process.env.NODE_DEBUG || ''))
	  debug = function() {
	    var m = util.format.apply(util, arguments)
	    m = 'GFS: ' + m.split(/\n/).join('\nGFS: ')
	    console.error(m)
	  }
	
	if (/\bgfs\b/i.test(process.env.NODE_DEBUG || '')) {
	  process.on('exit', function() {
	    debug('fds', fds)
	    debug(queue)
	    assert.equal(queue.length, 0)
	  })
	}
	
	
	var originalOpen = fs.open
	fs.open = open
	
	function open(path, flags, mode, cb) {
	  if (typeof mode === "function") cb = mode, mode = null
	  if (typeof cb !== "function") cb = noop
	  new OpenReq(path, flags, mode, cb)
	}
	
	function OpenReq(path, flags, mode, cb) {
	  this.path = path
	  this.flags = flags
	  this.mode = mode
	  this.cb = cb
	  Req.call(this)
	}
	
	util.inherits(OpenReq, Req)
	
	OpenReq.prototype.process = function() {
	  originalOpen.call(fs, this.path, this.flags, this.mode, this.done)
	}
	
	var fds = {}
	OpenReq.prototype.done = function(er, fd) {
	  debug('open done', er, fd)
	  if (fd)
	    fds['fd' + fd] = this.path
	  Req.prototype.done.call(this, er, fd)
	}
	
	
	var originalReaddir = fs.readdir
	fs.readdir = readdir
	
	function readdir(path, cb) {
	  if (typeof cb !== "function") cb = noop
	  new ReaddirReq(path, cb)
	}
	
	function ReaddirReq(path, cb) {
	  this.path = path
	  this.cb = cb
	  Req.call(this)
	}
	
	util.inherits(ReaddirReq, Req)
	
	ReaddirReq.prototype.process = function() {
	  originalReaddir.call(fs, this.path, this.done)
	}
	
	ReaddirReq.prototype.done = function(er, files) {
	  if (files && files.sort)
	    files = files.sort()
	  Req.prototype.done.call(this, er, files)
	  onclose()
	}
	
	
	var originalClose = fs.close
	fs.close = close
	
	function close (fd, cb) {
	  debug('close', fd)
	  if (typeof cb !== "function") cb = noop
	  delete fds['fd' + fd]
	  originalClose.call(fs, fd, function(er) {
	    onclose()
	    cb(er)
	  })
	}
	
	
	var originalCloseSync = fs.closeSync
	fs.closeSync = closeSync
	
	function closeSync (fd) {
	  try {
	    return originalCloseSync(fd)
	  } finally {
	    onclose()
	  }
	}
	
	
	// Req class
	function Req () {
	  // start processing
	  this.done = this.done.bind(this)
	  this.failures = 0
	  this.process()
	}
	
	Req.prototype.done = function (er, result) {
	  var tryAgain = false
	  if (er) {
	    var code = er.code
	    var tryAgain = code === "EMFILE" || code === "ENFILE"
	    if (process.platform === "win32")
	      tryAgain = tryAgain || code === "OK"
	  }
	
	  if (tryAgain) {
	    this.failures ++
	    enqueue(this)
	  } else {
	    var cb = this.cb
	    cb(er, result)
	  }
	}
	
	var queue = []
	
	function enqueue(req) {
	  queue.push(req)
	  debug('enqueue %d %s', queue.length, req.constructor.name, req)
	}
	
	function onclose() {
	  var req = queue.shift()
	  if (req) {
	    debug('process', req.constructor.name, req)
	    req.process()
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 492 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, module, __filename, __dirname) {// eeeeeevvvvviiiiiiillllll
	// more evil than monkey-patching the native builtin?
	// Not sure.
	
	var mod = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"module\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var pre = '(function (exports, require, module, __filename, __dirname) { '
	var post = '});'
	var src = pre + process.binding('natives').fs + post
	var vm = __webpack_require__(395)
	var fn = vm.runInThisContext(src)
	fn(exports, __webpack_require__(493), module, __filename, __dirname)
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), __webpack_require__(469)(module), "/index.js", "/"))

/***/ },
/* 493 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./fs": 492,
		"./fs.js": 492,
		"./graceful-fs": 491,
		"./graceful-fs.js": 491,
		"./polyfills": 496,
		"./polyfills.js": 496,
		"./test/max-open": 497,
		"./test/max-open.js": 497,
		"./test/open": 498,
		"./test/open.js": 498,
		"./test/readdir-sort": 499,
		"./test/readdir-sort.js": 499,
		"./test/write-then-read": 500,
		"./test/write-then-read.js": 500
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 493;


/***/ },
/* 494 */,
/* 495 */,
/* 496 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var fs = __webpack_require__(492)
	var constants = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"constants\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	
	var origCwd = process.cwd
	var cwd = null
	process.cwd = function() {
	  if (!cwd)
	    cwd = origCwd.call(process)
	  return cwd
	}
	var chdir = process.chdir
	process.chdir = function(d) {
	  cwd = null
	  chdir.call(process, d)
	}
	
	// (re-)implement some things that are known busted or missing.
	
	// lchmod, broken prior to 0.6.2
	// back-port the fix here.
	if (constants.hasOwnProperty('O_SYMLINK') &&
	    process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
	  fs.lchmod = function (path, mode, callback) {
	    callback = callback || noop
	    fs.open( path
	           , constants.O_WRONLY | constants.O_SYMLINK
	           , mode
	           , function (err, fd) {
	      if (err) {
	        callback(err)
	        return
	      }
	      // prefer to return the chmod error, if one occurs,
	      // but still try to close, and report closing errors if they occur.
	      fs.fchmod(fd, mode, function (err) {
	        fs.close(fd, function(err2) {
	          callback(err || err2)
	        })
	      })
	    })
	  }
	
	  fs.lchmodSync = function (path, mode) {
	    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)
	
	    // prefer to return the chmod error, if one occurs,
	    // but still try to close, and report closing errors if they occur.
	    var err, err2
	    try {
	      var ret = fs.fchmodSync(fd, mode)
	    } catch (er) {
	      err = er
	    }
	    try {
	      fs.closeSync(fd)
	    } catch (er) {
	      err2 = er
	    }
	    if (err || err2) throw (err || err2)
	    return ret
	  }
	}
	
	
	// lutimes implementation, or no-op
	if (!fs.lutimes) {
	  if (constants.hasOwnProperty("O_SYMLINK")) {
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.open(path, constants.O_SYMLINK, function (er, fd) {
	        cb = cb || noop
	        if (er) return cb(er)
	        fs.futimes(fd, at, mt, function (er) {
	          fs.close(fd, function (er2) {
	            return cb(er || er2)
	          })
	        })
	      })
	    }
	
	    fs.lutimesSync = function (path, at, mt) {
	      var fd = fs.openSync(path, constants.O_SYMLINK)
	        , err
	        , err2
	        , ret
	
	      try {
	        var ret = fs.futimesSync(fd, at, mt)
	      } catch (er) {
	        err = er
	      }
	      try {
	        fs.closeSync(fd)
	      } catch (er) {
	        err2 = er
	      }
	      if (err || err2) throw (err || err2)
	      return ret
	    }
	
	  } else if (fs.utimensat && constants.hasOwnProperty("AT_SYMLINK_NOFOLLOW")) {
	    // maybe utimensat will be bound soonish?
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.utimensat(path, at, mt, constants.AT_SYMLINK_NOFOLLOW, cb)
	    }
	
	    fs.lutimesSync = function (path, at, mt) {
	      return fs.utimensatSync(path, at, mt, constants.AT_SYMLINK_NOFOLLOW)
	    }
	
	  } else {
	    fs.lutimes = function (_a, _b, _c, cb) { process.nextTick(cb) }
	    fs.lutimesSync = function () {}
	  }
	}
	
	
	// https://github.com/isaacs/node-graceful-fs/issues/4
	// Chown should not fail on einval or eperm if non-root.
	// It should not fail on enosys ever, as this just indicates
	// that a fs doesn't support the intended operation.
	
	fs.chown = chownFix(fs.chown)
	fs.fchown = chownFix(fs.fchown)
	fs.lchown = chownFix(fs.lchown)
	
	fs.chmod = chownFix(fs.chmod)
	fs.fchmod = chownFix(fs.fchmod)
	fs.lchmod = chownFix(fs.lchmod)
	
	fs.chownSync = chownFixSync(fs.chownSync)
	fs.fchownSync = chownFixSync(fs.fchownSync)
	fs.lchownSync = chownFixSync(fs.lchownSync)
	
	fs.chmodSync = chownFix(fs.chmodSync)
	fs.fchmodSync = chownFix(fs.fchmodSync)
	fs.lchmodSync = chownFix(fs.lchmodSync)
	
	function chownFix (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid, cb) {
	    return orig.call(fs, target, uid, gid, function (er, res) {
	      if (chownErOk(er)) er = null
	      cb(er, res)
	    })
	  }
	}
	
	function chownFixSync (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid) {
	    try {
	      return orig.call(fs, target, uid, gid)
	    } catch (er) {
	      if (!chownErOk(er)) throw er
	    }
	  }
	}
	
	// ENOSYS means that the fs doesn't support the op. Just ignore
	// that, because it doesn't matter.
	//
	// if there's no getuid, or if getuid() is something other
	// than 0, and the error is EINVAL or EPERM, then just ignore
	// it.
	//
	// This specific case is a silent failure in cp, install, tar,
	// and most other unix tools that manage permissions.
	//
	// When running as root, or if other types of errors are
	// encountered, then it's strict.
	function chownErOk (er) {
	  if (!er)
	    return true
	
	  if (er.code === "ENOSYS")
	    return true
	
	  var nonroot = !process.getuid || process.getuid() !== 0
	  if (nonroot) {
	    if (er.code === "EINVAL" || er.code === "EPERM")
	      return true
	  }
	
	  return false
	}
	
	
	// if lchmod/lchown do not exist, then make them no-ops
	if (!fs.lchmod) {
	  fs.lchmod = function (path, mode, cb) {
	    process.nextTick(cb)
	  }
	  fs.lchmodSync = function () {}
	}
	if (!fs.lchown) {
	  fs.lchown = function (path, uid, gid, cb) {
	    process.nextTick(cb)
	  }
	  fs.lchownSync = function () {}
	}
	
	
	
	// on Windows, A/V software can lock the directory, causing this
	// to fail with an EACCES or EPERM if the directory contains newly
	// created files.  Try again on failure, for up to 1 second.
	if (process.platform === "win32") {
	  var rename_ = fs.rename
	  fs.rename = function rename (from, to, cb) {
	    var start = Date.now()
	    rename_(from, to, function CB (er) {
	      if (er
	          && (er.code === "EACCES" || er.code === "EPERM")
	          && Date.now() - start < 1000) {
	        return rename_(from, to, CB)
	      }
	      if(cb) cb(er)
	    })
	  }
	}
	
	
	// if read() returns EAGAIN, then just try it again.
	var read = fs.read
	fs.read = function (fd, buffer, offset, length, position, callback_) {
	  var callback
	  if (callback_ && typeof callback_ === 'function') {
	    var eagCounter = 0
	    callback = function (er, _, __) {
	      if (er && er.code === 'EAGAIN' && eagCounter < 10) {
	        eagCounter ++
	        return read.call(fs, fd, buffer, offset, length, position, callback)
	      }
	      callback_.apply(this, arguments)
	    }
	  }
	  return read.call(fs, fd, buffer, offset, length, position, callback)
	}
	
	var readSync = fs.readSync
	fs.readSync = function (fd, buffer, offset, length, position) {
	  var eagCounter = 0
	  while (true) {
	    try {
	      return readSync.call(fs, fd, buffer, offset, length, position)
	    } catch (er) {
	      if (er.code === 'EAGAIN' && eagCounter < 10) {
	        eagCounter ++
	        continue
	      }
	      throw er
	    }
	  }
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 497 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, __filename) {var test = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).test
	var fs = __webpack_require__(491)
	
	test('open lots of stuff', function (t) {
	  // Get around EBADF from libuv by making sure that stderr is opened
	  // Otherwise Darwin will refuse to give us a FD for stderr!
	  process.stderr.write('')
	
	  // How many parallel open()'s to do
	  var n = 1024
	  var opens = 0
	  var fds = []
	  var going = true
	  var closing = false
	  var doneCalled = 0
	
	  for (var i = 0; i < n; i++) {
	    go()
	  }
	
	  function go() {
	    opens++
	    fs.open(__filename, 'r', function (er, fd) {
	      if (er) throw er
	      fds.push(fd)
	      if (going) go()
	    })
	  }
	
	  // should hit ulimit pretty fast
	  setTimeout(function () {
	    going = false
	    t.equal(opens - fds.length, n)
	    done()
	  }, 100)
	
	
	  function done () {
	    if (closing) return
	    doneCalled++
	
	    if (fds.length === 0) {
	      console.error('done called %d times', doneCalled)
	      // First because of the timeout
	      // Then to close the fd's opened afterwards
	      // Then this time, to complete.
	      // Might take multiple passes, depending on CPU speed
	      // and ulimit, but at least 3 in every case.
	      t.ok(doneCalled >= 2)
	      return t.end()
	    }
	
	    closing = true
	    setTimeout(function () {
	      // console.error('do closing again')
	      closing = false
	      done()
	    }, 100)
	
	    // console.error('closing time')
	    var closes = fds.slice(0)
	    fds.length = 0
	    closes.forEach(function (fd) {
	      fs.close(fd, function (er) {
	        if (er) throw er
	      })
	    })
	  }
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), "/index.js"))

/***/ },
/* 498 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__filename) {var test = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).test
	var fs = __webpack_require__(491)
	
	test('graceful fs is monkeypatched fs', function (t) {
	  t.equal(fs, __webpack_require__(492))
	  t.end()
	})
	
	test('open an existing file works', function (t) {
	  var fd = fs.openSync(__filename, 'r')
	  fs.closeSync(fd)
	  fs.open(__filename, 'r', function (er, fd) {
	    if (er) throw er
	    fs.close(fd, function (er) {
	      if (er) throw er
	      t.pass('works')
	      t.end()
	    })
	  })
	})
	
	test('open a non-existing file throws', function (t) {
	  var er
	  try {
	    var fd = fs.openSync('this file does not exist', 'r')
	  } catch (x) {
	    er = x
	  }
	  t.ok(er, 'should throw')
	  t.notOk(fd, 'should not get an fd')
	  t.equal(er.code, 'ENOENT')
	
	  fs.open('neither does this file', 'r', function (er, fd) {
	    t.ok(er, 'should throw')
	    t.notOk(fd, 'should not get an fd')
	    t.equal(er.code, 'ENOENT')
	    t.end()
	  })
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/index.js"))

/***/ },
/* 499 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var test = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).test
	var fs = __webpack_require__(492)
	
	var readdir = fs.readdir
	fs.readdir = function(path, cb) {
	  process.nextTick(function() {
	    cb(null, ["b", "z", "a"])
	  })
	}
	
	var g = __webpack_require__(491)
	
	test("readdir reorder", function (t) {
	  g.readdir("whatevers", function (er, files) {
	    if (er)
	      throw er
	    t.same(files, [ "a", "b", "z" ])
	    t.end()
	  })
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 500 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname, process) {var fs = __webpack_require__(491);
	var rimraf = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"rimraf\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var mkdirp = __webpack_require__(501);
	var test = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).test;
	var p = __webpack_require__(180).resolve(__dirname, 'files');
	
	process.chdir(__dirname)
	
	// Make sure to reserve the stderr fd
	process.stderr.write('');
	
	var num = 4097;
	var paths = new Array(num);
	
	test('make files', function (t) {
	  rimraf.sync(p);
	  mkdirp.sync(p);
	
	  for (var i = 0; i < num; ++i) {
	    paths[i] = 'files/file-' + i;
	    fs.writeFileSync(paths[i], 'content');
	  }
	
	  t.end();
	})
	
	test('read files', function (t) {
	  // now read them
	  var done = 0;
	  for (var i = 0; i < num; ++i) {
	    fs.readFile(paths[i], function(err, data) {
	      if (err)
	        throw err;
	
	      ++done;
	      if (done === num) {
	        t.pass('success');
	        t.end()
	      }
	    });
	  }
	});
	
	test('cleanup', function (t) {
	  rimraf.sync(p);
	  t.end();
	});
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/", __webpack_require__(5)))

/***/ },
/* 501 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var path = __webpack_require__(180);
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var _0777 = parseInt('0777', 8);
	
	module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
	
	function mkdirP (p, opts, f, made) {
	    if (typeof opts === 'function') {
	        f = opts;
	        opts = {};
	    }
	    else if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = _0777 & (~process.umask());
	    }
	    if (!made) made = null;
	    
	    var cb = f || function () {};
	    p = path.resolve(p);
	    
	    xfs.mkdir(p, mode, function (er) {
	        if (!er) {
	            made = made || p;
	            return cb(null, made);
	        }
	        switch (er.code) {
	            case 'ENOENT':
	                mkdirP(path.dirname(p), opts, function (er, made) {
	                    if (er) cb(er, made);
	                    else mkdirP(p, opts, cb, made);
	                });
	                break;
	
	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                xfs.stat(p, function (er2, stat) {
	                    // if the stat fails, then that's super weird.
	                    // let the original error be the failure reason.
	                    if (er2 || !stat.isDirectory()) cb(er, made)
	                    else cb(null, made);
	                });
	                break;
	        }
	    });
	}
	
	mkdirP.sync = function sync (p, opts, made) {
	    if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = _0777 & (~process.umask());
	    }
	    if (!made) made = null;
	
	    p = path.resolve(p);
	
	    try {
	        xfs.mkdirSync(p, mode);
	        made = made || p;
	    }
	    catch (err0) {
	        switch (err0.code) {
	            case 'ENOENT' :
	                made = sync(path.dirname(p), opts, made);
	                sync(p, opts, made);
	                break;
	
	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                var stat;
	                try {
	                    stat = xfs.statSync(p);
	                }
	                catch (err1) {
	                    throw err0;
	                }
	                if (!stat.isDirectory()) throw err0;
	                break;
	        }
	    }
	
	    return made;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var path = __webpack_require__(180);
	var mkdirp = __webpack_require__(501);
	
	function NodeOutputFileSystem() {}
	module.exports = NodeOutputFileSystem;
	
	NodeOutputFileSystem.prototype.mkdirp = mkdirp;
	NodeOutputFileSystem.prototype.mkdir = fs.mkdir.bind(this);
	NodeOutputFileSystem.prototype.rmdir = fs.rmdir.bind(this);
	NodeOutputFileSystem.prototype.unlink = fs.unlink.bind(this);
	NodeOutputFileSystem.prototype.writeFile = fs.writeFile.bind(fs);
	NodeOutputFileSystem.prototype.join = path.join.bind(path);


/***/ },
/* 503 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var fs = __webpack_require__(504);
	
	function NodeJsInputFileSystem() {}
	module.exports = NodeJsInputFileSystem;
	
	NodeJsInputFileSystem.prototype.isSync = function() {
		return false;
	};
	
	NodeJsInputFileSystem.prototype.stat = fs.stat.bind(fs);
	NodeJsInputFileSystem.prototype.readdir = function readdir(path, callback) {
		fs.readdir(path, function (err, files) {
			callback(err, files && files.map(function (file) {
				return file.normalize ? file.normalize("NFC") : file;
			}));
		});
	};
	NodeJsInputFileSystem.prototype.readFile = fs.readFile.bind(fs);
	NodeJsInputFileSystem.prototype.readlink = fs.readlink.bind(fs);

/***/ },
/* 504 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Monkey-patching the fs module.
	// It's ugly, but there is simply no other way to do this.
	var fs = module.exports = __webpack_require__(505)
	
	var assert = __webpack_require__(467)
	
	// fix up some busted stuff, mostly on windows and old nodes
	__webpack_require__(509)
	
	var util = __webpack_require__(238)
	
	function noop () {}
	
	var debug = noop
	if (util.debuglog)
	  debug = util.debuglog('gfs')
	else if (/\bgfs\b/i.test(process.env.NODE_DEBUG || ''))
	  debug = function() {
	    var m = util.format.apply(util, arguments)
	    m = 'GFS: ' + m.split(/\n/).join('\nGFS: ')
	    console.error(m)
	  }
	
	if (/\bgfs\b/i.test(process.env.NODE_DEBUG || '')) {
	  process.on('exit', function() {
	    debug('fds', fds)
	    debug(queue)
	    assert.equal(queue.length, 0)
	  })
	}
	
	
	var originalOpen = fs.open
	fs.open = open
	
	function open(path, flags, mode, cb) {
	  if (typeof mode === "function") cb = mode, mode = null
	  if (typeof cb !== "function") cb = noop
	  new OpenReq(path, flags, mode, cb)
	}
	
	function OpenReq(path, flags, mode, cb) {
	  this.path = path
	  this.flags = flags
	  this.mode = mode
	  this.cb = cb
	  Req.call(this)
	}
	
	util.inherits(OpenReq, Req)
	
	OpenReq.prototype.process = function() {
	  originalOpen.call(fs, this.path, this.flags, this.mode, this.done)
	}
	
	var fds = {}
	OpenReq.prototype.done = function(er, fd) {
	  debug('open done', er, fd)
	  if (fd)
	    fds['fd' + fd] = this.path
	  Req.prototype.done.call(this, er, fd)
	}
	
	
	var originalReaddir = fs.readdir
	fs.readdir = readdir
	
	function readdir(path, cb) {
	  if (typeof cb !== "function") cb = noop
	  new ReaddirReq(path, cb)
	}
	
	function ReaddirReq(path, cb) {
	  this.path = path
	  this.cb = cb
	  Req.call(this)
	}
	
	util.inherits(ReaddirReq, Req)
	
	ReaddirReq.prototype.process = function() {
	  originalReaddir.call(fs, this.path, this.done)
	}
	
	ReaddirReq.prototype.done = function(er, files) {
	  if (files && files.sort)
	    files = files.sort()
	  Req.prototype.done.call(this, er, files)
	  onclose()
	}
	
	
	var originalClose = fs.close
	fs.close = close
	
	function close (fd, cb) {
	  debug('close', fd)
	  if (typeof cb !== "function") cb = noop
	  delete fds['fd' + fd]
	  originalClose.call(fs, fd, function(er) {
	    onclose()
	    cb(er)
	  })
	}
	
	
	var originalCloseSync = fs.closeSync
	fs.closeSync = closeSync
	
	function closeSync (fd) {
	  try {
	    return originalCloseSync(fd)
	  } finally {
	    onclose()
	  }
	}
	
	
	// Req class
	function Req () {
	  // start processing
	  this.done = this.done.bind(this)
	  this.failures = 0
	  this.process()
	}
	
	Req.prototype.done = function (er, result) {
	  var tryAgain = false
	  if (er) {
	    var code = er.code
	    var tryAgain = code === "EMFILE" || code === "ENFILE"
	    if (process.platform === "win32")
	      tryAgain = tryAgain || code === "OK"
	  }
	
	  if (tryAgain) {
	    this.failures ++
	    enqueue(this)
	  } else {
	    var cb = this.cb
	    cb(er, result)
	  }
	}
	
	var queue = []
	
	function enqueue(req) {
	  queue.push(req)
	  debug('enqueue %d %s', queue.length, req.constructor.name, req)
	}
	
	function onclose() {
	  var req = queue.shift()
	  if (req) {
	    debug('process', req.constructor.name, req)
	    req.process()
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, module, __filename, __dirname) {// eeeeeevvvvviiiiiiillllll
	// more evil than monkey-patching the native builtin?
	// Not sure.
	
	var mod = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"module\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var pre = '(function (exports, require, module, __filename, __dirname) { '
	var post = '});'
	var src = pre + process.binding('natives').fs + post
	var vm = __webpack_require__(395)
	var fn = vm.runInThisContext(src)
	fn(exports, __webpack_require__(506), module, __filename, __dirname)
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), __webpack_require__(469)(module), "/index.js", "/"))

/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./fs": 505,
		"./fs.js": 505,
		"./graceful-fs": 504,
		"./graceful-fs.js": 504,
		"./polyfills": 509,
		"./polyfills.js": 509,
		"./test/max-open": 510,
		"./test/max-open.js": 510,
		"./test/open": 511,
		"./test/open.js": 511,
		"./test/readdir-sort": 512,
		"./test/readdir-sort.js": 512,
		"./test/write-then-read": 513,
		"./test/write-then-read.js": 513
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 506;


/***/ },
/* 507 */,
/* 508 */,
/* 509 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var fs = __webpack_require__(505)
	var constants = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"constants\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	
	var origCwd = process.cwd
	var cwd = null
	process.cwd = function() {
	  if (!cwd)
	    cwd = origCwd.call(process)
	  return cwd
	}
	var chdir = process.chdir
	process.chdir = function(d) {
	  cwd = null
	  chdir.call(process, d)
	}
	
	// (re-)implement some things that are known busted or missing.
	
	// lchmod, broken prior to 0.6.2
	// back-port the fix here.
	if (constants.hasOwnProperty('O_SYMLINK') &&
	    process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
	  fs.lchmod = function (path, mode, callback) {
	    callback = callback || noop
	    fs.open( path
	           , constants.O_WRONLY | constants.O_SYMLINK
	           , mode
	           , function (err, fd) {
	      if (err) {
	        callback(err)
	        return
	      }
	      // prefer to return the chmod error, if one occurs,
	      // but still try to close, and report closing errors if they occur.
	      fs.fchmod(fd, mode, function (err) {
	        fs.close(fd, function(err2) {
	          callback(err || err2)
	        })
	      })
	    })
	  }
	
	  fs.lchmodSync = function (path, mode) {
	    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)
	
	    // prefer to return the chmod error, if one occurs,
	    // but still try to close, and report closing errors if they occur.
	    var err, err2
	    try {
	      var ret = fs.fchmodSync(fd, mode)
	    } catch (er) {
	      err = er
	    }
	    try {
	      fs.closeSync(fd)
	    } catch (er) {
	      err2 = er
	    }
	    if (err || err2) throw (err || err2)
	    return ret
	  }
	}
	
	
	// lutimes implementation, or no-op
	if (!fs.lutimes) {
	  if (constants.hasOwnProperty("O_SYMLINK")) {
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.open(path, constants.O_SYMLINK, function (er, fd) {
	        cb = cb || noop
	        if (er) return cb(er)
	        fs.futimes(fd, at, mt, function (er) {
	          fs.close(fd, function (er2) {
	            return cb(er || er2)
	          })
	        })
	      })
	    }
	
	    fs.lutimesSync = function (path, at, mt) {
	      var fd = fs.openSync(path, constants.O_SYMLINK)
	        , err
	        , err2
	        , ret
	
	      try {
	        var ret = fs.futimesSync(fd, at, mt)
	      } catch (er) {
	        err = er
	      }
	      try {
	        fs.closeSync(fd)
	      } catch (er) {
	        err2 = er
	      }
	      if (err || err2) throw (err || err2)
	      return ret
	    }
	
	  } else if (fs.utimensat && constants.hasOwnProperty("AT_SYMLINK_NOFOLLOW")) {
	    // maybe utimensat will be bound soonish?
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.utimensat(path, at, mt, constants.AT_SYMLINK_NOFOLLOW, cb)
	    }
	
	    fs.lutimesSync = function (path, at, mt) {
	      return fs.utimensatSync(path, at, mt, constants.AT_SYMLINK_NOFOLLOW)
	    }
	
	  } else {
	    fs.lutimes = function (_a, _b, _c, cb) { process.nextTick(cb) }
	    fs.lutimesSync = function () {}
	  }
	}
	
	
	// https://github.com/isaacs/node-graceful-fs/issues/4
	// Chown should not fail on einval or eperm if non-root.
	// It should not fail on enosys ever, as this just indicates
	// that a fs doesn't support the intended operation.
	
	fs.chown = chownFix(fs.chown)
	fs.fchown = chownFix(fs.fchown)
	fs.lchown = chownFix(fs.lchown)
	
	fs.chmod = chownFix(fs.chmod)
	fs.fchmod = chownFix(fs.fchmod)
	fs.lchmod = chownFix(fs.lchmod)
	
	fs.chownSync = chownFixSync(fs.chownSync)
	fs.fchownSync = chownFixSync(fs.fchownSync)
	fs.lchownSync = chownFixSync(fs.lchownSync)
	
	fs.chmodSync = chownFix(fs.chmodSync)
	fs.fchmodSync = chownFix(fs.fchmodSync)
	fs.lchmodSync = chownFix(fs.lchmodSync)
	
	function chownFix (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid, cb) {
	    return orig.call(fs, target, uid, gid, function (er, res) {
	      if (chownErOk(er)) er = null
	      cb(er, res)
	    })
	  }
	}
	
	function chownFixSync (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid) {
	    try {
	      return orig.call(fs, target, uid, gid)
	    } catch (er) {
	      if (!chownErOk(er)) throw er
	    }
	  }
	}
	
	// ENOSYS means that the fs doesn't support the op. Just ignore
	// that, because it doesn't matter.
	//
	// if there's no getuid, or if getuid() is something other
	// than 0, and the error is EINVAL or EPERM, then just ignore
	// it.
	//
	// This specific case is a silent failure in cp, install, tar,
	// and most other unix tools that manage permissions.
	//
	// When running as root, or if other types of errors are
	// encountered, then it's strict.
	function chownErOk (er) {
	  if (!er)
	    return true
	
	  if (er.code === "ENOSYS")
	    return true
	
	  var nonroot = !process.getuid || process.getuid() !== 0
	  if (nonroot) {
	    if (er.code === "EINVAL" || er.code === "EPERM")
	      return true
	  }
	
	  return false
	}
	
	
	// if lchmod/lchown do not exist, then make them no-ops
	if (!fs.lchmod) {
	  fs.lchmod = function (path, mode, cb) {
	    process.nextTick(cb)
	  }
	  fs.lchmodSync = function () {}
	}
	if (!fs.lchown) {
	  fs.lchown = function (path, uid, gid, cb) {
	    process.nextTick(cb)
	  }
	  fs.lchownSync = function () {}
	}
	
	
	
	// on Windows, A/V software can lock the directory, causing this
	// to fail with an EACCES or EPERM if the directory contains newly
	// created files.  Try again on failure, for up to 1 second.
	if (process.platform === "win32") {
	  var rename_ = fs.rename
	  fs.rename = function rename (from, to, cb) {
	    var start = Date.now()
	    rename_(from, to, function CB (er) {
	      if (er
	          && (er.code === "EACCES" || er.code === "EPERM")
	          && Date.now() - start < 1000) {
	        return rename_(from, to, CB)
	      }
	      if(cb) cb(er)
	    })
	  }
	}
	
	
	// if read() returns EAGAIN, then just try it again.
	var read = fs.read
	fs.read = function (fd, buffer, offset, length, position, callback_) {
	  var callback
	  if (callback_ && typeof callback_ === 'function') {
	    var eagCounter = 0
	    callback = function (er, _, __) {
	      if (er && er.code === 'EAGAIN' && eagCounter < 10) {
	        eagCounter ++
	        return read.call(fs, fd, buffer, offset, length, position, callback)
	      }
	      callback_.apply(this, arguments)
	    }
	  }
	  return read.call(fs, fd, buffer, offset, length, position, callback)
	}
	
	var readSync = fs.readSync
	fs.readSync = function (fd, buffer, offset, length, position) {
	  var eagCounter = 0
	  while (true) {
	    try {
	      return readSync.call(fs, fd, buffer, offset, length, position)
	    } catch (er) {
	      if (er.code === 'EAGAIN' && eagCounter < 10) {
	        eagCounter ++
	        continue
	      }
	      throw er
	    }
	  }
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 510 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, __filename) {var test = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).test
	var fs = __webpack_require__(504)
	
	test('open lots of stuff', function (t) {
	  // Get around EBADF from libuv by making sure that stderr is opened
	  // Otherwise Darwin will refuse to give us a FD for stderr!
	  process.stderr.write('')
	
	  // How many parallel open()'s to do
	  var n = 1024
	  var opens = 0
	  var fds = []
	  var going = true
	  var closing = false
	  var doneCalled = 0
	
	  for (var i = 0; i < n; i++) {
	    go()
	  }
	
	  function go() {
	    opens++
	    fs.open(__filename, 'r', function (er, fd) {
	      if (er) throw er
	      fds.push(fd)
	      if (going) go()
	    })
	  }
	
	  // should hit ulimit pretty fast
	  setTimeout(function () {
	    going = false
	    t.equal(opens - fds.length, n)
	    done()
	  }, 100)
	
	
	  function done () {
	    if (closing) return
	    doneCalled++
	
	    if (fds.length === 0) {
	      console.error('done called %d times', doneCalled)
	      // First because of the timeout
	      // Then to close the fd's opened afterwards
	      // Then this time, to complete.
	      // Might take multiple passes, depending on CPU speed
	      // and ulimit, but at least 3 in every case.
	      t.ok(doneCalled >= 2)
	      return t.end()
	    }
	
	    closing = true
	    setTimeout(function () {
	      // console.error('do closing again')
	      closing = false
	      done()
	    }, 100)
	
	    // console.error('closing time')
	    var closes = fds.slice(0)
	    fds.length = 0
	    closes.forEach(function (fd) {
	      fs.close(fd, function (er) {
	        if (er) throw er
	      })
	    })
	  }
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), "/index.js"))

/***/ },
/* 511 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__filename) {var test = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).test
	var fs = __webpack_require__(504)
	
	test('graceful fs is monkeypatched fs', function (t) {
	  t.equal(fs, __webpack_require__(505))
	  t.end()
	})
	
	test('open an existing file works', function (t) {
	  var fd = fs.openSync(__filename, 'r')
	  fs.closeSync(fd)
	  fs.open(__filename, 'r', function (er, fd) {
	    if (er) throw er
	    fs.close(fd, function (er) {
	      if (er) throw er
	      t.pass('works')
	      t.end()
	    })
	  })
	})
	
	test('open a non-existing file throws', function (t) {
	  var er
	  try {
	    var fd = fs.openSync('this file does not exist', 'r')
	  } catch (x) {
	    er = x
	  }
	  t.ok(er, 'should throw')
	  t.notOk(fd, 'should not get an fd')
	  t.equal(er.code, 'ENOENT')
	
	  fs.open('neither does this file', 'r', function (er, fd) {
	    t.ok(er, 'should throw')
	    t.notOk(fd, 'should not get an fd')
	    t.equal(er.code, 'ENOENT')
	    t.end()
	  })
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/index.js"))

/***/ },
/* 512 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var test = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).test
	var fs = __webpack_require__(505)
	
	var readdir = fs.readdir
	fs.readdir = function(path, cb) {
	  process.nextTick(function() {
	    cb(null, ["b", "z", "a"])
	  })
	}
	
	var g = __webpack_require__(504)
	
	test("readdir reorder", function (t) {
	  g.readdir("whatevers", function (er, files) {
	    if (er)
	      throw er
	    t.same(files, [ "a", "b", "z" ])
	    t.end()
	  })
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 513 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname, process) {var fs = __webpack_require__(504);
	var rimraf = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"rimraf\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var mkdirp = __webpack_require__(501);
	var test = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).test;
	var p = __webpack_require__(180).resolve(__dirname, 'files');
	
	process.chdir(__dirname)
	
	// Make sure to reserve the stderr fd
	process.stderr.write('');
	
	var num = 4097;
	var paths = new Array(num);
	
	test('make files', function (t) {
	  rimraf.sync(p);
	  mkdirp.sync(p);
	
	  for (var i = 0; i < num; ++i) {
	    paths[i] = 'files/file-' + i;
	    fs.writeFileSync(paths[i], 'content');
	  }
	
	  t.end();
	})
	
	test('read files', function (t) {
	  // now read them
	  var done = 0;
	  for (var i = 0; i < num; ++i) {
	    fs.readFile(paths[i], function(err, data) {
	      if (err)
	        throw err;
	
	      ++done;
	      if (done === num) {
	        t.pass('success');
	        t.end()
	      }
	    });
	  }
	});
	
	test('cleanup', function (t) {
	  rimraf.sync(p);
	  t.end();
	});
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/", __webpack_require__(5)))

/***/ },
/* 514 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function Storage(duration) {
		this.duration = duration;
		this.running = {};
		this.data = {};
		this.levels = [];
		if(duration > 0) {
			this.levels.push([], [], [], [], [], [], [], [], []);
			for(var i = 8000; i < duration; i+=500)
				this.levels.push([]);
		}
		this.count = 0;
		this.interval = null;
		this.needTickCheck = false;
		this.nextTick = null;
		this.passive = true;
	}
	
	Storage.prototype.ensureTick = function() {
		if(!this.interval && this.duration > 0 && !this.nextTick)
			this.interval = setInterval(this.tick.bind(this), Math.floor(this.duration / this.levels.length));
	};
	
	Storage.prototype.finished = function(name) {
		var args = Array.prototype.slice.call(arguments, 1);
		var callbacks = this.running[name];
		delete this.running[name];
		if(this.duration > 0) {
			this.count++;
			this.data[name] = args;
			this.levels[0].push(name);
			this.ensureTick();
		}
		for(var i = 0; i < callbacks.length; i++) {
			callbacks[i].apply(null, args);
		}
	};
	
	Storage.prototype.provide = function(name, provider, callback) {
		var running = this.running[name];
		if(running) {
			running.push(callback);
			return;
		}
		if(this.duration > 0) {
			this.checkTicks();
			var data = this.data[name];
			if(data) {
				return callback.apply(null, data);
			}
		}
		this.running[name] = running = [callback];
		provider(name, this.finished.bind(this, name));
	};
	
	Storage.prototype.tick = function() {
		var decay = this.levels.pop();
		for(var i = decay.length - 1; i >= 0; i--) {
			delete this.data[decay[i]];
		}
		this.count -= decay.length;
		decay.length = 0;
		this.levels.unshift(decay);
		if(this.count == 0) {
			clearInterval(this.interval);
			this.interval = null;
			this.nextTick = null;
			return true;
		} else if(this.nextTick) {
			this.nextTick += Math.floor(this.duration / this.levels.length);
			var time = new Date().getTime();
			if(this.nextTick > time) {
				this.nextTick = null;
				this.interval = setInterval(this.tick.bind(this), Math.floor(this.duration / this.levels.length));
				return true;
			}
		} else if(this.passive) {
			clearInterval(this.interval);
			this.interval = null;
			this.nextTick = new Date().getTime() + Math.floor(this.duration / this.levels.length);
		} else {
			this.passive = true;
		}
	};
	
	Storage.prototype.checkTicks = function() {
		this.passive = false;
		if(this.nextTick) {
			while(!this.tick());
		}
	};
	
	Storage.prototype.purge = function(what) {
		if(!what) {
			this.count = 0;
			clearInterval(this.interval);
			this.nextTick = null;
			this.data = {};
			this.levels.forEach(function(level) {
				level.length = 0;
			});
		} else if(typeof what === "string") {
			Object.keys(this.data).forEach(function(key) {
				if(key.indexOf(what) === 0)
					delete this.data[key];
			}, this);
		} else {
			for(var i = what.length - 1; i >= 0; i--) {
				this.purge(what[i]);
			}
		}
	};
	
	
	function CachedInputFileSystem(fileSystem, duration) {
		this.fileSystem = fileSystem;
		this._statStorage = new Storage(duration);
		this._readdirStorage = new Storage(duration);
		this._readFileStorage = new Storage(duration);
		this._readlinkStorage = new Storage(duration);
	}
	module.exports = CachedInputFileSystem;
	
	CachedInputFileSystem.prototype.isSync = function() {
		return this.fileSystem.isSync();
	};
	
	CachedInputFileSystem.prototype.stat = function(path, callback) {
		this._statStorage.provide(path, this.fileSystem.stat.bind(this.fileSystem), callback);
	};
	
	CachedInputFileSystem.prototype.readdir = function(path, callback) {
		this._readdirStorage.provide(path, this.fileSystem.readdir.bind(this.fileSystem), callback);
	};
	
	CachedInputFileSystem.prototype.readFile = function(path, callback) {
		this._readFileStorage.provide(path, this.fileSystem.readFile.bind(this.fileSystem), callback);
	};
	
	CachedInputFileSystem.prototype.readlink = function(path, callback) {
		this._readlinkStorage.provide(path, this.fileSystem.readlink.bind(this.fileSystem), callback);
	};
	
	CachedInputFileSystem.prototype.purge = function(what) {
		this._statStorage.purge(what);
		this._readdirStorage.purge(what);
		this._readFileStorage.purge(what);
		this._readlinkStorage.purge(what);
	};

/***/ },
/* 515 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(221);
	
	function NodeHotUpdateChunkTemplatePlugin() {}
	module.exports = NodeHotUpdateChunkTemplatePlugin;
	
	NodeHotUpdateChunkTemplatePlugin.prototype.apply = function(hotUpdateChunkTemplate) {
		hotUpdateChunkTemplate.plugin("render", function(modulesSource, modules, hash, id) {
			var source = new ConcatSource();
			source.add("exports.id = " + JSON.stringify(id) + ";\nexports.modules = ");
			source.add(modulesSource);
			source.add(";");
			return source;
		});
		hotUpdateChunkTemplate.plugin("hash", function(hash) {
			hash.update("NodeHotUpdateChunkTemplatePlugin");
			hash.update("3");
			hash.update(this.outputOptions.hotUpdateFunction + "");
			hash.update(this.outputOptions.library + "");
		});
	};


/***/ },
/* 516 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ExternalsPlugin = __webpack_require__(517);
	
	function NodeTargetPlugin() {}
	
	module.exports = NodeTargetPlugin;
	NodeTargetPlugin.prototype.apply = function(compiler) {
		new ExternalsPlugin("commonjs", Object.keys(process.binding("natives"))).apply(compiler);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 517 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ExternalModuleFactoryPlugin = __webpack_require__(518);
	
	function ExternalsPlugin(type, externals) {
		this.type = type;
		this.externals = externals;
	}
	module.exports = ExternalsPlugin;
	ExternalsPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compile", function(params) {
			params.normalModuleFactory.apply(new ExternalModuleFactoryPlugin(this.type, this.externals));
		}.bind(this));
	};


/***/ },
/* 518 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ExternalModule = __webpack_require__(519);
	
	function ExternalModuleFactoryPlugin(type, externals) {
		this.type = type;
		this.externals = externals;
	}
	module.exports = ExternalModuleFactoryPlugin;
	
	ExternalModuleFactoryPlugin.prototype.apply = function(normalModuleFactory) {
		var globalType = this.type;
		normalModuleFactory.plugin("factory", function(factory) {
			return function(data, callback) {
				var context = data.context;
				var dependency = data.dependency;
	
				function handleExternal(value, type, callback) {
					if(typeof type === "function") {
						callback = type;
						type = undefined;
					}
					if(value === false) return factory(data, callback);
					if(value === true) value = dependency.request;
					if(typeof type === "undefined" && /^[a-z0-9]+ /.test(value)) {
						var idx = value.indexOf(" ");
						type = value.substr(0, idx);
						value = value.substr(idx + 1);
					}
					callback(null, new ExternalModule(value, type || globalType));
					return true;
				}
				(function handleExternals(externals, callback) {
					if(typeof externals === "string") {
						if(externals === dependency.request) {
							return handleExternal(dependency.request, callback);
						}
					} else if(Array.isArray(externals)) {
						var i = 0;
						(function next() {
							do {
								var async = true;
								if(i >= externals.length) return callback();
								handleExternals(externals[i++], function(err, module) {
									if(err) return callback(err);
									if(!module) {
										if(async) {
											async = false;
											return;
										}
										return next();
									}
									callback(null, module);
								});
							} while (!async);
							async = false;
						}());
						return;
					} else if(externals instanceof RegExp) {
						if(externals.test(dependency.request)) {
							return handleExternal(dependency.request, callback);
						}
					} else if(typeof externals === "function") {
						externals.call(null, context, dependency.request, function(err, value, type) {
							if(err) return callback(err);
							if(typeof value !== "undefined") {
								handleExternal(value, type, callback);
							} else {
								callback();
							}
						});
						return;
					} else if(typeof externals === "object" && Object.prototype.hasOwnProperty.call(externals, dependency.request)) {
						return handleExternal(externals[dependency.request], callback);
					}
					callback();
				}(this.externals, function(err, module) {
					if(err) return callback(err);
					if(!module) return handleExternal(false, callback);
					return callback(null, module);
				}));
			}.bind(this);
		}.bind(this));
	};


/***/ },
/* 519 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Module = __webpack_require__(188);
	var OriginalSource = __webpack_require__(222);
	var RawSource = __webpack_require__(213);
	var WebpackMissingModule = __webpack_require__(315);
	
	function ExternalModule(request, type) {
		Module.call(this);
		this.request = request;
		this.type = type;
		this.built = false;
	}
	module.exports = ExternalModule;
	
	ExternalModule.prototype = Object.create(Module.prototype);
	
	ExternalModule.prototype.external = true;
	
	ExternalModule.prototype.identifier = function() {
		return "external " + JSON.stringify(this.request);
	};
	
	ExternalModule.prototype.readableIdentifier = function() {
		return "external " + JSON.stringify(this.request);
	};
	
	ExternalModule.prototype.needRebuild = function() {
		return false;
	};
	
	ExternalModule.prototype.build = function(options, compilation, resolver, fs, callback) {
		this.builtTime = new Date().getTime();
		callback();
	};
	
	ExternalModule.prototype.source = function() {
		var str = "throw new Error('Externals not supported');";
		var request = this.request;
		if(typeof request === "object") request = request[this.type];
		switch(this.type) {
			case "this":
			case "window":
			case "global":
				if(Array.isArray(request)) {
					str = "(function() { module.exports = " + this.type + request.map(function(r) {
						return "[" + JSON.stringify(r) + "]";
					}).join("") + "; }());";
				} else
					str = "(function() { module.exports = " + this.type + "[" + JSON.stringify(request) + "]; }());";
				break;
			case "commonjs":
			case "commonjs2":
				if(Array.isArray(request)) {
					str = "module.exports = require(" + JSON.stringify(request[0]) + ")" + request.slice(1).map(function(r) {
						return "[" + JSON.stringify(r) + "]";
					}).join("") + ";";
				} else
					str = "module.exports = require(" + JSON.stringify(request) + ");";
				break;
			case "amd":
			case "umd":
			case "umd2":
				str = "";
				if(this.optional) {
					str += "if(typeof __WEBPACK_EXTERNAL_MODULE_" + this.id + "__ === 'undefined') {" + WebpackMissingModule.moduleCode(request) + "}\n";
				}
				str += "module.exports = __WEBPACK_EXTERNAL_MODULE_" + this.id + "__;";
				break;
			default:
				str = "";
				if(this.optional) {
					str += "if(typeof " + request + " === 'undefined') {" + WebpackMissingModule.moduleCode(request) + "}\n";
				}
				str += "module.exports = " + request + ";";
				break;
		}
		if(this.useSourceMap) {
			return new OriginalSource(str, this.identifier());
		} else {
			return new RawSource(str);
		}
	};
	
	ExternalModule.prototype.size = function() {
		return 42;
	};


/***/ },
/* 520 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var path = __webpack_require__(180);
	var async = __webpack_require__(183);
	
	function OldNodeWatchFileSystem(inputFileSystem) {
		this.inputFileSystem = inputFileSystem;
	}
	module.exports = OldNodeWatchFileSystem;
	
	/**
	 *
	 * @param files {String[]} a sorted array of paths to files
	 * @param dirs {String[]} a sorted array of paths to directories
	 * @param startTime {number} the virtual start time
	 * @param delay {number} in ms, the time to wait to signal after the first change
	 * @param callback {function(err, filesModified: String[], dirsModified: String[], fileTimestamps: Object, dirTimestamps: Object)] called once after change plus delay
	 * @param callbackUndelayed {function()} called once after first change
	 */
	OldNodeWatchFileSystem.prototype.watch = function(files, dirs, missing, startTime, delay, callback, callbackUndelayed) {
		var inputFileSystem = this.inputFileSystem;
	
		if(!callbackUndelayed) callbackUndelayed = function() {};
		var closed = false;
		var fileTimestamps = {};
		var dirTimestamps = {};
		var filesModified = {};
		var dirsModified = {};
	
		var lastChangeTime;
	
		startTime = Math.floor(startTime / 1000) * 1000; // only 1 second accuracy
	
		var directories = {};
		dirs.forEach(function(dir) {
			directories[dir] = {
				context: dir,
				files: []
			};
		});
		files.forEach(function(file) {
			var dir = path.dirname(file);
			if(!directories[dir]) directories[dir] = {
				files: []
			};
			directories[dir].files.push(file);
		});
	
		var items = Object.keys(directories).map(function(dir) {
			directories[dir].path = dir;
			return directories[dir];
		});
		items.sort(function(a, b) {
			if(a.path === b.path) return 0;
			return a.path < b.path ? -1 : 1;
		});
		items.forEach(function(item) {
			if(item.files) {
				item.files.sort();
			}
		});
	
		var initialChange = false;
		var change = function() {
			initialChange = true;
		};
	
		function readStat(item, callback) {
			if(item.context) {
				fs.readdir(item.path, function(err, files) {
					function onTimestamp(ts) {
						if(!dirTimestamps[item.context] || dirTimestamps[item.context] < ts)
							dirTimestamps[item.context] = ts;
						if(ts >= startTime) {
							dirsModified[item.context] = true;
							change(item.path);
						}
						return callback();
					}
					if(err) return onTimestamp(Infinity);
					async.map(files, function(file, callback) {
						file = path.join(item.path, file);
						var isFile = false;
						if(item.files) {
							if(binarySearch(item.files, function(path) {
									if(path === file) return 0;
									return path < file ? -1 : 1;
								}) >= 0) {
								isFile = true;
							}
						}
						fs.stat(file, function(err, stat) {
							var ts = err ? Infinity : stat.mtime.getTime();
							if(isFile) {
								fileTimestamps[file] = ts;
								if(ts >= startTime) filesModified[file] = true;
							}
							return callback(null, ts);
						});
					}, function(err, timestamps) {
						if(err) return onTimestamp(Infinity);
						var ts = timestamps.reduce(function(max, ts) {
							if(ts > max)
								return ts;
							return max;
						}, 0);
						onTimestamp(ts);
					});
				});
			} else {
				async.forEach(item.files, function(file, callback) {
					fs.stat(file, function(err, stat) {
						var ts = err ? Infinity : stat.mtime.getTime();
						fileTimestamps[file] = ts;
						if(ts >= startTime) {
							filesModified[file] = true;
							change(file);
						}
						return callback(null, ts);
					});
				}, callback);
			}
		}
		async.forEach(items, function processItem(item, callback) {
			var isRunning = false;
			var isScheduled = false;
			item.watcher = fs.watch(item.path, function() {
				if(isRunning) {
					isScheduled = true;
					return;
				}
				isRunning = true;
				readStat(item, done);
			});
			if(item.context) {
				item.children = [];
				fs.readdir(item.path, function(err, files) {
					if(err) {
						change();
						onWatcherApplied();
						return;
					}
					async.forEach(files, function(file, callback) {
						file = path.join(item.path, file);
						fs.stat(file, function(err, stat) {
							if(err) {
								change(file);
								callback();
								return;
							}
							if(!stat.isDirectory()) return callback();
							var subitem = {
								path: file,
								context: item.context
							};
							item.children.push(subitem);
							processItem(subitem, callback);
						});
					}, onWatcherApplied);
				});
			} else onWatcherApplied();
	
			function onWatcherApplied() {
				readStat(item, function() {
					callback();
					done();
				});
			}
	
			function done() {
				if(closed) return;
				if(isScheduled) {
					isScheduled = false;
					readStat(item, done);
				} else {
					isRunning = false;
				}
			}
		}, function() {
			var timeout;
			if(initialChange) {
	
				callbackUndelayed();
				if(delay) {
					lastChangeTime = Date.now();
					change = restartDelay;
					timeout = setTimeout(onTimeout, delay);
				} else onTimeout();
	
			} else {
	
				change = function() {
	
					callbackUndelayed();
					if(delay) {
						lastChangeTime = Date.now();
						change = restartDelay;
						timeout = setTimeout(onTimeout, delay);
					} else {
						change = function() {};
						onTimeout();
					}
				};
	
			}
	
			function restartDelay() {
				lastChangeTime = Date.now();
				clearTimeout(timeout);
				timeout = setTimeout(onTimeout, delay);
			}
	
		});
	
		// 7.
		function onTimeout() {
			var nextSecond = Math.ceil(lastChangeTime / 1000) * 1000;
			var timeToNextSecond = nextSecond - Date.now();
			if(timeToNextSecond > 0) {
				setTimeout(onTimeout, timeToNextSecond);
				return;
			}
			change = function() {};
			if(closed) return;
			var outdatedFiles = Object.keys(filesModified).sort();
			var outdatedDirs = Object.keys(dirsModified).sort();
			if(inputFileSystem && inputFileSystem.purge) {
				inputFileSystem.purge(outdatedFiles);
				inputFileSystem.purge(outdatedDirs);
			}
			callback(null, outdatedFiles, outdatedDirs, [], fileTimestamps, dirTimestamps);
	
			close();
		}
	
		function close() {
			closed = true;
			items.forEach(function closeItem(item) {
				item.watcher.close();
				if(item.children) item.children.forEach(closeItem);
			});
		}
	
		return {
			close: close,
			pause: close
		};
	};
	
	function binarySearch(array, comparator) {
		var left = 0;
		var right = array.length - 1;
	
		while(left <= right) {
			var middle = ((left + right) / 2) | 0;
			var comp = comparator(array[middle]);
			if(comp === 0) return middle;
			if(comp > 0) right = middle - 1;
			if(comp < 0) left = middle + 1;
		}
		return -1;
	}


/***/ },
/* 521 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SetVarMainTemplatePlugin = __webpack_require__(522);
	
	function accessorToObjectAccess(accessor) {
		return accessor.map(function(a) {
			return "[" + JSON.stringify(a) + "]";
		}).join("");
	}
	
	function accessorAccess(base, accessor, joinWith) {
		accessor = [].concat(accessor);
		return accessor.map(function(a, idx) {
			a = base ?
				base + accessorToObjectAccess(accessor.slice(0, idx + 1)) :
				accessor[0] + accessorToObjectAccess(accessor.slice(1, idx + 1));
			if(idx === accessor.length - 1) return a;
			if(idx === 0 && typeof base === "undefined") return a + " = typeof " + a + " === \"object\" ? " + a + " : {}";
			return a + " = " + a + " || {}";
		}).join(joinWith || "; ");
	}
	
	function LibraryTemplatePlugin(name, target, umdNamedDefine) {
		this.name = name;
		this.target = target;
		this.umdNamedDefine = umdNamedDefine;
	}
	module.exports = LibraryTemplatePlugin;
	LibraryTemplatePlugin.prototype.apply = function(compiler) {
		compiler.plugin("this-compilation", function(compilation) {
			switch(this.target) {
				case "var":
					compilation.apply(new SetVarMainTemplatePlugin("var " + accessorAccess(false, this.name)));
					break;
				case "assign":
					compilation.apply(new SetVarMainTemplatePlugin(accessorAccess(undefined, this.name)));
					break;
				case "this":
				case "window":
				case "global":
					if(this.name)
						compilation.apply(new SetVarMainTemplatePlugin(accessorAccess(this.target, this.name)));
					else
						compilation.apply(new SetVarMainTemplatePlugin(this.target, true));
					break;
				case "commonjs":
					if(this.name)
						compilation.apply(new SetVarMainTemplatePlugin(accessorAccess("exports", this.name)));
					else
						compilation.apply(new SetVarMainTemplatePlugin("exports", true));
					break;
				case "commonjs2":
					compilation.apply(new SetVarMainTemplatePlugin("module.exports"));
					break;
				case "amd":
					var AmdMainTemplatePlugin = __webpack_require__(523);
					compilation.apply(new AmdMainTemplatePlugin(this.name));
					break;
				case "umd":
				case "umd2":
					var UmdMainTemplatePlugin = __webpack_require__(524);
					compilation.apply(new UmdMainTemplatePlugin(this.name, {
						optionalAmdExternalAsGlobal: this.target === "umd2",
						namedDefine: this.umdNamedDefine
					}));
					break;
				case "jsonp":
					var JsonpExportMainTemplatePlugin = __webpack_require__(525);
					compilation.apply(new JsonpExportMainTemplatePlugin(this.name));
					break;
				default:
					throw new Error(this.target + " is not a valid Library target");
			}
		}.bind(this));
	};


/***/ },
/* 522 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(221);
	
	function SetVarMainTemplatePlugin(varExpression, copyObject) {
		this.varExpression = varExpression;
		this.copyObject = copyObject;
	}
	module.exports = SetVarMainTemplatePlugin;
	SetVarMainTemplatePlugin.prototype.apply = function(compilation) {
		var mainTemplate = compilation.mainTemplate;
		compilation.templatesPlugin("render-with-entry", function(source, chunk, hash) {
			var varExpression = mainTemplate.applyPluginsWaterfall("asset-path", this.varExpression, {
				hash: hash,
				chunk: chunk
			});
			if(this.copyObject) {
				return new ConcatSource("(function(e, a) { for(var i in a) e[i] = a[i]; }(" +
					varExpression + ", ", source, "))");
			} else {
				var prefix = varExpression + " =\n";
				return new ConcatSource(prefix, source);
			}
		}.bind(this));
		mainTemplate.plugin("global-hash-paths", function(paths) {
			if(this.varExpression) paths.push(this.varExpression);
			return paths;
		});
		mainTemplate.plugin("hash", function(hash) {
			hash.update("set var");
			hash.update(this.varExpression + "");
			hash.update(this.copyObject + "");
		}.bind(this));
	};


/***/ },
/* 523 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(221);
	
	function AmdMainTemplatePlugin(name) {
		this.name = name;
	}
	module.exports = AmdMainTemplatePlugin;
	AmdMainTemplatePlugin.prototype.apply = function(compilation) {
		var mainTemplate = compilation.mainTemplate;
		compilation.templatesPlugin("render-with-entry", function(source, chunk, hash) {
			var externals = chunk.modules.filter(function(m) {
				return m.external;
			});
			var externalsDepsArray = JSON.stringify(externals.map(function(m) {
				return typeof m.request === "object" ? m.request.amd : m.request;
			}));
			var externalsArguments = externals.map(function(m) {
				return "__WEBPACK_EXTERNAL_MODULE_" + m.id + "__";
			}).join(", ");
			if(this.name) {
				var name = mainTemplate.applyPluginsWaterfall("asset-path", this.name, {
					hash: hash,
					chunk: chunk
				});
				return new ConcatSource("define(" + JSON.stringify(name) + ", " + externalsDepsArray + ", function(" + externalsArguments + ") { return ", source, "});");
			} else if(externalsArguments) {
				return new ConcatSource("define(" + externalsDepsArray + ", function(" + externalsArguments + ") { return ", source, "});");
			} else {
				return new ConcatSource("define(function() { return ", source, "});");
			}
		}.bind(this));
		mainTemplate.plugin("global-hash-paths", function(paths) {
			if(this.name) paths.push(this.name);
			return paths;
		}.bind(this));
		mainTemplate.plugin("hash", function(hash) {
			hash.update("exports amd");
			hash.update(this.name + "");
		}.bind(this));
	};


/***/ },
/* 524 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(221);
	var OriginalSource = __webpack_require__(222);
	
	function accessorToObjectAccess(accessor) {
		return accessor.map(function(a) {
			return "[" + JSON.stringify(a) + "]";
		}).join("");
	}
	
	function accessorAccess(base, accessor) {
		accessor = [].concat(accessor);
		return accessor.map(function(a, idx) {
			a = base + accessorToObjectAccess(accessor.slice(0, idx + 1));
			if(idx === accessor.length - 1) return a;
			return a + " = " + a + " || {}";
		}).join(", ");
	}
	
	function UmdMainTemplatePlugin(name, options) {
		this.name = name;
		this.optionalAmdExternalAsGlobal = options.optionalAmdExternalAsGlobal;
		this.namedDefine = options.namedDefine;
	}
	module.exports = UmdMainTemplatePlugin;
	UmdMainTemplatePlugin.prototype.apply = function(compilation) {
		var mainTemplate = compilation.mainTemplate;
		compilation.templatesPlugin("render-with-entry", function(source, chunk, hash) {
			var externals = chunk.modules.filter(function(m) {
				return m.external;
			});
			var optionalExternals = [],
				requiredExternals = [];
			if(this.optionalAmdExternalAsGlobal) {
				externals.forEach(function(m) {
					if(m.optional) {
						optionalExternals.push(m);
					} else {
						requiredExternals.push(m);
					}
				});
				externals = requiredExternals.concat(optionalExternals);
			} else {
				requiredExternals = externals;
			}
	
			function replaceKeys(str) {
				return mainTemplate.applyPluginsWaterfall("asset-path", str, {
					hash: hash,
					chunk: chunk
				});
			}
	
			function externalsDepsArray(modules) {
				return "[" + replaceKeys(modules.map(function(m) {
					return JSON.stringify(typeof m.request === "object" ? m.request.amd : m.request);
				}).join(", ")) + "]";
			}
	
			function externalsRootArray(modules) {
				return replaceKeys(modules.map(function(m) {
					var request = m.request;
					if(typeof request === "object") request = request.root;
					return "root" + accessorToObjectAccess([].concat(request));
				}).join(", "));
			}
	
			function externalsRequireArray(type) {
				return replaceKeys(externals.map(function(m) {
					var request = m.request;
					if(typeof request === "object") request = request[type];
					if(Array.isArray(request)) {
						var expr = "require(" + JSON.stringify(request[0]) + ")" + accessorToObjectAccess(request.slice(1));
					} else
						var expr = "require(" + JSON.stringify(request) + ")";
					if(m.optional) {
						expr = "(function webpackLoadOptionalExternalModule() { try { return " + expr + "; } catch(e) {} }())";
					}
					return expr;
				}).join(", "));
			}
	
			function externalsArguments(modules) {
				return modules.map(function(m) {
					return "__WEBPACK_EXTERNAL_MODULE_" + m.id + "__";
				}).join(", ");
			}
	
			function libraryName(library) {
				return JSON.stringify(replaceKeys([].concat(library).pop()));
			}
	
			if(optionalExternals.length > 0) {
				var amdFactory = "function webpackLoadOptionalExternalModuleAmd(" + externalsArguments(requiredExternals) + ") {\n" +
					"			return factory(" + (
						requiredExternals.length > 0 ?
						externalsArguments(requiredExternals) + ", " + externalsRootArray(optionalExternals) :
						externalsRootArray(optionalExternals)
					) + ");\n" +
					"		}";
			} else {
				var amdFactory = "factory";
			}
	
			return new ConcatSource(new OriginalSource(
				"(function webpackUniversalModuleDefinition(root, factory) {\n" +
				"	if(typeof exports === 'object' && typeof module === 'object')\n" +
				"		module.exports = factory(" + externalsRequireArray("commonjs2") + ");\n" +
				"	else if(typeof define === 'function' && define.amd)\n" +
				(requiredExternals.length > 0 ?
					(this.name && this.namedDefine === true ?
						"		define(" + libraryName(this.name) + ", " + externalsDepsArray(requiredExternals) + ", " + amdFactory + ");\n" :
						"		define(" + externalsDepsArray(requiredExternals) + ", " + amdFactory + ");\n"
					) :
					(this.name && this.namedDefine === true ?
						"		define(" + libraryName(this.name) + ", [], " + amdFactory + ");\n" :
						"		define([], " + amdFactory + ");\n"
					)
				) +
				(this.name ?
					"	else if(typeof exports === 'object')\n" +
					"		exports[" + libraryName(this.name) + "] = factory(" + externalsRequireArray("commonjs") + ");\n" +
					"	else\n" +
					"		" + replaceKeys(accessorAccess("root", this.name)) + " = factory(" + externalsRootArray(externals) + ");\n" :
					"	else {\n" +
					(externals.length > 0 ?
						"		var a = typeof exports === 'object' ? factory(" + externalsRequireArray("commonjs") + ") : factory(" + externalsRootArray(externals) + ");\n" :
						"		var a = factory();\n"
					) +
					"		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n" +
					"	}\n"
				) +
				"})(this, function(" + externalsArguments(externals) + ") {\nreturn ", "webpack/universalModuleDefinition"), source, "\n});\n");
		}.bind(this));
		mainTemplate.plugin("global-hash-paths", function(paths) {
			if(this.name) paths = paths.concat(this.name);
			return paths;
		}.bind(this));
		mainTemplate.plugin("hash", function(hash) {
			hash.update("umd");
			hash.update(this.name + "");
		}.bind(this));
	};


/***/ },
/* 525 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(221);
	
	function JsonpExportMainTemplatePlugin(name) {
		this.name = name;
	}
	module.exports = JsonpExportMainTemplatePlugin;
	JsonpExportMainTemplatePlugin.prototype.apply = function(compilation) {
		var mainTemplate = compilation.mainTemplate;
		compilation.templatesPlugin("render-with-entry", function(source, chunk, hash) {
			var name = mainTemplate.applyPluginsWaterfall("asset-path", this.name || "", {
				hash: hash,
				chunk: chunk
			});
			return new ConcatSource(name + "(", source, ");");
		}.bind(this));
		mainTemplate.plugin("global-hash-paths", function(paths) {
			if(this.name) paths.push(this.name);
			return paths;
		}.bind(this));
		mainTemplate.plugin("hash", function(hash) {
			hash.update("jsonp export");
			hash.update(this.name + "");
		}.bind(this));
	};


/***/ },
/* 526 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Template = __webpack_require__(224);
	var BasicEvaluatedExpression = __webpack_require__(251);
	var ModuleHotAcceptDependency = __webpack_require__(527);
	var ModuleHotDeclineDependency = __webpack_require__(528);
	var RawSource = __webpack_require__(213);
	var ConstDependency = __webpack_require__(295);
	var NullFactory = __webpack_require__(297);
	
	function HotModuleReplacementPlugin() {}
	module.exports = HotModuleReplacementPlugin;
	
	HotModuleReplacementPlugin.prototype.apply = function(compiler) {
		var hotUpdateChunkFilename = compiler.options.output.hotUpdateChunkFilename;
		var hotUpdateMainFilename = compiler.options.output.hotUpdateMainFilename;
		compiler.plugin("compilation", function(compilation, params) {
			var hotUpdateChunkTemplate = compilation.hotUpdateChunkTemplate;
			if(!hotUpdateChunkTemplate) return;
	
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
	
			compilation.dependencyFactories.set(ModuleHotAcceptDependency, normalModuleFactory);
			compilation.dependencyTemplates.set(ModuleHotAcceptDependency, new ModuleHotAcceptDependency.Template());
	
			compilation.dependencyFactories.set(ModuleHotDeclineDependency, normalModuleFactory);
			compilation.dependencyTemplates.set(ModuleHotDeclineDependency, new ModuleHotDeclineDependency.Template());
	
			compilation.plugin("record", function(compilation, records) {
				if(records.hash === this.hash) return;
				records.hash = compilation.hash;
				records.moduleHashs = {};
				this.modules.forEach(function(module) {
					var identifier = module.identifier();
					var hash = __webpack_require__(231).createHash("md5");
					module.updateHash(hash);
					records.moduleHashs[identifier] = hash.digest("hex");
				});
				records.chunkHashs = {};
				this.chunks.forEach(function(chunk) {
					records.chunkHashs[chunk.id] = chunk.hash;
				});
				records.chunkModuleIds = {};
				this.chunks.forEach(function(chunk) {
					records.chunkModuleIds[chunk.id] = chunk.modules.map(function(m) {
						return m.id;
					});
				});
			});
			compilation.plugin("after-hash", function() {
				var records = this.records;
				if(!records) return;
				var preHash = records.preHash || "x";
				var prepreHash = records.prepreHash || "x";
				if(preHash === this.hash) {
					this.modifyHash(prepreHash);
					return;
				}
				records.prepreHash = records.hash || "x";
				records.preHash = this.hash;
				this.modifyHash(records.prepreHash);
			});
			compilation.plugin("additional-chunk-assets", function() {
				var records = this.records;
				if(records.hash === this.hash) return;
				if(!records.moduleHashs || !records.chunkHashs || !records.chunkModuleIds) return;
				this.modules.forEach(function(module) {
					var identifier = module.identifier();
					var hash = __webpack_require__(231).createHash("md5");
					module.updateHash(hash);
					hash = hash.digest("hex");
					module.hotUpdate = records.moduleHashs[identifier] !== hash;
				});
				var hotUpdateMainContent = {
					h: this.hash,
					c: []
				};
				Object.keys(records.chunkHashs).forEach(function(chunkId) {
					chunkId = +chunkId;
					var currentChunk = this.chunks.filter(function(chunk) {
						return chunk.id === chunkId;
					})[0];
					if(currentChunk) {
						var newModules = currentChunk.modules.filter(function(module) {
							return module.hotUpdate;
						});
						if(newModules.length > 0) {
							var source = hotUpdateChunkTemplate.render(chunkId, newModules, this.hash, this.moduleTemplate, this.dependencyTemplates);
							var filename = this.getPath(hotUpdateChunkFilename, {
								hash: records.hash,
								chunk: currentChunk
							});
							this.additionalChunkAssets.push(filename);
							this.assets[filename] = source;
							hotUpdateMainContent.c.push(chunkId);
							currentChunk.files.push(filename);
							this.applyPlugins("chunk-asset", currentChunk, filename);
						}
					}
				}, this);
				var source = new RawSource(JSON.stringify(hotUpdateMainContent));
				var filename = this.getPath(hotUpdateMainFilename, {
					hash: records.hash
				});
				this.assets[filename] = source;
			});
	
			compilation.mainTemplate.plugin("hash", function(hash) {
				hash.update("HotMainTemplateDecorator");
			});
	
			compilation.mainTemplate.plugin("module-require", function(_, chunk, hash, varModuleId) {
				return "hotCreateRequire(" + varModuleId + ")";
			});
	
			compilation.mainTemplate.plugin("require-extensions", function(source) {
				var buf = [source];
				buf.push("");
				buf.push("// __webpack_hash__");
				buf.push(this.requireFn + ".h = function() { return hotCurrentHash; };");
				return this.asString(buf);
			});
	
			compilation.mainTemplate.plugin("bootstrap", function(source, chunk, hash) {
				source = this.applyPluginsWaterfall("hot-bootstrap", source, chunk, hash);
				return this.asString([
					source,
					"",
					hotInitCode
					.replace(/\$require\$/g, this.requireFn)
					.replace(/\$hash\$/g, JSON.stringify(hash))
					.replace(/\/\*foreachInstalledChunks\*\//g, chunk.chunks.length > 0 ? "for(var chunkId in installedChunks)" : "var chunkId = " + chunk.id + ";")
				]);
			});
	
			compilation.mainTemplate.plugin("global-hash", function() {
				return true;
			});
	
			compilation.mainTemplate.plugin("current-hash", function(_, length) {
				if(isFinite(length))
					return "hotCurrentHash.substr(0, " + length + ")";
				else
					return "hotCurrentHash";
			});
	
			compilation.mainTemplate.plugin("module-obj", function(source, chunk, hash, varModuleId) {
				return this.asString([
					source + ",",
					"hot: hotCreateModule(" + varModuleId + "),",
					"parents: hotCurrentParents,",
					"children: []"
				]);
			});
	
		});
		compiler.parser.plugin("expression __webpack_hash__", function(expr) {
			var dep = new ConstDependency("__webpack_require__.h()", expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		});
		compiler.parser.plugin("evaluate typeof __webpack_hash__", function(expr) {
			return new BasicEvaluatedExpression().setString("string").setRange(expr.range);
		});
		compiler.parser.plugin("evaluate Identifier module.hot", function(expr) {
			return new BasicEvaluatedExpression()
				.setBoolean(!!this.state.compilation.hotUpdateChunkTemplate)
				.setRange(expr.range);
		});
		compiler.parser.plugin("call module.hot.accept", function(expr) {
			if(!this.state.compilation.hotUpdateChunkTemplate) return false;
			if(expr.arguments.length > 1) {
				var arg = this.evaluateExpression(expr.arguments[0]);
				var params = [];
				if(arg.isString()) {
					params = [arg];
				} else if(arg.isArray()) {
					params = arg.items.filter(function(param) {
						return param.isString();
					});
				}
				params.forEach(function(param, idx) {
					var dep = new ModuleHotAcceptDependency(param.string, param.range);
					dep.optional = true;
					dep.loc = Object.create(expr.loc);
					dep.loc.index = idx;
					this.state.module.addDependency(dep);
				}.bind(this));
			}
		});
		compiler.parser.plugin("call module.hot.decline", function(expr) {
			if(!this.state.compilation.hotUpdateChunkTemplate) return false;
			if(expr.arguments.length === 1) {
				var arg = this.evaluateExpression(expr.arguments[0]);
				var params = [];
				if(arg.isString()) {
					params = [arg];
				} else if(arg.isArray()) {
					params = arg.items.filter(function(param) {
						return param.isString();
					});
				}
				params.forEach(function(param, idx) {
					var dep = new ModuleHotDeclineDependency(param.string, param.range);
					dep.optional = true;
					dep.loc = Object.create(expr.loc);
					dep.loc.index = idx;
					this.state.module.addDependency(dep);
				}.bind(this));
			}
		});
		compiler.parser.plugin("expression module.hot", function() {
			return true;
		});
	};
	
	var hotInitCode = Template.getFunctionContent(__webpack_require__(529));


/***/ },
/* 527 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(272);
	
	function ModuleHotAcceptDependency(request, range) {
		ModuleDependency.call(this, request);
		this.Class = ModuleHotAcceptDependency;
		this.range = range;
		this.weak = true;
	}
	module.exports = ModuleHotAcceptDependency;
	
	ModuleHotAcceptDependency.prototype = Object.create(ModuleDependency.prototype);
	ModuleHotAcceptDependency.prototype.constructor = ModuleHotAcceptDependency;
	ModuleHotAcceptDependency.prototype.type = "module.hot.accept";
	
	ModuleHotAcceptDependency.Template = __webpack_require__(314);


/***/ },
/* 528 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(272);
	
	function ModuleHotDeclineDependency(request, range) {
		ModuleDependency.call(this, request);
		this.Class = ModuleHotDeclineDependency;
		this.range = range;
		this.weak = true;
	}
	module.exports = ModuleHotDeclineDependency;
	
	ModuleHotDeclineDependency.prototype = Object.create(ModuleDependency.prototype);
	ModuleHotDeclineDependency.prototype.constructor = ModuleHotDeclineDependency;
	ModuleHotDeclineDependency.prototype.type = "module.hot.decline";
	
	ModuleHotDeclineDependency.Template = __webpack_require__(314);


/***/ },
/* 529 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*global $hash$ installedModules $require$ hotDownloadManifest hotDownloadUpdateChunk modules */
	module.exports = function() {
	
		var hotApplyOnUpdate = true;
		var hotCurrentHash = $hash$; // eslint-disable-line no-unused-vars
		var hotCurrentModuleData = {};
		var hotCurrentParents = []; // eslint-disable-line no-unused-vars
	
		function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
			var me = installedModules[moduleId];
			if(!me) return $require$;
			var fn = function(request) {
				if(me.hot.active) {
					if(installedModules[request]) {
						if(installedModules[request].parents.indexOf(moduleId) < 0)
							installedModules[request].parents.push(moduleId);
						if(me.children.indexOf(request) < 0)
							me.children.push(request);
					} else hotCurrentParents = [moduleId];
				} else {
					console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
					hotCurrentParents = [];
				}
				return $require$(request);
			};
			for(var name in $require$) {
				if(Object.prototype.hasOwnProperty.call($require$, name)) {
					fn[name] = $require$[name];
				}
			}
			fn.e = function(chunkId, callback) {
				if(hotStatus === "ready")
					hotSetStatus("prepare");
				hotChunksLoading++;
				$require$.e(chunkId, function() {
					try {
						callback.call(null, fn);
					} finally {
						finishChunkLoading();
					}
	
					function finishChunkLoading() {
						hotChunksLoading--;
						if(hotStatus === "prepare") {
							if(!hotWaitingFilesMap[chunkId]) {
								hotEnsureUpdateChunk(chunkId);
							}
							if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
								hotUpdateDownloaded();
							}
						}
					}
				});
			};
			return fn;
		}
	
		function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
			var hot = {
				// private stuff
				_acceptedDependencies: {},
				_declinedDependencies: {},
				_selfAccepted: false,
				_selfDeclined: false,
				_disposeHandlers: [],
	
				// Module API
				active: true,
				accept: function(dep, callback) {
					if(typeof dep === "undefined")
						hot._selfAccepted = true;
					else if(typeof dep === "function")
						hot._selfAccepted = dep;
					else if(typeof dep === "object")
						for(var i = 0; i < dep.length; i++)
							hot._acceptedDependencies[dep[i]] = callback;
					else
						hot._acceptedDependencies[dep] = callback;
				},
				decline: function(dep) {
					if(typeof dep === "undefined")
						hot._selfDeclined = true;
					else if(typeof dep === "number")
						hot._declinedDependencies[dep] = true;
					else
						for(var i = 0; i < dep.length; i++)
							hot._declinedDependencies[dep[i]] = true;
				},
				dispose: function(callback) {
					hot._disposeHandlers.push(callback);
				},
				addDisposeHandler: function(callback) {
					hot._disposeHandlers.push(callback);
				},
				removeDisposeHandler: function(callback) {
					var idx = hot._disposeHandlers.indexOf(callback);
					if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
				},
	
				// Management API
				check: hotCheck,
				apply: hotApply,
				status: function(l) {
					if(!l) return hotStatus;
					hotStatusHandlers.push(l);
				},
				addStatusHandler: function(l) {
					hotStatusHandlers.push(l);
				},
				removeStatusHandler: function(l) {
					var idx = hotStatusHandlers.indexOf(l);
					if(idx >= 0) hotStatusHandlers.splice(idx, 1);
				},
	
				//inherit from previous dispose call
				data: hotCurrentModuleData[moduleId]
			};
			return hot;
		}
	
		var hotStatusHandlers = [];
		var hotStatus = "idle";
	
		function hotSetStatus(newStatus) {
			hotStatus = newStatus;
			for(var i = 0; i < hotStatusHandlers.length; i++)
				hotStatusHandlers[i].call(null, newStatus);
		}
	
		// while downloading
		var hotWaitingFiles = 0;
		var hotChunksLoading = 0;
		var hotWaitingFilesMap = {};
		var hotRequestedFilesMap = {};
		var hotAvailibleFilesMap = {};
		var hotCallback;
	
		// The update info
		var hotUpdate, hotUpdateNewHash;
	
		function toModuleId(id) {
			var isNumber = (+id) + "" === id;
			return isNumber ? +id : id;
		}
	
		function hotCheck(apply, callback) {
			if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
			if(typeof apply === "function") {
				hotApplyOnUpdate = false;
				callback = apply;
			} else {
				hotApplyOnUpdate = apply;
				callback = callback || function(err) {
					if(err) throw err;
				};
			}
			hotSetStatus("check");
			hotDownloadManifest(function(err, update) {
				if(err) return callback(err);
				if(!update) {
					hotSetStatus("idle");
					callback(null, null);
					return;
				}
	
				hotRequestedFilesMap = {};
				hotAvailibleFilesMap = {};
				hotWaitingFilesMap = {};
				for(var i = 0; i < update.c.length; i++)
					hotAvailibleFilesMap[update.c[i]] = true;
				hotUpdateNewHash = update.h;
	
				hotSetStatus("prepare");
				hotCallback = callback;
				hotUpdate = {};
				/*foreachInstalledChunks*/
				{ // eslint-disable-line no-lone-blocks
					/*globals chunkId */
					hotEnsureUpdateChunk(chunkId);
				}
				if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
					hotUpdateDownloaded();
				}
			});
		}
	
		function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
			if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
				return;
			hotRequestedFilesMap[chunkId] = false;
			for(var moduleId in moreModules) {
				if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
					hotUpdate[moduleId] = moreModules[moduleId];
				}
			}
			if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
				hotUpdateDownloaded();
			}
		}
	
		function hotEnsureUpdateChunk(chunkId) {
			if(!hotAvailibleFilesMap[chunkId]) {
				hotWaitingFilesMap[chunkId] = true;
			} else {
				hotRequestedFilesMap[chunkId] = true;
				hotWaitingFiles++;
				hotDownloadUpdateChunk(chunkId);
			}
		}
	
		function hotUpdateDownloaded() {
			hotSetStatus("ready");
			var callback = hotCallback;
			hotCallback = null;
			if(!callback) return;
			if(hotApplyOnUpdate) {
				hotApply(hotApplyOnUpdate, callback);
			} else {
				var outdatedModules = [];
				for(var id in hotUpdate) {
					if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
						outdatedModules.push(toModuleId(id));
					}
				}
				callback(null, outdatedModules);
			}
		}
	
		function hotApply(options, callback) {
			if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
			if(typeof options === "function") {
				callback = options;
				options = {};
			} else if(options && typeof options === "object") {
				callback = callback || function(err) {
					if(err) throw err;
				};
			} else {
				options = {};
				callback = callback || function(err) {
					if(err) throw err;
				};
			}
	
			function getAffectedStuff(module) {
				var outdatedModules = [module];
				var outdatedDependencies = {};
	
				var queue = outdatedModules.slice();
				while(queue.length > 0) {
					var moduleId = queue.pop();
					var module = installedModules[moduleId];
					if(!module || module.hot._selfAccepted)
						continue;
					if(module.hot._selfDeclined) {
						return new Error("Aborted because of self decline: " + moduleId);
					}
					if(moduleId === 0) {
						return;
					}
					for(var i = 0; i < module.parents.length; i++) {
						var parentId = module.parents[i];
						var parent = installedModules[parentId];
						if(parent.hot._declinedDependencies[moduleId]) {
							return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
						}
						if(outdatedModules.indexOf(parentId) >= 0) continue;
						if(parent.hot._acceptedDependencies[moduleId]) {
							if(!outdatedDependencies[parentId])
								outdatedDependencies[parentId] = [];
							addAllToSet(outdatedDependencies[parentId], [moduleId]);
							continue;
						}
						delete outdatedDependencies[parentId];
						outdatedModules.push(parentId);
						queue.push(parentId);
					}
				}
	
				return [outdatedModules, outdatedDependencies];
			}
	
			function addAllToSet(a, b) {
				for(var i = 0; i < b.length; i++) {
					var item = b[i];
					if(a.indexOf(item) < 0)
						a.push(item);
				}
			}
	
			// at begin all updates modules are outdated
			// the "outdated" status can propagate to parents if they don't accept the children
			var outdatedDependencies = {};
			var outdatedModules = [];
			var appliedUpdate = {};
			for(var id in hotUpdate) {
				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
					var moduleId = toModuleId(id);
					var result = getAffectedStuff(moduleId);
					if(!result) {
						if(options.ignoreUnaccepted)
							continue;
						hotSetStatus("abort");
						return callback(new Error("Aborted because " + moduleId + " is not accepted"));
					}
					if(result instanceof Error) {
						hotSetStatus("abort");
						return callback(result);
					}
					appliedUpdate[moduleId] = hotUpdate[moduleId];
					addAllToSet(outdatedModules, result[0]);
					for(var moduleId in result[1]) {
						if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
							if(!outdatedDependencies[moduleId])
								outdatedDependencies[moduleId] = [];
							addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
						}
					}
				}
			}
	
			// Store self accepted outdated modules to require them later by the module system
			var outdatedSelfAcceptedModules = [];
			for(var i = 0; i < outdatedModules.length; i++) {
				var moduleId = outdatedModules[i];
				if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
					outdatedSelfAcceptedModules.push({
						module: moduleId,
						errorHandler: installedModules[moduleId].hot._selfAccepted
					});
			}
	
			// Now in "dispose" phase
			hotSetStatus("dispose");
			var queue = outdatedModules.slice();
			while(queue.length > 0) {
				var moduleId = queue.pop();
				var module = installedModules[moduleId];
				if(!module) continue;
	
				var data = {};
	
				// Call dispose handlers
				var disposeHandlers = module.hot._disposeHandlers;
				for(var j = 0; j < disposeHandlers.length; j++) {
					var cb = disposeHandlers[j];
					cb(data);
				}
				hotCurrentModuleData[moduleId] = data;
	
				// disable module (this disables requires from this module)
				module.hot.active = false;
	
				// remove module from cache
				delete installedModules[moduleId];
	
				// remove "parents" references from all children
				for(var j = 0; j < module.children.length; j++) {
					var child = installedModules[module.children[j]];
					if(!child) continue;
					var idx = child.parents.indexOf(moduleId);
					if(idx >= 0) {
						child.parents.splice(idx, 1);
					}
				}
			}
	
			// remove outdated dependency from module children
			for(var moduleId in outdatedDependencies) {
				if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
					var module = installedModules[moduleId];
					var moduleOutdatedDependencies = outdatedDependencies[moduleId];
					for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
						var dependency = moduleOutdatedDependencies[j];
						var idx = module.children.indexOf(dependency);
						if(idx >= 0) module.children.splice(idx, 1);
					}
				}
			}
	
			// Not in "apply" phase
			hotSetStatus("apply");
	
			hotCurrentHash = hotUpdateNewHash;
	
			// insert new code
			for(var moduleId in appliedUpdate) {
				if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
					modules[moduleId] = appliedUpdate[moduleId];
				}
			}
	
			// call accept handlers
			var error = null;
			for(var moduleId in outdatedDependencies) {
				if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
					var module = installedModules[moduleId];
					var moduleOutdatedDependencies = outdatedDependencies[moduleId];
					var callbacks = [];
					for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
						var dependency = moduleOutdatedDependencies[i];
						var cb = module.hot._acceptedDependencies[dependency];
						if(callbacks.indexOf(cb) >= 0) continue;
						callbacks.push(cb);
					}
					for(var i = 0; i < callbacks.length; i++) {
						var cb = callbacks[i];
						try {
							cb(outdatedDependencies);
						} catch(err) {
							if(!error)
								error = err;
						}
					}
				}
			}
	
			// Load self accepted modules
			for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
				var item = outdatedSelfAcceptedModules[i];
				var moduleId = item.module;
				hotCurrentParents = [moduleId];
				try {
					$require$(moduleId);
				} catch(err) {
					if(typeof item.errorHandler === "function") {
						try {
							item.errorHandler(err);
						} catch(err) {
							if(!error)
								error = err;
						}
					} else if(!error)
						error = err;
				}
			}
	
			// handle errors in accept handlers and self accepted module load
			if(error) {
				hotSetStatus("fail");
				return callback(error);
			}
	
			hotSetStatus("idle");
			callback(null, outdatedModules);
		}
	};


/***/ },
/* 530 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var PrefetchDependency = __webpack_require__(531);
	
	function PrefetchPlugin(context, request) {
		if(!request) {
			this.request = context;
		} else {
			this.context = context;
			this.request = request;
		}
	}
	module.exports = PrefetchPlugin;
	PrefetchPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation, params) {
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(PrefetchDependency, normalModuleFactory);
		});
		compiler.plugin("make", function(compilation, callback) {
			compilation.prefetch(this.context || compiler.context, new PrefetchDependency(this.request), callback);
		}.bind(this));
	};


/***/ },
/* 531 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(272);
	
	function PrefetchDependency(request) {
		ModuleDependency.call(this, request);
		this.Class = PrefetchDependency;
	}
	module.exports = PrefetchDependency;
	
	PrefetchDependency.prototype = Object.create(ModuleDependency.prototype);
	PrefetchDependency.prototype.constructor = PrefetchDependency;
	PrefetchDependency.prototype.type = "prefetch";


/***/ },
/* 532 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function OccurrenceOrderPlugin(preferEntry) {
		if(preferEntry !== undefined && typeof preferEntry !== "boolean") {
			throw new Error("Argument should be a boolean.\nFor more info on this plugin, see https://webpack.github.io/docs/list-of-plugins.html");
		}
		this.preferEntry = preferEntry;
	}
	module.exports = OccurrenceOrderPlugin;
	OccurrenceOrderPlugin.prototype.apply = function(compiler) {
		var preferEntry = this.preferEntry;
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("optimize-module-order", function(modules) {
				function entryChunks(m) {
					return m.chunks.filter(function(c) {
						return c.initial;
					}).length;
				}
	
				function occursInEntry(m) {
					return m.reasons.map(function(r) {
						if(!r.module) return 0;
						return entryChunks(r.module);
					}).reduce(function(a, b) {
						return a + b;
					}, 0) + entryChunks(m);
				}
	
				function occurs(m) {
					return m.reasons.map(function(r) {
						if(!r.module) return 0;
						return r.module.chunks.length;
					}).reduce(function(a, b) {
						return a + b;
					}, 0) + m.chunks.length;
				}
				modules.sort(function(a, b) {
					if(preferEntry) {
						var aEntryOccurs = occursInEntry(a);
						var bEntryOccurs = occursInEntry(b);
						if(aEntryOccurs > bEntryOccurs) return -1;
						if(aEntryOccurs < bEntryOccurs) return 1;
					}
					var aOccurs = occurs(a);
					var bOccurs = occurs(b);
					if(aOccurs > bOccurs) return -1;
					if(aOccurs < bOccurs) return 1;
					if(a.identifier() > b.identifier()) return 1;
					if(a.identifier() < b.identifier()) return -1;
					return 0;
				});
			});
			compilation.plugin("optimize-chunk-order", function(chunks) {
				function occursInEntry(c) {
					return c.parents.filter(function(p) {
						return p.initial;
					}).length + (c.entry ? 1 : 0);
				}
	
				function occurs(c) {
					return c.blocks.length + (c.entry ? 1 : 0);
				}
				chunks.forEach(function(c) {
					c.modules.sort(function(a, b) {
						if(a.identifier() > b.identifier()) return 1;
						if(a.identifier() < b.identifier()) return -1;
						return 0;
					});
				});
				chunks.sort(function(a, b) {
					var aEntryOccurs = occursInEntry(a);
					var bEntryOccurs = occursInEntry(b);
					if(aEntryOccurs > bEntryOccurs) return -1;
					if(aEntryOccurs < bEntryOccurs) return 1;
					var aOccurs = occurs(a);
					var bOccurs = occurs(b);
					if(aOccurs > bOccurs) return -1;
					if(aOccurs < bOccurs) return 1;
					if(a.modules.length > b.modules.length) return -1;
					if(a.modules.length < b.modules.length) return 1;
					for(var i = 0; i < a.modules.length; i++) {
						if(a.modules[i].identifier() > b.modules[i].identifier()) return -1;
						if(a.modules[i].identifier() < b.modules[i].identifier()) return 1;
					}
					return 0;
				});
			});
		});
	};


/***/ },
/* 533 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function MinChunkSizePlugin(options) {
		if(typeof options !== "object" || Array.isArray(options)) {
			throw new Error("Argument should be an options object.\nFor more info on options, see https://webpack.github.io/docs/list-of-plugins.html");
		}
		this.options = options;
	}
	module.exports = MinChunkSizePlugin;
	
	MinChunkSizePlugin.prototype.apply = function(compiler) {
		var options = this.options;
		var minChunkSize = options.minChunkSize;
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("optimize-chunks", function(chunks) {
	
				var combinations = [];
				chunks.forEach(function(a, idx) {
					for(var i = 0; i < idx; i++) {
						var b = chunks[i];
						combinations.push([b, a]);
					}
				});
	
				var equalOptions = {
					chunkOverhead: 1,
					entryChunkMultiplicator: 1
				};
				combinations = combinations.filter(function(pair) {
					return pair[0].size(equalOptions) < minChunkSize || pair[1].size(equalOptions) < minChunkSize;
				});
	
				combinations.forEach(function(pair) {
					var a = pair[0].size(options);
					var b = pair[1].size(options);
					var ab = pair[0].integratedSize(pair[1], options);
					pair.unshift(a + b - ab, ab);
				});
	
				combinations = combinations.filter(function(pair) {
					return pair[1] !== false;
				});
	
				if(combinations.length === 0) return;
	
				combinations.sort(function(a, b) {
					var diff = b[0] - a[0];
					if(diff !== 0) return diff;
					return a[1] - b[1];
				});
	
				var pair = combinations[0];
	
				pair[2].integrate(pair[3], "min-size");
				chunks.splice(chunks.indexOf(pair[3]), 1);
				this.restartApplyPlugins();
			});
		});
	};


/***/ },
/* 534 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function LimitChunkCountPlugin(options) {
		if(options !== undefined && typeof options !== "object" || Array.isArray(options)) {
			throw new Error("Argument should be an options object.\nFor more info on options, see https://webpack.github.io/docs/list-of-plugins.html");
		}
		this.options = options || {};
	}
	module.exports = LimitChunkCountPlugin;
	
	LimitChunkCountPlugin.prototype.apply = function(compiler) {
		var options = this.options;
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("optimize-chunks", function(chunks) {
				var maxChunks = options.maxChunks;
				if(!maxChunks) return;
				if(maxChunks < 1) return;
				if(chunks.length <= maxChunks) return;
	
				if(chunks.length > maxChunks) {
					var combinations = [];
					chunks.forEach(function(a, idx) {
						for(var i = 0; i < idx; i++) {
							var b = chunks[i];
							combinations.push([b, a]);
						}
					});
	
					combinations.forEach(function(pair) {
						var a = pair[0].size(options);
						var b = pair[1].size(options);
						var ab = pair[0].integratedSize(pair[1], options);
						pair.unshift(a + b - ab, ab);
					});
					combinations = combinations.filter(function(pair) {
						return pair[1] !== false;
					});
					combinations.sort(function(a, b) {
						var diff = b[0] - a[0];
						if(diff !== 0) return diff;
						return a[1] - b[1];
					});
	
					var pair = combinations[0];
	
					if(pair && pair[2].integrate(pair[3], "limit")) {
						chunks.splice(chunks.indexOf(pair[3]), 1);
						this.restartApplyPlugins();
					}
				}
			});
		});
	};


/***/ },
/* 535 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceMapConsumer = __webpack_require__(536).SourceMapConsumer;
	var SourceMapSource = __webpack_require__(259);
	var RawSource = __webpack_require__(213);
	var RequestShortener = __webpack_require__(219);
	var ModuleFilenameHelpers = __webpack_require__(281);
	var uglify = __webpack_require__(537);
	
	function UglifyJsPlugin(options) {
		if(typeof options !== "object") options = {};
		if(typeof options.compressor !== "undefined") {
			options.compress = options.compressor;
		}
		this.options = options;
	}
	module.exports = UglifyJsPlugin;
	
	UglifyJsPlugin.prototype.apply = function(compiler) {
		var options = this.options;
		options.test = options.test || /\.js($|\?)/i;
	
		var requestShortener = new RequestShortener(compiler.context);
		compiler.plugin("compilation", function(compilation) {
			if(options.sourceMap !== false) {
				compilation.plugin("build-module", function(module) {
					// to get detailed location info about errors
					module.useSourceMap = true;
				});
			}
			compilation.plugin("optimize-chunk-assets", function(chunks, callback) {
				var files = [];
				chunks.forEach(function(chunk) {
					chunk.files.forEach(function(file) {
						files.push(file);
					});
				});
				compilation.additionalChunkAssets.forEach(function(file) {
					files.push(file);
				});
				files = files.filter(ModuleFilenameHelpers.matchObject.bind(undefined, options));
				files.forEach(function(file) {
					var oldWarnFunction = uglify.AST_Node.warn_function;
					var warnings = [];
					try {
						var asset = compilation.assets[file];
						if(asset.__UglifyJsPlugin) {
							compilation.assets[file] = asset.__UglifyJsPlugin;
							return;
						}
						if(options.sourceMap !== false) {
							if(asset.sourceAndMap) {
								var sourceAndMap = asset.sourceAndMap();
								var inputSourceMap = sourceAndMap.map;
								var input = sourceAndMap.source;
							} else {
								var inputSourceMap = asset.map();
								var input = asset.source();
							}
							var sourceMap = new SourceMapConsumer(inputSourceMap);
							uglify.AST_Node.warn_function = function(warning) { // eslint-disable-line camelcase
								var match = /\[.+:([0-9]+),([0-9]+)\]/.exec(warning);
								var line = +match[1];
								var column = +match[2];
								var original = sourceMap.originalPositionFor({
									line: line,
									column: column
								});
								if(!original || !original.source || original.source === file) return;
								warnings.push(warning.replace(/\[.+:([0-9]+),([0-9]+)\]/, "") +
									"[" + requestShortener.shorten(original.source) + ":" + original.line + "," + original.column + "]");
							};
						} else {
							var input = asset.source();
							uglify.AST_Node.warn_function = function(warning) { // eslint-disable-line camelcase
								warnings.push(warning);
							};
						}
						var ast = uglify.parse(input, {
							filename: file
						});
						if(options.compress !== false) {
							ast.figure_out_scope();
							var compress = uglify.Compressor(options.compress); // eslint-disable-line new-cap
							ast = ast.transform(compress);
						}
						if(options.mangle !== false) {
							ast.figure_out_scope();
							ast.compute_char_frequency(options.mangle || {});
							ast.mangle_names(options.mangle || {});
						}
						var output = {};
						output.comments = Object.prototype.hasOwnProperty.call(options, "comments") ? options.comments : /^\**!|@preserve|@license/;
						output.beautify = options.beautify;
						for(var k in options.output) {
							output[k] = options.output[k];
						}
						if(options.sourceMap !== false) {
							var map = uglify.SourceMap({ // eslint-disable-line new-cap
								file: file,
								root: ""
							});
							output.source_map = map; // eslint-disable-line camelcase
						}
						var stream = uglify.OutputStream(output); // eslint-disable-line new-cap
						ast.print(stream);
						if(map) map = map + "";
						stream = stream + "";
						asset.__UglifyJsPlugin = compilation.assets[file] = (map ?
							new SourceMapSource(stream, file, JSON.parse(map), input, inputSourceMap) :
							new RawSource(stream));
						if(warnings.length > 0) {
							compilation.warnings.push(new Error(file + " from UglifyJs\n" + warnings.join("\n")));
						}
					} catch(err) {
						if(err.line) {
							var original = sourceMap && sourceMap.originalPositionFor({
								line: err.line,
								column: err.col
							});
							if(original && original.source) {
								compilation.errors.push(new Error(file + " from UglifyJs\n" + err.message + " [" + requestShortener.shorten(original.source) + ":" + original.line + "," + original.column + "]"));
							} else {
								compilation.errors.push(new Error(file + " from UglifyJs\n" + err.message + " [" + file + ":" + err.line + "," + err.col + "]"));
							}
						} else if(err.msg) {
							compilation.errors.push(new Error(file + " from UglifyJs\n" + err.msg));
						} else
							compilation.errors.push(new Error(file + " from UglifyJs\n" + err.stack));
					} finally {
						uglify.AST_Node.warn_function = oldWarnFunction; // eslint-disable-line camelcase
					}
				});
				callback();
			});
			compilation.plugin("normal-module-loader", function(context) {
				context.minimize = true;
			});
		});
	};


/***/ },
/* 536 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = __webpack_require__(193);

/***/ },
/* 537 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer, module, __filename, __dirname) {var path = __webpack_require__(180);
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var vm = __webpack_require__(395);
	
	var UglifyJS = vm.createContext({
	    console       : console,
	    process       : process,
	    Buffer        : Buffer,
	    MOZ_SourceMap : __webpack_require__(538)
	});
	
	function load_global(file) {
	    file = path.resolve(path.dirname(module.filename), file);
	    try {
	        var code = fs.readFileSync(file, "utf8");
	        return vm.runInContext(code, UglifyJS, file);
	    } catch(ex) {
	        // XXX: in case of a syntax error, the message is kinda
	        // useless. (no location information).
	        console.log("ERROR in file: " + file + " / " + ex);
	        process.exit(1);
	    }
	};
	
	var FILES = exports.FILES = [
	    "../lib/utils.js",
	    "../lib/ast.js",
	    "../lib/parse.js",
	    "../lib/transform.js",
	    "../lib/scope.js",
	    "../lib/output.js",
	    "../lib/compress.js",
	    "../lib/sourcemap.js",
	    "../lib/mozilla-ast.js",
	    "../lib/propmangle.js"
	].map(function(file){
	    return fs.realpathSync(path.join(path.dirname(__filename), file));
	});
	
	FILES.forEach(load_global);
	
	UglifyJS.AST_Node.warn_function = function(txt) {
	    console.error("WARN: %s", txt);
	};
	
	// XXX: perhaps we shouldn't export everything but heck, I'm lazy.
	for (var i in UglifyJS) {
	    if (UglifyJS.hasOwnProperty(i)) {
	        exports[i] = UglifyJS[i];
	    }
	}
	
	exports.minify = function(files, options) {
	    options = UglifyJS.defaults(options, {
	        spidermonkey : false,
	        outSourceMap : null,
	        sourceRoot   : null,
	        inSourceMap  : null,
	        fromString   : false,
	        warnings     : false,
	        mangle       : {},
	        output       : null,
	        compress     : {}
	    });
	    UglifyJS.base54.reset();
	
	    // 1. parse
	    var toplevel = null,
	        sourcesContent = {};
	
	    if (options.spidermonkey) {
	        toplevel = UglifyJS.AST_Node.from_mozilla_ast(files);
	    } else {
	        if (typeof files == "string")
	            files = [ files ];
	        files.forEach(function(file){
	            var code = options.fromString
	                ? file
	                : fs.readFileSync(file, "utf8");
	            sourcesContent[file] = code;
	            toplevel = UglifyJS.parse(code, {
	                filename: options.fromString ? "?" : file,
	                toplevel: toplevel
	            });
	        });
	    }
	
	    // 2. compress
	    if (options.compress) {
	        var compress = { warnings: options.warnings };
	        UglifyJS.merge(compress, options.compress);
	        toplevel.figure_out_scope();
	        var sq = UglifyJS.Compressor(compress);
	        toplevel = toplevel.transform(sq);
	    }
	
	    // 3. mangle
	    if (options.mangle) {
	        toplevel.figure_out_scope(options.mangle);
	        toplevel.compute_char_frequency(options.mangle);
	        toplevel.mangle_names(options.mangle);
	    }
	
	    // 4. output
	    var inMap = options.inSourceMap;
	    var output = {};
	    if (typeof options.inSourceMap == "string") {
	        inMap = fs.readFileSync(options.inSourceMap, "utf8");
	    }
	    if (options.outSourceMap) {
	        output.source_map = UglifyJS.SourceMap({
	            file: options.outSourceMap,
	            orig: inMap,
	            root: options.sourceRoot
	        });
	        if (options.sourceMapIncludeSources) {
	            for (var file in sourcesContent) {
	                if (sourcesContent.hasOwnProperty(file)) {
	                    output.source_map.get().setSourceContent(file, sourcesContent[file]);
	                }
	            }
	        }
	
	    }
	    if (options.output) {
	        UglifyJS.merge(output, options.output);
	    }
	    var stream = UglifyJS.OutputStream(output);
	    toplevel.print(stream);
	
	    if(options.outSourceMap){
	        stream += "\n//# sourceMappingURL=" + options.outSourceMap;
	    }
	
	    var source_map = output.source_map;
	    if (source_map) {
	        source_map = source_map + "";
	    }
	
	    return {
	        code : stream + "",
	        map  : source_map
	    };
	};
	
	// exports.describe_ast = function() {
	//     function doitem(ctor) {
	//         var sub = {};
	//         ctor.SUBCLASSES.forEach(function(ctor){
	//             sub[ctor.TYPE] = doitem(ctor);
	//         });
	//         var ret = {};
	//         if (ctor.SELF_PROPS.length > 0) ret.props = ctor.SELF_PROPS;
	//         if (ctor.SUBCLASSES.length > 0) ret.sub = sub;
	//         return ret;
	//     }
	//     return doitem(UglifyJS.AST_Node).sub;
	// }
	
	exports.describe_ast = function() {
	    var out = UglifyJS.OutputStream({ beautify: true });
	    function doitem(ctor) {
	        out.print("AST_" + ctor.TYPE);
	        var props = ctor.SELF_PROPS.filter(function(prop){
	            return !/^\$/.test(prop);
	        });
	        if (props.length > 0) {
	            out.space();
	            out.with_parens(function(){
	                props.forEach(function(prop, i){
	                    if (i) out.space();
	                    out.print(prop);
	                });
	            });
	        }
	        if (ctor.documentation) {
	            out.space();
	            out.print_string(ctor.documentation);
	        }
	        if (ctor.SUBCLASSES.length > 0) {
	            out.space();
	            out.with_block(function(){
	                ctor.SUBCLASSES.forEach(function(ctor, i){
	                    out.indent();
	                    doitem(ctor);
	                    out.newline();
	                });
	            });
	        }
	    };
	    doitem(UglifyJS.AST_Node);
	    return out + "";
	};
	
	function readReservedFile(filename, reserved) {
	    if (!reserved) {
	        reserved = { vars: [], props: [] };
	    }
	    var data = fs.readFileSync(filename, "utf8");
	    data = JSON.parse(data);
	    if (data.vars) {
	        data.vars.forEach(function(name){
	            UglifyJS.push_uniq(reserved.vars, name);
	        });
	    }
	    if (data.props) {
	        data.props.forEach(function(name){
	            UglifyJS.push_uniq(reserved.props, name);
	        });
	    }
	    return reserved;
	}
	
	exports.readReservedFile = readReservedFile;
	
	exports.readDefaultReservedFile = function(reserved) {
	    return readReservedFile(path.join(__dirname, "domprops.json"), reserved);
	};
	
	exports.readNameCache = function(filename, key) {
	    var cache = null;
	    if (filename) {
	        try {
	            var cache = fs.readFileSync(filename, "utf8");
	            cache = JSON.parse(cache)[key];
	            if (!cache) throw "init";
	            cache.props = UglifyJS.Dictionary.fromObject(cache.props);
	        } catch(ex) {
	            cache = {
	                cname: -1,
	                props: new UglifyJS.Dictionary()
	            };
	        }
	    }
	    return cache;
	};
	
	exports.writeNameCache = function(filename, key, cache) {
	    if (filename) {
	        var data;
	        try {
	            data = fs.readFileSync(filename, "utf8");
	            data = JSON.parse(data);
	        } catch(ex) {
	            data = {};
	        }
	        data[key] = {
	            cname: cache.cname,
	            props: cache.props.toObject()
	        };
	        fs.writeFileSync(filename, JSON.stringify(data, null, 2), "utf8");
	    }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), __webpack_require__(176).Buffer, __webpack_require__(469)(module), "/index.js", "/"))

/***/ },
/* 538 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	exports.SourceMapGenerator = __webpack_require__(539).SourceMapGenerator;
	exports.SourceMapConsumer = __webpack_require__(544).SourceMapConsumer;
	exports.SourceNode = __webpack_require__(546).SourceNode;


/***/ },
/* 539 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var base64VLQ = __webpack_require__(540);
	  var util = __webpack_require__(542);
	  var ArraySet = __webpack_require__(543).ArraySet;
	
	  /**
	   * An instance of the SourceMapGenerator represents a source map which is
	   * being built incrementally. You may pass an object with the following
	   * properties:
	   *
	   *   - file: The filename of the generated source.
	   *   - sourceRoot: A root for all relative URLs in this source map.
	   */
	  function SourceMapGenerator(aArgs) {
	    if (!aArgs) {
	      aArgs = {};
	    }
	    this._file = util.getArg(aArgs, 'file', null);
	    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	    this._mappings = [];
	    this._sourcesContents = null;
	  }
	
	  SourceMapGenerator.prototype._version = 3;
	
	  /**
	   * Creates a new SourceMapGenerator based on a SourceMapConsumer
	   *
	   * @param aSourceMapConsumer The SourceMap.
	   */
	  SourceMapGenerator.fromSourceMap =
	    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	      var sourceRoot = aSourceMapConsumer.sourceRoot;
	      var generator = new SourceMapGenerator({
	        file: aSourceMapConsumer.file,
	        sourceRoot: sourceRoot
	      });
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        var newMapping = {
	          generated: {
	            line: mapping.generatedLine,
	            column: mapping.generatedColumn
	          }
	        };
	
	        if (mapping.source) {
	          newMapping.source = mapping.source;
	          if (sourceRoot) {
	            newMapping.source = util.relative(sourceRoot, newMapping.source);
	          }
	
	          newMapping.original = {
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          };
	
	          if (mapping.name) {
	            newMapping.name = mapping.name;
	          }
	        }
	
	        generator.addMapping(newMapping);
	      });
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content) {
	          generator.setSourceContent(sourceFile, content);
	        }
	      });
	      return generator;
	    };
	
	  /**
	   * Add a single mapping from original source line and column to the generated
	   * source's line and column for this source map being created. The mapping
	   * object should have the following properties:
	   *
	   *   - generated: An object with the generated line and column positions.
	   *   - original: An object with the original line and column positions.
	   *   - source: The original source file (relative to the sourceRoot).
	   *   - name: An optional original token name for this mapping.
	   */
	  SourceMapGenerator.prototype.addMapping =
	    function SourceMapGenerator_addMapping(aArgs) {
	      var generated = util.getArg(aArgs, 'generated');
	      var original = util.getArg(aArgs, 'original', null);
	      var source = util.getArg(aArgs, 'source', null);
	      var name = util.getArg(aArgs, 'name', null);
	
	      this._validateMapping(generated, original, source, name);
	
	      if (source && !this._sources.has(source)) {
	        this._sources.add(source);
	      }
	
	      if (name && !this._names.has(name)) {
	        this._names.add(name);
	      }
	
	      this._mappings.push({
	        generatedLine: generated.line,
	        generatedColumn: generated.column,
	        originalLine: original != null && original.line,
	        originalColumn: original != null && original.column,
	        source: source,
	        name: name
	      });
	    };
	
	  /**
	   * Set the source content for a source file.
	   */
	  SourceMapGenerator.prototype.setSourceContent =
	    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	      var source = aSourceFile;
	      if (this._sourceRoot) {
	        source = util.relative(this._sourceRoot, source);
	      }
	
	      if (aSourceContent !== null) {
	        // Add the source content to the _sourcesContents map.
	        // Create a new _sourcesContents map if the property is null.
	        if (!this._sourcesContents) {
	          this._sourcesContents = {};
	        }
	        this._sourcesContents[util.toSetString(source)] = aSourceContent;
	      } else {
	        // Remove the source file from the _sourcesContents map.
	        // If the _sourcesContents map is empty, set the property to null.
	        delete this._sourcesContents[util.toSetString(source)];
	        if (Object.keys(this._sourcesContents).length === 0) {
	          this._sourcesContents = null;
	        }
	      }
	    };
	
	  /**
	   * Applies the mappings of a sub-source-map for a specific source file to the
	   * source map being generated. Each mapping to the supplied source file is
	   * rewritten using the supplied source map. Note: The resolution for the
	   * resulting mappings is the minimium of this map and the supplied map.
	   *
	   * @param aSourceMapConsumer The source map to be applied.
	   * @param aSourceFile Optional. The filename of the source file.
	   *        If omitted, SourceMapConsumer's file property will be used.
	   * @param aSourceMapPath Optional. The dirname of the path to the source map
	   *        to be applied. If relative, it is relative to the SourceMapConsumer.
	   *        This parameter is needed when the two source maps aren't in the same
	   *        directory, and the source map to be applied contains relative source
	   *        paths. If so, those relative source paths need to be rewritten
	   *        relative to the SourceMapGenerator.
	   */
	  SourceMapGenerator.prototype.applySourceMap =
	    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	      // If aSourceFile is omitted, we will use the file property of the SourceMap
	      if (!aSourceFile) {
	        if (!aSourceMapConsumer.file) {
	          throw new Error(
	            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	            'or the source map\'s "file" property. Both were omitted.'
	          );
	        }
	        aSourceFile = aSourceMapConsumer.file;
	      }
	      var sourceRoot = this._sourceRoot;
	      // Make "aSourceFile" relative if an absolute Url is passed.
	      if (sourceRoot) {
	        aSourceFile = util.relative(sourceRoot, aSourceFile);
	      }
	      // Applying the SourceMap can add and remove items from the sources and
	      // the names array.
	      var newSources = new ArraySet();
	      var newNames = new ArraySet();
	
	      // Find mappings for the "aSourceFile"
	      this._mappings.forEach(function (mapping) {
	        if (mapping.source === aSourceFile && mapping.originalLine) {
	          // Check if it can be mapped by the source map, then update the mapping.
	          var original = aSourceMapConsumer.originalPositionFor({
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          });
	          if (original.source !== null) {
	            // Copy mapping
	            mapping.source = original.source;
	            if (aSourceMapPath) {
	              mapping.source = util.join(aSourceMapPath, mapping.source)
	            }
	            if (sourceRoot) {
	              mapping.source = util.relative(sourceRoot, mapping.source);
	            }
	            mapping.originalLine = original.line;
	            mapping.originalColumn = original.column;
	            if (original.name !== null && mapping.name !== null) {
	              // Only use the identifier name if it's an identifier
	              // in both SourceMaps
	              mapping.name = original.name;
	            }
	          }
	        }
	
	        var source = mapping.source;
	        if (source && !newSources.has(source)) {
	          newSources.add(source);
	        }
	
	        var name = mapping.name;
	        if (name && !newNames.has(name)) {
	          newNames.add(name);
	        }
	
	      }, this);
	      this._sources = newSources;
	      this._names = newNames;
	
	      // Copy sourcesContents of applied map.
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content) {
	          if (aSourceMapPath) {
	            sourceFile = util.join(aSourceMapPath, sourceFile);
	          }
	          if (sourceRoot) {
	            sourceFile = util.relative(sourceRoot, sourceFile);
	          }
	          this.setSourceContent(sourceFile, content);
	        }
	      }, this);
	    };
	
	  /**
	   * A mapping can have one of the three levels of data:
	   *
	   *   1. Just the generated position.
	   *   2. The Generated position, original position, and original source.
	   *   3. Generated and original position, original source, as well as a name
	   *      token.
	   *
	   * To maintain consistency, we validate that any new mapping being added falls
	   * in to one of these categories.
	   */
	  SourceMapGenerator.prototype._validateMapping =
	    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                                aName) {
	      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	          && aGenerated.line > 0 && aGenerated.column >= 0
	          && !aOriginal && !aSource && !aName) {
	        // Case 1.
	        return;
	      }
	      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	               && aGenerated.line > 0 && aGenerated.column >= 0
	               && aOriginal.line > 0 && aOriginal.column >= 0
	               && aSource) {
	        // Cases 2 and 3.
	        return;
	      }
	      else {
	        throw new Error('Invalid mapping: ' + JSON.stringify({
	          generated: aGenerated,
	          source: aSource,
	          original: aOriginal,
	          name: aName
	        }));
	      }
	    };
	
	  /**
	   * Serialize the accumulated mappings in to the stream of base 64 VLQs
	   * specified by the source map format.
	   */
	  SourceMapGenerator.prototype._serializeMappings =
	    function SourceMapGenerator_serializeMappings() {
	      var previousGeneratedColumn = 0;
	      var previousGeneratedLine = 1;
	      var previousOriginalColumn = 0;
	      var previousOriginalLine = 0;
	      var previousName = 0;
	      var previousSource = 0;
	      var result = '';
	      var mapping;
	
	      // The mappings must be guaranteed to be in sorted order before we start
	      // serializing them or else the generated line numbers (which are defined
	      // via the ';' separators) will be all messed up. Note: it might be more
	      // performant to maintain the sorting as we insert them, rather than as we
	      // serialize them, but the big O is the same either way.
	      this._mappings.sort(util.compareByGeneratedPositions);
	
	      for (var i = 0, len = this._mappings.length; i < len; i++) {
	        mapping = this._mappings[i];
	
	        if (mapping.generatedLine !== previousGeneratedLine) {
	          previousGeneratedColumn = 0;
	          while (mapping.generatedLine !== previousGeneratedLine) {
	            result += ';';
	            previousGeneratedLine++;
	          }
	        }
	        else {
	          if (i > 0) {
	            if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
	              continue;
	            }
	            result += ',';
	          }
	        }
	
	        result += base64VLQ.encode(mapping.generatedColumn
	                                   - previousGeneratedColumn);
	        previousGeneratedColumn = mapping.generatedColumn;
	
	        if (mapping.source) {
	          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
	                                     - previousSource);
	          previousSource = this._sources.indexOf(mapping.source);
	
	          // lines are stored 0-based in SourceMap spec version 3
	          result += base64VLQ.encode(mapping.originalLine - 1
	                                     - previousOriginalLine);
	          previousOriginalLine = mapping.originalLine - 1;
	
	          result += base64VLQ.encode(mapping.originalColumn
	                                     - previousOriginalColumn);
	          previousOriginalColumn = mapping.originalColumn;
	
	          if (mapping.name) {
	            result += base64VLQ.encode(this._names.indexOf(mapping.name)
	                                       - previousName);
	            previousName = this._names.indexOf(mapping.name);
	          }
	        }
	      }
	
	      return result;
	    };
	
	  SourceMapGenerator.prototype._generateSourcesContent =
	    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	      return aSources.map(function (source) {
	        if (!this._sourcesContents) {
	          return null;
	        }
	        if (aSourceRoot) {
	          source = util.relative(aSourceRoot, source);
	        }
	        var key = util.toSetString(source);
	        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
	                                                    key)
	          ? this._sourcesContents[key]
	          : null;
	      }, this);
	    };
	
	  /**
	   * Externalize the source map.
	   */
	  SourceMapGenerator.prototype.toJSON =
	    function SourceMapGenerator_toJSON() {
	      var map = {
	        version: this._version,
	        file: this._file,
	        sources: this._sources.toArray(),
	        names: this._names.toArray(),
	        mappings: this._serializeMappings()
	      };
	      if (this._sourceRoot) {
	        map.sourceRoot = this._sourceRoot;
	      }
	      if (this._sourcesContents) {
	        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	      }
	
	      return map;
	    };
	
	  /**
	   * Render the source map being generated to a string.
	   */
	  SourceMapGenerator.prototype.toString =
	    function SourceMapGenerator_toString() {
	      return JSON.stringify(this);
	    };
	
	  exports.SourceMapGenerator = SourceMapGenerator;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 540 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var base64 = __webpack_require__(541);
	
	  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
	  // length quantities we use in the source map spec, the first bit is the sign,
	  // the next four bits are the actual value, and the 6th bit is the
	  // continuation bit. The continuation bit tells us whether there are more
	  // digits in this value following this digit.
	  //
	  //   Continuation
	  //   |    Sign
	  //   |    |
	  //   V    V
	  //   101011
	
	  var VLQ_BASE_SHIFT = 5;
	
	  // binary: 100000
	  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	
	  // binary: 011111
	  var VLQ_BASE_MASK = VLQ_BASE - 1;
	
	  // binary: 100000
	  var VLQ_CONTINUATION_BIT = VLQ_BASE;
	
	  /**
	   * Converts from a two-complement value to a value where the sign bit is
	   * is placed in the least significant bit.  For example, as decimals:
	   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	   */
	  function toVLQSigned(aValue) {
	    return aValue < 0
	      ? ((-aValue) << 1) + 1
	      : (aValue << 1) + 0;
	  }
	
	  /**
	   * Converts to a two-complement value from a value where the sign bit is
	   * is placed in the least significant bit.  For example, as decimals:
	   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	   */
	  function fromVLQSigned(aValue) {
	    var isNegative = (aValue & 1) === 1;
	    var shifted = aValue >> 1;
	    return isNegative
	      ? -shifted
	      : shifted;
	  }
	
	  /**
	   * Returns the base 64 VLQ encoded value.
	   */
	  exports.encode = function base64VLQ_encode(aValue) {
	    var encoded = "";
	    var digit;
	
	    var vlq = toVLQSigned(aValue);
	
	    do {
	      digit = vlq & VLQ_BASE_MASK;
	      vlq >>>= VLQ_BASE_SHIFT;
	      if (vlq > 0) {
	        // There are still more digits in this value, so we must make sure the
	        // continuation bit is marked.
	        digit |= VLQ_CONTINUATION_BIT;
	      }
	      encoded += base64.encode(digit);
	    } while (vlq > 0);
	
	    return encoded;
	  };
	
	  /**
	   * Decodes the next base 64 VLQ value from the given string and returns the
	   * value and the rest of the string.
	   */
	  exports.decode = function base64VLQ_decode(aStr) {
	    var i = 0;
	    var strLen = aStr.length;
	    var result = 0;
	    var shift = 0;
	    var continuation, digit;
	
	    do {
	      if (i >= strLen) {
	        throw new Error("Expected more digits in base 64 VLQ value.");
	      }
	      digit = base64.decode(aStr.charAt(i++));
	      continuation = !!(digit & VLQ_CONTINUATION_BIT);
	      digit &= VLQ_BASE_MASK;
	      result = result + (digit << shift);
	      shift += VLQ_BASE_SHIFT;
	    } while (continuation);
	
	    return {
	      value: fromVLQSigned(result),
	      rest: aStr.slice(i)
	    };
	  };
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 541 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var charToIntMap = {};
	  var intToCharMap = {};
	
	  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	    .split('')
	    .forEach(function (ch, index) {
	      charToIntMap[ch] = index;
	      intToCharMap[index] = ch;
	    });
	
	  /**
	   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	   */
	  exports.encode = function base64_encode(aNumber) {
	    if (aNumber in intToCharMap) {
	      return intToCharMap[aNumber];
	    }
	    throw new TypeError("Must be between 0 and 63: " + aNumber);
	  };
	
	  /**
	   * Decode a single base 64 digit to an integer.
	   */
	  exports.decode = function base64_decode(aChar) {
	    if (aChar in charToIntMap) {
	      return charToIntMap[aChar];
	    }
	    throw new TypeError("Not a valid base 64 digit: " + aChar);
	  };
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 542 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  /**
	   * This is a helper function for getting values from parameter/options
	   * objects.
	   *
	   * @param args The object we are extracting values from
	   * @param name The name of the property we are getting.
	   * @param defaultValue An optional value to return if the property is missing
	   * from the object. If this is not specified and the property is missing, an
	   * error will be thrown.
	   */
	  function getArg(aArgs, aName, aDefaultValue) {
	    if (aName in aArgs) {
	      return aArgs[aName];
	    } else if (arguments.length === 3) {
	      return aDefaultValue;
	    } else {
	      throw new Error('"' + aName + '" is a required argument.');
	    }
	  }
	  exports.getArg = getArg;
	
	  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	  var dataUrlRegexp = /^data:.+\,.+$/;
	
	  function urlParse(aUrl) {
	    var match = aUrl.match(urlRegexp);
	    if (!match) {
	      return null;
	    }
	    return {
	      scheme: match[1],
	      auth: match[2],
	      host: match[3],
	      port: match[4],
	      path: match[5]
	    };
	  }
	  exports.urlParse = urlParse;
	
	  function urlGenerate(aParsedUrl) {
	    var url = '';
	    if (aParsedUrl.scheme) {
	      url += aParsedUrl.scheme + ':';
	    }
	    url += '//';
	    if (aParsedUrl.auth) {
	      url += aParsedUrl.auth + '@';
	    }
	    if (aParsedUrl.host) {
	      url += aParsedUrl.host;
	    }
	    if (aParsedUrl.port) {
	      url += ":" + aParsedUrl.port
	    }
	    if (aParsedUrl.path) {
	      url += aParsedUrl.path;
	    }
	    return url;
	  }
	  exports.urlGenerate = urlGenerate;
	
	  /**
	   * Normalizes a path, or the path portion of a URL:
	   *
	   * - Replaces consequtive slashes with one slash.
	   * - Removes unnecessary '.' parts.
	   * - Removes unnecessary '<dir>/..' parts.
	   *
	   * Based on code in the Node.js 'path' core module.
	   *
	   * @param aPath The path or url to normalize.
	   */
	  function normalize(aPath) {
	    var path = aPath;
	    var url = urlParse(aPath);
	    if (url) {
	      if (!url.path) {
	        return aPath;
	      }
	      path = url.path;
	    }
	    var isAbsolute = (path.charAt(0) === '/');
	
	    var parts = path.split(/\/+/);
	    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	      part = parts[i];
	      if (part === '.') {
	        parts.splice(i, 1);
	      } else if (part === '..') {
	        up++;
	      } else if (up > 0) {
	        if (part === '') {
	          // The first part is blank if the path is absolute. Trying to go
	          // above the root is a no-op. Therefore we can remove all '..' parts
	          // directly after the root.
	          parts.splice(i + 1, up);
	          up = 0;
	        } else {
	          parts.splice(i, 2);
	          up--;
	        }
	      }
	    }
	    path = parts.join('/');
	
	    if (path === '') {
	      path = isAbsolute ? '/' : '.';
	    }
	
	    if (url) {
	      url.path = path;
	      return urlGenerate(url);
	    }
	    return path;
	  }
	  exports.normalize = normalize;
	
	  /**
	   * Joins two paths/URLs.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be joined with the root.
	   *
	   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	   *   first.
	   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	   *   is updated with the result and aRoot is returned. Otherwise the result
	   *   is returned.
	   *   - If aPath is absolute, the result is aPath.
	   *   - Otherwise the two paths are joined with a slash.
	   * - Joining for example 'http://' and 'www.example.com' is also supported.
	   */
	  function join(aRoot, aPath) {
	    var aPathUrl = urlParse(aPath);
	    var aRootUrl = urlParse(aRoot);
	    if (aRootUrl) {
	      aRoot = aRootUrl.path || '/';
	    }
	
	    // `join(foo, '//www.example.org')`
	    if (aPathUrl && !aPathUrl.scheme) {
	      if (aRootUrl) {
	        aPathUrl.scheme = aRootUrl.scheme;
	      }
	      return urlGenerate(aPathUrl);
	    }
	
	    if (aPathUrl || aPath.match(dataUrlRegexp)) {
	      return aPath;
	    }
	
	    // `join('http://', 'www.example.com')`
	    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	      aRootUrl.host = aPath;
	      return urlGenerate(aRootUrl);
	    }
	
	    var joined = aPath.charAt(0) === '/'
	      ? aPath
	      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
	
	    if (aRootUrl) {
	      aRootUrl.path = joined;
	      return urlGenerate(aRootUrl);
	    }
	    return joined;
	  }
	  exports.join = join;
	
	  /**
	   * Because behavior goes wacky when you set `__proto__` on objects, we
	   * have to prefix all the strings in our set with an arbitrary character.
	   *
	   * See https://github.com/mozilla/source-map/pull/31 and
	   * https://github.com/mozilla/source-map/issues/30
	   *
	   * @param String aStr
	   */
	  function toSetString(aStr) {
	    return '$' + aStr;
	  }
	  exports.toSetString = toSetString;
	
	  function fromSetString(aStr) {
	    return aStr.substr(1);
	  }
	  exports.fromSetString = fromSetString;
	
	  function relative(aRoot, aPath) {
	    aRoot = aRoot.replace(/\/$/, '');
	
	    var url = urlParse(aRoot);
	    if (aPath.charAt(0) == "/" && url && url.path == "/") {
	      return aPath.slice(1);
	    }
	
	    return aPath.indexOf(aRoot + '/') === 0
	      ? aPath.substr(aRoot.length + 1)
	      : aPath;
	  }
	  exports.relative = relative;
	
	  function strcmp(aStr1, aStr2) {
	    var s1 = aStr1 || "";
	    var s2 = aStr2 || "";
	    return (s1 > s2) - (s1 < s2);
	  }
	
	  /**
	   * Comparator between two mappings where the original positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same original source/line/column, but different generated
	   * line and column the same. Useful when searching for a mapping with a
	   * stubbed out mapping.
	   */
	  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	    var cmp;
	
	    cmp = strcmp(mappingA.source, mappingB.source);
	    if (cmp) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp || onlyCompareOriginal) {
	      return cmp;
	    }
	
	    cmp = strcmp(mappingA.name, mappingB.name);
	    if (cmp) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp) {
	      return cmp;
	    }
	
	    return mappingA.generatedColumn - mappingB.generatedColumn;
	  };
	  exports.compareByOriginalPositions = compareByOriginalPositions;
	
	  /**
	   * Comparator between two mappings where the generated positions are
	   * compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same generated line and column, but different
	   * source/name/original line and column the same. Useful when searching for a
	   * mapping with a stubbed out mapping.
	   */
	  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
	    var cmp;
	
	    cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp || onlyCompareGenerated) {
	      return cmp;
	    }
	
	    cmp = strcmp(mappingA.source, mappingB.source);
	    if (cmp) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp) {
	      return cmp;
	    }
	
	    return strcmp(mappingA.name, mappingB.name);
	  };
	  exports.compareByGeneratedPositions = compareByGeneratedPositions;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 543 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var util = __webpack_require__(542);
	
	  /**
	   * A data structure which is a combination of an array and a set. Adding a new
	   * member is O(1), testing for membership is O(1), and finding the index of an
	   * element is O(1). Removing elements from the set is not supported. Only
	   * strings are supported for membership.
	   */
	  function ArraySet() {
	    this._array = [];
	    this._set = {};
	  }
	
	  /**
	   * Static method for creating ArraySet instances from an existing array.
	   */
	  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	    var set = new ArraySet();
	    for (var i = 0, len = aArray.length; i < len; i++) {
	      set.add(aArray[i], aAllowDuplicates);
	    }
	    return set;
	  };
	
	  /**
	   * Add the given string to this set.
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	    var isDuplicate = this.has(aStr);
	    var idx = this._array.length;
	    if (!isDuplicate || aAllowDuplicates) {
	      this._array.push(aStr);
	    }
	    if (!isDuplicate) {
	      this._set[util.toSetString(aStr)] = idx;
	    }
	  };
	
	  /**
	   * Is the given string a member of this set?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.has = function ArraySet_has(aStr) {
	    return Object.prototype.hasOwnProperty.call(this._set,
	                                                util.toSetString(aStr));
	  };
	
	  /**
	   * What is the index of the given string in the array?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	    if (this.has(aStr)) {
	      return this._set[util.toSetString(aStr)];
	    }
	    throw new Error('"' + aStr + '" is not in the set.');
	  };
	
	  /**
	   * What is the element at the given index?
	   *
	   * @param Number aIdx
	   */
	  ArraySet.prototype.at = function ArraySet_at(aIdx) {
	    if (aIdx >= 0 && aIdx < this._array.length) {
	      return this._array[aIdx];
	    }
	    throw new Error('No element indexed by ' + aIdx);
	  };
	
	  /**
	   * Returns the array representation of this set (which has the proper indices
	   * indicated by indexOf). Note that this is a copy of the internal array used
	   * for storing the members so that no one can mess with internal state.
	   */
	  ArraySet.prototype.toArray = function ArraySet_toArray() {
	    return this._array.slice();
	  };
	
	  exports.ArraySet = ArraySet;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 544 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var util = __webpack_require__(542);
	  var binarySearch = __webpack_require__(545);
	  var ArraySet = __webpack_require__(543).ArraySet;
	  var base64VLQ = __webpack_require__(540);
	
	  /**
	   * A SourceMapConsumer instance represents a parsed source map which we can
	   * query for information about the original file positions by giving it a file
	   * position in the generated source.
	   *
	   * The only parameter is the raw source map (either as a JSON string, or
	   * already parsed to an object). According to the spec, source maps have the
	   * following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - sources: An array of URLs to the original source files.
	   *   - names: An array of identifiers which can be referrenced by individual mappings.
	   *   - sourceRoot: Optional. The URL root from which all sources are relative.
	   *   - sourcesContent: Optional. An array of contents of the original source files.
	   *   - mappings: A string of base64 VLQs which contain the actual mappings.
	   *   - file: Optional. The generated file this source map is associated with.
	   *
	   * Here is an example source map, taken from the source map spec[0]:
	   *
	   *     {
	   *       version : 3,
	   *       file: "out.js",
	   *       sourceRoot : "",
	   *       sources: ["foo.js", "bar.js"],
	   *       names: ["src", "maps", "are", "fun"],
	   *       mappings: "AA,AB;;ABCDE;"
	   *     }
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	   */
	  function SourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    var version = util.getArg(sourceMap, 'version');
	    var sources = util.getArg(sourceMap, 'sources');
	    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	    // requires the array) to play nice here.
	    var names = util.getArg(sourceMap, 'names', []);
	    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	    var mappings = util.getArg(sourceMap, 'mappings');
	    var file = util.getArg(sourceMap, 'file', null);
	
	    // Once again, Sass deviates from the spec and supplies the version as a
	    // string rather than a number, so we use loose equality checking here.
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	
	    // Pass `true` below to allow duplicate names and sources. While source maps
	    // are intended to be compressed and deduplicated, the TypeScript compiler
	    // sometimes generates source maps with duplicates in them. See Github issue
	    // #72 and bugzil.la/889492.
	    this._names = ArraySet.fromArray(names, true);
	    this._sources = ArraySet.fromArray(sources, true);
	
	    this.sourceRoot = sourceRoot;
	    this.sourcesContent = sourcesContent;
	    this._mappings = mappings;
	    this.file = file;
	  }
	
	  /**
	   * Create a SourceMapConsumer from a SourceMapGenerator.
	   *
	   * @param SourceMapGenerator aSourceMap
	   *        The source map that will be consumed.
	   * @returns SourceMapConsumer
	   */
	  SourceMapConsumer.fromSourceMap =
	    function SourceMapConsumer_fromSourceMap(aSourceMap) {
	      var smc = Object.create(SourceMapConsumer.prototype);
	
	      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	      smc.sourceRoot = aSourceMap._sourceRoot;
	      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                              smc.sourceRoot);
	      smc.file = aSourceMap._file;
	
	      smc.__generatedMappings = aSourceMap._mappings.slice()
	        .sort(util.compareByGeneratedPositions);
	      smc.__originalMappings = aSourceMap._mappings.slice()
	        .sort(util.compareByOriginalPositions);
	
	      return smc;
	    };
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  SourceMapConsumer.prototype._version = 3;
	
	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      return this._sources.toArray().map(function (s) {
	        return this.sourceRoot ? util.join(this.sourceRoot, s) : s;
	      }, this);
	    }
	  });
	
	  // `__generatedMappings` and `__originalMappings` are arrays that hold the
	  // parsed mapping coordinates from the source map's "mappings" attribute. They
	  // are lazily instantiated, accessed via the `_generatedMappings` and
	  // `_originalMappings` getters respectively, and we only parse the mappings
	  // and create these arrays once queried for a source location. We jump through
	  // these hoops because there can be many thousands of mappings, and parsing
	  // them is expensive, so we only want to do it if we must.
	  //
	  // Each object in the arrays is of the form:
	  //
	  //     {
	  //       generatedLine: The line number in the generated code,
	  //       generatedColumn: The column number in the generated code,
	  //       source: The path to the original source file that generated this
	  //               chunk of code,
	  //       originalLine: The line number in the original source that
	  //                     corresponds to this chunk of generated code,
	  //       originalColumn: The column number in the original source that
	  //                       corresponds to this chunk of generated code,
	  //       name: The name of the original symbol which generated this chunk of
	  //             code.
	  //     }
	  //
	  // All properties except for `generatedLine` and `generatedColumn` can be
	  // `null`.
	  //
	  // `_generatedMappings` is ordered by the generated positions.
	  //
	  // `_originalMappings` is ordered by the original positions.
	
	  SourceMapConsumer.prototype.__generatedMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	    get: function () {
	      if (!this.__generatedMappings) {
	        this.__generatedMappings = [];
	        this.__originalMappings = [];
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	
	      return this.__generatedMappings;
	    }
	  });
	
	  SourceMapConsumer.prototype.__originalMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	    get: function () {
	      if (!this.__originalMappings) {
	        this.__generatedMappings = [];
	        this.__originalMappings = [];
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	
	      return this.__originalMappings;
	    }
	  });
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  SourceMapConsumer.prototype._parseMappings =
	    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      var generatedLine = 1;
	      var previousGeneratedColumn = 0;
	      var previousOriginalLine = 0;
	      var previousOriginalColumn = 0;
	      var previousSource = 0;
	      var previousName = 0;
	      var mappingSeparator = /^[,;]/;
	      var str = aStr;
	      var mapping;
	      var temp;
	
	      while (str.length > 0) {
	        if (str.charAt(0) === ';') {
	          generatedLine++;
	          str = str.slice(1);
	          previousGeneratedColumn = 0;
	        }
	        else if (str.charAt(0) === ',') {
	          str = str.slice(1);
	        }
	        else {
	          mapping = {};
	          mapping.generatedLine = generatedLine;
	
	          // Generated column.
	          temp = base64VLQ.decode(str);
	          mapping.generatedColumn = previousGeneratedColumn + temp.value;
	          previousGeneratedColumn = mapping.generatedColumn;
	          str = temp.rest;
	
	          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
	            // Original source.
	            temp = base64VLQ.decode(str);
	            mapping.source = this._sources.at(previousSource + temp.value);
	            previousSource += temp.value;
	            str = temp.rest;
	            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
	              throw new Error('Found a source, but no line and column');
	            }
	
	            // Original line.
	            temp = base64VLQ.decode(str);
	            mapping.originalLine = previousOriginalLine + temp.value;
	            previousOriginalLine = mapping.originalLine;
	            // Lines are stored 0-based
	            mapping.originalLine += 1;
	            str = temp.rest;
	            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
	              throw new Error('Found a source and line, but no column');
	            }
	
	            // Original column.
	            temp = base64VLQ.decode(str);
	            mapping.originalColumn = previousOriginalColumn + temp.value;
	            previousOriginalColumn = mapping.originalColumn;
	            str = temp.rest;
	
	            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
	              // Original name.
	              temp = base64VLQ.decode(str);
	              mapping.name = this._names.at(previousName + temp.value);
	              previousName += temp.value;
	              str = temp.rest;
	            }
	          }
	
	          this.__generatedMappings.push(mapping);
	          if (typeof mapping.originalLine === 'number') {
	            this.__originalMappings.push(mapping);
	          }
	        }
	      }
	
	      this.__generatedMappings.sort(util.compareByGeneratedPositions);
	      this.__originalMappings.sort(util.compareByOriginalPositions);
	    };
	
	  /**
	   * Find the mapping that best matches the hypothetical "needle" mapping that
	   * we are searching for in the given "haystack" of mappings.
	   */
	  SourceMapConsumer.prototype._findMapping =
	    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                           aColumnName, aComparator) {
	      // To return the position we are searching for, we must first find the
	      // mapping for the given position and then return the opposite position it
	      // points to. Because the mappings are sorted, we can use binary search to
	      // find the best mapping.
	
	      if (aNeedle[aLineName] <= 0) {
	        throw new TypeError('Line must be greater than or equal to 1, got '
	                            + aNeedle[aLineName]);
	      }
	      if (aNeedle[aColumnName] < 0) {
	        throw new TypeError('Column must be greater than or equal to 0, got '
	                            + aNeedle[aColumnName]);
	      }
	
	      return binarySearch.search(aNeedle, aMappings, aComparator);
	    };
	
	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.
	   *   - column: The column number in the generated source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.
	   *   - column: The column number in the original source, or null.
	   *   - name: The original identifier, or null.
	   */
	  SourceMapConsumer.prototype.originalPositionFor =
	    function SourceMapConsumer_originalPositionFor(aArgs) {
	      var needle = {
	        generatedLine: util.getArg(aArgs, 'line'),
	        generatedColumn: util.getArg(aArgs, 'column')
	      };
	
	      var mapping = this._findMapping(needle,
	                                      this._generatedMappings,
	                                      "generatedLine",
	                                      "generatedColumn",
	                                      util.compareByGeneratedPositions);
	
	      if (mapping && mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source && this.sourceRoot) {
	          source = util.join(this.sourceRoot, source);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: util.getArg(mapping, 'name', null)
	        };
	      }
	
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    };
	
	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * availible.
	   */
	  SourceMapConsumer.prototype.sourceContentFor =
	    function SourceMapConsumer_sourceContentFor(aSource) {
	      if (!this.sourcesContent) {
	        return null;
	      }
	
	      if (this.sourceRoot) {
	        aSource = util.relative(this.sourceRoot, aSource);
	      }
	
	      if (this._sources.has(aSource)) {
	        return this.sourcesContent[this._sources.indexOf(aSource)];
	      }
	
	      var url;
	      if (this.sourceRoot
	          && (url = util.urlParse(this.sourceRoot))) {
	        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	        // many users. We can help them out when they expect file:// URIs to
	        // behave like it would if they were running a local HTTP server. See
	        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	        if (url.scheme == "file"
	            && this._sources.has(fileUriAbsPath)) {
	          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	        }
	
	        if ((!url.path || url.path == "/")
	            && this._sources.has("/" + aSource)) {
	          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	        }
	      }
	
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    };
	
	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: The column number in the original source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  SourceMapConsumer.prototype.generatedPositionFor =
	    function SourceMapConsumer_generatedPositionFor(aArgs) {
	      var needle = {
	        source: util.getArg(aArgs, 'source'),
	        originalLine: util.getArg(aArgs, 'line'),
	        originalColumn: util.getArg(aArgs, 'column')
	      };
	
	      if (this.sourceRoot) {
	        needle.source = util.relative(this.sourceRoot, needle.source);
	      }
	
	      var mapping = this._findMapping(needle,
	                                      this._originalMappings,
	                                      "originalLine",
	                                      "originalColumn",
	                                      util.compareByOriginalPositions);
	
	      if (mapping) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null)
	        };
	      }
	
	      return {
	        line: null,
	        column: null
	      };
	    };
	
	  SourceMapConsumer.GENERATED_ORDER = 1;
	  SourceMapConsumer.ORIGINAL_ORDER = 2;
	
	  /**
	   * Iterate over each mapping between an original source/line/column and a
	   * generated line/column in this source map.
	   *
	   * @param Function aCallback
	   *        The function that is called with each mapping.
	   * @param Object aContext
	   *        Optional. If specified, this object will be the value of `this` every
	   *        time that `aCallback` is called.
	   * @param aOrder
	   *        Either `SourceMapConsumer.GENERATED_ORDER` or
	   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	   *        iterate over the mappings sorted by the generated file's line/column
	   *        order or the original's source/line/column order, respectively. Defaults to
	   *        `SourceMapConsumer.GENERATED_ORDER`.
	   */
	  SourceMapConsumer.prototype.eachMapping =
	    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	      var context = aContext || null;
	      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
	
	      var mappings;
	      switch (order) {
	      case SourceMapConsumer.GENERATED_ORDER:
	        mappings = this._generatedMappings;
	        break;
	      case SourceMapConsumer.ORIGINAL_ORDER:
	        mappings = this._originalMappings;
	        break;
	      default:
	        throw new Error("Unknown order of iteration.");
	      }
	
	      var sourceRoot = this.sourceRoot;
	      mappings.map(function (mapping) {
	        var source = mapping.source;
	        if (source && sourceRoot) {
	          source = util.join(sourceRoot, source);
	        }
	        return {
	          source: source,
	          generatedLine: mapping.generatedLine,
	          generatedColumn: mapping.generatedColumn,
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: mapping.name
	        };
	      }).forEach(aCallback, context);
	    };
	
	  exports.SourceMapConsumer = SourceMapConsumer;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 545 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  /**
	   * Recursive implementation of binary search.
	   *
	   * @param aLow Indices here and lower do not contain the needle.
	   * @param aHigh Indices here and higher do not contain the needle.
	   * @param aNeedle The element being searched for.
	   * @param aHaystack The non-empty array being searched.
	   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	   */
	  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
	    // This function terminates when one of the following is true:
	    //
	    //   1. We find the exact element we are looking for.
	    //
	    //   2. We did not find the exact element, but we can return the next
	    //      closest element that is less than that element.
	    //
	    //   3. We did not find the exact element, and there is no next-closest
	    //      element which is less than the one we are searching for, so we
	    //      return null.
	    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	    var cmp = aCompare(aNeedle, aHaystack[mid], true);
	    if (cmp === 0) {
	      // Found the element we are looking for.
	      return aHaystack[mid];
	    }
	    else if (cmp > 0) {
	      // aHaystack[mid] is greater than our needle.
	      if (aHigh - mid > 1) {
	        // The element is in the upper half.
	        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
	      }
	      // We did not find an exact match, return the next closest one
	      // (termination case 2).
	      return aHaystack[mid];
	    }
	    else {
	      // aHaystack[mid] is less than our needle.
	      if (mid - aLow > 1) {
	        // The element is in the lower half.
	        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
	      }
	      // The exact needle element was not found in this haystack. Determine if
	      // we are in termination case (2) or (3) and return the appropriate thing.
	      return aLow < 0
	        ? null
	        : aHaystack[aLow];
	    }
	  }
	
	  /**
	   * This is an implementation of binary search which will always try and return
	   * the next lowest value checked if there is no exact hit. This is because
	   * mappings between original and generated line/col pairs are single points,
	   * and there is an implicit region between each of them, so a miss just means
	   * that you aren't on the very start of a region.
	   *
	   * @param aNeedle The element you are looking for.
	   * @param aHaystack The array that is being searched.
	   * @param aCompare A function which takes the needle and an element in the
	   *     array and returns -1, 0, or 1 depending on whether the needle is less
	   *     than, equal to, or greater than the element, respectively.
	   */
	  exports.search = function search(aNeedle, aHaystack, aCompare) {
	    return aHaystack.length > 0
	      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
	      : null;
	  };
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 546 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var SourceMapGenerator = __webpack_require__(539).SourceMapGenerator;
	  var util = __webpack_require__(542);
	
	  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	  // operating systems these days (capturing the result).
	  var REGEX_NEWLINE = /(\r?\n)/g;
	
	  // Matches a Windows-style newline, or any character.
	  var REGEX_CHARACTER = /\r\n|[\s\S]/g;
	
	  /**
	   * SourceNodes provide a way to abstract over interpolating/concatenating
	   * snippets of generated JavaScript source code while maintaining the line and
	   * column information associated with the original source code.
	   *
	   * @param aLine The original line number.
	   * @param aColumn The original column number.
	   * @param aSource The original source's filename.
	   * @param aChunks Optional. An array of strings which are snippets of
	   *        generated JS, or other SourceNodes.
	   * @param aName The original identifier.
	   */
	  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	    this.children = [];
	    this.sourceContents = {};
	    this.line = aLine === undefined ? null : aLine;
	    this.column = aColumn === undefined ? null : aColumn;
	    this.source = aSource === undefined ? null : aSource;
	    this.name = aName === undefined ? null : aName;
	    if (aChunks != null) this.add(aChunks);
	  }
	
	  /**
	   * Creates a SourceNode from generated code and a SourceMapConsumer.
	   *
	   * @param aGeneratedCode The generated code
	   * @param aSourceMapConsumer The SourceMap for the generated code
	   */
	  SourceNode.fromStringWithSourceMap =
	    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
	      // The SourceNode we want to fill with the generated code
	      // and the SourceMap
	      var node = new SourceNode();
	
	      // All even indices of this array are one line of the generated code,
	      // while all odd indices are the newlines between two adjacent lines
	      // (since `REGEX_NEWLINE` captures its match).
	      // Processed fragments are removed from this array, by calling `shiftNextLine`.
	      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	      var shiftNextLine = function() {
	        var lineContents = remainingLines.shift();
	        // The last line of a file might not have a newline.
	        var newLine = remainingLines.shift() || "";
	        return lineContents + newLine;
	      };
	
	      // We need to remember the position of "remainingLines"
	      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
	
	      // The generate SourceNodes we need a code range.
	      // To extract it current and last mapping is used.
	      // Here we store the last mapping.
	      var lastMapping = null;
	
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        if (lastMapping !== null) {
	          // We add the code from "lastMapping" to "mapping":
	          // First check if there is a new line in between.
	          if (lastGeneratedLine < mapping.generatedLine) {
	            var code = "";
	            // Associate first line with "lastMapping"
	            addMappingWithCode(lastMapping, shiftNextLine());
	            lastGeneratedLine++;
	            lastGeneratedColumn = 0;
	            // The remaining code is added without mapping
	          } else {
	            // There is no new line in between.
	            // Associate the code between "lastGeneratedColumn" and
	            // "mapping.generatedColumn" with "lastMapping"
	            var nextLine = remainingLines[0];
	            var code = nextLine.substr(0, mapping.generatedColumn -
	                                          lastGeneratedColumn);
	            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
	                                                lastGeneratedColumn);
	            lastGeneratedColumn = mapping.generatedColumn;
	            addMappingWithCode(lastMapping, code);
	            // No more remaining code, continue
	            lastMapping = mapping;
	            return;
	          }
	        }
	        // We add the generated code until the first mapping
	        // to the SourceNode without any mapping.
	        // Each line is added as separate string.
	        while (lastGeneratedLine < mapping.generatedLine) {
	          node.add(shiftNextLine());
	          lastGeneratedLine++;
	        }
	        if (lastGeneratedColumn < mapping.generatedColumn) {
	          var nextLine = remainingLines[0];
	          node.add(nextLine.substr(0, mapping.generatedColumn));
	          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	        }
	        lastMapping = mapping;
	      }, this);
	      // We have processed all mappings.
	      if (remainingLines.length > 0) {
	        if (lastMapping) {
	          // Associate the remaining code in the current line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	        }
	        // and add the remaining lines without any mapping
	        node.add(remainingLines.join(""));
	      }
	
	      // Copy sourcesContent into SourceNode
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content) {
	          node.setSourceContent(sourceFile, content);
	        }
	      });
	
	      return node;
	
	      function addMappingWithCode(mapping, code) {
	        if (mapping === null || mapping.source === undefined) {
	          node.add(code);
	        } else {
	          node.add(new SourceNode(mapping.originalLine,
	                                  mapping.originalColumn,
	                                  mapping.source,
	                                  code,
	                                  mapping.name));
	        }
	      }
	    };
	
	  /**
	   * Add a chunk of generated JS to this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.add = function SourceNode_add(aChunk) {
	    if (Array.isArray(aChunk)) {
	      aChunk.forEach(function (chunk) {
	        this.add(chunk);
	      }, this);
	    }
	    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
	      if (aChunk) {
	        this.children.push(aChunk);
	      }
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };
	
	  /**
	   * Add a chunk of generated JS to the beginning of this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	    if (Array.isArray(aChunk)) {
	      for (var i = aChunk.length-1; i >= 0; i--) {
	        this.prepend(aChunk[i]);
	      }
	    }
	    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
	      this.children.unshift(aChunk);
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };
	
	  /**
	   * Walk over the tree of JS snippets in this node and its children. The
	   * walking function is called once for each snippet of JS and is passed that
	   * snippet and the its original associated source's line/column location.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	    var chunk;
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      chunk = this.children[i];
	      if (chunk instanceof SourceNode) {
	        chunk.walk(aFn);
	      }
	      else {
	        if (chunk !== '') {
	          aFn(chunk, { source: this.source,
	                       line: this.line,
	                       column: this.column,
	                       name: this.name });
	        }
	      }
	    }
	  };
	
	  /**
	   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	   * each of `this.children`.
	   *
	   * @param aSep The separator.
	   */
	  SourceNode.prototype.join = function SourceNode_join(aSep) {
	    var newChildren;
	    var i;
	    var len = this.children.length;
	    if (len > 0) {
	      newChildren = [];
	      for (i = 0; i < len-1; i++) {
	        newChildren.push(this.children[i]);
	        newChildren.push(aSep);
	      }
	      newChildren.push(this.children[i]);
	      this.children = newChildren;
	    }
	    return this;
	  };
	
	  /**
	   * Call String.prototype.replace on the very right-most source snippet. Useful
	   * for trimming whitespace from the end of a source node, etc.
	   *
	   * @param aPattern The pattern to replace.
	   * @param aReplacement The thing to replace the pattern with.
	   */
	  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	    var lastChild = this.children[this.children.length - 1];
	    if (lastChild instanceof SourceNode) {
	      lastChild.replaceRight(aPattern, aReplacement);
	    }
	    else if (typeof lastChild === 'string') {
	      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	    }
	    else {
	      this.children.push(''.replace(aPattern, aReplacement));
	    }
	    return this;
	  };
	
	  /**
	   * Set the source content for a source file. This will be added to the SourceMapGenerator
	   * in the sourcesContent field.
	   *
	   * @param aSourceFile The filename of the source file
	   * @param aSourceContent The content of the source file
	   */
	  SourceNode.prototype.setSourceContent =
	    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	    };
	
	  /**
	   * Walk over the tree of SourceNodes. The walking function is called for each
	   * source file content and is passed the filename and source content.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walkSourceContents =
	    function SourceNode_walkSourceContents(aFn) {
	      for (var i = 0, len = this.children.length; i < len; i++) {
	        if (this.children[i] instanceof SourceNode) {
	          this.children[i].walkSourceContents(aFn);
	        }
	      }
	
	      var sources = Object.keys(this.sourceContents);
	      for (var i = 0, len = sources.length; i < len; i++) {
	        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	      }
	    };
	
	  /**
	   * Return the string representation of this source node. Walks over the tree
	   * and concatenates all the various snippets together to one string.
	   */
	  SourceNode.prototype.toString = function SourceNode_toString() {
	    var str = "";
	    this.walk(function (chunk) {
	      str += chunk;
	    });
	    return str;
	  };
	
	  /**
	   * Returns the string representation of this source node along with a source
	   * map.
	   */
	  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	    var generated = {
	      code: "",
	      line: 1,
	      column: 0
	    };
	    var map = new SourceMapGenerator(aArgs);
	    var sourceMappingActive = false;
	    var lastOriginalSource = null;
	    var lastOriginalLine = null;
	    var lastOriginalColumn = null;
	    var lastOriginalName = null;
	    this.walk(function (chunk, original) {
	      generated.code += chunk;
	      if (original.source !== null
	          && original.line !== null
	          && original.column !== null) {
	        if(lastOriginalSource !== original.source
	           || lastOriginalLine !== original.line
	           || lastOriginalColumn !== original.column
	           || lastOriginalName !== original.name) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	        lastOriginalSource = original.source;
	        lastOriginalLine = original.line;
	        lastOriginalColumn = original.column;
	        lastOriginalName = original.name;
	        sourceMappingActive = true;
	      } else if (sourceMappingActive) {
	        map.addMapping({
	          generated: {
	            line: generated.line,
	            column: generated.column
	          }
	        });
	        lastOriginalSource = null;
	        sourceMappingActive = false;
	      }
	      chunk.match(REGEX_CHARACTER).forEach(function (ch, idx, array) {
	        if (REGEX_NEWLINE.test(ch)) {
	          generated.line++;
	          generated.column = 0;
	          // Mappings end at eol
	          if (idx + 1 === array.length) {
	            lastOriginalSource = null;
	            sourceMappingActive = false;
	          } else if (sourceMappingActive) {
	            map.addMapping({
	              source: original.source,
	              original: {
	                line: original.line,
	                column: original.column
	              },
	              generated: {
	                line: generated.line,
	                column: generated.column
	              },
	              name: original.name
	            });
	          }
	        } else {
	          generated.column += ch.length;
	        }
	      });
	    });
	    this.walkSourceContents(function (sourceFile, sourceContent) {
	      map.setSourceContent(sourceFile, sourceContent);
	    });
	
	    return { code: generated.code, map: map };
	  };
	
	  exports.SourceNode = SourceNode;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 547 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var async = __webpack_require__(183);
	
	function CachePlugin(cache) {
		this.cache = cache || {};
	}
	module.exports = CachePlugin;
	
	CachePlugin.prototype.apply = function(compiler) {
		if(Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach(function(c, idx) {
				c.apply(new CachePlugin(this.cache[idx] = this.cache[idx] || {}));
			}, this);
		} else {
			compiler.plugin("compilation", function(compilation) {
				compilation.cache = this.cache;
			}.bind(this));
			compiler.plugin("run", function(compiler, callback) {
				if(!compiler._lastCompilationFileDependencies) return callback();
				var fs = compiler.inputFileSystem;
				var fileTs = compiler.fileTimestamps = {};
				async.forEach(compiler._lastCompilationFileDependencies, function(file, callback) {
					fs.stat(file, function(err, stat) {
						if(err) {
							if(err.code === "ENOENT") return callback();
							return callback(err);
						}
	
						fileTs[file] = stat.mtime || Infinity;
						callback();
					});
				}, callback);
			});
			compiler.plugin("after-compile", function(compilation, callback) {
				compilation.compiler._lastCompilationFileDependencies = compilation.fileDependencies;
				compilation.compiler._lastCompilationContextDependencies = compilation.contextDependencies;
				callback();
			});
		}
	};


/***/ },
/* 548 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleParserHelpers = __webpack_require__(301);
	var ConstDependency = __webpack_require__(295);
	
	var NullFactory = __webpack_require__(297);
	
	function ProvidePlugin(definitions) {
		this.definitions = definitions;
	}
	module.exports = ProvidePlugin;
	ProvidePlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
		});
		Object.keys(this.definitions).forEach(function(name) {
			var request = this.definitions[name];
			var splittedName = name.split(".");
			if(splittedName.length > 0) {
				splittedName.slice(1).forEach(function(_, i) {
					var name = splittedName.slice(0, i + 1).join(".");
					compiler.parser.plugin("can-rename " + name, function() {
						return true;
					});
				});
			}
			compiler.parser.plugin("expression " + name, function(expr) {
				var nameIdentifier = name;
				var scopedName = name.indexOf(".") >= 0;
				if(scopedName) {
					nameIdentifier = "__webpack_provided_" + name.replace(/\./g, "_dot_");
				}
				if(!ModuleParserHelpers.addParsedVariable(this, nameIdentifier, "require(" + JSON.stringify(request) + ")")) {
					return false;
				}
				if(scopedName) {
					nameIdentifier = "__webpack_provided_" + name.replace(/\./g, "_dot_");
					var dep = new ConstDependency(nameIdentifier, expr.range);
					dep.loc = expr.loc;
					this.state.current.addDependency(dep);
				}
				return true;
			});
		}, this);
	};


/***/ },
/* 549 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var OptionsDefaulter = __webpack_require__(550);
	
	function WebpackOptionsDefaulter() {
		OptionsDefaulter.call(this);
		this.set("debug", false);
		this.set("devtool", false);
		this.set("cache", true);
	
		this.set("context", process.cwd());
		this.set("target", "web");
		this.set("output", {});
		this.set("node", {});
		this.set("resolve", {});
		this.set("resolveLoader", {});
	
		this.set("module.unknownContextRequest", ".");
		this.set("module.unknownContextRecursive", true);
		this.set("module.unknownContextRegExp", /^\.\/.*$/);
		this.set("module.unknownContextCritical", true);
		this.set("module.exprContextRequest", ".");
		this.set("module.exprContextRegExp", /^\.\/.*$/);
		this.set("module.exprContextRecursive", true);
		this.set("module.exprContextCritical", true);
		this.set("module.wrappedContextRegExp", /.*/);
		this.set("module.wrappedContextRecursive", true);
		this.set("module.wrappedContextCritical", false);
	
		this.set("output.libraryTarget", "var");
		this.set("output.path", "");
		this.set("output.sourceMapFilename", "[file].map[query]");
		this.set("output.hotUpdateChunkFilename", "[id].[hash].hot-update.js");
		this.set("output.hotUpdateMainFilename", "[hash].hot-update.json");
		this.set("output.crossOriginLoading", false);
		this.set("output.hashFunction", "md5");
		this.set("output.hashDigest", "hex");
		this.set("output.hashDigestLength", 20);
		this.set("output.sourcePrefix", "\t");
		this.set("output.devtoolLineToLine", false);
	
		this.set("node.console", false);
		this.set("node.process", true);
		this.set("node.global", true);
		// TODO: add this in next major version
		// this.set("node.Buffer", true);
		this.set("node.setImmediate", true);
		this.set("node.__filename", "mock");
		this.set("node.__dirname", "mock");
	
		this.set("resolve.fastUnsafe", []);
		this.set("resolveLoader.fastUnsafe", []);
	
		this.set("resolve.alias", {});
		this.set("resolveLoader.alias", {});
	
		this.set("optimize.occurenceOrderPreferEntry", true);
	}
	module.exports = WebpackOptionsDefaulter;
	
	WebpackOptionsDefaulter.prototype = Object.create(OptionsDefaulter.prototype);
	
	WebpackOptionsDefaulter.prototype.constructor = WebpackOptionsDefaulter;
	
	WebpackOptionsDefaulter.prototype.process = function(options) {
		OptionsDefaulter.prototype.process.call(this, options);
	
		if(options.resolve.packageAlias === undefined) {
			if(options.target === "web" || options.target === "webworker")
				options.resolve.packageAlias = "browser";
		}
	
		function defaultByTarget(value, web, webworker, node, nodeWebkit, def) {
			if(value !== undefined) return value;
			switch(options.target) {
				case "web":
					return web;
				case "webworker":
					return webworker;
				case "node":
				case "async-node":
					return node;
				case "node-webkit":
					return nodeWebkit;
				default:
					return def;
			}
		}
	
		options.resolve.modulesDirectories = defaultByTarget(options.resolve.modulesDirectories, ["web_modules", "node_modules"], ["webworker_modules", "web_modules", "node_modules"], ["node_modules"], ["node_modules", "web_modules"], ["node_modules"]);
	
		options.resolveLoader.modulesDirectories = defaultByTarget(options.resolveLoader.modulesDirectories, ["web_loaders", "web_modules", "node_loaders", "node_modules"], ["webworker_loaders", "web_loaders", "web_modules", "node_loaders", "node_modules"], ["node_loaders", "node_modules"], ["node_loaders", "web_loaders", "node_modules", "web_modules"], ["node_modules"]);
	
		options.resolve.packageMains = defaultByTarget(options.resolve.packageMains, ["webpack", "browser", "web", "browserify", ["jam", "main"], "main"], ["webpackWorker", "webworker", "webpack", "browser", "web", "browserify", ["jam", "main"], "main"], ["webpackNode", "node", "main"], ["webpackNodeWebkit", "webpackNode", "node", "main", "web"], ["main"]);
	
		options.resolve.packageAlias = defaultByTarget(options.resolve.packageAlias,
			"browser",
			"browser",
			false,
			"node-webkit",
			false);
	
		options.resolveLoader.packageMains = defaultByTarget(options.resolveLoader.packageMains, ["webpackLoader", "webLoader", "loader", "main"], ["webpackWorkerLoader", "webworkerLoader", "webLoader", "loader", "main"], ["webpackNodeLoader", "nodeLoader", "loader", "main"], ["webpackNodeWebkitLoader", "webpackNodeLoader", "nodeLoader", "loader", "webLoader", "main"], ["loader", "main"]);
	
		options.resolve.extensions = defaultByTarget(options.resolve.extensions, ["", ".webpack.js", ".web.js", ".js", ".json"], ["", ".webpack-worker.js", ".webworker.js", ".web.js", ".js", ".json"], ["", ".webpack-node.js", ".js", ".json", ".node"], ["", ".webpack-node-webkit.js", ".webpack-node.js", ".js", ".json", ".node", ".web.js"], ["", ".js", ".json"]);
	
		options.resolveLoader.extensions = defaultByTarget(options.resolveLoader.extensions, ["", ".webpack-loader.js", ".web-loader.js", ".loader.js", ".js"], ["", ".webpack-worker-loader.js", ".webpack-loader.js", ".webworker-loader.js", ".web-loader.js", ".loader.js", ".js"], ["", ".webpack-node-loader.js", ".loader.js", ".js"], ["", ".webpack-node-webkit-loader.js", ".webpack-node-loader.js", ".loader.js", ".web-loader.js", ".js"], ["", ".js"]);
	
		options.resolveLoader.moduleTemplates = defaultByTarget(options.resolveLoader.moduleTemplates, ["*-webpack-loader", "*-web-loader", "*-loader", "*"], ["*-webpack-worker-loader", "*-webworker-loader", "*-web-loader", "*-loader", "*"], ["*-webpack-node-loader", "*-node-loader", "*-loader", "*"], ["*-webpack-node-webkit-loader", "*-webpack-node-loader", "*-node-loader", "*-loader", "*-web-loader", "*"], ["*-loader", "*"]);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 550 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function OptionsDefaulter() {
		this.defaults = {};
		this.config = {};
	}
	module.exports = OptionsDefaulter;
	
	function getProperty(obj, name) {
		name = name.split(".");
		for(var i = 0; i < name.length - 1; i++) {
			obj = obj[name[i]];
			if(typeof obj != "object" || !obj) return;
		}
		return obj[name.pop()];
	}
	
	function setProperty(obj, name, value) {
		name = name.split(".");
		for(var i = 0; i < name.length - 1; i++) {
			if(typeof (obj[name[i]]) !== "object" || !obj[name[i]]) obj[name[i]] = {};
			obj = obj[name[i]];
		}
		obj[name.pop()] = value;
	}
	
	function hasProperty(obj, name, value) {
		name = name.split(".");
		for(var i = 0; i < name.length - 1; i++) {
			obj = obj[name[i]];
			if(typeof obj != "object" || !obj) return false;
		}
		return Object.prototype.hasOwnProperty.call(obj, name.pop());
	}
	
	OptionsDefaulter.prototype.process = function(options) {
		for(var name in this.defaults) {
			switch(this.config[name]) {
			case undefined:
				if(getProperty(options, name) === undefined)
					setProperty(options, name, this.defaults[name]);
				break;
			case "call":
				setProperty(options, name, this.defaults[name].call(this, getProperty(options, name)), options);
				break;
			case "append":
				var oldValue = getProperty(options, name);
				if(!Array.isArray(oldValue)) oldValue = [];
				this.defaults[name].forEach(function(item) {
					oldValue.push(item);
				});
				setProperty(options, name, oldValue);
				break;
			default:
				throw new Error("OptionsDefaulter cannot process " + this.config[name]);
			}
		}
	};
	
	OptionsDefaulter.prototype.set = function(name, config, def) {
		if(arguments.length === 3) {
			this.defaults[name] = def;
			this.config[name] = config;
		} else {
			this.defaults[name] = config;
			delete this.config[name];
		}
	}

/***/ }
/******/ ]);
//# sourceMappingURL=index.js.map